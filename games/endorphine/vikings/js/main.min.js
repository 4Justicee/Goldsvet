eval('/*\r\n RequireJS 2.1.15 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.\r\n Available via the MIT or new BSD license.\r\n see: http://github.com/jrburke/requirejs for details\r\n*/\r\nvar requirejs,require,define;\r\n(function(ba){function G(b){return"[object Function]"===K.call(b)}function H(b){return"[object Array]"===K.call(b)}function v(b,c){if(b){var d;for(d=0;d<b.length&&(!b[d]||!c(b[d],d,b));d+=1);}}function T(b,c){if(b){var d;for(d=b.length-1;-1<d&&(!b[d]||!c(b[d],d,b));d-=1);}}function t(b,c){return fa.call(b,c)}function m(b,c){return t(b,c)&&b[c]}function B(b,c){for(var d in b)if(t(b,d)&&c(b[d],d))break}function U(b,c,d,e){c&&B(c,function(c,g){if(d||!t(b,g))e&&"object"===typeof c&&c&&!H(c)&&!G(c)&&!(c instanceof\r\nRegExp)?(b[g]||(b[g]={}),U(b[g],c,d,e)):b[g]=c});return b}function u(b,c){return function(){return c.apply(b,arguments)}}function ca(b){throw b;}function da(b){if(!b)return b;var c=ba;v(b.split("."),function(b){c=c[b]});return c}function C(b,c,d,e){c=Error(c+"\\nhttp://requirejs.org/docs/errors.html#"+b);c.requireType=b;c.requireModules=e;d&&(c.originalError=d);return c}function ga(b){function c(a,k,b){var f,l,c,d,e,g,i,p,k=k&&k.split("/"),h=j.map,n=h&&h["*"];if(a){a=a.split("/");l=a.length-1;j.nodeIdCompat&&\r\nQ.test(a[l])&&(a[l]=a[l].replace(Q,""));"."===a[0].charAt(0)&&k&&(l=k.slice(0,k.length-1),a=l.concat(a));l=a;for(c=0;c<l.length;c++)if(d=l[c],"."===d)l.splice(c,1),c-=1;else if(".."===d&&!(0===c||1==c&&".."===l[2]||".."===l[c-1])&&0<c)l.splice(c-1,2),c-=2;a=a.join("/")}if(b&&h&&(k||n)){l=a.split("/");c=l.length;a:for(;0<c;c-=1){e=l.slice(0,c).join("/");if(k)for(d=k.length;0<d;d-=1)if(b=m(h,k.slice(0,d).join("/")))if(b=m(b,e)){f=b;g=c;break a}!i&&(n&&m(n,e))&&(i=m(n,e),p=c)}!f&&i&&(f=i,g=p);f&&(l.splice(0,\r\ng,f),a=l.join("/"))}return(f=m(j.pkgs,a))?f:a}function d(a){z&&v(document.getElementsByTagName("script"),function(k){if(k.getAttribute("data-requiremodule")===a&&k.getAttribute("data-requirecontext")===i.contextName)return k.parentNode.removeChild(k),!0})}function e(a){var k=m(j.paths,a);if(k&&H(k)&&1<k.length)return k.shift(),i.require.undef(a),i.makeRequire(null,{skipMap:!0})([a]),!0}function n(a){var k,c=a?a.indexOf("!"):-1;-1<c&&(k=a.substring(0,c),a=a.substring(c+1,a.length));return[k,a]}function p(a,\r\nk,b,f){var l,d,e=null,g=k?k.name:null,j=a,p=!0,h="";a||(p=!1,a="_@r"+(K+=1));a=n(a);e=a[0];a=a[1];e&&(e=c(e,g,f),d=m(r,e));a&&(e?h=d&&d.normalize?d.normalize(a,function(a){return c(a,g,f)}):-1===a.indexOf("!")?c(a,g,f):a:(h=c(a,g,f),a=n(h),e=a[0],h=a[1],b=!0,l=i.nameToUrl(h)));b=e&&!d&&!b?"_unnormalized"+(O+=1):"";return{prefix:e,name:h,parentMap:k,unnormalized:!!b,url:l,originalName:j,isDefine:p,id:(e?e+"!"+h:h)+b}}function s(a){var k=a.id,b=m(h,k);b||(b=h[k]=new i.Module(a));return b}function q(a,\r\nk,b){var f=a.id,c=m(h,f);if(t(r,f)&&(!c||c.defineEmitComplete))"defined"===k&&b(r[f]);else if(c=s(a),c.error&&"error"===k)b(c.error);else c.on(k,b)}function w(a,b){var c=a.requireModules,f=!1;if(b)b(a);else if(v(c,function(b){if(b=m(h,b))b.error=a,b.events.error&&(f=!0,b.emit("error",a))}),!f)g.onError(a)}function x(){R.length&&(ha.apply(A,[A.length,0].concat(R)),R=[])}function y(a){delete h[a];delete V[a]}function F(a,b,c){var f=a.map.id;a.error?a.emit("error",a.error):(b[f]=!0,v(a.depMaps,function(f,\r\nd){var e=f.id,g=m(h,e);g&&(!a.depMatched[d]&&!c[e])&&(m(b,e)?(a.defineDep(d,r[e]),a.check()):F(g,b,c))}),c[f]=!0)}function D(){var a,b,c=(a=1E3*j.waitSeconds)&&i.startTime+a<(new Date).getTime(),f=[],l=[],g=!1,h=!0;if(!W){W=!0;B(V,function(a){var i=a.map,j=i.id;if(a.enabled&&(i.isDefine||l.push(a),!a.error))if(!a.inited&&c)e(j)?g=b=!0:(f.push(j),d(j));else if(!a.inited&&(a.fetched&&i.isDefine)&&(g=!0,!i.prefix))return h=!1});if(c&&f.length)return a=C("timeout","Load timeout for modules: "+f,null,\r\nf),a.contextName=i.contextName,w(a);h&&v(l,function(a){F(a,{},{})});if((!c||b)&&g)if((z||ea)&&!X)X=setTimeout(function(){X=0;D()},50);W=!1}}function E(a){t(r,a[0])||s(p(a[0],null,!0)).init(a[1],a[2])}function I(a){var a=a.currentTarget||a.srcElement,b=i.onScriptLoad;a.detachEvent&&!Y?a.detachEvent("onreadystatechange",b):a.removeEventListener("load",b,!1);b=i.onScriptError;(!a.detachEvent||Y)&&a.removeEventListener("error",b,!1);return{node:a,id:a&&a.getAttribute("data-requiremodule")}}function J(){var a;\r\nfor(x();A.length;){a=A.shift();if(null===a[0])return w(C("mismatch","Mismatched anonymous define() module: "+a[a.length-1]));E(a)}}var W,Z,i,L,X,j={waitSeconds:7,baseUrl:"./",paths:{},bundles:{},pkgs:{},shim:{},config:{}},h={},V={},$={},A=[],r={},S={},aa={},K=1,O=1;L={require:function(a){return a.require?a.require:a.require=i.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?r[a.map.id]=a.exports:a.exports=r[a.map.id]={}},module:function(a){return a.module?\r\na.module:a.module={id:a.map.id,uri:a.map.url,config:function(){return m(j.config,a.map.id)||{}},exports:a.exports||(a.exports={})}}};Z=function(a){this.events=m($,a.id)||{};this.map=a;this.shim=m(j.shim,a.id);this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};Z.prototype={init:function(a,b,c,f){f=f||{};if(!this.inited){this.factory=b;if(c)this.on("error",c);else this.events.error&&(c=u(this,function(a){this.emit("error",a)}));this.depMaps=a&&a.slice(0);this.errback=\r\nc;this.inited=!0;this.ignore=f.ignore;f.enabled||this.enabled?this.enable():this.check()}},defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;i.startTime=(new Date).getTime();var a=this.map;if(this.shim)i.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],u(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=\r\nthis.map.url;S[a]||(S[a]=!0,i.load(this.map.id,a))},check:function(){if(this.enabled&&!this.enabling){var a,b,c=this.map.id;b=this.depExports;var f=this.exports,l=this.factory;if(this.inited)if(this.error)this.emit("error",this.error);else{if(!this.defining){this.defining=!0;if(1>this.depCount&&!this.defined){if(G(l)){if(this.events.error&&this.map.isDefine||g.onError!==ca)try{f=i.execCb(c,l,b,f)}catch(d){a=d}else f=i.execCb(c,l,b,f);this.map.isDefine&&void 0===f&&((b=this.module)?f=b.exports:this.usingExports&&\r\n(f=this.exports));if(a)return a.requireMap=this.map,a.requireModules=this.map.isDefine?[this.map.id]:null,a.requireType=this.map.isDefine?"define":"require",w(this.error=a)}else f=l;this.exports=f;if(this.map.isDefine&&!this.ignore&&(r[c]=f,g.onResourceLoad))g.onResourceLoad(i,this.map,this.depMaps);y(c);this.defined=!0}this.defining=!1;this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=!0)}}else this.fetch()}},callPlugin:function(){var a=\r\nthis.map,b=a.id,d=p(a.prefix);this.depMaps.push(d);q(d,"defined",u(this,function(f){var l,d;d=m(aa,this.map.id);var e=this.map.name,P=this.map.parentMap?this.map.parentMap.name:null,n=i.makeRequire(a.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){if(f.normalize&&(e=f.normalize(e,function(a){return c(a,P,!0)})||""),f=p(a.prefix+"!"+e,this.map.parentMap),q(f,"defined",u(this,function(a){this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),d=m(h,f.id)){this.depMaps.push(f);\r\nif(this.events.error)d.on("error",u(this,function(a){this.emit("error",a)}));d.enable()}}else d?(this.map.url=i.nameToUrl(d),this.load()):(l=u(this,function(a){this.init([],function(){return a},null,{enabled:!0})}),l.error=u(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];B(h,function(a){0===a.map.id.indexOf(b+"_unnormalized")&&y(a.map.id)});w(a)}),l.fromText=u(this,function(f,c){var d=a.name,e=p(d),P=M;c&&(f=c);P&&(M=!1);s(e);t(j.config,b)&&(j.config[d]=j.config[b]);try{g.exec(f)}catch(h){return w(C("fromtexteval",\r\n"fromText eval for "+b+" failed: "+h,h,[b]))}P&&(M=!0);this.depMaps.push(e);i.completeLoad(d);n([d],l)}),f.load(a.name,n,l,j))}));i.enable(d,this);this.pluginMaps[d.id]=d},enable:function(){V[this.map.id]=this;this.enabling=this.enabled=!0;v(this.depMaps,u(this,function(a,b){var c,f;if("string"===typeof a){a=p(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=m(L,a.id)){this.depExports[b]=c(this);return}this.depCount+=1;q(a,"defined",u(this,function(a){this.defineDep(b,\r\na);this.check()}));this.errback&&q(a,"error",u(this,this.errback))}c=a.id;f=h[c];!t(L,c)&&(f&&!f.enabled)&&i.enable(a,this)}));B(this.pluginMaps,u(this,function(a){var b=m(h,a.id);b&&!b.enabled&&i.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){v(this.events[a],function(a){a(b)});"error"===a&&delete this.events[a]}};i={config:j,contextName:b,registry:h,defined:r,urlFetched:S,defQueue:A,Module:Z,makeModuleMap:p,\r\nnextTick:g.nextTick,onError:w,configure:function(a){a.baseUrl&&"/"!==a.baseUrl.charAt(a.baseUrl.length-1)&&(a.baseUrl+="/");var b=j.shim,c={paths:!0,bundles:!0,config:!0,map:!0};B(a,function(a,b){c[b]?(j[b]||(j[b]={}),U(j[b],a,!0,!0)):j[b]=a});a.bundles&&B(a.bundles,function(a,b){v(a,function(a){a!==b&&(aa[a]=b)})});a.shim&&(B(a.shim,function(a,c){H(a)&&(a={deps:a});if((a.exports||a.init)&&!a.exportsFn)a.exportsFn=i.makeShimExports(a);b[c]=a}),j.shim=b);a.packages&&v(a.packages,function(a){var b,\r\na="string"===typeof a?{name:a}:a;b=a.name;a.location&&(j.paths[b]=a.location);j.pkgs[b]=a.name+"/"+(a.main||"main").replace(ia,"").replace(Q,"")});B(h,function(a,b){!a.inited&&!a.map.unnormalized&&(a.map=p(b))});if(a.deps||a.callback)i.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;a.init&&(b=a.init.apply(ba,arguments));return b||a.exports&&da(a.exports)}},makeRequire:function(a,e){function j(c,d,m){var n,q;e.enableBuildCallback&&(d&&G(d))&&(d.__requireJsBuild=\r\n!0);if("string"===typeof c){if(G(d))return w(C("requireargs","Invalid require call"),m);if(a&&t(L,c))return L[c](h[a.id]);if(g.get)return g.get(i,c,a,j);n=p(c,a,!1,!0);n=n.id;return!t(r,n)?w(C("notloaded",\'Module name "\'+n+\'" has not been loaded yet for context: \'+b+(a?"":". Use require([])"))):r[n]}J();i.nextTick(function(){J();q=s(p(null,a));q.skipMap=e.skipMap;q.init(c,d,m,{enabled:!0});D()});return j}e=e||{};U(j,{isBrowser:z,toUrl:function(b){var d,e=b.lastIndexOf("."),k=b.split("/")[0];if(-1!==\r\ne&&(!("."===k||".."===k)||1<e))d=b.substring(e,b.length),b=b.substring(0,e);return i.nameToUrl(c(b,a&&a.id,!0),d,!0)},defined:function(b){return t(r,p(b,a,!1,!0).id)},specified:function(b){b=p(b,a,!1,!0).id;return t(r,b)||t(h,b)}});a||(j.undef=function(b){x();var c=p(b,a,!0),e=m(h,b);d(b);delete r[b];delete S[c.url];delete $[b];T(A,function(a,c){a[0]===b&&A.splice(c,1)});e&&(e.events.defined&&($[b]=e.events),y(b))});return j},enable:function(a){m(h,a.id)&&s(a).enable()},completeLoad:function(a){var b,\r\nc,d=m(j.shim,a)||{},g=d.exports;for(x();A.length;){c=A.shift();if(null===c[0]){c[0]=a;if(b)break;b=!0}else c[0]===a&&(b=!0);E(c)}c=m(h,a);if(!b&&!t(r,a)&&c&&!c.inited){if(j.enforceDefine&&(!g||!da(g)))return e(a)?void 0:w(C("nodefine","No define call for "+a,null,[a]));E([a,d.deps||[],d.exportsFn])}D()},nameToUrl:function(a,b,c){var d,e,h;(d=m(j.pkgs,a))&&(a=d);if(d=m(aa,a))return i.nameToUrl(d,b,c);if(g.jsExtRegExp.test(a))d=a+(b||"");else{d=j.paths;a=a.split("/");for(e=a.length;0<e;e-=1)if(h=a.slice(0,\r\ne).join("/"),h=m(d,h)){H(h)&&(h=h[0]);a.splice(0,e,h);break}d=a.join("/");d+=b||(/^data\\:|\\?/.test(d)||c?"":".js");d=("/"===d.charAt(0)||d.match(/^[\\w\\+\\.\\-]+:/)?"":j.baseUrl)+d}return j.urlArgs?d+((-1===d.indexOf("?")?"?":"&")+j.urlArgs):d},load:function(a,b){g.load(i,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if("load"===a.type||ja.test((a.currentTarget||a.srcElement).readyState))N=null,a=I(a),i.completeLoad(a.id)},onScriptError:function(a){var b=I(a);if(!e(b.id))return w(C("scripterror",\r\n"Script error for: "+b.id,a,[b.id]))}};i.require=i.makeRequire();return i}var g,x,y,D,I,E,N,J,s,O,ka=/(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,la=/[^.]\\s*require\\s*\\(\\s*["\']([^\'"\\s]+)["\']\\s*\\)/g,Q=/\\.js$/,ia=/^\\.\\//;x=Object.prototype;var K=x.toString,fa=x.hasOwnProperty,ha=Array.prototype.splice,z=!!("undefined"!==typeof window&&"undefined"!==typeof navigator&&window.document),ea=!z&&"undefined"!==typeof importScripts,ja=z&&"PLAYSTATION 3"===navigator.platform?/^complete$/:/^(complete|loaded)$/,\r\nY="undefined"!==typeof opera&&"[object Opera]"===opera.toString(),F={},q={},R=[],M=!1;if("undefined"===typeof define){if("undefined"!==typeof requirejs){if(G(requirejs))return;q=requirejs;requirejs=void 0}"undefined"!==typeof require&&!G(require)&&(q=require,require=void 0);g=requirejs=function(b,c,d,e){var n,p="_";!H(b)&&"string"!==typeof b&&(n=b,H(c)?(b=c,c=d,d=e):b=[]);n&&n.context&&(p=n.context);(e=m(F,p))||(e=F[p]=g.s.newContext(p));n&&e.configure(n);return e.require(b,c,d)};g.config=function(b){return g(b)};\r\ng.nextTick="undefined"!==typeof setTimeout?function(b){setTimeout(b,4)}:function(b){b()};require||(require=g);g.version="2.1.15";g.jsExtRegExp=/^\\/|:|\\?|\\.js$/;g.isBrowser=z;x=g.s={contexts:F,newContext:ga};g({});v(["toUrl","undef","defined","specified"],function(b){g[b]=function(){var c=F._;return c.require[b].apply(c,arguments)}});if(z&&(y=x.head=document.getElementsByTagName("head")[0],D=document.getElementsByTagName("base")[0]))y=x.head=D.parentNode;g.onError=ca;g.createNode=function(b){var c=\r\nb.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script");c.type=b.scriptType||"text/javascript";c.charset="utf-8";c.async=!0;return c};g.load=function(b,c,d){var e=b&&b.config||{};if(z)return e=g.createNode(e,c,d),e.setAttribute("data-requirecontext",b.contextName),e.setAttribute("data-requiremodule",c),e.attachEvent&&!(e.attachEvent.toString&&0>e.attachEvent.toString().indexOf("[native code"))&&!Y?(M=!0,e.attachEvent("onreadystatechange",b.onScriptLoad)):\r\n(e.addEventListener("load",b.onScriptLoad,!1),e.addEventListener("error",b.onScriptError,!1)),e.src=d,J=e,D?y.insertBefore(e,D):y.appendChild(e),J=null,e;if(ea)try{importScripts(d),b.completeLoad(c)}catch(m){b.onError(C("importscripts","importScripts failed for "+c+" at "+d,m,[c]))}};z&&!q.skipDataMain&&T(document.getElementsByTagName("script"),function(b){y||(y=b.parentNode);if(I=b.getAttribute("data-main"))return s=I,q.baseUrl||(E=s.split("/"),s=E.pop(),O=E.length?E.join("/")+"/":"./",q.baseUrl=\r\nO),s=s.replace(Q,""),g.jsExtRegExp.test(s)&&(s=I),q.deps=q.deps?q.deps.concat(s):[s],!0});define=function(b,c,d){var e,g;"string"!==typeof b&&(d=c,c=b,b=null);H(c)||(d=c,c=null);!c&&G(d)&&(c=[],d.length&&(d.toString().replace(ka,"").replace(la,function(b,d){c.push(d)}),c=(1===d.length?["require"]:["require","exports","module"]).concat(c)));if(M){if(!(e=J))N&&"interactive"===N.readyState||T(document.getElementsByTagName("script"),function(b){if("interactive"===b.readyState)return N=b}),e=N;e&&(b||\r\n(b=e.getAttribute("data-requiremodule")),g=F[e.getAttribute("data-requirecontext")])}(g?g.defQueue:R).push([b,c,d])};define.amd={jQuery:!0};g.exec=function(b){return eval(b)};g(q)}})(this);\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/require.js'),define("requireLib",function(){}),eval("/*\r\n Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk\r\n License: MIT - http://mrgnrdrck.mit-license.org\r\n \r\n https://github.com/mroderick/PubSubJS\r\n */\r\n/*jslint white:true, plusplus:true, stupid:true*/\r\n/*global\r\n setTimeout,\r\n module,\r\n exports,\r\n define,\r\n require,\r\n window\r\n */\r\n(function (root, factory) {\r\n    'use strict';\r\n\r\n    if (typeof define === 'function' && define.amd) {\r\n        // AMD. Register as an anonymous module.\r\n        define('pubsub',['exports'], factory);\r\n\r\n    } else if (typeof exports === 'object') {\r\n        // CommonJS\r\n        factory(exports);\r\n\r\n    } else {\r\n        // Browser globals\r\n        factory((root.PubSub = {}));\r\n\r\n    }\r\n}((typeof window === 'object' && window) || this, function (PubSub) {\r\n    'use strict';\r\n\r\n    var messages = {},\r\n            lastUid = -1;\r\n\r\n    function hasKeys(obj) {\r\n        var key;\r\n\r\n        for (key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\tReturns a function that throws the passed exception, for use as argument for setTimeout\r\n     *\t@param { Object } ex An Error object\r\n     */\r\n    function throwException(ex) {\r\n        return function reThrowException() {\r\n            throw ex;\r\n        };\r\n    }\r\n\r\n    function callSubscriberWithDelayedExceptions(subscriber, message, data) {\r\n//        try {\r\n        subscriber(message, data);\r\n//        } catch (ex) {\r\n//            setTimeout(throwException(ex), 0);\r\n//        }\r\n    }\r\n\r\n    function callSubscriberWithImmediateExceptions(subscriber, message, data) {\r\n        subscriber(message, data);\r\n    }\r\n\r\n    function deliverMessage(originalMessage, matchedMessage, data, immediateExceptions) {\r\n        var subscribers = messages[matchedMessage],\r\n                callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,\r\n                s;\r\n\r\n        if (!messages.hasOwnProperty(matchedMessage)) {\r\n            return;\r\n        }\r\n\r\n        for (s in subscribers) {\r\n            if (subscribers.hasOwnProperty(s)) {\r\n                callSubscriber(subscribers[s], originalMessage, data);\r\n            }\r\n        }\r\n    }\r\n\r\n    function createDeliveryFunction(message, data, immediateExceptions) {\r\n        return function deliverNamespaced() {\r\n            var topic = String(message),\r\n                    position = topic.lastIndexOf('.');\r\n\r\n            // deliver the message as it is now\r\n            deliverMessage(message, message, data, immediateExceptions);\r\n\r\n            // trim the hierarchy and deliver message to each level\r\n            while (position !== -1) {\r\n                topic = topic.substr(0, position);\r\n                position = topic.lastIndexOf('.');\r\n                deliverMessage(message, topic, data);\r\n            }\r\n        };\r\n    }\r\n\r\n    function messageHasSubscribers(message) {\r\n        var topic = String(message),\r\n                found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic])),\r\n                position = topic.lastIndexOf('.');\r\n\r\n        while (!found && position !== -1) {\r\n            topic = topic.substr(0, position);\r\n            position = topic.lastIndexOf('.');\r\n            found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic]));\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    function publish(message, data, sync, immediateExceptions) {\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n        console.log('pubsub: ', message, data);\r\n        //>>includeEnd(\"debug\");\r\n        \r\n        if (data === undefined) {\r\n            data = {};\r\n        }\r\n        var deliver = createDeliveryFunction(message, data, immediateExceptions),\r\n                hasSubscribers = messageHasSubscribers(message);\r\n\r\n        if (!hasSubscribers) {\r\n            return false;\r\n        }\r\n\r\n        if (sync === true) {\r\n            deliver();\r\n        } else {\r\n            setTimeout(deliver, 0);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\tPubSub.publish( message[, data] ) -> Boolean\r\n     *\t- message (String): The message to publish\r\n     *\t- data: The data to pass to subscribers\r\n     *\tPublishes the the message, passing the data to it's subscribers\r\n     **/\r\n    PubSub.publish = function (message, data) {\r\n        return PubSub.publishSync.apply(null, arguments);\r\n//        return publish(message, data, false, PubSub.immediateExceptions);\r\n    };\r\n\r\n    /**\r\n     *\tPubSub.publishSync( message[, data] ) -> Boolean\r\n     *\t- message (String): The message to publish\r\n     *\t- data: The data to pass to subscribers\r\n     *\tPublishes the the message synchronously, passing the data to it's subscribers\r\n     **/\r\n    PubSub.publishSync = function (message, data) {\r\n        return publish(message, data, true, PubSub.immediateExceptions);\r\n    };\r\n\r\n    /**\r\n     *\tPubSub.subscribe( message, func ) -> String\r\n     *\t- message (String): The message to subscribe to\r\n     *\t- func (Function): The function to call when a new message is published\r\n     *\tSubscribes the passed function to the passed message. Every returned token is unique and should be stored if\r\n     *\tyou need to unsubscribe\r\n     **/\r\n    PubSub.subscribe = function (message, func) {\r\n        if (typeof func !== 'function') {\r\n            return false;\r\n        }\r\n\r\n        // message is not registered yet\r\n        if (!messages.hasOwnProperty(message)) {\r\n            messages[message] = {};\r\n        }\r\n\r\n        // forcing token as String, to allow for future expansions without breaking usage\r\n        // and allow for easy use as key names for the 'messages' object\r\n        var token = 'uid_' + String(++lastUid);\r\n        messages[message][token] = func;\r\n\r\n        // return token for unsubscribing\r\n        return token;\r\n    };\r\n    /* Public: Subscribe multiple handlers at once\r\n     */\r\n    PubSub.subscribeBatch = function (handlers) {\r\n        for (var key in handlers) {\r\n            if (handlers.hasOwnProperty(key)) {\r\n                PubSub.subscribe(key, handlers[key]);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /* Public: Clears all subscriptions\r\n     */\r\n    PubSub.clearAllSubscriptions = function clearSubscriptions() {\r\n        messages = {};\r\n    };\r\n\r\n    /* Public: removes subscriptions.\r\n     * When passed a token, removes a specific subscription.\r\n     * When passed a function, removes all subscriptions for that function\r\n     * When passed a topic, removes all subscriptions for that topic (hierarchy)\r\n     *\r\n     * value - A token, function or topic to unsubscribe.\r\n     *\r\n     * Examples\r\n     *\r\n     *\t\t// Example 1 - unsubscribing with a token\r\n     *\t\tvar token = PubSub.subscribe('mytopic', myFunc);\r\n     *\t\tPubSub.unsubscribe(token);\r\n     *\r\n     *\t\t// Example 2 - unsubscribing with a function\r\n     *\t\tPubSub.unsubscribe(myFunc);\r\n     *\r\n     *\t\t// Example 3 - unsubscribing a topic\r\n     *\t\tPubSub.unsubscribe('mytopic');\r\n     */\r\n    PubSub.unsubscribe = function (value) {\r\n        var isTopic = typeof value === 'string' && messages.hasOwnProperty(value),\r\n                isToken = !isTopic && typeof value === 'string',\r\n                isFunction = typeof value === 'function',\r\n                result = false,\r\n                m, message, t, token;\r\n\r\n        if (isTopic) {\r\n            delete messages[value];\r\n            return;\r\n        }\r\n\r\n        for (m in messages) {\r\n            if (messages.hasOwnProperty(m)) {\r\n                message = messages[m];\r\n\r\n                if (isToken && message[value]) {\r\n                    delete message[value];\r\n                    result = value;\r\n                    // tokens are unique, so we can just stop here\r\n                    break;\r\n                } else if (isFunction) {\r\n                    for (t in message) {\r\n                        if (message.hasOwnProperty(t) && message[t] === value) {\r\n                            delete message[t];\r\n                            result = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n}));\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/pubsub.js"),eval('/*! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license\r\n//@ sourceMappingURL=jquery.min.map\r\n*/(function(e,t){var n,r,i=typeof t,o=e.document,a=e.location,s=e.jQuery,u=e.$,l={},c=[],p="1.9.1",f=c.concat,d=c.push,h=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,b=function(e,t){return new b.fn.init(e,t,r)},x=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,w=/\\S+/g,T=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,N=/^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,C=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,k=/^[\\],:{}\\s]*$/,E=/(?:^|:|,)(?:\\s*\\[)+/g,S=/\\\\(?:["\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,A=/"[^"\\\\\\r\\n]*"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,j=/^-ms-/,D=/-([\\da-z])/gi,L=function(e,t){return t.toUpperCase()},H=function(e){(o.addEventListener||"load"===e.type||"complete"===o.readyState)&&(q(),b.ready())},q=function(){o.addEventListener?(o.removeEventListener("DOMContentLoaded",H,!1),e.removeEventListener("load",H,!1)):(o.detachEvent("onreadystatechange",H),e.detachEvent("onload",H))};b.fn=b.prototype={jquery:p,constructor:b,init:function(e,n,r){var i,a;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof b?n[0]:n,b.merge(this,b.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:o,!0)),C.test(i[1])&&b.isPlainObject(n))for(i in n)b.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(a=o.getElementById(i[2]),a&&a.parentNode){if(a.id!==i[2])return r.find(e);this.length=1,this[0]=a}return this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):b.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),b.makeArray(e,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return h.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=b.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return b.each(this,e,t)},ready:function(e){return b.ready.promise().done(e),this},slice:function(){return this.pushStack(h.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(b.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:d,sort:[].sort,splice:[].splice},b.fn.init.prototype=b.fn,b.extend=b.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},u=1,l=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},u=2),"object"==typeof s||b.isFunction(s)||(s={}),l===u&&(s=this,--u);l>u;u++)if(null!=(o=arguments[u]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(b.isPlainObject(r)||(n=b.isArray(r)))?(n?(n=!1,a=e&&b.isArray(e)?e:[]):a=e&&b.isPlainObject(e)?e:{},s[i]=b.extend(c,a,r)):r!==t&&(s[i]=r));return s},b.extend({noConflict:function(t){return e.$===b&&(e.$=u),t&&e.jQuery===b&&(e.jQuery=s),b},isReady:!1,readyWait:1,holdReady:function(e){e?b.readyWait++:b.ready(!0)},ready:function(e){if(e===!0?!--b.readyWait:!b.isReady){if(!o.body)return setTimeout(b.ready);b.isReady=!0,e!==!0&&--b.readyWait>0||(n.resolveWith(o,[b]),b.fn.trigger&&b(o).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===b.type(e)},isArray:Array.isArray||function(e){return"array"===b.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if(!e||"object"!==b.type(e)||e.nodeType||b.isWindow(e))return!1;try{if(e.constructor&&!y.call(e,"constructor")&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||y.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=b.buildFragment([e],t,i),i&&b(i).remove(),b.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=b.trim(n),n&&k.test(n.replace(S,"@").replace(A,"]").replace(E,"")))?Function("return "+n)():(b.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||b.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&b.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(j,"ms-").replace(D,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:v&&!v.call("\\ufeff\\u00a0")?function(e){return null==e?"":v.call(e)}:function(e){return null==e?"":(e+"").replace(T,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?b.merge(n,"string"==typeof e?[e]:e):d.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(g)return g.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return f.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),b.isFunction(e)?(r=h.call(arguments,2),i=function(){return e.apply(n||this,r.concat(h.call(arguments)))},i.guid=e.guid=e.guid||b.guid++,i):t},access:function(e,n,r,i,o,a,s){var u=0,l=e.length,c=null==r;if("object"===b.type(r)){o=!0;for(u in r)b.access(e,n,u,r[u],!0,a,s)}else if(i!==t&&(o=!0,b.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(b(e),n)})),n))for(;l>u;u++)n(e[u],r,s?i:i.call(e[u],u,n(e[u],r)));return o?e:c?n.call(e):l?n(e[0],r):a},now:function(){return(new Date).getTime()}}),b.ready.promise=function(t){if(!n)if(n=b.Deferred(),"complete"===o.readyState)setTimeout(b.ready);else if(o.addEventListener)o.addEventListener("DOMContentLoaded",H,!1),e.addEventListener("load",H,!1);else{o.attachEvent("onreadystatechange",H),e.attachEvent("onload",H);var r=!1;try{r=null==e.frameElement&&o.documentElement}catch(i){}r&&r.doScroll&&function a(){if(!b.isReady){try{r.doScroll("left")}catch(e){return setTimeout(a,50)}q(),b.ready()}}()}return n.promise(t)},b.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=b.type(e);return b.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=b(o);var _={};function F(e){var t=_[e]={};return b.each(e.match(w)||[],function(e,n){t[n]=!0}),t}b.Callbacks=function(e){e="string"==typeof e?_[e]||F(e):b.extend({},e);var n,r,i,o,a,s,u=[],l=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=u.length,n=!0;u&&o>a;a++)if(u[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,u&&(l?l.length&&c(l.shift()):r?u=[]:p.disable())},p={add:function(){if(u){var t=u.length;(function i(t){b.each(t,function(t,n){var r=b.type(n);"function"===r?e.unique&&p.has(n)||u.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=u.length:r&&(s=t,c(r))}return this},remove:function(){return u&&b.each(arguments,function(e,t){var r;while((r=b.inArray(t,u,r))>-1)u.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?b.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],this},disable:function(){return u=l=r=t,this},disabled:function(){return!u},lock:function(){return l=t,r||p.disable(),this},locked:function(){return!l},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!u||i&&!l||(n?l.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},b.extend({Deferred:function(e){var t=[["resolve","done",b.Callbacks("once memory"),"resolved"],["reject","fail",b.Callbacks("once memory"),"rejected"],["notify","progress",b.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return b.Deferred(function(n){b.each(t,function(t,o){var a=o[0],s=b.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&b.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?b.extend(e,r):r}},i={};return r.pipe=r.then,b.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=h.call(arguments),r=n.length,i=1!==r||e&&b.isFunction(e.promise)?r:0,o=1===i?e:b.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?h.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,u,l;if(r>1)for(s=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&b.isFunction(n[t].promise)?n[t].promise().done(a(t,l,n)).fail(o.reject).progress(a(t,u,s)):--i;return i||o.resolveWith(l,n),o.promise()}}),b.support=function(){var t,n,r,a,s,u,l,c,p,f,d=o.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>",n=d.getElementsByTagName("*"),r=d.getElementsByTagName("a")[0],!n||!r||!n.length)return{};s=o.createElement("select"),l=s.appendChild(o.createElement("option")),a=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={getSetAttribute:"t"!==d.className,leadingWhitespace:3===d.firstChild.nodeType,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:"/a"===r.getAttribute("href"),opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:!!a.value,optSelected:l.selected,enctype:!!o.createElement("form").enctype,html5Clone:"<:nav></:nav>"!==o.createElement("nav").cloneNode(!0).outerHTML,boxModel:"CSS1Compat"===o.compatMode,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},a.checked=!0,t.noCloneChecked=a.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!l.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}a=o.createElement("input"),a.setAttribute("value",""),t.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),t.radioValue="t"===a.value,a.setAttribute("checked","t"),a.setAttribute("name","t"),u=o.createDocumentFragment(),u.appendChild(a),t.appendChecked=a.checked,t.checkClone=u.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;return d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip,b(function(){var n,r,a,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",u=o.getElementsByTagName("body")[0];u&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",u.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",a=d.getElementsByTagName("td"),a[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===a[0].offsetHeight,a[0].style.display="",a[1].style.display="none",t.reliableHiddenOffsets=p&&0===a[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=4===d.offsetWidth,t.doesNotIncludeMarginInBodyOffset=1!==u.offsetTop,e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(o.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(u.style.zoom=1)),u.removeChild(n),n=d=a=r=null)}),n=s=u=l=r=a=null,t}();var O=/(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,B=/([A-Z])/g;function P(e,n,r,i){if(b.acceptData(e)){var o,a,s=b.expando,u="string"==typeof n,l=e.nodeType,p=l?b.cache:e,f=l?e[s]:e[s]&&s;if(f&&p[f]&&(i||p[f].data)||!u||r!==t)return f||(l?e[s]=f=c.pop()||b.guid++:f=s),p[f]||(p[f]={},l||(p[f].toJSON=b.noop)),("object"==typeof n||"function"==typeof n)&&(i?p[f]=b.extend(p[f],n):p[f].data=b.extend(p[f].data,n)),o=p[f],i||(o.data||(o.data={}),o=o.data),r!==t&&(o[b.camelCase(n)]=r),u?(a=o[n],null==a&&(a=o[b.camelCase(n)])):a=o,a}}function R(e,t,n){if(b.acceptData(e)){var r,i,o,a=e.nodeType,s=a?b.cache:e,u=a?e[b.expando]:b.expando;if(s[u]){if(t&&(o=n?s[u]:s[u].data)){b.isArray(t)?t=t.concat(b.map(t,b.camelCase)):t in o?t=[t]:(t=b.camelCase(t),t=t in o?[t]:t.split(" "));for(r=0,i=t.length;i>r;r++)delete o[t[r]];if(!(n?$:b.isEmptyObject)(o))return}(n||(delete s[u].data,$(s[u])))&&(a?b.cleanData([e],!0):b.support.deleteExpando||s!=s.window?delete s[u]:s[u]=null)}}}b.extend({cache:{},expando:"jQuery"+(p+Math.random()).replace(/\\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?b.cache[e[b.expando]]:e[b.expando],!!e&&!$(e)},data:function(e,t,n){return P(e,t,n)},removeData:function(e,t){return R(e,t)},_data:function(e,t,n){return P(e,t,n,!0)},_removeData:function(e,t){return R(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&b.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),b.fn.extend({data:function(e,n){var r,i,o=this[0],a=0,s=null;if(e===t){if(this.length&&(s=b.data(o),1===o.nodeType&&!b._data(o,"parsedAttrs"))){for(r=o.attributes;r.length>a;a++)i=r[a].name,i.indexOf("data-")||(i=b.camelCase(i.slice(5)),W(o,i,s[i]));b._data(o,"parsedAttrs",!0)}return s}return"object"==typeof e?this.each(function(){b.data(this,e)}):b.access(this,function(n){return n===t?o?W(o,e,b.data(o,e)):null:(this.each(function(){b.data(this,e,n)}),t)},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){b.removeData(this,e)})}});function W(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(B,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:O.test(r)?b.parseJSON(r):r}catch(o){}b.data(e,n,r)}else r=t}return r}function $(e){var t;for(t in e)if(("data"!==t||!b.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}b.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=b._data(e,n),r&&(!i||b.isArray(r)?i=b._data(e,n,b.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=b.queue(e,t),r=n.length,i=n.shift(),o=b._queueHooks(e,t),a=function(){b.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),o.cur=i,i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return b._data(e,n)||b._data(e,n,{empty:b.Callbacks("once memory").add(function(){b._removeData(e,t+"queue"),b._removeData(e,n)})})}}),b.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?b.queue(this[0],e):n===t?this:this.each(function(){var t=b.queue(this,e,n);b._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&b.dequeue(this,e)})},dequeue:function(e){return this.each(function(){b.dequeue(this,e)})},delay:function(e,t){return e=b.fx?b.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=b.Deferred(),a=this,s=this.length,u=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=b._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(u));return u(),o.promise(n)}});var I,z,X=/[\\t\\r\\n]/g,U=/\\r/g,V=/^(?:input|select|textarea|button|object)$/i,Y=/^(?:a|area)$/i,J=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,G=/^(?:checked|selected)$/i,Q=b.support.getSetAttribute,K=b.support.input;b.fn.extend({attr:function(e,t){return b.access(this,b.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){b.removeAttr(this,e)})},prop:function(e,t){return b.access(this,b.prop,e,t,arguments.length>1)},removeProp:function(e){return e=b.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,u="string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=b.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,u=0===arguments.length||"string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?b.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return b.isFunction(e)?this.each(function(n){b(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var o,a=0,s=b(this),u=t,l=e.match(w)||[];while(o=l[a++])u=r?u:!s.hasClass(o),s[u?"addClass":"removeClass"](o)}else(n===i||"boolean"===n)&&(this.className&&b._data(this,"__className__",this.className),this.className=this.className||e===!1?"":b._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(X," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=b.isFunction(e),this.each(function(n){var o,a=b(this);1===this.nodeType&&(o=i?e.call(this,n,a.val()):e,null==o?o="":"number"==typeof o?o+="":b.isArray(o)&&(o=b.map(o,function(e){return null==e?"":e+""})),r=b.valHooks[this.type]||b.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=b.valHooks[o.type]||b.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(U,""):null==n?"":n)}}}),b.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,u=0>i?s:o?i:0;for(;s>u;u++)if(n=r[u],!(!n.selected&&u!==i||(b.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&b.nodeName(n.parentNode,"optgroup"))){if(t=b(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n=b.makeArray(t);return b(e).find("option").each(function(){this.selected=b.inArray(b(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attr:function(e,n,r){var o,a,s,u=e.nodeType;if(e&&3!==u&&8!==u&&2!==u)return typeof e.getAttribute===i?b.prop(e,n,r):(a=1!==u||!b.isXMLDoc(e),a&&(n=n.toLowerCase(),o=b.attrHooks[n]||(J.test(n)?z:I)),r===t?o&&a&&"get"in o&&null!==(s=o.get(e,n))?s:(typeof e.getAttribute!==i&&(s=e.getAttribute(n)),null==s?t:s):null!==r?o&&a&&"set"in o&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r):(b.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=b.propFix[n]||n,J.test(n)?!Q&&G.test(n)?e[b.camelCase("default-"+n)]=e[r]=!1:e[r]=!1:b.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!b.support.radioValue&&"radio"===t&&b.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!b.isXMLDoc(e),a&&(n=b.propFix[n]||n,o=b.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):V.test(e.nodeName)||Y.test(e.nodeName)&&e.href?0:t}}}}),z={get:function(e,n){var r=b.prop(e,n),i="boolean"==typeof r&&e.getAttribute(n),o="boolean"==typeof r?K&&Q?null!=i:G.test(n)?e[b.camelCase("default-"+n)]:!!i:e.getAttributeNode(n);return o&&o.value!==!1?n.toLowerCase():t},set:function(e,t,n){return t===!1?b.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&b.propFix[n]||n,n):e[b.camelCase("default-"+n)]=e[n]=!0,n}},K&&Q||(b.attrHooks.value={get:function(e,n){var r=e.getAttributeNode(n);return b.nodeName(e,"input")?e.defaultValue:r&&r.specified?r.value:t},set:function(e,n,r){return b.nodeName(e,"input")?(e.defaultValue=n,t):I&&I.set(e,n,r)}}),Q||(I=b.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&("id"===n||"name"===n||"coords"===n?""!==r.value:r.specified)?r.value:t},set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},b.attrHooks.contenteditable={get:I.get,set:function(e,t,n){I.set(e,""===t?!1:t,n)}},b.each(["width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}})})),b.support.hrefNormalized||(b.each(["href","src","width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return null==r?t:r}})}),b.each(["href","src"],function(e,t){b.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}})),b.support.style||(b.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),b.support.optSelected||(b.propHooks.selected=b.extend(b.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),b.support.enctype||(b.propFix.enctype="encoding"),b.support.checkOn||b.each(["radio","checkbox"],function(){b.valHooks[this]={get:function(e){return null===e.getAttribute("value")?"on":e.value}}}),b.each(["radio","checkbox"],function(){b.valHooks[this]=b.extend(b.valHooks[this],{set:function(e,n){return b.isArray(n)?e.checked=b.inArray(b(e).val(),n)>=0:t}})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\\.(.+)|)$/;function it(){return!0}function ot(){return!1}b.event={global:{},add:function(e,n,r,o,a){var s,u,l,c,p,f,d,h,g,m,y,v=b._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=b.guid++),(u=v.events)||(u=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof b===i||e&&b.event.triggered===e.type?t:b.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(w)||[""],l=n.length;while(l--)s=rt.exec(n[l])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),p=b.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=b.event.special[g]||{},d=b.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&b.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=u[g])||(h=u[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),b.event.global[g]=!0;e=null}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,p,f,d,h,g,m=b.hasData(e)&&b._data(e);if(m&&(c=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(s=rt.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=b.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\\\.)"+h.join("\\\\.(?:.*\\\\.|)")+"(\\\\.|$)"),u=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));u&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||b.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)b.event.remove(e,d+t[l],n,r,!0);b.isEmptyObject(c)&&(delete m.handle,b._removeData(e,"events"))}},trigger:function(n,r,i,a){var s,u,l,c,p,f,d,h=[i||o],g=y.call(n,"type")?n.type:n,m=y.call(n,"namespace")?n.namespace.split("."):[];if(l=f=i=i||o,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+b.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),u=0>g.indexOf(":")&&"on"+g,n=n[b.expando]?n:new b.Event(g,"object"==typeof n&&n),n.isTrigger=!0,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\\\.)"+m.join("\\\\.(?:.*\\\\.|)")+"(\\\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:b.makeArray(r,[n]),p=b.event.special[g]||{},a||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!a&&!p.noBubble&&!b.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(l=l.parentNode);l;l=l.parentNode)h.push(l),f=l;f===(i.ownerDocument||o)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((l=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(b._data(l,"events")||{})[n.type]&&b._data(l,"handle"),s&&s.apply(l,r),s=u&&l[u],s&&b.acceptData(l)&&s.apply&&s.apply(l,r)===!1&&n.preventDefault();if(n.type=g,!(a||n.isDefaultPrevented()||p._default&&p._default.apply(i.ownerDocument,r)!==!1||"click"===g&&b.nodeName(i,"a")||!b.acceptData(i)||!u||!i[g]||b.isWindow(i))){f=i[u],f&&(i[u]=null),b.event.triggered=g;try{i[g]()}catch(v){}b.event.triggered=t,f&&(i[u]=f)}return n.result}},dispatch:function(e){e=b.event.fix(e);var n,r,i,o,a,s=[],u=h.call(arguments),l=(b._data(this,"events")||{})[e.type]||[],c=b.event.special[e.type]||{};if(u[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=b.event.handlers.call(this,e,l),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((b.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,u),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],u=n.delegateCount,l=e.target;if(u&&l.nodeType&&(!e.button||"click"!==e.type))for(;l!=this;l=l.parentNode||this)if(1===l.nodeType&&(l.disabled!==!0||"click"!==e.type)){for(o=[],a=0;u>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?b(r,this).index(l)>=0:b.find(r,this,null,[l]).length),o[r]&&o.push(i);o.length&&s.push({elem:l,handlers:o})}return n.length>u&&s.push({elem:this,handlers:n.slice(u)}),s},fix:function(e){if(e[b.expando])return e;var t,n,r,i=e.type,a=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new b.Event(a),t=r.length;while(t--)n=r[t],e[n]=a[n];return e.target||(e.target=a.srcElement||o),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,a):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,a,s=n.button,u=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||o,a=i.documentElement,r=i.body,e.pageX=n.clientX+(a&&a.scrollLeft||r&&r.scrollLeft||0)-(a&&a.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(a&&a.scrollTop||r&&r.scrollTop||0)-(a&&a.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&u&&(e.relatedTarget=u===e.target?n.toElement:u),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},click:{trigger:function(){return b.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t}},focus:{trigger:function(){if(this!==o.activeElement&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===o.activeElement&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=b.extend(new b.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?b.event.trigger(i,null,t):b.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},b.removeEvent=o.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},b.Event=function(e,n){return this instanceof b.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&b.extend(this,n),this.timeStamp=e&&e.timeStamp||b.now(),this[b.expando]=!0,t):new b.Event(e,n)},b.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},b.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){b.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;\r\nreturn(!i||i!==r&&!b.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),b.support.submitBubbles||(b.event.special.submit={setup:function(){return b.nodeName(this,"form")?!1:(b.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=b.nodeName(n,"input")||b.nodeName(n,"button")?n.form:t;r&&!b._data(r,"submitBubbles")&&(b.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),b._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&b.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return b.nodeName(this,"form")?!1:(b.event.remove(this,"._submit"),t)}}),b.support.changeBubbles||(b.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(b.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),b.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),b.event.simulate("change",this,e,!0)})),!1):(b.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!b._data(t,"changeBubbles")&&(b.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||b.event.simulate("change",this.parentNode,e,!0)}),b._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return b.event.remove(this,"._change"),!Z.test(this.nodeName)}}),b.support.focusinBubbles||b.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){b.event.simulate(t,e.target,b.event.fix(e),!0)};b.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),b.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return b().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=b.guid++)),this.each(function(){b.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,b(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){b.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){b.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?b.event.trigger(e,n,r,!0):t}}),function(e,t){var n,r,i,o,a,s,u,l,c,p,f,d,h,g,m,y,v,x="sizzle"+-new Date,w=e.document,T={},N=0,C=0,k=it(),E=it(),S=it(),A=typeof t,j=1<<31,D=[],L=D.pop,H=D.push,q=D.slice,M=D.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},_="[\\\\x20\\\\t\\\\r\\\\n\\\\f]",F="(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",O=F.replace("w","w#"),B="([*^$|!~]?=)",P="\\\\["+_+"*("+F+")"+_+"*(?:"+B+_+"*(?:([\'\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|("+O+")|)|)"+_+"*\\\\]",R=":("+F+")(?:\\\\((([\'\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|"+P.replace(3,8)+")*)|.*)\\\\)|)",W=RegExp("^"+_+"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)"+_+"+$","g"),$=RegExp("^"+_+"*,"+_+"*"),I=RegExp("^"+_+"*([\\\\x20\\\\t\\\\r\\\\n\\\\f>+~])"+_+"*"),z=RegExp(R),X=RegExp("^"+O+"$"),U={ID:RegExp("^#("+F+")"),CLASS:RegExp("^\\\\.("+F+")"),NAME:RegExp("^\\\\[name=[\'\\"]?("+F+")[\'\\"]?\\\\]"),TAG:RegExp("^("+F.replace("w","w*")+")"),ATTR:RegExp("^"+P),PSEUDO:RegExp("^"+R),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\("+_+"*(even|odd|(([+-]|)(\\\\d*)n|)"+_+"*(?:([+-]|)"+_+"*(\\\\d+)|))"+_+"*\\\\)|)","i"),needsContext:RegExp("^"+_+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\("+_+"*((?:-\\\\d)?\\\\d*)"+_+"*\\\\)|)(?=[^-]|$)","i")},V=/[\\x20\\t\\r\\n\\f]*[+~]/,Y=/^[^{]+\\{\\s*\\[native code/,J=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,G=/^(?:input|select|textarea|button)$/i,Q=/^h\\d$/i,K=/\'|\\\\/g,Z=/\\=[\\x20\\t\\r\\n\\f]*([^\'"\\]]*)[\\x20\\t\\r\\n\\f]*\\]/g,et=/\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,tt=function(e,t){var n="0x"+t-65536;return n!==n?t:0>n?String.fromCharCode(n+65536):String.fromCharCode(55296|n>>10,56320|1023&n)};try{q.call(w.documentElement.childNodes,0)[0].nodeType}catch(nt){q=function(e){var t,n=[];while(t=this[e++])n.push(t);return n}}function rt(e){return Y.test(e+"")}function it(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>i.cacheLength&&delete e[t.shift()],e[n]=r}}function ot(e){return e[x]=!0,e}function at(e){var t=p.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}}function st(e,t,n,r){var i,o,a,s,u,l,f,g,m,v;if((t?t.ownerDocument||t:w)!==p&&c(t),t=t||p,n=n||[],!e||"string"!=typeof e)return n;if(1!==(s=t.nodeType)&&9!==s)return[];if(!d&&!r){if(i=J.exec(e))if(a=i[1]){if(9===s){if(o=t.getElementById(a),!o||!o.parentNode)return n;if(o.id===a)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(a))&&y(t,o)&&o.id===a)return n.push(o),n}else{if(i[2])return H.apply(n,q.call(t.getElementsByTagName(e),0)),n;if((a=i[3])&&T.getByClassName&&t.getElementsByClassName)return H.apply(n,q.call(t.getElementsByClassName(a),0)),n}if(T.qsa&&!h.test(e)){if(f=!0,g=x,m=t,v=9===s&&e,1===s&&"object"!==t.nodeName.toLowerCase()){l=ft(e),(f=t.getAttribute("id"))?g=f.replace(K,"\\\\$&"):t.setAttribute("id",g),g="[id=\'"+g+"\'] ",u=l.length;while(u--)l[u]=g+dt(l[u]);m=V.test(e)&&t.parentNode||t,v=l.join(",")}if(v)try{return H.apply(n,q.call(m.querySelectorAll(v),0)),n}catch(b){}finally{f||t.removeAttribute("id")}}}return wt(e.replace(W,"$1"),t,n,r)}a=st.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},c=st.setDocument=function(e){var n=e?e.ownerDocument||e:w;return n!==p&&9===n.nodeType&&n.documentElement?(p=n,f=n.documentElement,d=a(n),T.tagNameNoComments=at(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),T.attributes=at(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return"boolean"!==t&&"string"!==t}),T.getByClassName=at(function(e){return e.innerHTML="<div class=\'hidden e\'></div><div class=\'hidden\'></div>",e.getElementsByClassName&&e.getElementsByClassName("e").length?(e.lastChild.className="e",2===e.getElementsByClassName("e").length):!1}),T.getByName=at(function(e){e.id=x+0,e.innerHTML="<a name=\'"+x+"\'></a><div name=\'"+x+"\'></div>",f.insertBefore(e,f.firstChild);var t=n.getElementsByName&&n.getElementsByName(x).length===2+n.getElementsByName(x+0).length;return T.getIdNotName=!n.getElementById(x),f.removeChild(e),t}),i.attrHandle=at(function(e){return e.innerHTML="<a href=\'#\'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==A&&"#"===e.firstChild.getAttribute("href")})?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},T.getIdNotName?(i.find.ID=function(e,t){if(typeof t.getElementById!==A&&!d){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){return e.getAttribute("id")===t}}):(i.find.ID=function(e,n){if(typeof n.getElementById!==A&&!d){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==A&&r.getAttributeNode("id").value===e?[r]:t:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){var n=typeof e.getAttributeNode!==A&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=T.tagNameNoComments?function(e,n){return typeof n.getElementsByTagName!==A?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},i.find.NAME=T.getByName&&function(e,n){return typeof n.getElementsByName!==A?n.getElementsByName(name):t},i.find.CLASS=T.getByClassName&&function(e,n){return typeof n.getElementsByClassName===A||d?t:n.getElementsByClassName(e)},g=[],h=[":focus"],(T.qsa=rt(n.querySelectorAll))&&(at(function(e){e.innerHTML="<select><option selected=\'\'></option></select>",e.querySelectorAll("[selected]").length||h.push("\\\\["+_+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||h.push(":checked")}),at(function(e){e.innerHTML="<input type=\'hidden\' i=\'\'/>",e.querySelectorAll("[i^=\'\']").length&&h.push("[*^$]="+_+"*(?:\\"\\"|\'\')"),e.querySelectorAll(":enabled").length||h.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),h.push(",.*:")})),(T.matchesSelector=rt(m=f.matchesSelector||f.mozMatchesSelector||f.webkitMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&at(function(e){T.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!=\'\']:x"),g.push("!=",R)}),h=RegExp(h.join("|")),g=RegExp(g.join("|")),y=rt(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},v=f.compareDocumentPosition?function(e,t){var r;return e===t?(u=!0,0):(r=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t))?1&r||e.parentNode&&11===e.parentNode.nodeType?e===n||y(w,e)?-1:t===n||y(w,t)?1:0:4&r?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return u=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:0;if(o===a)return ut(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?ut(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},u=!1,[0,0].sort(v),T.detectDuplicates=u,p):p},st.matches=function(e,t){return st(e,null,null,t)},st.matchesSelector=function(e,t){if((e.ownerDocument||e)!==p&&c(e),t=t.replace(Z,"=\'$1\']"),!(!T.matchesSelector||d||g&&g.test(t)||h.test(t)))try{var n=m.call(e,t);if(n||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(r){}return st(t,p,null,[e]).length>0},st.contains=function(e,t){return(e.ownerDocument||e)!==p&&c(e),y(e,t)},st.attr=function(e,t){var n;return(e.ownerDocument||e)!==p&&c(e),d||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):d||T.attributes?e.getAttribute(t):((n=e.getAttributeNode(t))||e.getAttribute(t))&&e[t]===!0?t:n&&n.specified?n.value:null},st.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},st.uniqueSort=function(e){var t,n=[],r=1,i=0;if(u=!T.detectDuplicates,e.sort(v),u){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e};function ut(e,t){var n=t&&e,r=n&&(~t.sourceIndex||j)-(~e.sourceIndex||j);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function lt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ct(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function pt(e){return ot(function(t){return t=+t,ot(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}o=st.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=o(t);return n},i=st.selectors={cacheLength:50,createPseudo:ot,match:U,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(et,tt),e[3]=(e[4]||e[5]||"").replace(et,tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||st.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&st.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return U.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&z.test(n)&&(t=ft(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){return"*"===e?function(){return!0}:(e=e.replace(et,tt).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[e+" "];return t||(t=RegExp("(^|"+_+")"+e+"("+_+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==A&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=st.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!u&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[x]||(m[x]={}),l=c[e]||[],d=l[0]===N&&l[1],f=l[0]===N&&l[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[N,d,f];break}}else if(v&&(l=(t[x]||(t[x]={}))[e])&&l[0]===N)f=l[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[x]||(p[x]={}))[e]=[N,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||st.error("unsupported pseudo: "+e);return r[x]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?ot(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=M.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:ot(function(e){var t=[],n=[],r=s(e.replace(W,"$1"));return r[x]?ot(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:ot(function(e){return function(t){return st(e,t).length>0}}),contains:ot(function(e){return function(t){return(t.textContent||t.innerText||o(t)).indexOf(e)>-1}}),lang:ot(function(e){return X.test(e||"")||st.error("unsupported lang: "+e),e=e.replace(et,tt).toLowerCase(),function(t){var n;do if(n=d?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return Q.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:pt(function(){return[0]}),last:pt(function(e,t){return[t-1]}),eq:pt(function(e,t,n){return[0>n?n+t:n]}),even:pt(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:pt(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:pt(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:pt(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[n]=lt(n);for(n in{submit:!0,reset:!0})i.pseudos[n]=ct(n);function ft(e,t){var n,r,o,a,s,u,l,c=E[e+" "];if(c)return t?0:c.slice(0);s=e,u=[],l=i.preFilter;while(s){(!n||(r=$.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),u.push(o=[])),n=!1,(r=I.exec(s))&&(n=r.shift(),o.push({value:n,type:r[0].replace(W," ")}),s=s.slice(n.length));for(a in i.filter)!(r=U[a].exec(s))||l[a]&&!(r=l[a](r))||(n=r.shift(),o.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?st.error(e):E(e,u).slice(0)}function dt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function ht(e,t,n){var i=t.dir,o=n&&"parentNode"===i,a=C++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,n,s){var u,l,c,p=N+" "+a;if(s){while(t=t[i])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[x]||(t[x]={}),(l=c[i])&&l[0]===p){if((u=l[1])===!0||u===r)return u===!0}else if(l=c[i]=[p],l[1]=e(t,n,s)||r,l[1]===!0)return!0}}function gt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function mt(e,t,n,r,i){var o,a=[],s=0,u=e.length,l=null!=t;for(;u>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),l&&t.push(s));return a}function yt(e,t,n,r,i,o){return r&&!r[x]&&(r=yt(r)),i&&!i[x]&&(i=yt(i,o)),ot(function(o,a,s,u){var l,c,p,f=[],d=[],h=a.length,g=o||xt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:mt(g,f,e,s,u),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,u),r){l=mt(y,d),r(l,[],s,u),c=l.length;while(c--)(p=l[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(p=y[c])&&l.push(m[c]=p);i(null,y=[],l,u)}c=y.length;while(c--)(p=y[c])&&(l=i?M.call(o,p):f[c])>-1&&(o[l]=!(a[l]=p))}}else y=mt(y===a?y.splice(h,y.length):y),i?i(null,a,y,u):H.apply(a,y)})}function vt(e){var t,n,r,o=e.length,a=i.relative[e[0].type],s=a||i.relative[" "],u=a?1:0,c=ht(function(e){return e===t},s,!0),p=ht(function(e){return M.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;o>u;u++)if(n=i.relative[e[u].type])f=[ht(gt(f),n)];else{if(n=i.filter[e[u].type].apply(null,e[u].matches),n[x]){for(r=++u;o>r;r++)if(i.relative[e[r].type])break;return yt(u>1&&gt(f),u>1&&dt(e.slice(0,u-1)).replace(W,"$1"),n,r>u&&vt(e.slice(u,r)),o>r&&vt(e=e.slice(r)),o>r&&dt(e))}f.push(n)}return gt(f)}function bt(e,t){var n=0,o=t.length>0,a=e.length>0,s=function(s,u,c,f,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,T=l,C=s||a&&i.find.TAG("*",d&&u.parentNode||u),k=N+=null==T?1:Math.random()||.1;for(w&&(l=u!==p&&u,r=n);null!=(h=C[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,u,c)){f.push(h);break}w&&(N=k,r=++n)}o&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,o&&b!==v){g=0;while(m=t[g++])m(x,y,u,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=L.call(f));y=mt(y)}H.apply(f,y),w&&!s&&y.length>0&&v+t.length>1&&st.uniqueSort(f)}return w&&(N=k,l=T),x};return o?ot(s):s}s=st.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=ft(e)),n=t.length;while(n--)o=vt(t[n]),o[x]?r.push(o):i.push(o);o=S(e,bt(i,r))}return o};function xt(e,t,n){var r=0,i=t.length;for(;i>r;r++)st(e,t[r],n);return n}function wt(e,t,n,r){var o,a,u,l,c,p=ft(e);if(!r&&1===p.length){if(a=p[0]=p[0].slice(0),a.length>2&&"ID"===(u=a[0]).type&&9===t.nodeType&&!d&&i.relative[a[1].type]){if(t=i.find.ID(u.matches[0].replace(et,tt),t)[0],!t)return n;e=e.slice(a.shift().value.length)}o=U.needsContext.test(e)?0:a.length;while(o--){if(u=a[o],i.relative[l=u.type])break;if((c=i.find[l])&&(r=c(u.matches[0].replace(et,tt),V.test(a[0].type)&&t.parentNode||t))){if(a.splice(o,1),e=r.length&&dt(a),!e)return H.apply(n,q.call(r,0)),n;break}}}return s(e,p)(r,t,d,n,V.test(e)),n}i.pseudos.nth=i.pseudos.eq;function Tt(){}i.filters=Tt.prototype=i.pseudos,i.setFilters=new Tt,c(),st.attr=b.attr,b.find=st,b.expr=st.selectors,b.expr[":"]=b.expr.pseudos,b.unique=st.uniqueSort,b.text=st.getText,b.isXMLDoc=st.isXML,b.contains=st.contains}(e);var at=/Until$/,st=/^(?:parents|prev(?:Until|All))/,ut=/^.[^:#\\[\\.,]*$/,lt=b.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};b.fn.extend({find:function(e){var t,n,r,i=this.length;if("string"!=typeof e)return r=this,this.pushStack(b(e).filter(function(){for(t=0;i>t;t++)if(b.contains(r[t],this))return!0}));for(n=[],t=0;i>t;t++)b.find(e,this[t],n);return n=this.pushStack(i>1?b.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t,n=b(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(b.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1))},filter:function(e){return this.pushStack(ft(this,e,!0))},is:function(e){return!!e&&("string"==typeof e?lt.test(e)?b(e,this.context).index(this[0])>=0:b.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,o=[],a=lt.test(e)||"string"!=typeof e?b(e,t||this.context):0;for(;i>r;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&11!==n.nodeType){if(a?a.index(n)>-1:b.find.matchesSelector(n,e)){o.push(n);break}n=n.parentNode}}return this.pushStack(o.length>1?b.unique(o):o)},index:function(e){return e?"string"==typeof e?b.inArray(this[0],b(e)):b.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?b(e,t):b.makeArray(e&&e.nodeType?[e]:e),r=b.merge(this.get(),n);return this.pushStack(b.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),b.fn.andSelf=b.fn.addBack;function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}b.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return b.dir(e,"parentNode")},parentsUntil:function(e,t,n){return b.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return b.dir(e,"nextSibling")},prevAll:function(e){return b.dir(e,"previousSibling")},nextUntil:function(e,t,n){return b.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return b.dir(e,"previousSibling",n)},siblings:function(e){return b.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return b.sibling(e.firstChild)},contents:function(e){return b.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:b.merge([],e.childNodes)}},function(e,t){b.fn[e]=function(n,r){var i=b.map(this,t,n);return at.test(e)||(r=n),r&&"string"==typeof r&&(i=b.filter(r,i)),i=this.length>1&&!ct[e]?b.unique(i):i,this.length>1&&st.test(e)&&(i=i.reverse()),this.pushStack(i)}}),b.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),1===t.length?b.find.matchesSelector(t[0],e)?[t[0]]:[]:b.find.matches(e,t)},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!b(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(t=t||0,b.isFunction(t))return b.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return b.grep(e,function(e){return e===t===n});if("string"==typeof t){var r=b.grep(e,function(e){return 1===e.nodeType});if(ut.test(t))return b.filter(t,r,!n);t=b.filter(t,r)}return b.grep(e,function(e){return b.inArray(e,t)>=0===n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\\d+="(?:null|\\d+)"/g,mt=RegExp("<(?:"+ht+")[\\\\s/>]","i"),yt=/^\\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,bt=/<([\\w:]+)/,xt=/<tbody/i,wt=/<|&#?\\w+;/,Tt=/<(?:script|style|link)/i,Nt=/^(?:checkbox|radio)$/i,Ct=/checked\\s*(?:[^=]|=\\s*.checked.)/i,kt=/^$|\\/(?:java|ecma)script/i,Et=/^true\\/(.*)/,St=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,At={option:[1,"<select multiple=\'multiple\'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:b.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(o),Dt=jt.appendChild(o.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,b.fn.extend({text:function(e){return b.access(this,function(e){return e===t?b.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(b.isFunction(e))return this.each(function(t){b(this).wrapAll(e.call(this,t))});if(this[0]){var t=b(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return b.isFunction(e)?this.each(function(t){b(this).wrapInner(e.call(this,t))}):this.each(function(){var t=b(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=b.isFunction(e);return this.each(function(n){b(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){b.nodeName(this,"body")||b(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.insertBefore(e,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=0;for(;null!=(n=this[r]);r++)(!e||b.filter(e,[n]).length>0)&&(t||1!==n.nodeType||b.cleanData(Ot(n)),n.parentNode&&(t&&b.contains(n.ownerDocument,n)&&Mt(Ot(n,"script")),n.parentNode.removeChild(n)));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&b.cleanData(Ot(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&b.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return b.clone(this,e,t)})},html:function(e){return b.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!b.support.htmlSerialize&&mt.test(e)||!b.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(b.cleanData(Ot(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){var t=b.isFunction(e);return t||"string"==typeof e||(e=b(e).not(this).detach()),this.domManip([e],!0,function(e){var t=this.nextSibling,n=this.parentNode;n&&(b(this).remove(),n.insertBefore(e,t))})},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=f.apply([],e);var i,o,a,s,u,l,c=0,p=this.length,d=this,h=p-1,g=e[0],m=b.isFunction(g);if(m||!(1>=p||"string"!=typeof g||b.support.checkClone)&&Ct.test(g))return this.each(function(i){var o=d.eq(i);m&&(e[0]=g.call(this,i,n?o.html():t)),o.domManip(e,n,r)});if(p&&(l=b.buildFragment(e,this[0].ownerDocument,!1,this),i=l.firstChild,1===l.childNodes.length&&(l=i),i)){for(n=n&&b.nodeName(i,"tr"),s=b.map(Ot(l,"script"),Ht),a=s.length;p>c;c++)o=l,c!==h&&(o=b.clone(o,!0,!0),a&&b.merge(s,Ot(o,"script"))),r.call(n&&b.nodeName(this[c],"table")?Lt(this[c],"tbody"):this[c],o,c);if(a)for(u=s[s.length-1].ownerDocument,b.map(s,qt),c=0;a>c;c++)o=s[c],kt.test(o.type||"")&&!b._data(o,"globalEval")&&b.contains(u,o)&&(o.src?b.ajax({url:o.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):b.globalEval((o.text||o.textContent||o.innerHTML||"").replace(St,"")));l=i=null}return this}});function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function Ht(e){var t=e.getAttributeNode("type");return e.type=(t&&t.specified)+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function Mt(e,t){var n,r=0;for(;null!=(n=e[r]);r++)b._data(n,"globalEval",!t||b._data(t[r],"globalEval"))}function _t(e,t){if(1===t.nodeType&&b.hasData(e)){var n,r,i,o=b._data(e),a=b._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)b.event.add(t,n,s[n][r])}a.data&&(a.data=b.extend({},a.data))}}function Ft(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!b.support.noCloneEvent&&t[b.expando]){i=b._data(t);for(r in i.events)b.removeEvent(t,r,i.handle);t.removeAttribute(b.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),b.support.html5Clone&&e.innerHTML&&!b.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Nt.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}b.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){b.fn[e]=function(e){var n,r=0,i=[],o=b(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),b(o[r])[t](n),d.apply(i,n.get());return this.pushStack(i)}});function Ot(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||b.nodeName(o,n)?s.push(o):b.merge(s,Ot(o,n));return n===t||n&&b.nodeName(e,n)?b.merge([e],s):s}function Bt(e){Nt.test(e.type)&&(e.defaultChecked=e.checked)}b.extend({clone:function(e,t,n){var r,i,o,a,s,u=b.contains(e.ownerDocument,e);if(b.support.html5Clone||b.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(b.support.noCloneEvent&&b.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||b.isXMLDoc(e)))for(r=Ot(o),s=Ot(e),a=0;null!=(i=s[a]);++a)r[a]&&Ft(i,r[a]);if(t)if(n)for(s=s||Ot(e),r=r||Ot(o),a=0;null!=(i=s[a]);a++)_t(i,r[a]);else _t(e,o);return r=Ot(o,"script"),r.length>0&&Mt(r,!u&&Ot(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,u,l,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===b.type(o))b.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),u=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[u]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!b.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!b.support.tbody){o="table"!==u||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)b.nodeName(l=o.childNodes[i],"tbody")&&!l.childNodes.length&&o.removeChild(l)\r\n}b.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),b.support.appendChecked||b.grep(Ot(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===b.inArray(o,r))&&(a=b.contains(o.ownerDocument,o),s=Ot(f.appendChild(o),"script"),a&&Mt(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,u=b.expando,l=b.cache,p=b.support.deleteExpando,f=b.event.special;for(;null!=(n=e[s]);s++)if((t||b.acceptData(n))&&(o=n[u],a=o&&l[o])){if(a.events)for(r in a.events)f[r]?b.event.remove(n,r):b.removeEvent(n,r,a.handle);l[o]&&(delete l[o],p?delete n[u]:typeof n.removeAttribute!==i?n.removeAttribute(u):n[u]=null,c.push(o))}}});var Pt,Rt,Wt,$t=/alpha\\([^)]*\\)/i,It=/opacity\\s*=\\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+x+")(.*)$","i"),Yt=RegExp("^("+x+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+x+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===b.css(e,"display")||!b.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=b._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=b._data(r,"olddisplay",un(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&b._data(r,"olddisplay",i?n:b.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}b.fn.extend({css:function(e,n){return b.access(this,function(e,n,r){var i,o,a={},s=0;if(b.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=b.css(e,n[s],!1,o);return a}return r!==t?b.style(e,n,r):b.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){var t="boolean"==typeof e;return this.each(function(){(t?e:nn(this))?b(this).show():b(this).hide()})}}),b.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":b.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,u=b.camelCase(n),l=e.style;if(n=b.cssProps[u]||(b.cssProps[u]=tn(l,u)),s=b.cssHooks[n]||b.cssHooks[u],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:l[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(b.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||b.cssNumber[u]||(r+="px"),b.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(l[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{l[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,u=b.camelCase(n);return n=b.cssProps[u]||(b.cssProps[u]=tn(e.style,u)),s=b.cssHooks[n]||b.cssHooks[u],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||b.isNumeric(o)?o||0:a):a},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s.getPropertyValue(n)||s[n]:t,l=e.style;return s&&(""!==u||b.contains(e.ownerDocument,e)||(u=b.style(e,n)),Yt.test(u)&&Ut.test(n)&&(i=l.width,o=l.minWidth,a=l.maxWidth,l.minWidth=l.maxWidth=l.width=u,u=s.width,l.width=i,l.minWidth=o,l.maxWidth=a)),u}):o.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s[n]:t,l=e.style;return null==u&&l&&l[n]&&(u=l[n]),Yt.test(u)&&!zt.test(n)&&(i=l.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),l.left="fontSize"===n?"1em":u,u=l.pixelLeft+"px",l.left=i,a&&(o.left=a)),""===u?"auto":u});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=b.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=b.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=b.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=b.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=b.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(b.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function un(e){var t=o,n=Gt[e];return n||(n=ln(e,t),"none"!==n&&n||(Pt=(Pt||b("<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=ln(e,t),Pt.detach()),Gt[e]=n),n}function ln(e,t){var n=b(t.createElement(e)).appendTo(t.body),r=b.css(n[0],"display");return n.remove(),r}b.each(["height","width"],function(e,n){b.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(b.css(e,"display"))?b.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,i),i):0)}}}),b.support.opacity||(b.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=b.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===b.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),b(function(){b.support.reliableMarginRight||(b.cssHooks.marginRight={get:function(e,n){return n?b.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!b.support.pixelPosition&&b.fn.position&&b.each(["top","left"],function(e,n){b.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?b(e).position()[n]+"px":r):t}}})}),b.expr&&b.expr.filters&&(b.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!b.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||b.css(e,"display"))},b.expr.filters.visible=function(e){return!b.expr.filters.hidden(e)}),b.each({margin:"",padding:"",border:"Width"},function(e,t){b.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(b.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\\[\\]$/,fn=/\\r?\\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;b.fn.extend({serialize:function(){return b.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=b.prop(this,"elements");return e?b.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!b(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Nt.test(e))}).map(function(e,t){var n=b(this).val();return null==n?null:b.isArray(n)?b.map(n,function(e){return{name:t.name,value:e.replace(fn,"\\r\\n")}}):{name:t.name,value:n.replace(fn,"\\r\\n")}}).get()}}),b.param=function(e,n){var r,i=[],o=function(e,t){t=b.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=b.ajaxSettings&&b.ajaxSettings.traditional),b.isArray(e)||e.jquery&&!b.isPlainObject(e))b.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(b.isArray(t))b.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==b.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}b.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){b.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),b.fn.hover=function(e,t){return this.mouseenter(e).mouseleave(t||e)};var mn,yn,vn=b.now(),bn=/\\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/gm,Nn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Cn=/^(?:GET|HEAD)$/,kn=/^\\/\\//,En=/^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,Sn=b.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=a.href}catch(Ln){yn=o.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(w)||[];if(b.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(u){var l;return o[u]=!0,b.each(e[u]||[],function(e,u){var c=u(n,r,i);return"string"!=typeof c||a||o[c]?a?!(l=c):t:(n.dataTypes.unshift(c),s(c),!1)}),l}return s(n.dataTypes[0])||!o["*"]&&s("*")}function Mn(e,n){var r,i,o=b.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&b.extend(!0,e,r),e}b.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,u=e.indexOf(" ");return u>=0&&(i=e.slice(u,e.length),e=e.slice(0,u)),b.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&b.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?b("<div>").append(b.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},b.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){b.fn[t]=function(e){return this.on(t,e)}}),b.each(["get","post"],function(e,n){b[n]=function(e,r,i,o){return b.isFunction(r)&&(o=o||i,i=r,r=t),b.ajax({url:e,type:n,dataType:o,data:r,success:i})}}),b.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Nn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":b.parseJSON,"text xml":b.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Mn(Mn(e,b.ajaxSettings),t):Mn(b.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,u,l,c,p=b.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?b(f):b.event,h=b.Deferred(),g=b.Callbacks("once memory"),m=p.statusCode||{},y={},v={},x=0,T="canceled",N={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return x||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>x)for(t in e)m[t]=[m[t],e[t]];else N.always(e[N.status]);return this},abort:function(e){var t=e||T;return l&&l.abort(t),k(0,t),this}};if(h.promise(N).complete=g.add,N.success=N.done,N.error=N.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=b.trim(p.dataType||"*").toLowerCase().match(w)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?80:443))==(mn[3]||("http:"===mn[1]?80:443)))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=b.param(p.data,p.traditional)),qn(An,p,n,N),2===x)return N;u=p.global,u&&0===b.active++&&b.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Cn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(b.lastModified[o]&&N.setRequestHeader("If-Modified-Since",b.lastModified[o]),b.etag[o]&&N.setRequestHeader("If-None-Match",b.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&N.setRequestHeader("Content-Type",p.contentType),N.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)N.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,N,p)===!1||2===x))return N.abort();T="abort";for(i in{success:1,error:1,complete:1})N[i](p[i]);if(l=qn(jn,p,n,N)){N.readyState=1,u&&d.trigger("ajaxSend",[N,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){N.abort("timeout")},p.timeout));try{x=1,l.send(y,k)}catch(C){if(!(2>x))throw C;k(-1,C)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,C=n;2!==x&&(x=2,s&&clearTimeout(s),l=t,a=i||"",N.readyState=e>0?4:0,r&&(w=_n(p,N,r)),e>=200&&300>e||304===e?(p.ifModified&&(T=N.getResponseHeader("Last-Modified"),T&&(b.lastModified[o]=T),T=N.getResponseHeader("etag"),T&&(b.etag[o]=T)),204===e?(c=!0,C="nocontent"):304===e?(c=!0,C="notmodified"):(c=Fn(p,w),C=c.state,y=c.data,v=c.error,c=!v)):(v=C,(e||!C)&&(C="error",0>e&&(e=0))),N.status=e,N.statusText=(n||C)+"",c?h.resolveWith(f,[y,C,N]):h.rejectWith(f,[N,C,v]),N.statusCode(m),m=t,u&&d.trigger(c?"ajaxSuccess":"ajaxError",[N,p,c?y:v]),g.fireWith(f,[N,C]),u&&(d.trigger("ajaxComplete",[N,p]),--b.active||b.event.trigger("ajaxStop")))}return N},getScript:function(e,n){return b.get(e,t,n,"script")},getJSON:function(e,t,n){return b.get(e,t,n,"json")}});function _n(e,n,r){var i,o,a,s,u=e.contents,l=e.dataTypes,c=e.responseFields;for(s in c)s in r&&(n[c[s]]=r[s]);while("*"===l[0])l.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in u)if(u[s]&&u[s].test(o)){l.unshift(s);break}if(l[0]in r)a=l[0];else{for(s in r){if(!l[0]||e.converters[s+" "+l[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==l[0]&&l.unshift(a),r[a]):t}function Fn(e,t){var n,r,i,o,a={},s=0,u=e.dataTypes.slice(),l=u[0];if(e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u[1])for(i in e.converters)a[i.toLowerCase()]=e.converters[i];for(;r=u[++s];)if("*"!==r){if("*"!==l&&l!==r){if(i=a[l+" "+r]||a["* "+r],!i)for(n in a)if(o=n.split(" "),o[1]===r&&(i=a[l+" "+o[0]]||a["* "+o[0]])){i===!0?i=a[n]:a[n]!==!0&&(r=o[0],u.splice(s--,0,r));break}if(i!==!0)if(i&&e["throws"])t=i(t);else try{t=i(t)}catch(c){return{state:"parsererror",error:i?c:"No conversion from "+l+" to "+r}}}l=r}return{state:"success",data:t}}b.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return b.globalEval(e),e}}}),b.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),b.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=o.head||b("head")[0]||o.documentElement;return{send:function(t,i){n=o.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var On=[],Bn=/(=)\\?(?=&|$)|\\?\\?/;b.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=On.pop()||b.expando+"_"+vn++;return this[e]=!0,e}}),b.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,u=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return u||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=b.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,u?n[u]=n[u].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||b.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,On.push(o)),s&&b.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}b.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=b.ajaxSettings.xhr(),b.support.cors=!!Rn&&"withCredentials"in Rn,Rn=b.support.ajax=!!Rn,Rn&&b.ajaxTransport(function(n){if(!n.crossDomain||b.support.cors){var r;return{send:function(i,o){var a,s,u=n.xhr();if(n.username?u.open(n.type,n.url,n.async,n.username,n.password):u.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)u[s]=n.xhrFields[s];n.mimeType&&u.overrideMimeType&&u.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)u.setRequestHeader(s,i[s])}catch(l){}u.send(n.hasContent&&n.data||null),r=function(e,i){var s,l,c,p;try{if(r&&(i||4===u.readyState))if(r=t,a&&(u.onreadystatechange=b.noop,$n&&delete Pn[a]),i)4!==u.readyState&&u.abort();else{p={},s=u.status,l=u.getAllResponseHeaders(),"string"==typeof u.responseText&&(p.text=u.responseText);try{c=u.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,l)},n.async?4===u.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},b(e).unload($n)),Pn[a]=r),u.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+x+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n,r,i=this.createTween(e,t),o=Yn.exec(t),a=i.cur(),s=+a||0,u=1,l=20;if(o){if(n=+o[2],r=o[3]||(b.cssNumber[e]?"":"px"),"px"!==r&&s){s=b.css(i.elem,e,!0)||n||1;do u=u||".5",s/=u,b.style(i.elem,e,s+r);while(u!==(u=i.cur()/a)&&1!==u&&--l)}i.unit=r,i.start=s,i.end=o[1]?s+(o[1]+1)*n:n}return i}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=b.now()}function Zn(e,t){b.each(t,function(t,n){var r=(Qn[t]||[]).concat(Qn["*"]),i=0,o=r.length;for(;o>i;i++)if(r[i].call(e,t,n))return})}function er(e,t,n){var r,i,o=0,a=Gn.length,s=b.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;for(;u>a;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),1>o&&u?n:(s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:b.extend({},t),opts:b.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=b.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?s.resolveWith(e,[l,t]):s.rejectWith(e,[l,t]),this}}),c=l.props;for(tr(c,l.opts.specialEasing);a>o;o++)if(r=Gn[o].call(l,e,c,l.opts))return r;return Zn(l,c),b.isFunction(l.opts.start)&&l.opts.start.call(e,l),b.fx.timer(b.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function tr(e,t){var n,r,i,o,a;for(i in e)if(r=b.camelCase(i),o=t[r],n=e[i],b.isArray(n)&&(o=n[1],n=e[i]=n[0]),i!==r&&(e[r]=n,delete e[i]),a=b.cssHooks[r],a&&"expand"in a){n=a.expand(n),delete e[r];for(i in n)i in e||(e[i]=n[i],t[i]=o)}else t[r]=o}b.Animation=b.extend(er,{tweener:function(e,t){b.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,u,l,c,p,f=this,d=e.style,h={},g=[],m=e.nodeType&&nn(e);n.queue||(c=b._queueHooks(e,"fx"),null==c.unqueued&&(c.unqueued=0,p=c.empty.fire,c.empty.fire=function(){c.unqueued||p()}),c.unqueued++,f.always(function(){f.always(function(){c.unqueued--,b.queue(e,"fx").length||c.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[d.overflow,d.overflowX,d.overflowY],"inline"===b.css(e,"display")&&"none"===b.css(e,"float")&&(b.support.inlineBlockNeedsLayout&&"inline"!==un(e.nodeName)?d.zoom=1:d.display="inline-block")),n.overflow&&(d.overflow="hidden",b.support.shrinkWrapBlocks||f.always(function(){d.overflow=n.overflow[0],d.overflowX=n.overflow[1],d.overflowY=n.overflow[2]}));for(i in t)if(a=t[i],Vn.exec(a)){if(delete t[i],u=u||"toggle"===a,a===(m?"hide":"show"))continue;g.push(i)}if(o=g.length){s=b._data(e,"fxshow")||b._data(e,"fxshow",{}),"hidden"in s&&(m=s.hidden),u&&(s.hidden=!m),m?b(e).show():f.done(function(){b(e).hide()}),f.done(function(){var t;b._removeData(e,"fxshow");for(t in h)b.style(e,t,h[t])});for(i=0;o>i;i++)r=g[i],l=f.createTween(r,m?s[r]:0),h[r]=s[r]||b.style(e,r),r in s||(s[r]=l.start,m&&(l.end=l.start,l.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}b.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(b.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?b.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=b.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){b.fx.step[e.prop]?b.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[b.cssProps[e.prop]]||b.cssHooks[e.prop])?b.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},b.each(["toggle","show","hide"],function(e,t){var n=b.fn[t];b.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),b.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=b.isEmptyObject(e),o=b.speed(t,n,r),a=function(){var t=er(this,b.extend({},e),o);a.finish=function(){t.stop(!0)},(i||b._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=b.timers,a=b._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&b.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=b._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=b.timers,a=r?r.length:0;for(n.finish=!0,b.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}b.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){b.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),b.speed=function(e,t,n){var r=e&&"object"==typeof e?b.extend({},e):{complete:n||!n&&t||b.isFunction(e)&&e,duration:e,easing:n&&t||t&&!b.isFunction(t)&&t};return r.duration=b.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in b.fx.speeds?b.fx.speeds[r.duration]:b.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){b.isFunction(r.old)&&r.old.call(this),r.queue&&b.dequeue(this,r.queue)},r},b.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},b.timers=[],b.fx=rr.prototype.init,b.fx.tick=function(){var e,n=b.timers,r=0;for(Xn=b.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||b.fx.stop(),Xn=t},b.fx.timer=function(e){e()&&b.timers.push(e)&&b.fx.start()},b.fx.interval=13,b.fx.start=function(){Un||(Un=setInterval(b.fx.tick,b.fx.interval))},b.fx.stop=function(){clearInterval(Un),Un=null},b.fx.speeds={slow:600,fast:200,_default:400},b.fx.step={},b.expr&&b.expr.filters&&(b.expr.filters.animated=function(e){return b.grep(b.timers,function(t){return e===t.elem}).length}),b.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){b.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,b.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},b.offset={setOffset:function(e,t,n){var r=b.css(e,"position");"static"===r&&(e.style.position="relative");var i=b(e),o=i.offset(),a=b.css(e,"top"),s=b.css(e,"left"),u=("absolute"===r||"fixed"===r)&&b.inArray("auto",[a,s])>-1,l={},c={},p,f;u?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),b.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(l.top=t.top-o.top+p),null!=t.left&&(l.left=t.left-o.left+f),"using"in t?t.using.call(e,l):i.css(l)}},b.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===b.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),b.nodeName(e[0],"html")||(n=e.offset()),n.top+=b.css(e[0],"borderTopWidth",!0),n.left+=b.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-b.css(r,"marginTop",!0),left:t.left-n.left-b.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||o.documentElement;while(e&&!b.nodeName(e,"html")&&"static"===b.css(e,"position"))e=e.offsetParent;return e||o.documentElement})}}),b.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);b.fn[e]=function(i){return b.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?b(a).scrollLeft():o,r?o:b(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return b.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}b.each({Height:"height",Width:"width"},function(e,n){b.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){b.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return b.access(this,function(n,r,i){var o;return b.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?b.css(n,r,s):b.style(n,r,i,s)},n,a?i:t,a,null)}})}),e.jQuery=e.$=b,"function"==typeof define&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return b})})(window);\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/jquery-1.9.1.min.js'),
eval("define('data/config-core',[], function () {\r\n    return  {\r\n        VERSION: '1.0.17',\r\n        DUMMY_DATA: false,\r\n        TOGGLE_FULL_SCREEN_ON_POINTER: true,\r\n        SET_FULL_SCREEN_ON_START: true,\r\n        UI_TYPE: 'mobile',\r\n        SOUND_BASE_URL: 'sound/',\r\n        REQUEST_TIMEOUT: 10000,\r\n        LONG_REQUEST_NOTIFICATION_TRESHOLD_MS: 4000,\r\n        REELS_AREA_SCALE: 1.0,\r\n        REELS_AREA_OFFSET_TOP: 0,\r\n        REELS_AREA_OFFSET_LEFT: 0,\r\n        CANVAS_SIZE_DEFAULT_RATIO: 3 / 2,\r\n        CANVAS_SIZE_TOP_MAX_CUT_PERCENT: 10,\r\n        CANVAS_SIZE_BOTTOM_MAX_CUT_PERCENT: 8.6,\r\n        CANVAS_LIMITED_BY_WIDTH_OFFSET_TOP: 0,\r\n        CANVAS_LIMITED_BY_WIDTH_OFFSET_LEFT: 0,\r\n        CANVAS_SIZE_WIDTH_MAX_CUT_PERCENT: 0,\r\n        CANVAS_BASE_WIDTH: 960,\r\n        CANVAS_BASE_HEIGHT: 640,\r\n        OVERLAY_1_TOP: 594,\r\n        OVERLAY_2_TOP: -586,\r\n        REELS_DRAG_SPIN_TRESHOLD_POSITIONS: .5,\r\n        MENU_PRIMARY_TEXT_STYLE: {type: 'css', font: 'myriadpro-semiext', color: 'white', lineHeight: 1},\r\n        MENU_SECONDARY_TEXT_STYLE: {type: 'css', font: 'myriadpro-semiext', color: '#acaca9', lineHeight: 1},\r\n        MENU_HEADER_TEXT_STYLE: {type: 'css', font: 'myriadpro-semiext', color: 'white', lineHeight: 1},\r\n        BIG_BUTTON_TEXT_STYLE_UP: {type: 'pixi', font: 'myriadpro-semiext', color: 'white'},\r\n        BIG_BUTTON_TEXT_STYLE_HOVER: {type: 'pixi', font: 'myriadpro-semiext', color: 'white'},\r\n        BIG_BUTTON_TEXT_STYLE_DOWN: {type: 'pixi', font: 'myriadpro-semiext', color: 'white'},\r\n        BIG_BUTTON_TEXT_STYLE_DISABLED: {type: 'pixi', font: 'myriadpro-semiext', color: 'white'},\r\n        OLD_BIG_BUTTON_TEXT_STYLE_UP: {type: 'bitmap', font: 'big-button-text-old-up', scaleX: .95, lineHeight: .9, adjustment: {x: 0, y: -5}},\r\n        OLD_BIG_BUTTON_TEXT_STYLE_DOWN: {type: 'bitmap', font: 'big-button-text-old-down', scaleX: .9, lineHeight: .9},\r\n        OLD_BIG_BUTTON_TEXT_STYLE_DISABLED: {type: 'bitmap', font: 'big-button-text-old-disabled', scaleX: .95, lineHeight: .9},\r\n        MAIN_TEXT_STYLE_4: {type: 'bitmap', font: 'myriadpro-white', scaleX: .9}, // bottom text\r\n        DEFAULT_FONT_SIZE: 20,\r\n        // from server\r\n        BET_STEPS: null,\r\n        LINES_STEPS: null,\r\n        DENOMINATION_STEPS: null,\r\n        MAX_BET_IN_MONEY: null,\r\n        // menu\r\n        ROUNDS_STEPS: [5, 10, 20, 50, 75, 100, 200, 500, 1000],\r\n        STOP_TIME_SUFFIX: ' min',\r\n        WIN_EXCEEDS_STEPS: [5, 10, 20, 50, 75, 100, 200, 500, 1000],\r\n        WIN_EXCEEDS_SUFFIX: ' bets',\r\n        BALANCE_DECERASE_STEPS: [10, 20, 30, 40, 50, 60, 70, 80, 90],\r\n        BALANCE_DECREASE_SUFFIX: ' %',\r\n        BALANCE_INCREASE_STEPS: [1.5, 2, 3, 5, 10],\r\n        BALANCE_INCREASE_SUFFIX: 'x',\r\n        // timing\r\n        IDLE_TIMEOUT_MS: 5000,\r\n        DEFAULT_ANIM_SPEED: 30,\r\n        GAME_SPEED_MODIFIER: 1,\r\n        ANIM_SPEED_MODIFIER: 1,\r\n        CREDIT_AMOUNT_ANIMATION_DELAY: 65,\r\n        CROSSFADE_ANIMATION_DURATION: 1350,\r\n        MINIMUM_FIRST_WIN_LINE_VIEW_DURATION: 1600,\r\n        BETLINES_PREVIEW_TIMEOUT: 5000,\r\n        WIN_LINES_CYCLE_PAUSE_DURATION: 2000,\r\n        WIN_LINES_CYCLE_VIEW_DURATION_FIRST_PASS: 550,\r\n        WIN_LINES_CYCLE_VIEW_DURATION: 1000,\r\n        FREE_GAME_INTRO_DELAY: 3500,\r\n        FREE_GAME_OUTRO_DELAY: 3500,\r\n        FREE_SPIN_NO_WIN_PAUSE_DURATION: 500,\r\n        FREE_SPIN_AFTER_WIN_PREVIEW_PAUSE_DURATION: 500,\r\n        FREE_GAME_WIN_LINES_FIRST_VIEW_DURATION: 1000,\r\n        FREE_SPIN_ADDITIONAL_WIN_PAUSE_DURATION: 3500,\r\n        AUTO_SPIN_NO_WIN_PAUSE_DURATION: 250,\r\n        AUTO_SPIN_AFTER_WIN_PREVIEW_PAUSE_DURATION: 300,\r\n        BEFORE_FORCE_SPIN_PAUSE: 300,\r\n        BEFORE_FREE_SPINS_START_PAUSE: 300,\r\n        PRE_WIN_ACTIVITY_TIMEOUT: 150,\r\n        WIN_LINES_FIRST_VIEW_DURATION: 1000,\r\n        GAMBLE_CARD_FLIP_DURATION: 700,\r\n        GAMBLE_VIEW_PAUSE_DURATION: 2500,\r\n        EXPANDING_STEP_DELAY_MS: 750,\r\n        BIG_WIN_ANIMATION_DURATION: 6500,\r\n        REELS_STOP_TIMEOUT: {\r\n            0: .252,\r\n            1: .670,\r\n            2: 1.075,\r\n            3: 1.35,\r\n            4: 1.76,\r\n        },\r\n        FASTER_SPIN_SPEED_MODIFIER: 2.5,\r\n        SPIN_SPEED: 15,\r\n// sound\r\n        BACKGROUND_SOUND_INACTIVITY_TIMEOUT: 30000,\r\n        BACKGROUND_SOUND_MAX_VOLUME: 1,\r\n        ATTENTION_SOUND: 'bell',\r\n        ROTATE_SOUND: 'rotate',\r\n        LIGHTWEIGHT_SPIN_SOUND_DATA: {\r\n            stopSound: {\r\n                0: 'stop0',\r\n                1: 'stop1',\r\n                2: 'stop2',\r\n                3: 'stop3',\r\n                4: 'stop4',\r\n                5: 'stop4',\r\n            },\r\n            scatterSound: {\r\n                0: 'trigger',\r\n                1: 'trigger',\r\n                2: 'trigger',\r\n                3: 'trigger',\r\n                4: 'trigger',\r\n                5: 'trigger',\r\n            },\r\n        },\r\n        FANCY_CLICK_SOUND: 'actions_start',\r\n        AUTOSPIN_ON_SOUND: 'auto_button_on',\r\n        AUTOSPIN_OFF_SOUND: 'auto_button_off',\r\n        TAKE_WIN_FINISH_SOUND: 'credits_accept_finished',\r\n        CARD_FLIP_SOUND: 'gamble_card_open',\r\n        CARD_FLIP_ALL_SOUND: 'gamble_cards_close',\r\n        GAMBLE_WIN_SOUND: 'gamble_card_open_win',\r\n        GAMBLE_LOSE_SOUND: 'gamble_card_open_loss',\r\n        GAMBLE_TIE_SOUND: 'gamble_card_open_same',\r\n        WIN_AMOUNT_ANIMATION_SOUND: 'accepting_credits',\r\n        BASIC_WIN_SOUND: 'winner-short',\r\n        BACKGROUND_SOUND: 'background-base',\r\n        HIGH_WIN_SOUND_1: 'winner-mid',\r\n        HIGH_WIN_SOUND_2: 'winner-long',\r\n        TEASER_SOUND: 'teaser',\r\n        LIGHWEIGHT_FG_INTRO_SOUND: 'wintable',\r\n        WIN_LINE_SHOW_SOUND: 'winline',\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-core.js"),eval("define('data/config',['jquery', 'data/config-core'], function ($, coreConfig) {\r\n    return $.extend(coreConfig, {\r\n        GAME_NAME: 'VIKINGS',\r\n        IMAGES_JSON_SIZE_BYTES: 5400303,\r\n        // reels\r\n        REEL_STOP_TIME_DIFF_ALLOWED: true,\r\n        SHOW_SCATTER_WIN_OVER_REELS: true,\r\n        HIDE_STATIC_SYMBOLS_WHEN_ANIMATING: true,\r\n        HIDE_WINNINGS_ON_FG_BANNER: true,\r\n        // betlines\r\n        BETLINES_TOTAL: 20,\r\n        BETLINES_INCREMENT_STEP: 1,\r\n        // labels, fonts\r\n        // winline info text\r\n        MAIN_TEXT_STYLE_6: {type: 'bitmap', font: 'winline'}, //  winline info text\r\n        // gamble - gamble amount/to win labels\r\n        MAIN_TEXT_STYLE_7: {type: 'bitmap', font: 'ochre'},\r\n        // gamble - gamble values\r\n        MAIN_TEXT_STYLE_8: {type: 'bitmap', font: 'ochre'},\r\n        // sounds\r\n        BASIC_SPIN_SOUND_DATA: {\r\n            stopSound: {\r\n                0: 'stop0',\r\n                1: 'stop1',\r\n                2: 'stop2',\r\n                3: 'stop3',\r\n                4: 'stop4',\r\n            },\r\n            scatterSound: {\r\n                0: 'trigger0',\r\n                1: 'trigger1',\r\n                2: 'trigger2',\r\n                3: 'trigger3',\r\n                4: 'trigger4',\r\n            },\r\n        },\r\n        FREE_SPIN_SOUND_DATA: {\r\n            stopSound: {\r\n                0: 'stop0',\r\n                1: 'stop1',\r\n                2: 'stop2',\r\n                3: 'stop3',\r\n                4: 'stop4',\r\n            },\r\n            scatterSound: {\r\n                0: 'trigger0',\r\n                1: 'trigger1',\r\n                2: 'trigger2',\r\n                3: 'trigger3',\r\n                4: 'trigger4',\r\n            },\r\n        },\r\n        // SYMBOL SOUND\r\n        BASIC_SPIN_SYMBOL_WIN_SOUND: {\r\n            0: 'win_$0$1$2$3',\r\n            1: 'win_$4$5$6',\r\n            2: 'win_$7$8$9',\r\n            3: 'win_$10$11$12',\r\n            4: 'win_$13$14$15',\r\n            5: 'win_$16$17$18',\r\n            6: 'win_$19$20$21',\r\n            7: 'win_$22$23$24$25$26$27',\r\n            8: 'win_$22$23$24$25$26$27',\r\n            9: 'win_$28$29$30',\r\n            10: 'win_$16$17$18',\r\n        },\r\n        FREE_GAME_START_SOUND: 'start_wintable',\r\n        FREE_GAME_ADDITIONAL_SOUND: 'start_wintable',\r\n        FREE_GAME_SPIN_SOUND: 'background-fg',\r\n        FREE_GAME_ENDED_SOUND: 'end_wintable',\r\n        TRIPLE_SCATTER_WIN_SOUND: 'win_$28$29$30',\r\n        //\r\n        REELS_AREA_SCALE: 1.23,\r\n        REELS_AREA_OFFSET_TOP: -31,\r\n        REELS_AREA_OFFSET_LEFT: 0,\r\n        //\r\n        TEASER_ANIMATION_LEFT: {\r\n            0: 149.5,\r\n            1: 279,\r\n            2: 400,\r\n            3: 539.5,\r\n            4: 679.5,\r\n        },\r\n        TEASER_ANIMATION_TOP: 121,\r\n        TEASER_ANIMATION_WIDTH: 157,\r\n        TEASER_ANIMATION_HEIGHT: 406,\r\n    });\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config.js"),eval("/**\n * @license\n * pixi.js - v3.0.10\n * Compiled 2016-03-31T20:39:38.722Z\n *\n * pixi.js is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license.php\n *\n *\n * The MIT License\n * \n * Copyright (c) 2013-2015 Mathew Groves\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n * \n */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define('pixi',[],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PIXI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,global){\n/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"_process\":3}],2:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":3}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],5:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],6:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":5,\"./encode\":6}],8:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar punycode = require('punycode');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a puny coded representation of \"domain\".\n      // It only converts the part of the domain name that\n      // has non ASCII characters. I.e. it dosent matter if\n      // you call it with a domain that already is in ASCII.\n      var domainArray = this.hostname.split('.');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            'xn--' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join('.');\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    Object.keys(relative).forEach(function(k) {\n      if (k !== 'protocol')\n        result[k] = relative[k];\n    });\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!isNull(result.pathname) || !isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!isNull(result.pathname) || !isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return  arg == null;\n}\n\n},{\"punycode\":4,\"querystring\":7}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, size;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\n        size = Math.max(maxX - minX, maxY - minY);\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, size);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var sum = 0,\n        i, j, last;\n\n    // calculate original winding order of a polygon ring\n    for (i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n\n    // link points into circular doubly-linked list in the specified winding order\n    if (clockwise === (sum > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) return null;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && size) indexCurve(ear, minX, minY, size);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, size);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, size) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, size),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, size);\n\n    // first look for points inside the triangle in increasing z-order\n    var p = ear.nextZ;\n\n    while (p && p.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.nextZ;\n    }\n\n    // then look for points in decreasing z-order\n    p = ear.prevZ;\n\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        // a self-intersection where edge (v[i-1],v[i]) intersects (v[i+1],v[i+2])\n        if (intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, size) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, size);\n                earcutLinked(c, triangles, dim, minX, minY, size);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hole.x === m.x) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= m.x &&\n                pointInTriangle(hy < m.y ? hx : qx, hy, m.x, m.y, hy < m.y ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, size) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize === 0) {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                } else if (qSize === 0 || !q) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else if (p.z <= q.z) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and size of the data bounding box\nfunction zOrder(x, y, minX, minY, size) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) / size;\n    y = 32767 * (y - minY) / size;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n},{}],11:[function(require,module,exports){\n/* eslint-disable no-unused-vars */\n'use strict';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nmodule.exports = Object.assign || function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n},{}],12:[function(require,module,exports){\n(function (process){\n/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n/*jshint onevar: false, indent:4 */\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = function () {};\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = function () {};\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        }\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= q.concurrency; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        };\n\n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n}).call(this,require('_process'))\n},{\"_process\":3}],13:[function(require,module,exports){\nvar async       = require('async'),\n    urlParser   = require('url'),\n    Resource    = require('./Resource'),\n    EventEmitter = require('eventemitter3');\n\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.\n * @param [concurrency=10] {number} The number of resources to load concurrently.\n */\nfunction Loader(baseUrl, concurrency) {\n    EventEmitter.call(this);\n\n    concurrency = concurrency || 10;\n\n    /**\n     * The base url for all resources loaded by this loader.\n     *\n     * @member {string}\n     */\n    this.baseUrl = baseUrl || '';\n\n    /**\n     * The progress percent of the loader going through the queue.\n     *\n     * @member {number}\n     */\n    this.progress = 0;\n\n    /**\n     * Loading state of the loader, true if it is currently loading resources.\n     *\n     * @member {boolean}\n     */\n    this.loading = false;\n\n    /**\n     * The percentage of total progress that a single resource represents.\n     *\n     * @member {number}\n     */\n    this._progressChunk = 0;\n\n    /**\n     * The middleware to run before loading each resource.\n     *\n     * @member {function[]}\n     */\n    this._beforeMiddleware = [];\n\n    /**\n     * The middleware to run after loading each resource.\n     *\n     * @member {function[]}\n     */\n    this._afterMiddleware = [];\n\n    /**\n     * The `_loadResource` function bound with this object context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundLoadResource = this._loadResource.bind(this);\n\n    /**\n     * The `_onLoad` function bound with this object context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnLoad = this._onLoad.bind(this);\n\n    /**\n     * The resource buffer that fills until `load` is called to start loading resources.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n    this._buffer = [];\n\n    /**\n     * Used to track load completion.\n     *\n     * @private\n     * @member {number}\n     */\n    this._numToLoad = 0;\n\n    /**\n     * The resources waiting to be loaded.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n    this._queue = async.queue(this._boundLoadResource, concurrency);\n\n    /**\n     * All the resources for this loader keyed by name.\n     *\n     * @member {object<string, Resource>}\n     */\n    this.resources = {};\n\n    /**\n     * Emitted once per loaded or errored resource.\n     *\n     * @event progress\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted once per errored resource.\n     *\n     * @event error\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted once per loaded resource.\n     *\n     * @event load\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted when the loader begins to process the queue.\n     *\n     * @event start\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted when the queued resources all load.\n     *\n     * @event complete\n     * @memberof Loader#\n     */\n}\n\nLoader.prototype = Object.create(EventEmitter.prototype);\nLoader.prototype.constructor = Loader;\nmodule.exports = Loader;\n\n/**\n * Adds a resource (or multiple resources) to the loader queue.\n *\n * This function can take a wide variety of different parameters. The only thing that is always\n * required the url to load. All the following will work:\n *\n * ```js\n * loader\n *     // normal param syntax\n *     .add('key', 'http://...', function () {})\n *     .add('http://...', function () {})\n *     .add('http://...')\n *\n *     // object syntax\n *     .add({\n *         name: 'key2',\n *         url: 'http://...'\n *     }, function () {})\n *     .add({\n *         url: 'http://...'\n *     }, function () {})\n *     .add({\n *         name: 'key3',\n *         url: 'http://...'\n *         onComplete: function () {}\n *     })\n *     .add({\n *         url: 'https://...',\n *         onComplete: function () {},\n *         crossOrigin: true\n *     })\n *\n *     // you can also pass an array of objects or urls or both\n *     .add([\n *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n *         { url: 'http://...', onComplete: function () {} },\n *         'http://...'\n *     ]);\n * ```\n *\n * @alias enqueue\n * @param [name] {string} The name of the resource to load, if not passed the url is used.\n * @param url {string} The url for this resource, relative to the baseUrl of this loader.\n * @param [options] {object} The options for the load.\n * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.\n * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?\n * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being\n *      loaded be interpreted when using XHR?\n * @param [callback] {function} Function to call when this specific resource completes loading.\n * @return {Loader}\n */\nLoader.prototype.add = Loader.prototype.enqueue = function (name, url, options, cb) {\n    // special case of an array of objects or urls\n    if (Array.isArray(name)) {\n        for (var i = 0; i < name.length; ++i) {\n            this.add(name[i]);\n        }\n\n        return this;\n    }\n\n    // if an object is passed instead of params\n    if (typeof name === 'object') {\n        cb = url || name.callback || name.onComplete;\n        options = name;\n        url = name.url;\n        name = name.name || name.key || name.url;\n    }\n\n    // case where no name is passed shift all args over by one.\n    if (typeof url !== 'string') {\n        cb = options;\n        options = url;\n        url = name;\n    }\n\n    // now that we shifted make sure we have a proper url.\n    if (typeof url !== 'string') {\n        throw new Error('No url passed to add resource to loader.');\n    }\n\n    // options are optional so people might pass a function and no options\n    if (typeof options === 'function') {\n        cb = options;\n        options = null;\n    }\n\n    // check if resource already exists.\n    if (this.resources[name]) {\n        throw new Error('Resource with name \"' + name + '\" already exists.');\n    }\n\n    // add base url if this isn't an absolute url\n    url = this._handleBaseUrl(url);\n\n    // create the store the resource\n    this.resources[name] = new Resource(name, url, options);\n\n    if (typeof cb === 'function') {\n        this.resources[name].once('afterMiddleware', cb);\n    }\n\n    this._numToLoad++;\n\n    // if already loading add it to the worker queue\n    if (this._queue.started) {\n        this._queue.push(this.resources[name]);\n        this._progressChunk = (100 - this.progress) / (this._queue.length() + this._queue.running());\n    }\n    // otherwise buffer it to be added to the queue later\n    else {\n        this._buffer.push(this.resources[name]);\n        this._progressChunk = 100 / this._buffer.length;\n    }\n\n    return this;\n};\n\nLoader.prototype._handleBaseUrl = function (url) {\n    var parsedUrl = urlParser.parse(url);\n\n    // absolute url, just use it as is.\n    if (parsedUrl.protocol || parsedUrl.pathname.indexOf('//') === 0) {\n        return url;\n    }\n\n    // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n    if (\n        this.baseUrl.length &&\n        this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 &&\n        url.charAt(0) !== '/'\n    ) {\n        return this.baseUrl + '/' + url;\n    }\n    else {\n        return this.baseUrl + url;\n    }\n};\n\n\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @alias pre\n * @param middleware {function} The middleware function to register.\n * @return {Loader}\n */\nLoader.prototype.before = Loader.prototype.pre = function (fn) {\n    this._beforeMiddleware.push(fn);\n\n    return this;\n};\n\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @alias use\n * @param middleware {function} The middleware function to register.\n * @return {Loader}\n */\nLoader.prototype.after = Loader.prototype.use = function (fn) {\n    this._afterMiddleware.push(fn);\n\n    return this;\n};\n\n/**\n * Resets the queue of the loader to prepare for a new load.\n *\n * @return {Loader}\n */\nLoader.prototype.reset = function () {\n    // this.baseUrl = baseUrl || '';\n\n    this.progress = 0;\n\n    this.loading = false;\n\n    this._progressChunk = 0;\n\n    // this._beforeMiddleware.length = 0;\n    // this._afterMiddleware.length = 0;\n\n    this._buffer.length = 0;\n\n    this._numToLoad = 0;\n\n    this._queue.kill();\n    this._queue.started = false;\n\n    this.resources = {};\n};\n\n/**\n * Starts loading the queued resources.\n *\n * @fires start\n * @param [callback] {function} Optional callback that will be bound to the `complete` event.\n * @return {Loader}\n */\nLoader.prototype.load = function (cb) {\n    // register complete callback if they pass one\n    if (typeof cb === 'function') {\n        this.once('complete', cb);\n    }\n\n    // if the queue has already started we are done here\n    if (this._queue.started) {\n        return this;\n    }\n\n    // notify of start\n    this.emit('start', this);\n\n    // start the internal queue\n    for (var i = 0; i < this._buffer.length; ++i) {\n        this._queue.push(this._buffer[i]);\n    }\n\n    // empty the buffer\n    this._buffer.length = 0;\n\n    return this;\n};\n\n/**\n * Loads a single resource.\n *\n * @fires progress\n * @private\n */\nLoader.prototype._loadResource = function (resource, dequeue) {\n    var self = this;\n\n    resource._dequeue = dequeue;\n\n    this._runMiddleware(resource, this._beforeMiddleware, function () {\n        // resource.on('progress', self.emit.bind(self, 'progress'));\n\n        resource.load(self._boundOnLoad);\n    });\n};\n\n/**\n * Called once each resource has loaded.\n *\n * @fires complete\n * @private\n */\nLoader.prototype._onComplete = function () {\n    this.emit('complete', this, this.resources);\n};\n\n/**\n * Called each time a resources is loaded.\n *\n * @fires progress\n * @fires error\n * @fires load\n * @private\n */\nLoader.prototype._onLoad = function (resource) {\n    this.progress += this._progressChunk;\n\n    this.emit('progress', this, resource);\n\n    // run middleware, this *must* happen before dequeue so sub-assets get added properly\n    this._runMiddleware(resource, this._afterMiddleware, function () {\n        resource.emit('afterMiddleware', resource);\n\n        this._numToLoad--;\n\n        // do completion check\n        if (this._numToLoad === 0) {\n            this.progress = 100;\n            this._onComplete();\n        }\n        \n        if (resource.error) {\n            this.emit('error', resource.error, this, resource);\n        }\n        else {\n            this.emit('load', this, resource);\n        }\n    });\n    \n\n\n    // remove this resource from the async queue\n    resource._dequeue();\n};\n\n/**\n * Run middleware functions on a resource.\n *\n * @private\n */\nLoader.prototype._runMiddleware = function (resource, fns, cb) {\n    var self = this;\n\n    async.eachSeries(fns, function (fn, next) {\n        fn.call(self, resource, next);\n    }, cb.bind(this, resource));\n};\n\nLoader.LOAD_TYPE = Resource.LOAD_TYPE;\nLoader.XHR_READY_STATE = Resource.XHR_READY_STATE;\nLoader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;\n\n},{\"./Resource\":14,\"async\":12,\"eventemitter3\":10,\"url\":8}],14:[function(require,module,exports){\nvar EventEmitter = require('eventemitter3'),\n    _url = require('url'),\n    // tests is CORS is supported in XHR, if not we need to use XDR\n    useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest()))),\n    tempAnchor = null;\n\n/**\n * Manages the state and loading of a single resource represented by\n * a single URL.\n *\n * @class\n * @param name {string} The name of the resource to load.\n * @param url {string|string[]} The url for this resource, for audio/video loads you can pass an array of sources.\n * @param [options] {object} The options for the load.\n * @param [options.crossOrigin] {string|boolean} Is this request cross-origin? Default is to determine automatically.\n * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.LOAD_TYPE} How should this resource be loaded?\n * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being\n *      loaded be interpreted when using XHR?\n * @param [options.metadata] {object} Extra info for middleware.\n */\nfunction Resource(name, url, options) {\n    EventEmitter.call(this);\n\n    options = options || {};\n\n    if (typeof name !== 'string' || typeof url !== 'string') {\n        throw new Error('Both name and url are required for constructing a resource.');\n    }\n\n    /**\n     * The name of this resource.\n     *\n     * @member {string}\n     * @readonly\n     */\n    this.name = name;\n\n    /**\n     * The url used to load this resource.\n     *\n     * @member {string}\n     * @readonly\n     */\n    this.url = url;\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    this.isDataUrl = this.url.indexOf('data:') === 0;\n\n    /**\n     * The data that was loaded by the resource.\n     *\n     * @member {any}\n     */\n    this.data = null;\n\n    /**\n     * Is this request cross-origin? If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n    /**\n     * The method of loading to use for this resource.\n     *\n     * @member {Resource.LOAD_TYPE}\n     */\n    this.loadType = options.loadType || this._determineLoadType();\n\n    /**\n     * The type used to load the resource via XHR. If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.xhrType = options.xhrType;\n\n    /**\n     * Extra info for middleware\n     *\n     * @member {object}\n     */\n    this.metadata = options.metadata || {};\n\n    /**\n     * The error that occurred while loading (if any).\n     *\n     * @member {Error}\n     * @readonly\n     */\n    this.error = null;\n\n    /**\n     * The XHR object that was used to load this resource. This is only set\n     * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n     *\n     * @member {XMLHttpRequest}\n     */\n    this.xhr = null;\n\n    /**\n     * Describes if this resource was loaded as json. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isJson = false;\n\n    /**\n     * Describes if this resource was loaded as xml. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isXml = false;\n\n    /**\n     * Describes if this resource was loaded as an image tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isImage = false;\n\n    /**\n     * Describes if this resource was loaded as an audio tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isAudio = false;\n\n    /**\n     * Describes if this resource was loaded as a video tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isVideo = false;\n\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     *\n     * @member {function}\n     * @private\n     */\n    this._dequeue = null;\n\n    /**\n     * The `complete` function bound to this resource's context.\n     *\n     * @member {function}\n     * @private\n     */\n    this._boundComplete = this.complete.bind(this);\n\n    /**\n     * The `_onError` function bound to this resource's context.\n     *\n     * @member {function}\n     * @private\n     */\n    this._boundOnError = this._onError.bind(this);\n\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     *\n     * @member {function}\n     * @private\n     */\n    this._boundOnProgress = this._onProgress.bind(this);\n\n    // xhr callbacks\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);\n\n    /**\n     * Emitted when the resource beings to load.\n     *\n     * @event start\n     * @memberof Resource#\n     */\n\n    /**\n     * Emitted each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     *\n     * @event progress\n     * @memberof Resource#\n     */\n\n    /**\n     * Emitted once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     *\n     * @event complete\n     * @memberof Resource#\n     */\n}\n\nResource.prototype = Object.create(EventEmitter.prototype);\nResource.prototype.constructor = Resource;\nmodule.exports = Resource;\n\n/**\n * Marks the resource as complete.\n *\n * @fires complete\n */\nResource.prototype.complete = function () {\n    // TODO: Clean this up in a wrapper or something...gross....\n    if (this.data && this.data.removeEventListener) {\n        this.data.removeEventListener('error', this._boundOnError);\n        this.data.removeEventListener('load', this._boundComplete);\n        this.data.removeEventListener('progress', this._boundOnProgress);\n        this.data.removeEventListener('canplaythrough', this._boundComplete);\n    }\n\n    if (this.xhr) {\n        if (this.xhr.removeEventListener) {\n            this.xhr.removeEventListener('error', this._boundXhrOnError);\n            this.xhr.removeEventListener('abort', this._boundXhrOnAbort);\n            this.xhr.removeEventListener('progress', this._boundOnProgress);\n            this.xhr.removeEventListener('load', this._boundXhrOnLoad);\n        }\n        else {\n            this.xhr.onerror = null;\n            this.xhr.ontimeout = null;\n            this.xhr.onprogress = null;\n            this.xhr.onload = null;\n        }\n    }\n\n    this.emit('complete', this);\n};\n\n/**\n * Kicks off loading of this resource.\n *\n * @fires start\n * @param [callback] {function} Optional callback to call once the resource is loaded.\n */\nResource.prototype.load = function (cb) {\n    this.emit('start', this);\n\n    // if a callback is set, listen for complete event\n    if (cb) {\n        this.once('complete', cb);\n    }\n\n    // if unset, determine the value\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n        this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n\n    switch(this.loadType) {\n        case Resource.LOAD_TYPE.IMAGE:\n            this._loadImage();\n            break;\n\n        case Resource.LOAD_TYPE.AUDIO:\n            this._loadElement('audio');\n            break;\n\n        case Resource.LOAD_TYPE.VIDEO:\n            this._loadElement('video');\n            break;\n\n        case Resource.LOAD_TYPE.XHR:\n            /* falls through */\n        default:\n            if (useXdr && this.crossOrigin) {\n                this._loadXdr();\n            }\n            else {\n                this._loadXhr();\n            }\n            break;\n    }\n};\n\n/**\n * Loads this resources using an Image object.\n *\n * @private\n */\nResource.prototype._loadImage = function () {\n    this.data = new Image();\n\n    if (this.crossOrigin) {\n        this.data.crossOrigin = this.crossOrigin;\n    }\n\n    this.data.src = this.url;\n\n    this.isImage = true;\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n};\n\n/**\n * Loads this resources using an HTMLAudioElement or HTMLVideoElement.\n *\n * @private\n */\nResource.prototype._loadElement = function (type) {\n    if (type === 'audio' && typeof Audio !== 'undefined') {\n        this.data = new Audio();\n    }\n    else {\n        this.data = document.createElement(type);\n    }\n\n    if (this.data === null) {\n        this.error = new Error('Unsupported element ' + type);\n        this.complete();\n        return;\n    }\n\n    // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n    if (navigator.isCocoonJS) {\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n    }\n    else {\n        if (Array.isArray(this.url)) {\n            for (var i = 0; i < this.url.length; ++i) {\n                this.data.appendChild(this._createSource(type, this.url[i]));\n            }\n        }\n        else {\n            this.data.appendChild(this._createSource(type, this.url));\n        }\n    }\n\n    this['is' + type[0].toUpperCase() + type.substring(1)] = true;\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n    this.data.load();\n};\n\n/**\n * Loads this resources using an XMLHttpRequest.\n *\n * @private\n */\nResource.prototype._loadXhr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n    }\n\n    var xhr = this.xhr = new XMLHttpRequest();\n\n    // set the request type and url\n    xhr.open('GET', this.url, true);\n\n    // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n    else {\n        xhr.responseType = this.xhrType;\n    }\n\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n    xhr.send();\n};\n\n/**\n * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n *\n * @private\n */\nResource.prototype._loadXdr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n    }\n\n    var xdr = this.xhr = new XDomainRequest();\n\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n    xdr.timeout = 5000;\n\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXdrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n\n    xdr.open('GET', this.url, true);\n\n    //  Note: The xdr.send() call is wrapped in a timeout to prevent an issue with the interface where some requests are lost\n    //  if multiple XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n    setTimeout(function () {\n        xdr.send();\n    }, 0);\n};\n\n/**\n * Creates a source used in loading via an element.\n *\n * @param type {string} The element type (video or audio).\n * @param url {string} The source URL to load from.\n * @param [mime] {string} The mime type of the video\n * @private\n */\nResource.prototype._createSource = function (type, url, mime) {\n    if (!mime) {\n        mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);\n    }\n\n    var source = document.createElement('source');\n\n    source.src = url;\n    source.type = mime;\n\n    return source;\n};\n\n/**\n * Called if a load errors out.\n *\n * @param event {Event} The error event from the element that emits it.\n * @private\n */\nResource.prototype._onError = function (event) {\n    this.error = new Error('Failed to load element using ' + event.target.nodeName);\n    this.complete();\n};\n\n/**\n * Called if a load progress event fires for xhr/xdr.\n *\n * @fires progress\n * @param event {XMLHttpRequestProgressEvent|Event}\n * @private\n */\nResource.prototype._onProgress =  function (event) {\n    if (event && event.lengthComputable) {\n        this.emit('progress', this, event.loaded / event.total);\n    }\n};\n\n/**\n * Called if an error event fires for xhr/xdr.\n *\n * @param event {XMLHttpRequestErrorEvent|Event}\n * @private\n */\nResource.prototype._xhrOnError = function () {\n    this.error = new Error(\n        reqType(this.xhr) + ' Request failed. ' +\n        'Status: ' + this.xhr.status + ', text: \"' + this.xhr.statusText + '\"'\n    );\n\n    this.complete();\n};\n\n/**\n * Called if an abort event fires for xhr.\n *\n * @param event {XMLHttpRequestAbortEvent}\n * @private\n */\nResource.prototype._xhrOnAbort = function () {\n    this.error = new Error(reqType(this.xhr) + ' Request was aborted by the user.');\n    this.complete();\n};\n\n/**\n * Called if a timeout event fires for xdr.\n *\n * @param event {Event}\n * @private\n */\nResource.prototype._xdrOnTimeout = function () {\n    this.error = new Error(reqType(this.xhr) + ' Request timed out.');\n    this.complete();\n};\n\n/**\n * Called when data successfully loads from an xhr/xdr request.\n *\n * @param event {XMLHttpRequestLoadEvent|Event}\n * @private\n */\nResource.prototype._xhrOnLoad = function () {\n    var xhr = this.xhr,\n        status = xhr.status !== undefined ? xhr.status : 200; //XDR has no `.status`, assume 200.\n\n    // status can be 0 when using the file:// protocol, also check if a response was found\n    if (status === 200 || status === 204 || (status === 0 && xhr.responseText.length > 0)) {\n        // if text, just return it\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n            this.data = xhr.responseText;\n        }\n        // if json, parse into json object\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n            try {\n                this.data = JSON.parse(xhr.responseText);\n                this.isJson = true;\n            } catch(e) {\n                this.error = new Error('Error trying to parse loaded json:', e);\n            }\n        }\n        // if xml, parse into an xml document or div element\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            try {\n                if (window.DOMParser) {\n                    var domparser = new DOMParser();\n                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml');\n                }\n                else {\n                    var div = document.createElement('div');\n                    div.innerHTML = xhr.responseText;\n                    this.data = div;\n                }\n                this.isXml = true;\n            } catch (e) {\n                this.error = new Error('Error trying to parse loaded xml:', e);\n            }\n        }\n        // other types just return the response\n        else {\n            this.data = xhr.response || xhr.responseText;\n        }\n    }\n    else {\n        this.error = new Error('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);\n    }\n\n    this.complete();\n};\n\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n *\n * @private\n * @param url {string} The url to test.\n * @param [location=window.location] {object} The location object to test against.\n * @return {string} The crossOrigin value to use (or empty string for none).\n */\nResource.prototype._determineCrossOrigin = function (url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n        return '';\n    }\n\n    // default is window.location\n    loc = loc || window.location;\n\n    if (!tempAnchor) {\n        tempAnchor = document.createElement('a');\n    }\n\n    // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n    tempAnchor.href = url;\n    url = _url.parse(tempAnchor.href);\n\n    var samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n\n    // if cross origin\n    if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {\n        return 'anonymous';\n    }\n\n    return '';\n};\n\n/**\n * Determines the responseType of an XHR request based on the extension of the\n * resource being loaded.\n *\n * @private\n * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n */\nResource.prototype._determineXhrType = function () {\n    return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;\n};\n\nResource.prototype._determineLoadType = function () {\n    return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;\n};\n\nResource.prototype._getExtension = function () {\n    var url = this.url,\n        ext;\n\n    if (this.isDataUrl) {\n        var slashIndex = url.indexOf('/');\n        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    }\n    else {\n        var queryStart = url.indexOf('?');\n        if (queryStart !== -1) {\n            url = url.substring(0, queryStart);\n        }\n\n        ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n\n    return ext;\n};\n\n/**\n * Determines the mime type of an XHR request based on the responseType of\n * resource being loaded.\n *\n * @private\n * @return {string} The mime type to use.\n */\nResource.prototype._getMimeFromXhrType = function (type) {\n    switch(type) {\n        case Resource.XHR_RESPONSE_TYPE.BUFFER:\n            return 'application/octet-binary';\n\n        case Resource.XHR_RESPONSE_TYPE.BLOB:\n            return 'application/blob';\n\n        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n            return 'application/xml';\n\n        case Resource.XHR_RESPONSE_TYPE.JSON:\n            return 'application/json';\n\n        case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n        case Resource.XHR_RESPONSE_TYPE.TEXT:\n            /* falls through */\n        default:\n            return 'text/plain';\n\n    }\n};\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @constant\n * @property {object} LOAD_TYPE\n * @property {number} LOAD_TYPE.XHR - Uses XMLHttpRequest to load the resource.\n * @property {number} LOAD_TYPE.IMAGE - Uses an `Image` object to load the resource.\n * @property {number} LOAD_TYPE.AUDIO - Uses an `Audio` object to load the resource.\n * @property {number} LOAD_TYPE.VIDEO - Uses a `Video` object to load the resource.\n */\nResource.LOAD_TYPE = {\n    XHR:    1,\n    IMAGE:  2,\n    AUDIO:  3,\n    VIDEO:  4\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @constant\n * @property {object} XHR_READY_STATE\n * @property {number} XHR_READY_STATE.UNSENT - open()has not been called yet.\n * @property {number} XHR_READY_STATE.OPENED - send()has not been called yet.\n * @property {number} XHR_READY_STATE.HEADERS_RECEIVED - send() has been called, and headers and status are available.\n * @property {number} XHR_READY_STATE.LOADING - Downloading; responseText holds partial data.\n * @property {number} XHR_READY_STATE.DONE - The operation is complete.\n */\nResource.XHR_READY_STATE = {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @constant\n * @property {object} XHR_RESPONSE_TYPE\n * @property {string} XHR_RESPONSE_TYPE.DEFAULT - defaults to text\n * @property {string} XHR_RESPONSE_TYPE.BUFFER - ArrayBuffer\n * @property {string} XHR_RESPONSE_TYPE.BLOB - Blob\n * @property {string} XHR_RESPONSE_TYPE.DOCUMENT - Document\n * @property {string} XHR_RESPONSE_TYPE.JSON - Object\n * @property {string} XHR_RESPONSE_TYPE.TEXT - String\n */\nResource.XHR_RESPONSE_TYPE = {\n    DEFAULT:    'text',\n    BUFFER:     'arraybuffer',\n    BLOB:       'blob',\n    DOCUMENT:   'document',\n    JSON:       'json',\n    TEXT:       'text'\n};\n\nResource._loadTypeMap = {\n    'gif':      Resource.LOAD_TYPE.IMAGE,\n    'png':      Resource.LOAD_TYPE.IMAGE,\n    'bmp':      Resource.LOAD_TYPE.IMAGE,\n    'jpg':      Resource.LOAD_TYPE.IMAGE,\n    'jpeg':     Resource.LOAD_TYPE.IMAGE,\n    'tif':      Resource.LOAD_TYPE.IMAGE,\n    'tiff':     Resource.LOAD_TYPE.IMAGE,\n    'webp':     Resource.LOAD_TYPE.IMAGE,\n    'tga':      Resource.LOAD_TYPE.IMAGE\n};\n\nResource._xhrTypeMap = {\n    // xml\n    'xhtml':    Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    'html':     Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    'htm':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    'xml':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    'tmx':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    'tsx':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    'svg':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    'gif':      Resource.XHR_RESPONSE_TYPE.BLOB,\n    'png':      Resource.XHR_RESPONSE_TYPE.BLOB,\n    'bmp':      Resource.XHR_RESPONSE_TYPE.BLOB,\n    'jpg':      Resource.XHR_RESPONSE_TYPE.BLOB,\n    'jpeg':     Resource.XHR_RESPONSE_TYPE.BLOB,\n    'tif':      Resource.XHR_RESPONSE_TYPE.BLOB,\n    'tiff':     Resource.XHR_RESPONSE_TYPE.BLOB,\n    'webp':     Resource.XHR_RESPONSE_TYPE.BLOB,\n    'tga':      Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    'json':     Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    'text':     Resource.XHR_RESPONSE_TYPE.TEXT,\n    'txt':      Resource.XHR_RESPONSE_TYPE.TEXT\n};\n\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param extname {string} The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param loadType {Resource.LOAD_TYPE} The load type to set it to.\n */\nResource.setExtensionLoadType = function (extname, loadType) {\n    setExtMap(Resource._loadTypeMap, extname, loadType);\n};\n\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param extname {string} The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param xhrType {Resource.XHR_RESPONSE_TYPE} The xhr type to set it to.\n */\nResource.setExtensionXhrType = function (extname, xhrType) {\n    setExtMap(Resource._xhrTypeMap, extname, xhrType);\n};\n\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n\n},{\"eventemitter3\":10,\"url\":8}],15:[function(require,module,exports){\nmodule.exports = {\n\n    // private property\n    _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n\n    encodeBinary: function (input) {\n        var output = \"\";\n        var bytebuffer;\n        var encodedCharIndexes = new Array(4);\n        var inx = 0;\n        var jnx = 0;\n        var paddingBytes = 0;\n\n        while (inx < input.length) {\n            // Fill byte buffer array\n            bytebuffer = new Array(3);\n            for (jnx = 0; jnx < bytebuffer.length; jnx++) {\n                if (inx < input.length) {\n                    // throw away high-order byte, as documented at:\n                    // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                    bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n                }\n                else {\n                    bytebuffer[jnx] = 0;\n                }\n            }\n\n            // Get each encoded character, 6 bits at a time\n            // index 1: first 6 bits\n            encodedCharIndexes[0] = bytebuffer[0] >> 2;\n            // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n            encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n            // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n            encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n            // index 3: forth 6 bits (6 least significant bits from input byte 3)\n            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n            // Determine whether padding happened, and adjust accordingly\n            paddingBytes = inx - (input.length - 1);\n            switch (paddingBytes) {\n                case 2:\n                    // Set last 2 characters to padding char\n                    encodedCharIndexes[3] = 64;\n                    encodedCharIndexes[2] = 64;\n                    break;\n\n                case 1:\n                    // Set last character to padding char\n                    encodedCharIndexes[3] = 64;\n                    break;\n\n                default:\n                    break; // No padding - proceed\n            }\n\n            // Now we will grab each appropriate character out of our keystring\n            // based on our index array and append it to the output string\n            for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {\n                output += this._keyStr.charAt(encodedCharIndexes[jnx]);\n            }\n        }\n        return output;\n    }\n};\n\n},{}],16:[function(require,module,exports){\nmodule.exports = require('./Loader');\n\nmodule.exports.Resource = require('./Resource');\n\nmodule.exports.middleware = {\n    caching: {\n        memory: require('./middlewares/caching/memory')\n    },\n    parsing: {\n        blob: require('./middlewares/parsing/blob')\n    }\n};\n\n},{\"./Loader\":13,\"./Resource\":14,\"./middlewares/caching/memory\":17,\"./middlewares/parsing/blob\":18}],17:[function(require,module,exports){\n// a simple in-memory cache for resources\nvar cache = {};\n\nmodule.exports = function () {\n    return function (resource, next) {\n        // if cached, then set data and complete the resource\n        if (cache[resource.url]) {\n            resource.data = cache[resource.url];\n            resource.complete();\n        }\n        // if not cached, wait for complete and store it in the cache.\n        else {\n            resource.once('complete', function () {\n               cache[this.url] = this.data;\n            });\n        }\n        \n        next();\n    };\n};\n\n},{}],18:[function(require,module,exports){\nvar Resource = require('../../Resource'),\n    b64 = require('../../b64');\n\nwindow.URL = window.URL || window.webkitURL;\n\n// a middleware for transforming XHR loaded Blobs into more useful objects\n\nmodule.exports = function () {\n    return function (resource, next) {\n        if (!resource.data) {\n            return next();\n        }\n\n        // if this was an XHR load of a blob\n        if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {\n            // if there is no blob support we probably got a binary string back\n            if (!window.Blob || typeof resource.data === 'string') {\n                var type = resource.xhr.getResponseHeader('content-type');\n\n                // this is an image, convert the binary string into a data url\n                if (type && type.indexOf('image') === 0) {\n                    resource.data = new Image();\n                    resource.data.src = 'data:' + type + ';base64,' + b64.encodeBinary(resource.xhr.responseText);\n\n                    resource.isImage = true;\n\n                    // wait until the image loads and then callback\n                    resource.data.onload = function () {\n                        resource.data.onload = null;\n\n                        next();\n                    };\n                }\n            }\n            // if content type says this is an image, then we should transform the blob into an Image object\n            else if (resource.data.type.indexOf('image') === 0) {\n                var src = URL.createObjectURL(resource.data);\n\n                resource.blob = resource.data;\n                resource.data = new Image();\n                resource.data.src = src;\n\n                resource.isImage = true;\n\n                // cleanup the no longer used blob after the image loads\n                resource.data.onload = function () {\n                    URL.revokeObjectURL(src);\n                    resource.data.onload = null;\n\n                    next();\n                };\n            }\n        }\n        else {\n            next();\n        }\n    };\n};\n\n},{\"../../Resource\":14,\"../../b64\":15}],19:[function(require,module,exports){\nvar core = require('../core');\n\n// add some extra variables to the container..\nObject.assign(\n    core.DisplayObject.prototype,\n    require('./accessibleTarget')\n);\n\n\n/**\n * The Accessibility manager reacreates the ability to tab and and have content read by screen readers. This is very important as it can possibly help people with disabilities access pixi content.\n * Much like interaction any DisplayObject can be made accessible. This manager will map the events as if the mouse was being used, minimizing the efferot required to implement.\n *\n * @class\n * @memberof PIXI\n * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer\n */\nfunction AccessibilityManager(renderer)\n{\n\t// first we create a div that will sit over the pixi element. This is where the div overlays will go.\n    var div = document.createElement('div');\n    \n    div.style.width = 100 + 'px';\n    div.style.height = 100 + 'px';\n    div.style.position = 'absolute';\n    div.style.top = 0;\n    div.style.left = 0;\n   //\n    div.style.zIndex = 2;\n   \t\n   \t/**\n   \t * This is the dom element that will sit over the pixi element. This is where the div overlays will go.\n   \t * \n   \t * @type {HTMLElement}\n   \t * @private\n   \t */\n   \tthis.div = div;\n\n   \t/**\n   \t * A simple pool for storing divs.\n   \t * \n   \t * @type {Array}\n   \t * @private\n   \t */\n \tthis.pool = [];\n\n \t/**\n \t * This is a tick used to check if an object is no longer being rendered.\n \t * \n \t * @type {Number}\n \t * @private\n \t */\n   \tthis.renderId = 0;\n\n   \t/**\n   \t * Setting this to true will visually show the divs\n   \t * \n   \t * @type {Boolean}\n   \t */\n   \tthis.debug = false;\n\n  \t/**\n     * The renderer this accessibility manager works for.\n     *\n     * @member {PIXI.SystemRenderer}\n     */\n   \tthis.renderer = renderer;\n\n   \t/**\n     * The array of currently active accessible items.\n     *\n     * @member {Array}\n     * @private\n     */\n   \tthis.children = [];\n   \t\n   \t/**\n     * pre bind the functions..\n     */\n   \tthis._onKeyDown = this._onKeyDown.bind(this);\n   \tthis._onMouseMove = this._onMouseMove.bind(this);\n   \t\n   \t/**\n     * stores the state of the manager. If there are no accessible objects or the mouse is moving the will be false.\n     *\n     * @member {Array}\n     * @private\n     */\n   \tthis.isActive = false;\n\n\n   \t// let listen for tab.. once pressed we can fire up and show the accessibility layer\n   \twindow.addEventListener('keydown', this._onKeyDown, false);\n}\n\n\nAccessibilityManager.prototype.constructor = AccessibilityManager;\nmodule.exports = AccessibilityManager;\n\n/**\n * Activating will cause the Accessibility layer to be shown. This is called when a user preses the tab key\n * @private\n */\nAccessibilityManager.prototype.activate = function()\n{\n\tif(this.isActive)\n\t{\n\t\treturn;\n\t}\n\n\tthis.isActive = true;\n\n\twindow.document.addEventListener('mousemove', this._onMouseMove, true);\n\twindow.removeEventListener('keydown', this._onKeyDown, false);\n\n\tthis.renderer.on('postrender', this.update, this);\n\n\tthis.renderer.view.parentNode.appendChild(this.div);\t\n};\n\n/**\n * Deactivating will cause the Accessibility layer to be hidden. This is called when a user moves the mouse\n * @private\n */\nAccessibilityManager.prototype.deactivate = function()\n{\n\tif(!this.isActive)\n\t{\n\t\treturn;\n\t}\n\n\tthis.isActive = false;\n\n\twindow.document.removeEventListener('mousemove', this._onMouseMove);\n\twindow.addEventListener('keydown', this._onKeyDown, false);\n\n\tthis.renderer.off('postrender', this.update);\n\n\tthis.div.parentNode.removeChild(this.div);\n\n};\n\n/**\n * This recursive function will run throught he scene graph and add any new accessible objects to the DOM layer.\n * @param element {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the DisplayObject to check.\n * @private\n */\nAccessibilityManager.prototype.updateAccessibleObjects = function(displayObject)\n{\n\tif(!displayObject.visible)\n\t{\n\t\treturn;\n\t}\n\n\tif(displayObject.accessible && displayObject.interactive)\n\t{\n\t\tif(!displayObject._accessibleActive)\n\t\t{\n\t\t\tthis.addChild(displayObject);\n\t\t}\n\t   \t\n\t   \tdisplayObject.renderId = this.renderId;\n\t}\n\n\n\tif(displayObject.interactiveChildren)\n\t{\n\n\t\tvar children = displayObject.children;\n\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\n\t\t\tthis.updateAccessibleObjects(children[i]);\n\t\t}\n\t}\n};\n\n\n/**\n * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects\n * @private\n */\nAccessibilityManager.prototype.update = function()\n{\n\n\t// update children...\n\tthis.updateAccessibleObjects(this.renderer._lastObjectRendered);\n\n\tvar rect = this.renderer.view.getBoundingClientRect();\n\tvar sx = rect.width  / this.renderer.width;\n\tvar sy = rect.height / this.renderer.height;\n\n\tvar div = this.div;\n\n\tdiv.style.left = rect.left + 'px';\n\tdiv.style.top = rect.top + 'px';\n\tdiv.style.width = this.renderer.width + 'px';\n\tdiv.style.height = this.renderer.height + 'px';\n\n\tfor (var i = 0; i < this.children.length; i++)\n\t{\n\n\t\tvar child = this.children[i];\n\n\t\tif(child.renderId !== this.renderId)\n\t\t{\n\t\t\tchild._accessibleActive = false;\n\n            core.utils.removeItems(this.children, i, 1);\n\t\t\tthis.div.removeChild( child._accessibleDiv );\n\t\t\tthis.pool.push(child._accessibleDiv);\n\t\t\tchild._accessibleDiv = null;\n\n\t\t\ti--;\n\n\t\t\tif(this.children.length === 0)\n\t\t\t{\n\t\t\t\tthis.deactivate();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// map div to display..\n\t\t\tdiv = child._accessibleDiv;\n\t\t\tvar hitArea = child.hitArea;\n\t\t\tvar wt = child.worldTransform;\n\n\t\t\tif(child.hitArea)\n\t\t\t{\n\t\t\t\tdiv.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + 'px';\n\t\t\t\tdiv.style.top =  ((wt.ty + (hitArea.y * wt.d)) * sy) +  'px';\n\n\t\t\t\tdiv.style.width = (hitArea.width * wt.a * sx) + 'px';\n\t\t\t\tdiv.style.height = (hitArea.height * wt.d * sy) + 'px';\n\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thitArea = child.getBounds();\n\n\t\t\t\tthis.capHitArea(hitArea);\n\n\t\t\t\tdiv.style.left = (hitArea.x * sx) + 'px';\n\t\t\t\tdiv.style.top =  (hitArea.y * sy) +  'px';\n\n\t\t\t\tdiv.style.width = (hitArea.width * sx) + 'px';\n\t\t\t\tdiv.style.height = (hitArea.height * sy) + 'px';\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\t// increment the render id..\n\tthis.renderId++;\n};\n\nAccessibilityManager.prototype.capHitArea = function (hitArea)\n{\n    if (hitArea.x < 0)\n    {\n        hitArea.width += hitArea.x;\n        hitArea.x = 0;\n    }\n\n    if (hitArea.y < 0)\n    {\n        hitArea.height += hitArea.y;\n        hitArea.y = 0;\n    }\n\n    if ( hitArea.x + hitArea.width > this.renderer.width )\n    {\n        hitArea.width = this.renderer.width - hitArea.x;\n    }\n\n    if ( hitArea.y + hitArea.height > this.renderer.height )\n    {\n        hitArea.height = this.renderer.height - hitArea.y;\n    }\n};\n\n\n/**\n * Adds a DisplayObject to the accessibility manager\n * @private\n */\nAccessibilityManager.prototype.addChild = function(displayObject)\n{\n//\tthis.activate();\n\t\n\tvar div = this.pool.pop();\n\n\tif(!div)\n\t{\n\t\tdiv = document.createElement('button'); \n\n\t    div.style.width = 100 + 'px';\n\t    div.style.height = 100 + 'px';\n\t    div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';\n\t    div.style.position = 'absolute';\n\t    div.style.zIndex = 2;\n\t    div.style.borderStyle = 'none';\n\n\t    \n\t    div.addEventListener('click', this._onClick.bind(this));\n\t    div.addEventListener('focus', this._onFocus.bind(this));\n\t    div.addEventListener('focusout', this._onFocusOut.bind(this));\n\t}\n\t   \t\n\n\n\n\tdiv.title = displayObject.accessibleTitle || 'displayObject ' + this.tabIndex;\n\n\t//\n\t\n\tdisplayObject._accessibleActive = true;\n\tdisplayObject._accessibleDiv = div;\n\tdiv.displayObject = displayObject;\n\n\n\tthis.children.push(displayObject);\n\tthis.div.appendChild( displayObject._accessibleDiv );\n\tdisplayObject._accessibleDiv.tabIndex = displayObject.tabIndex;\n};\n\n\n/**\n * Maps the div button press to pixi's InteractionManager (click)\n * @private\n */\nAccessibilityManager.prototype._onClick = function(e)\n{\n\tvar interactionManager = this.renderer.plugins.interaction;\n\tinteractionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);\n};\n\n/**\n * Maps the div focus events to pixis InteractionManager (mouseover)\n * @private\n */\nAccessibilityManager.prototype._onFocus = function(e)\n{\n\tvar interactionManager = this.renderer.plugins.interaction;\n\tinteractionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);\n};\n\n/**\n * Maps the div focus events to pixis InteractionManager (mouseout)\n * @private\n */\nAccessibilityManager.prototype._onFocusOut = function(e)\n{\n\tvar interactionManager = this.renderer.plugins.interaction;\n\tinteractionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);\n};\n\n/**\n * Is called when a key is pressed\n *\n * @private\n */\nAccessibilityManager.prototype._onKeyDown = function(e)\n{\n\tif(e.keyCode !== 9)\n\t{\n\t\treturn;\n\t}\n\n\tthis.activate();\n};\n\n/**\n * Is called when the mouse moves across the renderer element\n *\n * @private\n */\nAccessibilityManager.prototype._onMouseMove = function()\n{\n\tthis.deactivate();\n};\n\n\n/**\n * Destroys the accessibility manager\n *\n */\nAccessibilityManager.prototype.destroy = function () \n{\n\tthis.div = null;\n\n\tfor (var i = 0; i < this.children.length; i++)\n\t{\n\t\tthis.children[i].div = null;\n\t}\n\n\t\n\twindow.document.removeEventListener('mousemove', this._onMouseMove);\n\twindow.removeEventListener('keydown', this._onKeyDown);\n\t\t\n\tthis.pool = null;\n\tthis.children = null;\n\tthis.renderer = null;\n\n};\n\ncore.WebGLRenderer.registerPlugin('accessibility', AccessibilityManager);\ncore.CanvasRenderer.registerPlugin('accessibility', AccessibilityManager);\n\n\n},{\"../core\":29,\"./accessibleTarget\":20}],20:[function(require,module,exports){\n/**\n * Default property values of accessible objects\n * used by {@link PIXI.accessibility.AccessibilityManager}.\n *\n * @mixin\n * @memberof PIXI\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          MyObject.prototype,\n *          PIXI.accessibility.accessibleTarget\n *      );\n */\nvar accessibleTarget = {\n    \n    /**\n     * @todo Needs docs.\n     */\n    accessible:false,\n\n    /**\n     * @todo Needs docs.\n     */\n    accessibleTitle:null,\n\n    /**\n     * @todo Needs docs.\n     */\n    tabIndex:0,\n\n    /**\n     * @todo Needs docs.\n     */\n    _accessibleActive:false,\n\n    /**\n     * @todo Needs docs.\n     */\n    _accessibleDiv:false\n\n};\n\nmodule.exports = accessibleTarget;\n\n},{}],21:[function(require,module,exports){\n/**\n * @file        Main export of the PIXI accessibility library\n * @author      Mat Groves <mat@goodboydigital.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI.interaction\n */\nmodule.exports = {\n    accessibleTarget:     require('./accessibleTarget'),\n    AccessibilityManager: require('./AccessibilityManager')\n};\n\n},{\"./AccessibilityManager\":19,\"./accessibleTarget\":20}],22:[function(require,module,exports){\n/**\n * Constant values used in pixi\n *\n * @lends PIXI\n */\nvar CONST = {\n    /**\n     * String of the current PIXI version\n     *\n     * @static\n     * @constant\n     * @property {string} VERSION\n     */\n    VERSION: '3.0.10',\n\n    /**\n     * @property {number} PI_2 - Two Pi\n     * @constant\n     * @static\n     */\n    PI_2: Math.PI * 2,\n\n    /**\n     * @property {number} RAD_TO_DEG - Constant conversion factor for converting radians to degrees\n     * @constant\n     * @static\n     */\n    RAD_TO_DEG: 180 / Math.PI,\n\n    /**\n     * @property {Number} DEG_TO_RAD - Constant conversion factor for converting degrees to radians\n     * @constant\n     * @static\n     */\n    DEG_TO_RAD: Math.PI / 180,\n\n    /**\n     * Target frames per millisecond.\n     *\n     * @static\n     * @constant\n     * @property {number} TARGET_FPMS=0.06\n     */\n    TARGET_FPMS: 0.06,\n\n    /**\n     * Constant to identify the Renderer Type.\n     *\n     * @static\n     * @constant\n     * @property {object} RENDERER_TYPE\n     * @property {number} RENDERER_TYPE.UNKNOWN\n     * @property {number} RENDERER_TYPE.WEBGL\n     * @property {number} RENDERER_TYPE.CANVAS\n     */\n    RENDERER_TYPE: {\n        UNKNOWN:    0,\n        WEBGL:      1,\n        CANVAS:     2\n    },\n\n    /**\n     * Various blend modes supported by PIXI. IMPORTANT - The WebGL renderer only supports\n     * the NORMAL, ADD, MULTIPLY and SCREEN blend modes. Anything else will silently act like\n     * NORMAL.\n     *\n     * @static\n     * @constant\n     * @property {object} BLEND_MODES\n     * @property {number} BLEND_MODES.NORMAL\n     * @property {number} BLEND_MODES.ADD\n     * @property {number} BLEND_MODES.MULTIPLY\n     * @property {number} BLEND_MODES.SCREEN\n     * @property {number} BLEND_MODES.OVERLAY\n     * @property {number} BLEND_MODES.DARKEN\n     * @property {number} BLEND_MODES.LIGHTEN\n     * @property {number} BLEND_MODES.COLOR_DODGE\n     * @property {number} BLEND_MODES.COLOR_BURN\n     * @property {number} BLEND_MODES.HARD_LIGHT\n     * @property {number} BLEND_MODES.SOFT_LIGHT\n     * @property {number} BLEND_MODES.DIFFERENCE\n     * @property {number} BLEND_MODES.EXCLUSION\n     * @property {number} BLEND_MODES.HUE\n     * @property {number} BLEND_MODES.SATURATION\n     * @property {number} BLEND_MODES.COLOR\n     * @property {number} BLEND_MODES.LUMINOSITY\n     */\n    BLEND_MODES: {\n        NORMAL:         0,\n        ADD:            1,\n        MULTIPLY:       2,\n        SCREEN:         3,\n        OVERLAY:        4,\n        DARKEN:         5,\n        LIGHTEN:        6,\n        COLOR_DODGE:    7,\n        COLOR_BURN:     8,\n        HARD_LIGHT:     9,\n        SOFT_LIGHT:     10,\n        DIFFERENCE:     11,\n        EXCLUSION:      12,\n        HUE:            13,\n        SATURATION:     14,\n        COLOR:          15,\n        LUMINOSITY:     16\n    },\n\n    /**\n     * Various webgl draw modes. These can be used to specify which GL drawMode to use\n     * under certain situations and renderers.\n     *\n     * @static\n     * @constant\n     * @property {object} DRAW_MODES\n     * @property {number} DRAW_MODES.POINTS\n     * @property {number} DRAW_MODES.LINES\n     * @property {number} DRAW_MODES.LINE_LOOP\n     * @property {number} DRAW_MODES.LINE_STRIP\n     * @property {number} DRAW_MODES.TRIANGLES\n     * @property {number} DRAW_MODES.TRIANGLE_STRIP\n     * @property {number} DRAW_MODES.TRIANGLE_FAN\n     */\n    DRAW_MODES: {\n        POINTS:         0,\n        LINES:          1,\n        LINE_LOOP:      2,\n        LINE_STRIP:     3,\n        TRIANGLES:      4,\n        TRIANGLE_STRIP: 5,\n        TRIANGLE_FAN:   6\n    },\n\n    /**\n     * The scale modes that are supported by pixi.\n     *\n     * The DEFAULT scale mode affects the default scaling mode of future operations.\n     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.\n     *\n     * @static\n     * @constant\n     * @property {object} SCALE_MODES\n     * @property {number} SCALE_MODES.DEFAULT=LINEAR\n     * @property {number} SCALE_MODES.LINEAR Smooth scaling\n     * @property {number} SCALE_MODES.NEAREST Pixelating scaling\n     */\n    SCALE_MODES: {\n        DEFAULT:    0,\n        LINEAR:     0,\n        NEAREST:    1\n    },\n\n    /**\n     * The prefix that denotes a URL is for a retina asset\n     *\n     * @static\n     * @constant\n     * @property {string} RETINA_PREFIX\n     */\n    //example: '@2x',\n    RETINA_PREFIX: /@(.+)x/,\n\n    RESOLUTION:1,\n\n    FILTER_RESOLUTION:1,\n\n    /**\n     * The default render options if none are supplied to {@link PIXI.WebGLRenderer}\n     * or {@link PIXI.CanvasRenderer}.\n     *\n     * @static\n     * @constant\n     * @property {object} DEFAULT_RENDER_OPTIONS\n     * @property {HTMLCanvasElement} DEFAULT_RENDER_OPTIONS.view=null\n     * @property {boolean} DEFAULT_RENDER_OPTIONS.transparent=false\n     * @property {boolean} DEFAULT_RENDER_OPTIONS.antialias=false\n     * @property {boolean} DEFAULT_RENDER_OPTIONS.forceFXAA=false\n     * @property {boolean} DEFAULT_RENDER_OPTIONS.preserveDrawingBuffer=false\n     * @property {number} DEFAULT_RENDER_OPTIONS.resolution=1\n     * @property {number} DEFAULT_RENDER_OPTIONS.backgroundColor=0x000000\n     * @property {boolean} DEFAULT_RENDER_OPTIONS.clearBeforeRender=true\n     * @property {boolean} DEFAULT_RENDER_OPTIONS.autoResize=false\n     */\n    DEFAULT_RENDER_OPTIONS: {\n        view: null,\n        resolution: 1,\n        antialias: false,\n        forceFXAA: false,\n        autoResize: false,\n        transparent: false,\n        backgroundColor: 0x000000,\n        clearBeforeRender: true,\n        preserveDrawingBuffer: false,\n        roundPixels: false\n    },\n\n    /**\n     * Constants that identify shapes, mainly to prevent `instanceof` calls.\n     *\n     * @static\n     * @constant\n     * @property {object} SHAPES\n     * @property {object} SHAPES.POLY=0\n     * @property {object} SHAPES.RECT=1\n     * @property {object} SHAPES.CIRC=2\n     * @property {object} SHAPES.ELIP=3\n     * @property {object} SHAPES.RREC=4\n     */\n    SHAPES: {\n        POLY: 0,\n        RECT: 1,\n        CIRC: 2,\n        ELIP: 3,\n        RREC: 4\n    },\n\n    // TODO: maybe change to SPRITE.BATCH_SIZE: 2000\n    // TODO: maybe add PARTICLE.BATCH_SIZE: 15000\n    SPRITE_BATCH_SIZE: 2000 //nice balance between mobile and desktop machines\n};\n\nmodule.exports = CONST;\n\n},{}],23:[function(require,module,exports){\nvar math = require('../math'),\n    utils = require('../utils'),\n    DisplayObject = require('./DisplayObject'),\n    RenderTexture = require('../textures/RenderTexture'),\n    _tempMatrix = new math.Matrix();\n\n/**\n * A Container represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n *```js\n * var container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nfunction Container()\n{\n    DisplayObject.call(this);\n\n    /**\n     * The array of children of this container.\n     *\n     * @member {PIXI.DisplayObject[]}\n     * @readonly\n     */\n    this.children = [];\n}\n\n// constructor\nContainer.prototype = Object.create(DisplayObject.prototype);\nContainer.prototype.constructor = Container;\nmodule.exports = Container;\n\nObject.defineProperties(Container.prototype, {\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Container#\n     */\n    width: {\n        get: function ()\n        {\n            return this.scale.x * this.getLocalBounds().width;\n        },\n        set: function (value)\n        {\n\n            var width = this.getLocalBounds().width;\n\n            if (width !== 0)\n            {\n                this.scale.x = value / width;\n            }\n            else\n            {\n                this.scale.x = 1;\n            }\n\n\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Container#\n     */\n    height: {\n        get: function ()\n        {\n            return  this.scale.y * this.getLocalBounds().height;\n        },\n        set: function (value)\n        {\n\n            var height = this.getLocalBounds().height;\n\n            if (height !== 0)\n            {\n                this.scale.y = value / height ;\n            }\n            else\n            {\n                this.scale.y = 1;\n            }\n\n            this._height = value;\n        }\n    }\n});\n\n/**\n * Overridable method that can be used by Container subclasses whenever the children array is modified\n *\n * @private\n */\nContainer.prototype.onChildrenChange = function () {};\n\n/**\n * Adds a child to the container.\n * \n * You can also add multple items like so: myContainer.addChild(thinkOne, thingTwo, thingThree)\n * @param child {PIXI.DisplayObject} The DisplayObject to add to the container\n * @return {PIXI.DisplayObject} The child that was added.\n */\nContainer.prototype.addChild = function (child)\n{ \n    var argumentsLength = arguments.length;\n\n    // if there is only one argument we can bypass looping through the them\n    if(argumentsLength > 1)\n    {\n        // loop through the arguments property and add all children\n        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n        for (var i = 0; i < argumentsLength; i++)\n        {\n            this.addChild( arguments[i] );\n        }\n    }     \n    else\n    {\n        // if the child has a parent then lets remove it as Pixi objects can only exist in one place\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        \n        this.children.push(child);\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(this.children.length-1);\n        child.emit('added', this);\n    }\n\n    return child;\n};\n\n/**\n * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @param child {PIXI.DisplayObject} The child to add\n * @param index {number} The index to place the child in\n * @return {PIXI.DisplayObject} The child that was added.\n */\nContainer.prototype.addChildAt = function (child, index)\n{\n    if (index >= 0 && index <= this.children.length)\n    {\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n\n        this.children.splice(index, 0, child);\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n\n        return child;\n    }\n    else\n    {\n        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);\n    }\n};\n\n/**\n * Swaps the position of 2 Display Objects within this container.\n *\n * @param child {PIXI.DisplayObject}\n * @param child2 {PIXI.DisplayObject}\n */\nContainer.prototype.swapChildren = function (child, child2)\n{\n    if (child === child2)\n    {\n        return;\n    }\n\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n\n    if (index1 < 0 || index2 < 0)\n    {\n        throw new Error('swapChildren: Both the supplied DisplayObjects must be children of the caller.');\n    }\n\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n};\n\n/**\n * Returns the index position of a child DisplayObject instance\n *\n * @param child {PIXI.DisplayObject} The DisplayObject instance to identify\n * @return {number} The index position of the child display object to identify\n */\nContainer.prototype.getChildIndex = function (child)\n{\n    var index = this.children.indexOf(child);\n\n    if (index === -1)\n    {\n        throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n\n    return index;\n};\n\n/**\n * Changes the position of an existing child in the display object container\n *\n * @param child {PIXI.DisplayObject} The child DisplayObject instance for which you want to change the index number\n * @param index {number} The resulting index number for the child display object\n */\nContainer.prototype.setChildIndex = function (child, index)\n{\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('The supplied index is out of bounds');\n    }\n\n    var currentIndex = this.getChildIndex(child);\n\n    utils.removeItems(this.children, currentIndex, 1); // remove from old position\n    this.children.splice(index, 0, child); //add at new position\n    this.onChildrenChange(index);\n};\n\n/**\n * Returns the child at the specified index\n *\n * @param index {number} The index to get the child at\n * @return {PIXI.DisplayObject} The child at the given index, if any.\n */\nContainer.prototype.getChildAt = function (index)\n{\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject is not a child of the caller');\n    }\n\n    return this.children[index];\n};\n\n/**\n * Removes a child from the container.\n *\n * @param child {PIXI.DisplayObject} The DisplayObject to remove\n * @return {PIXI.DisplayObject} The child that was removed.\n */\nContainer.prototype.removeChild = function (child)\n{\n    var argumentsLength = arguments.length;\n\n    // if there is only one argument we can bypass looping through the them\n    if(argumentsLength > 1)\n    {\n        // loop through the arguments property and add all children\n        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n        for (var i = 0; i < argumentsLength; i++)\n        {\n            this.removeChild( arguments[i] );\n        }\n    }     \n    else\n    {   \n        var index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            return;\n        }\n\n        child.parent = null;\n        utils.removeItems(this.children, index, 1);\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n    }\n\n    return child;\n};\n\n/**\n * Removes a child from the specified index position.\n *\n * @param index {number} The index to get the child from\n * @return {PIXI.DisplayObject} The child that was removed.\n */\nContainer.prototype.removeChildAt = function (index)\n{\n    var child = this.getChildAt(index);\n\n    child.parent = null;\n    utils.removeItems(this.children, index, 1);\n\n    // TODO - lets either do all callbacks or all events.. not both!\n    this.onChildrenChange(index);\n    child.emit('removed', this);\n\n    return child;\n};\n\n/**\n * Removes all children from this container that are within the begin and end indexes.\n *\n * @param beginIndex {number} The beginning position. Default value is 0.\n * @param endIndex {number} The ending position. Default value is size of the container.\n */\nContainer.prototype.removeChildren = function (beginIndex, endIndex)\n{\n    var begin = beginIndex || 0;\n    var end = typeof endIndex === 'number' ? endIndex : this.children.length;\n    var range = end - begin;\n    var removed, i;\n\n    if (range > 0 && range <= end)\n    {\n        removed = this.children.splice(begin, range);\n\n        for (i = 0; i < removed.length; ++i)\n        {\n            removed[i].parent = null;\n        }\n\n        this.onChildrenChange(beginIndex);\n\n        for (i = 0; i < removed.length; ++i)\n        {\n            removed[i].emit('removed', this);\n        }\n\n        return removed;\n    }\n    else if (range === 0 && this.children.length === 0)\n    {\n        return [];\n    }\n    else\n    {\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n};\n\n/**\n * Useful function that returns a texture of the display object that can then be used to create sprites\n * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.\n *\n * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.\n * @param resolution {number} The resolution of the texture being generated\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.Texture} a texture of the display object\n */\nContainer.prototype.generateTexture = function (renderer, resolution, scaleMode)\n{\n    var bounds = this.getLocalBounds();\n\n    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);\n\n    _tempMatrix.tx = -bounds.x;\n    _tempMatrix.ty = -bounds.y;\n\n    renderTexture.render(this, _tempMatrix);\n\n    return renderTexture;\n};\n\n/*\n * Updates the transform on all children of this container for rendering\n *\n * @private\n */\nContainer.prototype.updateTransform = function ()\n{\n    if (!this.visible)\n    {\n        return;\n    }\n\n    this.displayObjectUpdateTransform();\n\n    for (var i = 0, j = this.children.length; i < j; ++i)\n    {\n        this.children[i].updateTransform();\n    }\n};\n\n// performance increase to avoid using call.. (10x faster)\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n\n/**\n * Retrieves the bounds of the Container as a rectangle. The bounds calculation takes all visible children into consideration.\n *\n * @return {PIXI.Rectangle} The rectangular bounding area\n */\nContainer.prototype.getBounds = function ()\n{\n    if(!this._currentBounds)\n    {\n\n        if (this.children.length === 0)\n        {\n            return math.Rectangle.EMPTY;\n        }\n\n        // TODO the bounds have already been calculated this render session so return what we have\n\n        var minX = Infinity;\n        var minY = Infinity;\n\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n\n        var childBounds;\n        var childMaxX;\n        var childMaxY;\n\n        var childVisible = false;\n\n        for (var i = 0, j = this.children.length; i < j; ++i)\n        {\n            var child = this.children[i];\n\n            if (!child.visible)\n            {\n                continue;\n            }\n\n            childVisible = true;\n\n            childBounds = this.children[i].getBounds();\n\n            minX = minX < childBounds.x ? minX : childBounds.x;\n            minY = minY < childBounds.y ? minY : childBounds.y;\n\n            childMaxX = childBounds.width + childBounds.x;\n            childMaxY = childBounds.height + childBounds.y;\n\n            maxX = maxX > childMaxX ? maxX : childMaxX;\n            maxY = maxY > childMaxY ? maxY : childMaxY;\n        }\n\n        if (!childVisible)\n        {\n            return math.Rectangle.EMPTY;\n        }\n\n        var bounds = this._bounds;\n\n        bounds.x = minX;\n        bounds.y = minY;\n        bounds.width = maxX - minX;\n        bounds.height = maxY - minY;\n\n        this._currentBounds = bounds;\n    }\n\n    return this._currentBounds;\n};\n\nContainer.prototype.containerGetBounds = Container.prototype.getBounds;\n\n/**\n * Retrieves the non-global local bounds of the Container as a rectangle.\n * The calculation takes all visible children into consideration.\n *\n * @return {PIXI.Rectangle} The rectangular bounding area\n */\nContainer.prototype.getLocalBounds = function ()\n{\n    var matrixCache = this.worldTransform;\n\n    this.worldTransform = math.Matrix.IDENTITY;\n\n    for (var i = 0, j = this.children.length; i < j; ++i)\n    {\n        this.children[i].updateTransform();\n    }\n\n    this.worldTransform = matrixCache;\n\n    this._currentBounds = null;\n\n    return this.getBounds( math.Matrix.IDENTITY );\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer} The renderer\n */\nContainer.prototype.renderWebGL = function (renderer)\n{\n\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    var i, j;\n\n    // do a quick check to see if this element has a mask or a filter.\n    if (this._mask || this._filters)\n    {\n        renderer.currentRenderer.flush();\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (this._filters && this._filters.length)\n        {\n            renderer.filterManager.pushFilter(this, this._filters);\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.pushMask(this, this._mask);\n        }\n\n        renderer.currentRenderer.start();\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._renderWebGL(renderer);\n\n        // now loop through the children and make sure they get rendered\n        for (i = 0, j = this.children.length; i < j; i++)\n        {\n            this.children[i].renderWebGL(renderer);\n        }\n\n        renderer.currentRenderer.flush();\n\n        if (this._mask)\n        {\n            renderer.maskManager.popMask(this, this._mask);\n        }\n\n        if (this._filters)\n        {\n            renderer.filterManager.popFilter();\n\n        }\n        renderer.currentRenderer.start();\n    }\n    else\n    {\n        this._renderWebGL(renderer);\n\n        // simple render children!\n        for (i = 0, j = this.children.length; i < j; ++i)\n        {\n            this.children[i].renderWebGL(renderer);\n        }\n    }\n};\n\n/**\n * To be overridden by the subclass\n *\n * @param renderer {PIXI.WebGLRenderer} The renderer\n * @private\n */\nContainer.prototype._renderWebGL = function (renderer) // jshint unused:false\n{\n    // this is where content itself gets rendered...\n};\n\n/**\n * To be overridden by the subclass\n *\n * @param renderer {PIXI.CanvasRenderer} The renderer\n * @private\n */\nContainer.prototype._renderCanvas = function (renderer) // jshint unused:false\n{\n    // this is where content itself gets rendered...\n};\n\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {PIXI.CanvasRenderer} The renderer\n */\nContainer.prototype.renderCanvas = function (renderer)\n{\n    // if not visible or the alpha is 0 then no need to render this\n    if (!this.visible || this.alpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    if (this._mask)\n    {\n        renderer.maskManager.pushMask(this._mask, renderer);\n    }\n\n    this._renderCanvas(renderer);\n    for (var i = 0, j = this.children.length; i < j; ++i)\n    {\n        this.children[i].renderCanvas(renderer);\n    }\n\n    if (this._mask)\n    {\n        renderer.maskManager.popMask(renderer);\n    }\n};\n\n/**\n * Destroys the container\n * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well\n */\nContainer.prototype.destroy = function (destroyChildren)\n{\n    DisplayObject.prototype.destroy.call(this);\n\n    if (destroyChildren)\n    {\n        for (var i = 0, j = this.children.length; i < j; ++i)\n        {\n            this.children[i].destroy(destroyChildren);\n        }\n    }\n\n    this.removeChildren();\n\n    this.children = null;\n};\n\n},{\"../math\":33,\"../textures/RenderTexture\":71,\"../utils\":77,\"./DisplayObject\":24}],24:[function(require,module,exports){\nvar math = require('../math'),\n    RenderTexture = require('../textures/RenderTexture'),\n    EventEmitter = require('eventemitter3'),\n    CONST = require('../const'),\n    _tempMatrix = new math.Matrix(),\n    _tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};\n\n\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nfunction DisplayObject()\n{\n    EventEmitter.call(this);\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     *\n     * @member {PIXI.Point}\n     */\n    this.position = new math.Point();\n\n    /**\n     * The scale factor of the object.\n     *\n     * @member {PIXI.Point}\n     */\n    this.scale = new math.Point(1, 1);\n\n    /**\n     * The pivot point of the displayObject that it rotates around\n     *\n     * @member {PIXI.Point}\n     */\n    this.pivot = new math.Point(0, 0);\n\n\n    /**\n     * The skew factor for the object in radians.\n     *\n     * @member {PIXI.Point}\n     */\n    this.skew = new math.Point(0, 0);\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @member {number}\n     */\n    this.rotation = 0;\n\n    /**\n     * The opacity of the object.\n     *\n     * @member {number}\n     */\n    this.alpha = 1;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * @member {boolean}\n     */\n    this.visible = true;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * @member {boolean}\n     */\n    this.renderable = true;\n\n    /**\n     * The display object container that contains this display object.\n     *\n     * @member {PIXI.Container}\n     * @readOnly\n     */\n    this.parent = null;\n\n    /**\n     * The multiplied alpha of the displayObject\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.worldAlpha = 1;\n\n    /**\n     * Current transform of the object based on world (parent) factors\n     *\n     * @member {PIXI.Matrix}\n     * @readOnly\n     */\n    this.worldTransform = new math.Matrix();\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimisation\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.filterArea = null;\n\n    /**\n     * cached sin rotation\n     *\n     * @member {number}\n     * @private\n     */\n    this._sr = 0;\n\n    /**\n     * cached cos rotation\n     *\n     * @member {number}\n     * @private\n     */\n    this._cr = 1;\n\n    /**\n     * The original, cached bounds of the object\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n    this._bounds = new math.Rectangle(0, 0, 1, 1);\n\n    /**\n     * The most up-to-date bounds of the object\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n    this._currentBounds = null;\n\n    /**\n     * The original, cached mask of the object\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n    this._mask = null;\n}\n\n// constructor\nDisplayObject.prototype = Object.create(EventEmitter.prototype);\nDisplayObject.prototype.constructor = DisplayObject;\nmodule.exports = DisplayObject;\n\nObject.defineProperties(DisplayObject.prototype, {\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     *\n     * @member {number}\n     * @memberof PIXI.DisplayObject#\n     */\n    x: {\n        get: function ()\n        {\n            return this.position.x;\n        },\n        set: function (value)\n        {\n            this.position.x = value;\n        }\n    },\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     *\n     * @member {number}\n     * @memberof PIXI.DisplayObject#\n     */\n    y: {\n        get: function ()\n        {\n            return this.position.y;\n        },\n        set: function (value)\n        {\n            this.position.y = value;\n        }\n    },\n\n    /**\n     * Indicates if the sprite is globally visible.\n     *\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     * @readonly\n     */\n    worldVisible: {\n        get: function ()\n        {\n            var item = this;\n\n            do {\n                if (!item.visible)\n                {\n                    return false;\n                }\n\n                item = item.parent;\n            } while (item);\n\n            return true;\n        }\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.\n     * In PIXI a regular mask must be a PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it utilises shape clipping.\n     * To remove a mask, set this property to null.\n     *\n     * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite}\n     * @memberof PIXI.DisplayObject#\n     */\n    mask: {\n        get: function ()\n        {\n            return this._mask;\n        },\n        set: function (value)\n        {\n            if (this._mask)\n            {\n                this._mask.renderable = true;\n            }\n\n            this._mask = value;\n\n            if (this._mask)\n            {\n                this._mask.renderable = false;\n            }\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to 'null'\n     *\n     * @member {PIXI.AbstractFilter[]}\n     * @memberof PIXI.DisplayObject#\n     */\n    filters: {\n        get: function ()\n        {\n            return this._filters && this._filters.slice();\n        },\n        set: function (value)\n        {\n            this._filters = value && value.slice();\n        }\n    }\n\n});\n\n/*\n * Updates the object transform for rendering\n *\n * TODO - Optimization pass!\n */\nDisplayObject.prototype.updateTransform = function ()\n{\n    // create some matrix refs for easy access\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n\n    // temporary matrix variables\n    var a, b, c, d, tx, ty;\n\n    // looks like we are skewing\n    if(this.skew.x || this.skew.y)\n    {\n        // I'm assuming that skewing is not going to be very common\n        // With that in mind, we can do a full setTransform using the temp matrix\n        _tempMatrix.setTransform(\n            this.position.x,\n            this.position.y,\n            this.pivot.x,\n            this.pivot.y,\n            this.scale.x,\n            this.scale.y,\n            this.rotation,\n            this.skew.x,\n            this.skew.y\n        );\n\n        // now concat the matrix (inlined so that we can avoid using copy)\n        wt.a  = _tempMatrix.a  * pt.a + _tempMatrix.b  * pt.c;\n        wt.b  = _tempMatrix.a  * pt.b + _tempMatrix.b  * pt.d;\n        wt.c  = _tempMatrix.c  * pt.a + _tempMatrix.d  * pt.c;\n        wt.d  = _tempMatrix.c  * pt.b + _tempMatrix.d  * pt.d;\n        wt.tx = _tempMatrix.tx * pt.a + _tempMatrix.ty * pt.c + pt.tx;\n        wt.ty = _tempMatrix.tx * pt.b + _tempMatrix.ty * pt.d + pt.ty;\n    }\n    else\n    {\n        // so if rotation is between 0 then we can simplify the multiplication process...\n        if (this.rotation % CONST.PI_2)\n        {\n            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes\n            if (this.rotation !== this.rotationCache)\n            {\n                this.rotationCache = this.rotation;\n                this._sr = Math.sin(this.rotation);\n                this._cr = Math.cos(this.rotation);\n            }\n\n            // get the matrix values of the displayobject based on its transform properties..\n            a  =  this._cr * this.scale.x;\n            b  =  this._sr * this.scale.x;\n            c  = -this._sr * this.scale.y;\n            d  =  this._cr * this.scale.y;\n            tx =  this.position.x;\n            ty =  this.position.y;\n\n            // check for pivot.. not often used so geared towards that fact!\n            if (this.pivot.x || this.pivot.y)\n            {\n                tx -= this.pivot.x * a + this.pivot.y * c;\n                ty -= this.pivot.x * b + this.pivot.y * d;\n            }\n\n            // concat the parent matrix with the objects transform.\n            wt.a  = a  * pt.a + b  * pt.c;\n            wt.b  = a  * pt.b + b  * pt.d;\n            wt.c  = c  * pt.a + d  * pt.c;\n            wt.d  = c  * pt.b + d  * pt.d;\n            wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n            wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n        }\n        else\n        {\n            // lets do the fast version as we know there is no rotation..\n            a  = this.scale.x;\n            d  = this.scale.y;\n\n            tx = this.position.x - this.pivot.x * a;\n            ty = this.position.y - this.pivot.y * d;\n\n            wt.a  = a  * pt.a;\n            wt.b  = a  * pt.b;\n            wt.c  = d  * pt.c;\n            wt.d  = d  * pt.d;\n            wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n            wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n        }\n    }\n\n    // multiply the alphas..\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n    // reset the bounds each time this is called!\n    this._currentBounds = null;\n};\n\n// performance increase to avoid using call.. (10x faster)\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n\n/**\n *\n *\n * Retrieves the bounds of the displayObject as a rectangle object\n *\n * @param matrix {PIXI.Matrix}\n * @return {PIXI.Rectangle} the rectangular bounding area\n */\nDisplayObject.prototype.getBounds = function (matrix) // jshint unused:false\n{\n    return math.Rectangle.EMPTY;\n};\n\n/**\n * Retrieves the local bounds of the displayObject as a rectangle object\n *\n * @return {PIXI.Rectangle} the rectangular bounding area\n */\nDisplayObject.prototype.getLocalBounds = function ()\n{\n    return this.getBounds(math.Matrix.IDENTITY);\n};\n\n/**\n * Calculates the global position of the display object\n *\n * @param position {PIXI.Point} The world origin to calculate from\n * @return {PIXI.Point} A point object representing the position of this object\n */\nDisplayObject.prototype.toGlobal = function (position)\n{\n    // this parent check is for just in case the item is a root object.\n    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n    if(!this.parent)\n    {\n        this.parent = _tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n    }\n    else\n    {\n        this.displayObjectUpdateTransform();\n    }\n\n    // don't need to update the lot\n    return this.worldTransform.apply(position);\n};\n\n/**\n * Calculates the local position of the display object relative to another point\n *\n * @param position {PIXI.Point} The world origin to calculate from\n * @param [from] {PIXI.DisplayObject} The DisplayObject to calculate the global position from\n * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new Point)\n * @return {PIXI.Point} A point object representing the position of this object\n */\nDisplayObject.prototype.toLocal = function (position, from, point)\n{\n    if (from)\n    {\n        position = from.toGlobal(position);\n    }\n\n    // this parent check is for just in case the item is a root object.\n    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n    if(!this.parent)\n    {\n        this.parent = _tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n    }\n    else\n    {\n        this.displayObjectUpdateTransform();\n    }\n\n    // simply apply the matrix..\n    return this.worldTransform.applyInverse(position, point);\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer} The renderer\n * @private\n */\nDisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false\n{\n    // OVERWRITE;\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {PIXI.CanvasRenderer} The renderer\n * @private\n */\nDisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false\n{\n    // OVERWRITE;\n};\n/**\n * Useful function that returns a texture of the display object that can then be used to create sprites\n * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.\n *\n * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @param resolution {number} The resolution of the texture being generated\n * @return {PIXI.Texture} a texture of the display object\n */\nDisplayObject.prototype.generateTexture = function (renderer, scaleMode, resolution)\n{\n    var bounds = this.getLocalBounds();\n\n    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);\n\n    _tempMatrix.tx = -bounds.x;\n    _tempMatrix.ty = -bounds.y;\n\n    renderTexture.render(this, _tempMatrix);\n\n    return renderTexture;\n};\n\n/**\n * Set the parent Container of this DisplayObject\n *\n * @param container {Container} The Container to add this DisplayObject to\n * @return {Container} The Container that this DisplayObject was added to\n */\nDisplayObject.prototype.setParent = function (container)\n{\n    if (!container || !container.addChild)\n    {\n        throw new Error('setParent: Argument must be a Container');\n    }\n\n    container.addChild(this);\n    return container;\n};\n\n/**\n * Convenience function to set the postion, scale, skew and pivot at once.\n *\n * @param [x=0] {number} The X position\n * @param [y=0] {number} The Y position\n * @param [scaleX=1] {number} The X scale value\n * @param [scaleY=1] {number} The Y scale value\n * @param [rotation=0] {number} The rotation\n * @param [skewX=0] {number} The X skew value\n * @param [skewY=0] {number} The Y skew value\n * @param [pivotX=0] {number} The X pivot value\n * @param [pivotY=0] {number} The Y pivot value\n * @return {PIXI.DisplayObject}\n */\nDisplayObject.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) //jshint ignore:line\n{\n    this.position.x = x || 0;\n    this.position.y = y || 0;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation || 0;\n    this.skew.x = skewX || 0;\n    this.skew.y = skewY || 0;\n    this.pivot.x = pivotX || 0;\n    this.pivot.y = pivotY || 0;\n    return this;\n};\n\n/**\n * Base destroy method for generic display objects\n *\n */\nDisplayObject.prototype.destroy = function ()\n{\n\n    this.position = null;\n    this.scale = null;\n    this.pivot = null;\n    this.skew = null;\n\n    this.parent = null;\n\n    this._bounds = null;\n    this._currentBounds = null;\n    this._mask = null;\n\n    this.worldTransform = null;\n    this.filterArea = null;\n};\n\n},{\"../const\":22,\"../math\":33,\"../textures/RenderTexture\":71,\"eventemitter3\":10}],25:[function(require,module,exports){\nvar Container = require('../display/Container'),\n    Texture = require('../textures/Texture'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),\n    GraphicsData = require('./GraphicsData'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempPoint = new math.Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nfunction Graphics()\n{\n    Container.call(this);\n\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.fillAlpha = 1;\n\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n    this.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn.\n     *\n     * @member {string}\n     * @default 0\n     */\n    this.lineColor = 0;\n\n    /**\n     * Graphics data\n     *\n     * @member {PIXI.GraphicsData[]}\n     * @private\n     */\n    this.graphicsData = [];\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.\n     *\n     * @member {number}\n     * @private\n     * @default 0xFFFFFF\n     */\n    this._prevTint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    this.blendMode = CONST.BLEND_MODES.NORMAL;\n\n    /**\n     * Current path\n     *\n     * @member {PIXI.GraphicsData}\n     * @private\n     */\n    this.currentPath = null;\n\n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer.\n     *\n     * @member {object<number, object>}\n     * @private\n     */\n    // TODO - _webgl should use a prototype object, not a random undocumented object...\n    this._webGL = {};\n\n    /**\n     * Whether this shape is being used as a mask.\n     *\n     * @member {boolean}\n     */\n    this.isMask = false;\n\n    /**\n     * The bounds' padding used for bounds calculation.\n     *\n     * @member {number}\n     */\n    this.boundsPadding = 0;\n\n    /**\n     * A cache of the local bounds to prevent recalculation.\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n    this._localBounds = new math.Rectangle(0,0,1,1);\n\n    /**\n     * Used to detect if the graphics object has changed. If this is set to true then the graphics\n     * object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.dirty = true;\n\n    /**\n     * Used to detect if the WebGL graphics object has changed. If this is set to true then the\n     * graphics object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.glDirty = false;\n\n    this.boundsDirty = true;\n\n    /**\n     * Used to detect if the cached sprite object needs to be updated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.cachedSpriteDirty = false;\n\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n}\n\n// constructor\nGraphics.prototype = Object.create(Container.prototype);\nGraphics.prototype.constructor = Graphics;\nmodule.exports = Graphics;\n\n/**\n * Creates a new Graphics object with the same values as this one.\n * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n *\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.clone = function ()\n{\n    var clone = new Graphics();\n\n    clone.renderable    = this.renderable;\n    clone.fillAlpha     = this.fillAlpha;\n    clone.lineWidth     = this.lineWidth;\n    clone.lineColor     = this.lineColor;\n    clone.tint          = this.tint;\n    clone.blendMode     = this.blendMode;\n    clone.isMask        = this.isMask;\n    clone.boundsPadding = this.boundsPadding;\n    clone.dirty         = true;\n    clone.glDirty       = true;\n    clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n    // copy graphics data\n    for (var i = 0; i < this.graphicsData.length; ++i)\n    {\n        clone.graphicsData.push(this.graphicsData[i].clone());\n    }\n\n    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n\n    clone.updateLocalBounds();\n\n    return clone;\n};\n\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @param lineWidth {number} width of the line to draw, will update the objects stored style\n * @param color {number} color of the line to draw, will update the objects stored style\n * @param alpha {number} alpha of the line to draw, will update the objects stored style\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.lineStyle = function (lineWidth, color, alpha)\n{\n    this.lineWidth = lineWidth || 0;\n    this.lineColor = color || 0;\n    this.lineAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length)\n        {\n            // halfway through a line? start a new one!\n            var shape = new math.Polygon(this.currentPath.shape.points.slice(-2));\n            shape.closed = false;\n            this.drawShape(shape);\n        }\n        else\n        {\n            // otherwise its empty so lets just set the line properties\n            this.currentPath.lineWidth = this.lineWidth;\n            this.currentPath.lineColor = this.lineColor;\n            this.currentPath.lineAlpha = this.lineAlpha;\n        }\n    }\n\n    return this;\n};\n\n/**\n * Moves the current drawing position to x, y.\n *\n * @param x {number} the X coordinate to move to\n * @param y {number} the Y coordinate to move to\n * @return {PIXI.Graphics}\n  */\nGraphics.prototype.moveTo = function (x, y)\n{\n    var shape = new math.Polygon([x,y]);\n    shape.closed = false;\n    this.drawShape(shape);\n\n    return this;\n};\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * The current drawing position is then set to (x, y).\n *\n * @param x {number} the X coordinate to draw to\n * @param y {number} the Y coordinate to draw to\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.lineTo = function (x, y)\n{\n    this.currentPath.shape.points.push(x, y);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var xa,\n        ya,\n        n = 20,\n        points = this.currentPath.shape.points;\n\n    if (points.length === 0)\n    {\n        this.moveTo(0, 0);\n    }\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n\n    var j = 0;\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        xa = fromX + ( (cpX - fromX) * j );\n        ya = fromY + ( (cpY - fromY) * j );\n\n        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),\n                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param cpX2 {number} Second Control point x\n * @param cpY2 {number} Second Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var n = 20,\n        dt,\n        dt2,\n        dt3,\n        t2,\n        t3,\n        points = this.currentPath.shape.points;\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n\n    var j = 0;\n\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n\n        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,\n                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n *\n * @param x1 {number} The x-coordinate of the beginning of the arc\n * @param y1 {number} The y-coordinate of the beginning of the arc\n * @param x2 {number} The x-coordinate of the end of the arc\n * @param y2 {number} The y-coordinate of the end of the arc\n * @param radius {number} The radius of the arc\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.arcTo = function (x1, y1, x2, y2, radius)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points.push(x1, y1);\n        }\n    }\n    else\n    {\n        this.moveTo(x1, y1);\n    }\n\n    var points = this.currentPath.shape.points,\n        fromX = points[points.length-2],\n        fromY = points[points.length-1],\n        a1 = fromY - y1,\n        b1 = fromX - x1,\n        a2 = y2   - y1,\n        b2 = x2   - x1,\n        mm = Math.abs(a1 * b2 - b1 * a2);\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n    }\n    else\n    {\n        var dd = a1 * a1 + b1 * b1,\n            cc = a2 * a2 + b2 * b2,\n            tt = a1 * a2 + b1 * b2,\n            k1 = radius * Math.sqrt(dd) / mm,\n            k2 = radius * Math.sqrt(cc) / mm,\n            j1 = k1 * tt / dd,\n            j2 = k2 * tt / cc,\n            cx = k1 * b2 + k2 * b1,\n            cy = k1 * a2 + k2 * a1,\n            px = b1 * (k2 + j1),\n            py = a1 * (k2 + j1),\n            qx = b2 * (k1 + j2),\n            qy = a2 * (k1 + j2),\n            startAngle = Math.atan2(py - cy, px - cx),\n            endAngle   = Math.atan2(qy - cy, qx - cx);\n\n        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @param cx {number} The x-coordinate of the center of the circle\n * @param cy {number} The y-coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n * @param endAngle {number} The ending angle, in radians\n * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)\n{\n    anticlockwise = anticlockwise || false;\n\n    if (startAngle === endAngle)\n    {\n        return this;\n    }\n\n    if( !anticlockwise && endAngle <= startAngle )\n    {\n        endAngle += Math.PI * 2;\n    }\n    else if( anticlockwise && startAngle <= endAngle )\n    {\n        startAngle += Math.PI * 2;\n    }\n\n    var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);\n    var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;\n\n    if(sweep === 0)\n    {\n        return this;\n    }\n\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n\n    if (this.currentPath)\n    {\n        this.currentPath.shape.points.push(startX, startY);\n    }\n    else\n    {\n        this.moveTo(startX, startY);\n    }\n\n    var points = this.currentPath.shape.points;\n\n    var theta = sweep/(segs*2);\n    var theta2 = theta*2;\n\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n\n    var segMinus = segs - 1;\n\n    var remainder = ( segMinus % 1 ) / segMinus;\n\n    for(var i=0; i<=segMinus; i++)\n    {\n        var real =  i + remainder * i;\n\n\n        var angle = ((theta) + startAngle + (theta2 * real));\n\n        var c = Math.cos(angle);\n        var s = -Math.sin(angle);\n\n        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,\n                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @param color {number} the color of the fill\n * @param alpha {number} the alpha of the fill\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.beginFill = function (color, alpha)\n{\n    this.filling = true;\n    this.fillColor = color || 0;\n    this.fillAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.currentPath.fill = this.filling;\n            this.currentPath.fillColor = this.fillColor;\n            this.currentPath.fillAlpha = this.fillAlpha;\n        }\n    }\n    return this;\n};\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @return {Graphics}\n */\nGraphics.prototype.endFill = function ()\n{\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n\n    return this;\n};\n\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.drawRect = function ( x, y, width, height )\n{\n    this.drawShape(new math.Rectangle(x,y, width, height));\n\n    return this;\n};\n\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @param radius {number} Radius of the rectangle corners\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.drawRoundedRect = function ( x, y, width, height, radius )\n{\n    this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));\n\n    return this;\n};\n\n/**\n * Draws a circle.\n *\n * @param x {number} The X coordinate of the center of the circle\n * @param y {number} The Y coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.drawCircle = function (x, y, radius)\n{\n    this.drawShape(new math.Circle(x,y, radius));\n\n    return this;\n};\n\n/**\n * Draws an ellipse.\n *\n * @param x {number} The X coordinate of the center of the ellipse\n * @param y {number} The Y coordinate of the center of the ellipse\n * @param width {number} The half width of the ellipse\n * @param height {number} The half height of the ellipse\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.drawEllipse = function (x, y, width, height)\n{\n    this.drawShape(new math.Ellipse(x, y, width, height));\n\n    return this;\n};\n\n/**\n * Draws a polygon using the given path.\n *\n * @param path {number[]|PIXI.Point[]} The path data used to construct the polygon.\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.drawPolygon = function (path)\n{\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = path;\n\n    var closed = true;\n\n    if (points instanceof math.Polygon)\n    {\n        closed = points.closed;\n        points = points.points;\n    }\n\n    if (!Array.isArray(points))\n    {\n        // prevents an argument leak deopt\n        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        points = new Array(arguments.length);\n\n        for (var i = 0; i < points.length; ++i)\n        {\n            points[i] = arguments[i];\n        }\n    }\n\n    var shape = new math.Polygon(points);\n    shape.closed = closed;\n\n    this.drawShape(shape);\n\n    return this;\n};\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @return {PIXI.Graphics}\n */\nGraphics.prototype.clear = function ()\n{\n    this.lineWidth = 0;\n    this.filling = false;\n\n    this.dirty = true;\n    this.clearDirty = true;\n    this.graphicsData = [];\n\n    return this;\n};\n\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @param resolution {number} The resolution of the texture being generated\n * @param scaleMode {number} Should be one of the scaleMode consts\n * @return {PIXI.Texture} a texture of the graphics object\n */\nGraphics.prototype.generateTexture = function (renderer, resolution, scaleMode)\n{\n\n    resolution = resolution || 1;\n\n    var bounds = this.getLocalBounds();\n\n    var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);\n\n    var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);\n    texture.baseTexture.resolution = resolution;\n\n    canvasBuffer.context.scale(resolution, resolution);\n\n    canvasBuffer.context.translate(-bounds.x,-bounds.y);\n\n    CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n\n    return texture;\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer}\n * @private\n */\nGraphics.prototype._renderWebGL = function (renderer)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n\n    // this code may still be needed so leaving for now..\n    //\n    /*\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n\n            // we will also need to update the texture on the gpu too!\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.worldAlpha = this.worldAlpha;\n\n        Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);\n\n        return;\n    }\n\n    */\n\n    if (this.glDirty)\n    {\n        this.dirty = true;\n        this.glDirty = false;\n    }\n\n    renderer.setObjectRenderer(renderer.plugins.graphics);\n    renderer.plugins.graphics.render(this);\n\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {PIXI.CanvasRenderer}\n * @private\n */\nGraphics.prototype._renderCanvas = function (renderer)\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    // if the tint has changed, set the graphics object to dirty.\n    if (this._prevTint !== this.tint) {\n        this.dirty = true;\n    }\n\n    // this code may still be needed so leaving for now..\n    //\n    /*\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n\n            // we will also need to update the texture\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.alpha = this.alpha;\n\n        Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);\n\n        return;\n    }\n    */\n    var context = renderer.context;\n    var transform = this.worldTransform;\n\n    var compositeOperation = renderer.blendModes[this.blendMode];\n    if (compositeOperation !== context.globalCompositeOperation)\n    {\n        context.globalCompositeOperation = compositeOperation;\n    }\n\n    var resolution = renderer.resolution;\n    context.setTransform(\n        transform.a * resolution,\n        transform.b * resolution,\n        transform.c * resolution,\n        transform.d * resolution,\n        transform.tx * resolution,\n        transform.ty * resolution\n    );\n\n    CanvasGraphics.renderGraphics(this, context);\n};\n\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @param [matrix] {PIXI.Matrix} The world transform matrix to use, defaults to this\n *  object's worldTransform.\n * @return {PIXI.Rectangle} the rectangular bounding area\n */\nGraphics.prototype.getBounds = function (matrix)\n{\n    if(!this._currentBounds)\n    {\n\n        // return an empty object if the item is a mask!\n        if (!this.renderable)\n        {\n            return math.Rectangle.EMPTY;\n        }\n\n        if (this.boundsDirty)\n        {\n            this.updateLocalBounds();\n\n            this.glDirty = true;\n            this.cachedSpriteDirty = true;\n            this.boundsDirty = false;\n        }\n\n        var bounds = this._localBounds;\n\n        var w0 = bounds.x;\n        var w1 = bounds.width + bounds.x;\n\n        var h0 = bounds.y;\n        var h1 = bounds.height + bounds.y;\n\n        var worldTransform = matrix || this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 =  a * w1 + c * h0 + tx;\n        var y4 =  d * h0 + b * w1 + ty;\n\n        var maxX = x1;\n        var maxY = y1;\n\n        var minX = x1;\n        var minY = y1;\n\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n\n        this._bounds.x = minX;\n        this._bounds.width = maxX - minX;\n\n        this._bounds.y = minY;\n        this._bounds.height = maxY - minY;\n\n        this._currentBounds = this._bounds;\n    }\n\n    return this._currentBounds;\n};\n\n/**\n* Tests if a point is inside this graphics object\n*\n* @param point {PIXI.Point} the point to test\n* @return {boolean} the result of the test\n*/\nGraphics.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var graphicsData = this.graphicsData;\n\n    for (var i = 0; i < graphicsData.length; i++)\n    {\n        var data = graphicsData[i];\n\n        if (!data.fill)\n        {\n            continue;\n        }\n\n        // only deal with fills..\n        if (data.shape)\n        {\n            if ( data.shape.contains( tempPoint.x, tempPoint.y ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Update the bounds of the object\n *\n */\nGraphics.prototype.updateLocalBounds = function ()\n{\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    if (this.graphicsData.length)\n    {\n        var shape, points, x, y, w, h;\n\n        for (var i = 0; i < this.graphicsData.length; i++)\n        {\n            var data = this.graphicsData[i];\n            var type = data.type;\n            var lineWidth = data.lineWidth;\n            shape = data.shape;\n\n            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC)\n            {\n                x = shape.x - lineWidth/2;\n                y = shape.y - lineWidth/2;\n                w = shape.width + lineWidth;\n                h = shape.height + lineWidth;\n\n                minX = x < minX ? x : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y < minY ? y : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === CONST.SHAPES.CIRC)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.radius + lineWidth/2;\n                h = shape.radius + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === CONST.SHAPES.ELIP)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.width + lineWidth/2;\n                h = shape.height + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else\n            {\n                // POLY\n                points = shape.points;\n\n                for (var j = 0; j < points.length; j += 2)\n                {\n                    x = points[j];\n                    y = points[j+1];\n\n                    minX = x-lineWidth < minX ? x-lineWidth : minX;\n                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;\n\n                    minY = y-lineWidth < minY ? y-lineWidth : minY;\n                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;\n                }\n            }\n        }\n    }\n    else\n    {\n        minX = 0;\n        maxX = 0;\n        minY = 0;\n        maxY = 0;\n    }\n\n    var padding = this.boundsPadding;\n\n    this._localBounds.x = minX - padding;\n    this._localBounds.width = (maxX - minX) + padding * 2;\n\n    this._localBounds.y = minY - padding;\n    this._localBounds.height = (maxY - minY) + padding * 2;\n};\n\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @private\n */\n/*\nGraphics.prototype._generateCachedSprite = function ()\n{\n    var bounds = this.getLocalBounds();\n\n    if (!this._cachedSprite)\n    {\n        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);\n        var texture = Texture.fromCanvas(canvasBuffer.canvas);\n\n        this._cachedSprite = new Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n\n    // make sure we set the alpha of the graphics to 1 for the render..\n    this.worldAlpha = 1;\n\n    // now render the graphic..\n    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n\n    this._cachedSprite.alpha = this.alpha;\n};\n*/\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\n/*\nGraphics.prototype.updateCachedSpriteTexture = function ()\n{\n    var cachedSprite = this._cachedSprite;\n    var texture = cachedSprite.texture;\n    var canvas = cachedSprite.buffer.canvas;\n\n    texture.baseTexture.width = canvas.width;\n    texture.baseTexture.height = canvas.height;\n    texture.crop.width = texture.frame.width = canvas.width;\n    texture.crop.height = texture.frame.height = canvas.height;\n\n    cachedSprite._width = canvas.width;\n    cachedSprite._height = canvas.height;\n\n    // update the dirty base textures\n    texture.baseTexture.dirty();\n};*/\n\n/**\n * Destroys a previous cached sprite.\n *\n */\n/*\nGraphics.prototype.destroyCachedSprite = function ()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};*/\n\n/**\n * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n *\n * @param shape {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.\n * @return {PIXI.GraphicsData} The generated GraphicsData object.\n */\nGraphics.prototype.drawShape = function (shape)\n{\n    if (this.currentPath)\n    {\n        // check current path!\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.graphicsData.pop();\n        }\n    }\n\n    this.currentPath = null;\n\n    var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);\n\n    this.graphicsData.push(data);\n\n    if (data.type === CONST.SHAPES.POLY)\n    {\n        data.shape.closed = data.shape.closed || this.filling;\n        this.currentPath = data;\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return data;\n};\n\n/**\n * Destroys the Graphics object.\n */\nGraphics.prototype.destroy = function () {\n    Container.prototype.destroy.apply(this, arguments);\n\n    // destroy each of the GraphicsData objects\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n        this.graphicsData[i].destroy();\n    }\n\n    // for each webgl data entry, destroy the WebGLGraphicsData\n    for (var id in this._webgl) {\n        for (var j = 0; j < this._webgl[id].data.length; ++j) {\n            this._webgl[id].data[j].destroy();\n        }\n    }\n\n    this.graphicsData = null;\n\n    this.currentPath = null;\n    this._webgl = null;\n    this._localBounds = null;\n};\n\n},{\"../const\":22,\"../display/Container\":23,\"../math\":33,\"../renderers/canvas/utils/CanvasBuffer\":45,\"../renderers/canvas/utils/CanvasGraphics\":46,\"../textures/Texture\":72,\"./GraphicsData\":26}],26:[function(require,module,exports){\n/**\n * A GraphicsData object.\n *\n * @class\n * @memberof PIXI\n * @param lineWidth {number} the width of the line to draw\n * @param lineColor {number} the color of the line to draw\n * @param lineAlpha {number} the alpha of the line to draw\n * @param fillColor {number} the color of the fill\n * @param fillAlpha {number} the alpha of the fill\n * @param fill      {boolean} whether or not the shape is filled with a colour\n * @param shape     {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.\n */\nfunction GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape)\n{\n    /*\n     * @member {number} the width of the line to draw\n     */\n    this.lineWidth = lineWidth;\n\n    /*\n     * @member {number} the color of the line to draw\n     */\n    this.lineColor = lineColor;\n    /*\n     * @member {number} the alpha of the line to draw\n     */\n    this.lineAlpha = lineAlpha;\n    /*\n     * @member {number} cached tint of the line to draw\n     */\n    this._lineTint = lineColor;\n\n    /*\n     * @member {number} the color of the fill\n     */\n    this.fillColor = fillColor;\n\n    /*\n     * @member {number} the alpha of the fill\n     */\n    this.fillAlpha = fillAlpha;\n\n    /*\n     * @member {number} cached tint of the fill\n     */\n    this._fillTint = fillColor;\n\n    /*\n     * @member {boolean} whether or not the shape is filled with a colour\n     */\n    this.fill = fill;\n\n    /*\n     * @member {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.\n     */\n    this.shape = shape;\n\n    /*\n     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,\n     */\n    this.type = shape.type;\n}\n\nGraphicsData.prototype.constructor = GraphicsData;\nmodule.exports = GraphicsData;\n\n/**\n * Creates a new GraphicsData object with the same values as this one.\n *\n * @return {PIXI.GraphicsData}\n */\nGraphicsData.prototype.clone = function ()\n{\n    return new GraphicsData(\n        this.lineWidth,\n        this.lineColor,\n        this.lineAlpha,\n        this.fillColor,\n        this.fillAlpha,\n        this.fill,\n        this.shape\n    );\n};\n\n/**\n * Destroys the Graphics data.\n */\nGraphicsData.prototype.destroy = function () {\n    this.shape = null;\n};\n\n},{}],27:[function(require,module,exports){\nvar utils = require('../../utils'),\n    math = require('../../math'),\n    CONST = require('../../const'),\n    ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),\n    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),\n    WebGLGraphicsData = require('./WebGLGraphicsData'),\n    earcut = require('earcut');\n\n/**\n * Renders the graphics object.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.\n */\nfunction GraphicsRenderer(renderer)\n{\n    ObjectRenderer.call(this, renderer);\n\n    this.graphicsDataPool = [];\n\n    this.primitiveShader = null;\n    this.complexPrimitiveShader = null;\n\n    /**\n     * This is the maximum number of points a poly can contain before it is rendered as a complex polygon (using the stencil buffer)\n     * @type {Number}\n     */\n    this.maximumSimplePolySize = 200;\n}\n\nGraphicsRenderer.prototype = Object.create(ObjectRenderer.prototype);\nGraphicsRenderer.prototype.constructor = GraphicsRenderer;\nmodule.exports = GraphicsRenderer;\n\nWebGLRenderer.registerPlugin('graphics', GraphicsRenderer);\n\n/**\n * Called when there is a WebGL context change\n *\n * @private\n *\n */\nGraphicsRenderer.prototype.onContextChange = function()\n{\n\n};\n\n/**\n * Destroys this renderer.\n *\n */\nGraphicsRenderer.prototype.destroy = function () {\n    ObjectRenderer.prototype.destroy.call(this);\n\n    for (var i = 0; i < this.graphicsDataPool.length; ++i) {\n        this.graphicsDataPool[i].destroy();\n    }\n\n    this.graphicsDataPool = null;\n};\n\n/**\n * Renders a graphics object.\n *\n * @param graphics {PIXI.Graphics} The graphics object to render.\n */\nGraphicsRenderer.prototype.render = function(graphics)\n{\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n\n    var shader = renderer.shaderManager.plugins.primitiveShader,\n        webGLData;\n\n    if (graphics.dirty || !graphics._webGL[gl.id])\n    {\n        this.updateGraphics(graphics);\n    }\n\n    var webGL = graphics._webGL[gl.id];\n\n    // This  could be speeded up for sure!\n\n    renderer.blendModeManager.setBlendMode( graphics.blendMode );\n\n//    var matrix =  graphics.worldTransform.clone();\n//    var matrix =  renderer.currentRenderTarget.projectionMatrix.clone();\n//    matrix.append(graphics.worldTransform);\n\n    for (var i = 0, n = webGL.data.length; i < n; i++)\n    {\n        webGLData = webGL.data[i];\n\n        if (webGL.data[i].mode === 1)\n        {\n\n            renderer.stencilManager.pushStencil(graphics, webGLData);\n\n            gl.uniform1f(renderer.shaderManager.complexPrimitiveShader.uniforms.alpha._location, graphics.worldAlpha * webGLData.alpha);\n\n            // render quad..\n            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n\n            renderer.stencilManager.popStencil(graphics, webGLData);\n        }\n        else\n        {\n\n            shader = renderer.shaderManager.primitiveShader;\n\n            renderer.shaderManager.setShader( shader );//activatePrimitiveShader();\n\n            gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));\n\n            gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));\n\n            gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));\n\n            gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);\n\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n            gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n            // set the index buffer!\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n        }\n\n        renderer.drawCount++;\n    }\n};\n\n/**\n * Updates the graphics object\n *\n * @private\n * @param graphics {PIXI.Graphics} The graphics object to update\n */\nGraphicsRenderer.prototype.updateGraphics = function(graphics)\n{\n    var gl = this.renderer.gl;\n\n     // get the contexts graphics object\n    var webGL = graphics._webGL[gl.id];\n\n    // if the graphics object does not exist in the webGL context time to create it!\n    if (!webGL)\n    {\n        webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};\n    }\n\n    // flag the graphics as not dirty as we are about to update it...\n    graphics.dirty = false;\n\n    var i;\n\n    // if the user cleared the graphics object we will need to clear every object\n    if (graphics.clearDirty)\n    {\n        graphics.clearDirty = false;\n\n        // loop through and return all the webGLDatas to the object pool so than can be reused later on\n        for (i = 0; i < webGL.data.length; i++)\n        {\n            var graphicsData = webGL.data[i];\n            graphicsData.reset();\n            this.graphicsDataPool.push( graphicsData );\n        }\n\n        // clear the array and reset the index..\n        webGL.data = [];\n        webGL.lastIndex = 0;\n    }\n\n    var webGLData;\n\n    // loop through the graphics datas and construct each one..\n    // if the object is a complex fill then the new stencil buffer technique will be used\n    // other wise graphics objects will be pushed into a batch..\n    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n\n        if (data.type === CONST.SHAPES.POLY)\n        {\n            // need to add the points the the graphics object..\n            data.points = data.shape.points.slice();\n            if (data.shape.closed)\n            {\n                // close the poly if the value is true!\n                if (data.points[0] !== data.points[data.points.length-2] || data.points[1] !== data.points[data.points.length-1])\n                {\n                    data.points.push(data.points[0], data.points[1]);\n                }\n            }\n\n            // MAKE SURE WE HAVE THE CORRECT TYPE..\n            if (data.fill)\n            {\n                if (data.points.length >= 6)\n                {\n                    if (data.points.length < this.maximumSimplePolySize * 2)\n                    {\n                        webGLData = this.switchMode(webGL, 0);\n\n                        var canDrawUsingSimple = this.buildPoly(data, webGLData);\n\n                        if (!canDrawUsingSimple)\n                        {\n                            webGLData = this.switchMode(webGL, 1);\n                            this.buildComplexPoly(data, webGLData);\n                        }\n\n                    }\n                    else\n                    {\n                        webGLData = this.switchMode(webGL, 1);\n                        this.buildComplexPoly(data, webGLData);\n                    }\n                }\n            }\n\n            if (data.lineWidth > 0)\n            {\n                webGLData = this.switchMode(webGL, 0);\n                this.buildLine(data, webGLData);\n            }\n        }\n        else\n        {\n            webGLData = this.switchMode(webGL, 0);\n\n            if (data.type === CONST.SHAPES.RECT)\n            {\n                this.buildRectangle(data, webGLData);\n            }\n            else if (data.type === CONST.SHAPES.CIRC || data.type === CONST.SHAPES.ELIP)\n            {\n                this.buildCircle(data, webGLData);\n            }\n            else if (data.type === CONST.SHAPES.RREC)\n            {\n                this.buildRoundedRectangle(data, webGLData);\n            }\n        }\n\n        webGL.lastIndex++;\n    }\n\n    // upload all the dirty data...\n    for (i = 0; i < webGL.data.length; i++)\n    {\n        webGLData = webGL.data[i];\n\n        if (webGLData.dirty)\n        {\n            webGLData.upload();\n        }\n    }\n};\n\n/**\n *\n *\n * @private\n * @param webGL {WebGLRenderingContext} the current WebGL drawing context\n * @param type {number} TODO @Alvin\n */\nGraphicsRenderer.prototype.switchMode = function (webGL, type)\n{\n    var webGLData;\n\n    if (!webGL.data.length)\n    {\n        webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);\n        webGLData.mode = type;\n        webGL.data.push(webGLData);\n    }\n    else\n    {\n        webGLData = webGL.data[webGL.data.length-1];\n\n        if ((webGLData.points.length > 320000) || webGLData.mode !== type || type === 1)\n        {\n            webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);\n            webGLData.mode = type;\n            webGL.data.push(webGLData);\n        }\n    }\n\n    webGLData.dirty = true;\n\n    return webGLData;\n};\n\n/**\n * Builds a rectangle to draw\n *\n * @private\n * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties\n * @param webGLData {object} an object containing all the webGL-specific information to create this shape\n */\nGraphicsRenderer.prototype.buildRectangle = function (graphicsData, webGLData)\n{\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n\n    if (graphicsData.fill)\n    {\n        var color = utils.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vertPos = verts.length/6;\n\n        // start\n        verts.push(x, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x , y + height);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y + height);\n        verts.push(r, g, b, alpha);\n\n        // insert 2 dead triangles..\n        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [x, y,\n                  x + width, y,\n                  x + width, y + height,\n                  x, y + height,\n                  x, y];\n\n\n        this.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a rounded rectangle to draw\n *\n * @private\n * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties\n * @param webGLData {object} an object containing all the webGL-specific information to create this shape\n */\nGraphicsRenderer.prototype.buildRoundedRectangle = function (graphicsData, webGLData)\n{\n    var rrectData = graphicsData.shape;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n\n    var radius = rrectData.radius;\n\n    var recPoints = [];\n    recPoints.push(x, y + radius);\n    this.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);\n    this.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);\n    this.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);\n    this.quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);\n\n    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n    // TODO - fix this properly, this is not very elegant.. but it works for now.\n\n    if (graphicsData.fill)\n    {\n        var color = utils.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length/6;\n\n        var triangles = earcut(recPoints, null, 2);\n\n        var i = 0;\n        for (i = 0; i < triangles.length; i+=3)\n        {\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i+1] + vecPos);\n            indices.push(triangles[i+2] + vecPos);\n            indices.push(triangles[i+2] + vecPos);\n        }\n\n        for (i = 0; i < recPoints.length; i++)\n        {\n            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);\n        }\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = recPoints;\n\n        this.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @private\n * @param fromX {number} Origin point x\n * @param fromY {number} Origin point x\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @param [out] {number[]} The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nGraphicsRenderer.prototype.quadraticBezierCurve = function (fromX, fromY, cpX, cpY, toX, toY, out)\n{\n    var xa,\n        ya,\n        xb,\n        yb,\n        x,\n        y,\n        n = 20,\n        points = out || [];\n\n    function getPt(n1 , n2, perc) {\n        var diff = n2 - n1;\n\n        return n1 + ( diff * perc );\n    }\n\n    var j = 0;\n    for (var i = 0; i <= n; i++ ) {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt( fromX , cpX , j );\n        ya = getPt( fromY , cpY , j );\n        xb = getPt( cpX , toX , j );\n        yb = getPt( cpY , toY , j );\n\n        // The Black Dot\n        x = getPt( xa , xb , j );\n        y = getPt( ya , yb , j );\n\n        points.push(x, y);\n    }\n\n    return points;\n};\n\n/**\n * Builds a circle to draw\n *\n * @private\n * @param graphicsData {PIXI.Graphics} The graphics object to draw\n * @param webGLData {object} an object containing all the webGL-specific information to create this shape\n */\nGraphicsRenderer.prototype.buildCircle = function (graphicsData, webGLData)\n{\n    // need to convert points to a nice regular data\n    var circleData = graphicsData.shape;\n    var x = circleData.x;\n    var y = circleData.y;\n    var width;\n    var height;\n\n    // TODO - bit hacky??\n    if (graphicsData.type === CONST.SHAPES.CIRC)\n    {\n        width = circleData.radius;\n        height = circleData.radius;\n    }\n    else\n    {\n        width = circleData.width;\n        height = circleData.height;\n    }\n\n    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));\n    var seg = (Math.PI * 2) / totalSegs ;\n\n    var i = 0;\n\n    if (graphicsData.fill)\n    {\n        var color = utils.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length/6;\n\n        indices.push(vecPos);\n\n        for (i = 0; i < totalSegs + 1 ; i++)\n        {\n            verts.push(x,y, r, g, b, alpha);\n\n            verts.push(x + Math.sin(seg * i) * width,\n                       y + Math.cos(seg * i) * height,\n                       r, g, b, alpha);\n\n            indices.push(vecPos++, vecPos++);\n        }\n\n        indices.push(vecPos-1);\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [];\n\n        for (i = 0; i < totalSegs + 1; i++)\n        {\n            graphicsData.points.push(x + Math.sin(seg * i) * width,\n                                     y + Math.cos(seg * i) * height);\n        }\n\n        this.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a line to draw\n *\n * @private\n * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties\n * @param webGLData {object} an object containing all the webGL-specific information to create this shape\n */\nGraphicsRenderer.prototype.buildLine = function (graphicsData, webGLData)\n{\n    // TODO OPTIMISE!\n    var i = 0;\n    var points = graphicsData.points;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    // get first and last point.. figure out the middle!\n    var firstPoint = new math.Point(points[0], points[1]);\n    var lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);\n\n    // if the first point is the last point - gonna have issues :)\n    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        points.pop();\n        points.pop();\n\n        lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);\n\n        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;\n        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var length = points.length / 2;\n    var indexCount = points.length;\n    var indexStart = verts.length/6;\n\n    // DRAW the Line\n    var width = graphicsData.lineWidth / 2;\n\n    // sort color\n    var color = utils.hex2rgb(graphicsData.lineColor);\n    var alpha = graphicsData.lineAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;\n    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;\n    var a1, b1, c1, a2, b2, c2;\n    var denom, pdist, dist;\n\n    p1x = points[0];\n    p1y = points[1];\n\n    p2x = points[2];\n    p2y = points[3];\n\n    perpx = -(p1y - p2y);\n    perpy =  p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    // start\n    verts.push(p1x - perpx , p1y - perpy,\n                r, g, b, alpha);\n\n    verts.push(p1x + perpx , p1y + perpy,\n                r, g, b, alpha);\n\n    for (i = 1; i < length-1; i++)\n    {\n        p1x = points[(i-1)*2];\n        p1y = points[(i-1)*2 + 1];\n\n        p2x = points[(i)*2];\n        p2y = points[(i)*2 + 1];\n\n        p3x = points[(i+1)*2];\n        p3y = points[(i+1)*2 + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt(perpx*perpx + perpy*perpy);\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        a1 = (-perpy + p1y) - (-perpy + p2y);\n        b1 = (-perpx + p2x) - (-perpx + p1x);\n        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\n        a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\n\n        denom = a1*b2 - a2*b1;\n\n        if (Math.abs(denom) < 0.1 )\n        {\n\n            denom+=10.1;\n            verts.push(p2x - perpx , p2y - perpy,\n                r, g, b, alpha);\n\n            verts.push(p2x + perpx , p2y + perpy,\n                r, g, b, alpha);\n\n            continue;\n        }\n\n        px = (b1*c2 - b2*c1)/denom;\n        py = (a2*c1 - a1*c2)/denom;\n\n\n        pdist = (px -p2x) * (px -p2x) + (py -p2y) * (py -p2y);\n\n\n        if (pdist > 140 * 140)\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x + perp3x, p2y +perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            indexCount++;\n        }\n        else\n        {\n\n            verts.push(px , py);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - (px-p2x), p2y - (py - p2y));\n            verts.push(r, g, b, alpha);\n        }\n    }\n\n    p1x = points[(length-2)*2];\n    p1y = points[(length-2)*2 + 1];\n\n    p2x = points[(length-1)*2];\n    p2y = points[(length-1)*2 + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - perpx , p2y - perpy);\n    verts.push(r, g, b, alpha);\n\n    verts.push(p2x + perpx , p2y + perpy);\n    verts.push(r, g, b, alpha);\n\n    indices.push(indexStart);\n\n    for (i = 0; i < indexCount; i++)\n    {\n        indices.push(indexStart++);\n    }\n\n    indices.push(indexStart-1);\n};\n\n/**\n * Builds a complex polygon to draw\n *\n * @private\n * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties\n * @param webGLData {object} an object containing all the webGL-specific information to create this shape\n */\nGraphicsRenderer.prototype.buildComplexPoly = function (graphicsData, webGLData)\n{\n    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..\n    var points = graphicsData.points.slice();\n\n    if (points.length < 6)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n    var indices = webGLData.indices;\n    webGLData.points = points;\n    webGLData.alpha = graphicsData.fillAlpha;\n    webGLData.color = utils.hex2rgb(graphicsData.fillColor);\n\n    // calclate the bounds..\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    var x,y;\n\n    // get size..\n    for (var i = 0; i < points.length; i+=2)\n    {\n        x = points[i];\n        y = points[i+1];\n\n        minX = x < minX ? x : minX;\n        maxX = x > maxX ? x : maxX;\n\n        minY = y < minY ? y : minY;\n        maxY = y > maxY ? y : maxY;\n    }\n\n    // add a quad to the end cos there is no point making another buffer!\n    points.push(minX, minY,\n                maxX, minY,\n                maxX, maxY,\n                minX, maxY);\n\n    // push a quad onto the end..\n\n    //TODO - this aint needed!\n    var length = points.length / 2;\n    for (i = 0; i < length; i++)\n    {\n        indices.push( i );\n    }\n\n};\n\n/**\n * Builds a polygon to draw\n *\n * @private\n * @param graphicsData {PIXI.WebGLGraphicsData} The graphics object containing all the necessary properties\n * @param webGLData {object} an object containing all the webGL-specific information to create this shape\n */\nGraphicsRenderer.prototype.buildPoly = function (graphicsData, webGLData)\n{\n    var points = graphicsData.points;\n\n    if (points.length < 6)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n\n    var length = points.length / 2;\n\n    // sort color\n    var color = utils.hex2rgb(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var triangles = earcut(points, null, 2);\n\n    if (!triangles) {\n        return false;\n    }\n\n    var vertPos = verts.length / 6;\n\n    var i = 0;\n\n    for (i = 0; i < triangles.length; i+=3)\n    {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i+1] + vertPos);\n        indices.push(triangles[i+2] +vertPos);\n        indices.push(triangles[i+2] + vertPos);\n    }\n\n    for (i = 0; i < length; i++)\n    {\n        verts.push(points[i * 2], points[i * 2 + 1],\n                   r, g, b, alpha);\n    }\n\n    return true;\n};\n\n},{\"../../const\":22,\"../../math\":33,\"../../renderers/webgl/WebGLRenderer\":49,\"../../renderers/webgl/utils/ObjectRenderer\":63,\"../../utils\":77,\"./WebGLGraphicsData\":28,\"earcut\":9}],28:[function(require,module,exports){\n/**\n * An object containing WebGL specific properties to be used by the WebGL renderer\n *\n * @class\n * @memberof PIXI\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\n * @private\n */\nfunction WebGLGraphicsData(gl) {\n\n    /**\n     * The current WebGL drawing context\n     *\n     * @member {WebGLRenderingContext}\n     */\n    this.gl = gl;\n\n    //TODO does this need to be split before uploding??\n    /**\n     * An array of color components (r,g,b)\n     * @member {number[]}\n     */\n    this.color = [0,0,0]; // color split!\n\n    /**\n     * An array of points to draw\n     * @member {PIXI.Point[]}\n     */\n    this.points = [];\n\n    /**\n     * The indices of the vertices\n     * @member {number[]}\n     */\n    this.indices = [];\n    /**\n     * The main buffer\n     * @member {WebGLBuffer}\n     */\n    this.buffer = gl.createBuffer();\n\n    /**\n     * The index buffer\n     * @member {WebGLBuffer}\n     */\n    this.indexBuffer = gl.createBuffer();\n\n    /**\n     * todo @alvin\n     * @member {number}\n     */\n    this.mode = 1;\n\n    /**\n     * The alpha of the graphics\n     * @member {number}\n     */\n    this.alpha = 1;\n\n    /**\n     * Whether this graphics is dirty or not\n     * @member {boolean}\n     */\n    this.dirty = true;\n\n    this.glPoints = null;\n    this.glIndices = null;\n}\n\nWebGLGraphicsData.prototype.constructor = WebGLGraphicsData;\nmodule.exports = WebGLGraphicsData;\n\n/**\n * Resets the vertices and the indices\n */\nWebGLGraphicsData.prototype.reset = function () {\n    this.points.length = 0;\n    this.indices.length = 0;\n};\n\n/**\n * Binds the buffers and uploads the data\n */\nWebGLGraphicsData.prototype.upload = function () {\n    var gl = this.gl;\n\n//    this.lastIndex = graphics.graphicsData.length;\n    this.glPoints = new Float32Array(this.points);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);\n\n    this.glIndices = new Uint16Array(this.indices);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndices, gl.STATIC_DRAW);\n\n    this.dirty = false;\n};\n\nWebGLGraphicsData.prototype.destroy = function () {\n    this.color = null;\n    this.points = null;\n    this.indices = null;\n\n    this.gl.deleteBuffer(this.buffer);\n    this.gl.deleteBuffer(this.indexBuffer);\n    \n    this.gl = null;\n\n    this.buffer = null;\n    this.indexBuffer = null;\n\n    this.glPoints = null;\n    this.glIndices = null;\n};\n\n},{}],29:[function(require,module,exports){\n/**\n * @file        Main export of the PIXI core library\n * @author      Mat Groves <mat@goodboydigital.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI\n */\n// export core and const. We assign core to const so that the non-reference types in const remain in-tact\nvar core = module.exports = Object.assign(require('./const'), require('./math'), {\n    // utils\n    utils: require('./utils'),\n    ticker: require('./ticker'),\n\n    // display\n    DisplayObject:          require('./display/DisplayObject'),\n    Container:              require('./display/Container'),\n\n    // sprites\n    Sprite:                 require('./sprites/Sprite'),\n    ParticleContainer:      require('./particles/ParticleContainer'),\n    SpriteRenderer:         require('./sprites/webgl/SpriteRenderer'),\n    ParticleRenderer:       require('./particles/webgl/ParticleRenderer'),\n\n    // text\n    Text:                   require('./text/Text'),\n\n    // primitives\n    Graphics:               require('./graphics/Graphics'),\n    GraphicsData:           require('./graphics/GraphicsData'),\n    GraphicsRenderer:       require('./graphics/webgl/GraphicsRenderer'),\n\n    // textures\n    Texture:                require('./textures/Texture'),\n    BaseTexture:            require('./textures/BaseTexture'),\n    RenderTexture:          require('./textures/RenderTexture'),\n    VideoBaseTexture:       require('./textures/VideoBaseTexture'),\n    TextureUvs:             require('./textures/TextureUvs'),\n\n    // renderers - canvas\n    CanvasRenderer:         require('./renderers/canvas/CanvasRenderer'),\n    CanvasGraphics:         require('./renderers/canvas/utils/CanvasGraphics'),\n    CanvasBuffer:           require('./renderers/canvas/utils/CanvasBuffer'),\n\n    // renderers - webgl\n    WebGLRenderer:          require('./renderers/webgl/WebGLRenderer'),\n    WebGLManager:           require('./renderers/webgl/managers/WebGLManager'),\n    ShaderManager:          require('./renderers/webgl/managers/ShaderManager'),\n    Shader:                 require('./renderers/webgl/shaders/Shader'),\n    TextureShader:          require('./renderers/webgl/shaders/TextureShader'),\n    PrimitiveShader:        require('./renderers/webgl/shaders/PrimitiveShader'),\n    ComplexPrimitiveShader: require('./renderers/webgl/shaders/ComplexPrimitiveShader'),\n    ObjectRenderer:         require('./renderers/webgl/utils/ObjectRenderer'),\n    RenderTarget:           require('./renderers/webgl/utils/RenderTarget'),\n\n    // filters - webgl\n    AbstractFilter:         require('./renderers/webgl/filters/AbstractFilter'),\n    FXAAFilter:             require('./renderers/webgl/filters/FXAAFilter'),\n    SpriteMaskFilter:       require('./renderers/webgl/filters/SpriteMaskFilter'),\n\n    /**\n     * This helper function will automatically detect which renderer you should be using.\n     * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by\n     * the browser then this function will return a canvas renderer\n     *\n     * @memberof PIXI\n     * @param width=800 {number} the width of the renderers view\n     * @param height=600 {number} the height of the renderers view\n     * @param [options] {object} The optional renderer parameters\n     * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n     * @param [options.transparent=false] {boolean} If the render view is transparent, default false\n     * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)\n     * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if you\n     *      need to call toDataUrl on the webgl context\n     * @param [options.resolution=1] {number} the resolution of the renderer, retina would be 2\n     * @param [noWebGL=false] {boolean} prevents selection of WebGL renderer, even if such is present\n     *\n     * @return {WebGLRenderer|CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer\n     */\n    autoDetectRenderer: function (width, height, options, noWebGL)\n    {\n        width = width || 800;\n        height = height || 600;\n\n        if (!noWebGL && core.utils.isWebGLSupported())\n        {\n            return new core.WebGLRenderer(width, height, options);\n        }\n\n        return new core.CanvasRenderer(width, height, options);\n    }\n});\n\n},{\"./const\":22,\"./display/Container\":23,\"./display/DisplayObject\":24,\"./graphics/Graphics\":25,\"./graphics/GraphicsData\":26,\"./graphics/webgl/GraphicsRenderer\":27,\"./math\":33,\"./particles/ParticleContainer\":39,\"./particles/webgl/ParticleRenderer\":41,\"./renderers/canvas/CanvasRenderer\":44,\"./renderers/canvas/utils/CanvasBuffer\":45,\"./renderers/canvas/utils/CanvasGraphics\":46,\"./renderers/webgl/WebGLRenderer\":49,\"./renderers/webgl/filters/AbstractFilter\":50,\"./renderers/webgl/filters/FXAAFilter\":51,\"./renderers/webgl/filters/SpriteMaskFilter\":52,\"./renderers/webgl/managers/ShaderManager\":56,\"./renderers/webgl/managers/WebGLManager\":58,\"./renderers/webgl/shaders/ComplexPrimitiveShader\":59,\"./renderers/webgl/shaders/PrimitiveShader\":60,\"./renderers/webgl/shaders/Shader\":61,\"./renderers/webgl/shaders/TextureShader\":62,\"./renderers/webgl/utils/ObjectRenderer\":63,\"./renderers/webgl/utils/RenderTarget\":65,\"./sprites/Sprite\":67,\"./sprites/webgl/SpriteRenderer\":68,\"./text/Text\":69,\"./textures/BaseTexture\":70,\"./textures/RenderTexture\":71,\"./textures/Texture\":72,\"./textures/TextureUvs\":73,\"./textures/VideoBaseTexture\":74,\"./ticker\":76,\"./utils\":77}],30:[function(require,module,exports){\n// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16\n\nvar ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nvar uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nvar tempMatrices = [];\nvar Matrix = require('./Matrix');\n\nvar mul = [];\n\nfunction signum(x) {\n    if (x < 0) {\n        return -1;\n    }\n    if (x > 0) {\n        return 1;\n    }\n    return 0;\n}\n\nfunction init() {\n    for (var i = 0; i < 16; i++) {\n        var row = [];\n        mul.push(row);\n        for (var j = 0; j < 16; j++) {\n            var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n            var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n            var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n            var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n            for (var k = 0; k < 16; k++) {\n                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i=0;i<16;i++) {\n        var mat = new Matrix();\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        tempMatrices.push(mat);\n    }\n}\n\ninit();\n\n/**\n * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html}, D8 is the same but with diagonals\n * Used for texture rotations\n * Vector xX(i), xY(i) is U-axis of sprite with rotation i\n * Vector yY(i), yY(i) is V-axis of sprite with rotation i\n * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)\n * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)\n * This is the small part of gameofbombs.com portal system. It works.\n * @author Ivan @ivanpopelyshev\n *\n * @namespace PIXI.GroupD8\n */\nvar GroupD8 = {\n    E: 0,\n    SE: 1,\n    S: 2,\n    SW: 3,\n    W: 4,\n    NW: 5,\n    N: 6,\n    NE: 7,\n    MIRROR_VERTICAL: 8,\n    MIRROR_HORIZONTAL: 12,\n    uX: function (ind) {\n        return ux[ind];\n    },\n    uY: function (ind) {\n        return uy[ind];\n    },\n    vX: function (ind) {\n        return vx[ind];\n    },\n    vY: function (ind) {\n        return vy[ind];\n    },\n    inv: function (rotation) {\n        if (rotation & 8) {\n            return rotation & 15;\n        }\n        return (-rotation) & 7;\n    },\n    add: function (rotationSecond, rotationFirst) {\n        return mul[rotationSecond][rotationFirst];\n    },\n    sub: function (rotationSecond, rotationFirst) {\n        return mul[rotationSecond][GroupD8.inv(rotationFirst)];\n    },\n    /**\n     * Adds 180 degrees to rotation. Commutative operation\n     * @param rotation\n     * @returns {number}\n     */\n    rotate180: function (rotation) {\n        return rotation ^ 4;\n    },\n    /**\n     * I dont know why sometimes width and heights needs to be swapped. We'll fix it later.\n     * @param rotation\n     * @returns {boolean}\n     */\n    isSwapWidthHeight: function(rotation) {\n        return (rotation & 3) === 2;\n    },\n    byDirection: function (dx, dy) {\n        if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n            if (dy >= 0) {\n                return GroupD8.S;\n            }\n            else {\n                return GroupD8.N;\n            }\n        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n            if (dx > 0) {\n                return GroupD8.E;\n            }\n            else {\n                return GroupD8.W;\n            }\n        } else {\n            if (dy > 0) {\n                if (dx > 0) {\n                    return GroupD8.SE;\n                }\n                else {\n                    return GroupD8.SW;\n                }\n            }\n            else if (dx > 0) {\n                return GroupD8.NE;\n            }\n            else {\n                return GroupD8.NW;\n            }\n        }\n    },\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @param matrix {PIXI.Matrix} sprite world matrix\n     * @param rotation {number}\n     * @param tx {number|*} sprite anchoring\n     * @param ty {number|*} sprite anchoring\n     */\n    matrixAppendRotationInv: function (matrix, rotation, tx, ty) {\n        //Packer used \"rotation\", we use \"inv(rotation)\"\n        var mat = tempMatrices[GroupD8.inv(rotation)];\n        tx = tx || 0;\n        ty = ty || 0;\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    }\n};\n\nmodule.exports = GroupD8;\n\n},{\"./Matrix\":31}],31:[function(require,module,exports){\n// @todo - ignore the too many parameters warning for now\n// should either fix it or change the jshint config\n// jshint -W072\n\nvar Point = require('./Point');\n\n/**\n * The pixi Matrix class as an object, which makes it a lot faster,\n * here is a representation of it :\n * | a | b | tx|\n * | c | d | ty|\n * | 0 | 0 | 1 |\n *\n * @class\n * @memberof PIXI\n */\nfunction Matrix()\n{\n    /**\n     * @member {number}\n     * @default 1\n     */\n    this.a = 1;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.b = 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.c = 0;\n\n    /**\n     * @member {number}\n     * @default 1\n     */\n    this.d = 1;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.tx = 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.ty = 0;\n}\n\nMatrix.prototype.constructor = Matrix;\nmodule.exports = Matrix;\n\n/**\n * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n *\n * a = array[0]\n * b = array[1]\n * c = array[3]\n * d = array[4]\n * tx = array[2]\n * ty = array[5]\n *\n * @param array {number[]} The array that the matrix will be populated from.\n */\nMatrix.prototype.fromArray = function (array)\n{\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n};\n\n\n/**\n * sets the matrix properties\n *\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} d\n * @param {number} tx\n * @param {number} ty\n *\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.set = function (a, b, c, d, tx, ty)\n{\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n\n    return this;\n};\n\n\n/**\n * Creates an array from the current Matrix object.\n *\n * @param transpose {boolean} Whether we need to transpose the matrix or not\n * @param [out] {Array} If provided the array will be assigned to out\n * @return {number[]} the newly created array which contains the matrix\n */\nMatrix.prototype.toArray = function (transpose, out)\n{\n    if (!this.array)\n    {\n        this.array = new Float32Array(9);\n    }\n\n    var array = out || this.array;\n\n    if (transpose)\n    {\n        array[0] = this.a;\n        array[1] = this.b;\n        array[2] = 0;\n        array[3] = this.c;\n        array[4] = this.d;\n        array[5] = 0;\n        array[6] = this.tx;\n        array[7] = this.ty;\n        array[8] = 1;\n    }\n    else\n    {\n        array[0] = this.a;\n        array[1] = this.c;\n        array[2] = this.tx;\n        array[3] = this.b;\n        array[4] = this.d;\n        array[5] = this.ty;\n        array[6] = 0;\n        array[7] = 0;\n        array[8] = 1;\n    }\n\n    return array;\n};\n\n/**\n * Get a new position with the current transformation applied.\n * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n *\n * @param pos {PIXI.Point} The origin\n * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)\n * @return {PIXI.Point} The new point, transformed through this matrix\n */\nMatrix.prototype.apply = function (pos, newPos)\n{\n    newPos = newPos || new Point();\n\n    var x = pos.x;\n    var y = pos.y;\n\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n\n    return newPos;\n};\n\n/**\n * Get a new position with the inverse of the current transformation applied.\n * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n *\n * @param pos {PIXI.Point} The origin\n * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)\n * @return {PIXI.Point} The new point, inverse-transformed through this matrix\n */\nMatrix.prototype.applyInverse = function (pos, newPos)\n{\n    newPos = newPos || new Point();\n\n    var id = 1 / (this.a * this.d + this.c * -this.b);\n\n    var x = pos.x;\n    var y = pos.y;\n\n    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;\n    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;\n\n    return newPos;\n};\n\n/**\n * Translates the matrix on the x and y.\n *\n * @param {number} x\n * @param {number} y\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.translate = function (x, y)\n{\n    this.tx += x;\n    this.ty += y;\n\n    return this;\n};\n\n/**\n * Applies a scale transformation to the matrix.\n *\n * @param {number} x The amount to scale horizontally\n * @param {number} y The amount to scale vertically\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.scale = function (x, y)\n{\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n\n    return this;\n};\n\n\n/**\n * Applies a rotation transformation to the matrix.\n *\n * @param {number} angle - The angle in radians.\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.rotate = function (angle)\n{\n    var cos = Math.cos( angle );\n    var sin = Math.sin( angle );\n\n    var a1 = this.a;\n    var c1 = this.c;\n    var tx1 = this.tx;\n\n    this.a = a1 * cos-this.b * sin;\n    this.b = a1 * sin+this.b * cos;\n    this.c = c1 * cos-this.d * sin;\n    this.d = c1 * sin+this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n\n    return this;\n};\n\n/**\n * Appends the given Matrix to this Matrix.\n *\n * @param {PIXI.Matrix} matrix\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.append = function (matrix)\n{\n    var a1 = this.a;\n    var b1 = this.b;\n    var c1 = this.c;\n    var d1 = this.d;\n\n    this.a  = matrix.a * a1 + matrix.b * c1;\n    this.b  = matrix.a * b1 + matrix.b * d1;\n    this.c  = matrix.c * a1 + matrix.d * c1;\n    this.d  = matrix.c * b1 + matrix.d * d1;\n\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n\n    return this;\n};\n\n/**\n * Sets the matrix based on all the available properties\n *\n * @param {number} x\n * @param {number} y\n * @param {number} pivotX\n * @param {number} pivotY\n * @param {number} scaleX\n * @param {number} scaleY\n * @param {number} rotation\n * @param {number} skewX\n * @param {number} skewY\n *\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.setTransform = function (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY)\n{\n    var a, b, c, d, sr, cr, cy, sy, nsx, cx;\n\n    sr  = Math.sin(rotation);\n    cr  = Math.cos(rotation);\n    cy  = Math.cos(skewY);\n    sy  = Math.sin(skewY);\n    nsx = -Math.sin(skewX);\n    cx  =  Math.cos(skewX);\n\n    a  =  cr * scaleX;\n    b  =  sr * scaleX;\n    c  = -sr * scaleY;\n    d  =  cr * scaleY;\n\n    this.a  = cy * a + sy * c;\n    this.b  = cy * b + sy * d;\n    this.c  = nsx * a + cx * c;\n    this.d  = nsx * b + cx * d;\n\n    this.tx = x + ( pivotX * a + pivotY * c );\n    this.ty = y + ( pivotX * b + pivotY * d );\n\n    return this;\n};\n\n/**\n * Prepends the given Matrix to this Matrix.\n *\n * @param {PIXI.Matrix} matrix\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.prepend = function(matrix)\n{\n    var tx1 = this.tx;\n\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n    {\n        var a1 = this.a;\n        var c1 = this.c;\n        this.a  = a1*matrix.a+this.b*matrix.c;\n        this.b  = a1*matrix.b+this.b*matrix.d;\n        this.c  = c1*matrix.a+this.d*matrix.c;\n        this.d  = c1*matrix.b+this.d*matrix.d;\n    }\n\n    this.tx = tx1*matrix.a+this.ty*matrix.c+matrix.tx;\n    this.ty = tx1*matrix.b+this.ty*matrix.d+matrix.ty;\n\n    return this;\n};\n\n/**\n * Inverts this matrix\n *\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.invert = function()\n{\n    var a1 = this.a;\n    var b1 = this.b;\n    var c1 = this.c;\n    var d1 = this.d;\n    var tx1 = this.tx;\n    var n = a1*d1-b1*c1;\n\n    this.a = d1/n;\n    this.b = -b1/n;\n    this.c = -c1/n;\n    this.d = a1/n;\n    this.tx = (c1*this.ty-d1*tx1)/n;\n    this.ty = -(a1*this.ty-b1*tx1)/n;\n\n    return this;\n};\n\n\n/**\n * Resets this Matix to an identity (default) matrix.\n *\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\nMatrix.prototype.identity = function ()\n{\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n\n    return this;\n};\n\n/**\n * Creates a new Matrix object with the same values as this one.\n *\n * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.\n */\nMatrix.prototype.clone = function ()\n{\n    var matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n\n    return matrix;\n};\n\n/**\n * Changes the values of the given matrix to be the same as the ones in this matrix\n *\n * @return {PIXI.Matrix} The matrix given in parameter with its values updated.\n */\nMatrix.prototype.copy = function (matrix)\n{\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n\n    return matrix;\n};\n\n/**\n * A default (identity) matrix\n *\n * @static\n * @const\n */\nMatrix.IDENTITY = new Matrix();\n\n/**\n * A temp matrix\n *\n * @static\n * @const\n */\nMatrix.TEMP_MATRIX = new Matrix();\n\n},{\"./Point\":32}],32:[function(require,module,exports){\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where x represents\n * the horizontal axis and y represents the vertical axis.\n *\n * @class\n * @memberof PIXI\n * @param [x=0] {number} position of the point on the x axis\n * @param [y=0] {number} position of the point on the y axis\n */\nfunction Point(x, y)\n{\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.y = y || 0;\n}\n\nPoint.prototype.constructor = Point;\nmodule.exports = Point;\n\n/**\n * Creates a clone of this point\n *\n * @return {PIXI.Point} a copy of the point\n */\nPoint.prototype.clone = function ()\n{\n    return new Point(this.x, this.y);\n};\n\n/**\n * Copies x and y from the given point\n *\n * @param p {PIXI.Point}\n */\nPoint.prototype.copy = function (p) {\n    this.set(p.x, p.y);\n};\n\n/**\n * Returns true if the given point is equal to this point\n *\n * @param p {PIXI.Point}\n * @returns {boolean}\n */\nPoint.prototype.equals = function (p) {\n    return (p.x === this.x) && (p.y === this.y);\n};\n\n/**\n * Sets the point to a new x and y position.\n * If y is omitted, both x and y will be set to x.\n *\n * @param [x=0] {number} position of the point on the x axis\n * @param [y=0] {number} position of the point on the y axis\n */\nPoint.prototype.set = function (x, y)\n{\n    this.x = x || 0;\n    this.y = y || ( (y !== 0) ? this.x : 0 ) ;\n};\n\n},{}],33:[function(require,module,exports){\n/**\n * Math classes and utilities mixed into PIXI namespace.\n *\n * @lends PIXI\n */\nmodule.exports = {\n    // These will be mixed to be made publicly available,\n    // while this module is used internally in core\n    // to avoid circular dependencies and cut down on\n    // internal module requires.\n\n    Point:      require('./Point'),\n    Matrix:     require('./Matrix'),\n    GroupD8:    require('./GroupD8'),\n\n    Circle:     require('./shapes/Circle'),\n    Ellipse:    require('./shapes/Ellipse'),\n    Polygon:    require('./shapes/Polygon'),\n    Rectangle:  require('./shapes/Rectangle'),\n    RoundedRectangle: require('./shapes/RoundedRectangle')\n};\n\n},{\"./GroupD8\":30,\"./Matrix\":31,\"./Point\":32,\"./shapes/Circle\":34,\"./shapes/Ellipse\":35,\"./shapes/Polygon\":36,\"./shapes/Rectangle\":37,\"./shapes/RoundedRectangle\":38}],34:[function(require,module,exports){\nvar Rectangle = require('./Rectangle'),\n    CONST = require('../../const');\n\n/**\n * The Circle object can be used to specify a hit area for displayObjects\n *\n * @class\n * @memberof PIXI\n * @param x {number} The X coordinate of the center of this circle\n * @param y {number} The Y coordinate of the center of this circle\n * @param radius {number} The radius of the circle\n */\nfunction Circle(x, y, radius)\n{\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.radius = radius || 0;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     */\n    this.type = CONST.SHAPES.CIRC;\n}\n\nCircle.prototype.constructor = Circle;\nmodule.exports = Circle;\n\n/**\n * Creates a clone of this Circle instance\n *\n * @return {PIXI.Circle} a copy of the Circle\n */\nCircle.prototype.clone = function ()\n{\n    return new Circle(this.x, this.y, this.radius);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this circle\n *\n * @param x {number} The X coordinate of the point to test\n * @param y {number} The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this Circle\n */\nCircle.prototype.contains = function (x, y)\n{\n    if (this.radius <= 0)\n    {\n        return false;\n    }\n\n    var dx = (this.x - x),\n        dy = (this.y - y),\n        r2 = this.radius * this.radius;\n\n    dx *= dx;\n    dy *= dy;\n\n    return (dx + dy <= r2);\n};\n\n/**\n* Returns the framing rectangle of the circle as a Rectangle object\n*\n* @return {PIXI.Rectangle} the framing rectangle\n*/\nCircle.prototype.getBounds = function ()\n{\n    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n};\n\n},{\"../../const\":22,\"./Rectangle\":37}],35:[function(require,module,exports){\nvar Rectangle = require('./Rectangle'),\n    CONST = require('../../const');\n\n/**\n * The Ellipse object can be used to specify a hit area for displayObjects\n *\n * @class\n * @memberof PIXI\n * @param x {number} The X coordinate of the center of the ellipse\n * @param y {number} The Y coordinate of the center of the ellipse\n * @param width {number} The half width of this ellipse\n * @param height {number} The half height of this ellipse\n */\nfunction Ellipse(x, y, width, height)\n{\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.height = height || 0;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     */\n    this.type = CONST.SHAPES.ELIP;\n}\n\nEllipse.prototype.constructor = Ellipse;\nmodule.exports = Ellipse;\n\n/**\n * Creates a clone of this Ellipse instance\n *\n * @return {PIXI.Ellipse} a copy of the ellipse\n */\nEllipse.prototype.clone = function ()\n{\n    return new Ellipse(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this ellipse\n *\n * @param x {number} The X coordinate of the point to test\n * @param y {number} The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coords are within this ellipse\n */\nEllipse.prototype.contains = function (x, y)\n{\n    if (this.width <= 0 || this.height <= 0)\n    {\n        return false;\n    }\n\n    //normalize the coords to an ellipse with center 0,0\n    var normx = ((x - this.x) / this.width),\n        normy = ((y - this.y) / this.height);\n\n    normx *= normx;\n    normy *= normy;\n\n    return (normx + normy <= 1);\n};\n\n/**\n * Returns the framing rectangle of the ellipse as a Rectangle object\n *\n * @return {PIXI.Rectangle} the framing rectangle\n */\nEllipse.prototype.getBounds = function ()\n{\n    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n};\n\n},{\"../../const\":22,\"./Rectangle\":37}],36:[function(require,module,exports){\nvar Point = require('../Point'),\n    CONST = require('../../const');\n\n/**\n * @class\n * @memberof PIXI\n * @param points {PIXI.Point[]|number[]|...PIXI.Point|...number} This can be an array of Points that form the polygon,\n *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be\n *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the\n *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are\n *      Numbers.\n */\nfunction Polygon(points_)\n{\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = points_;\n\n    //if points isn't an array, use arguments as the array\n    if (!Array.isArray(points))\n    {\n        // prevents an argument leak deopt\n        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        points = new Array(arguments.length);\n\n        for (var a = 0; a < points.length; ++a) {\n            points[a] = arguments[a];\n        }\n    }\n\n    // if this is an array of points, convert it to a flat array of numbers\n    if (points[0] instanceof Point)\n    {\n        var p = [];\n        for (var i = 0, il = points.length; i < il; i++)\n        {\n            p.push(points[i].x, points[i].y);\n        }\n\n        points = p;\n    }\n\n    this.closed = true;\n\n    /**\n     * An array of the points of this polygon\n     *\n     * @member {number[]}\n     */\n    this.points = points;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     */\n    this.type = CONST.SHAPES.POLY;\n}\n\nPolygon.prototype.constructor = Polygon;\nmodule.exports = Polygon;\n\n/**\n * Creates a clone of this polygon\n *\n * @return {PIXI.Polygon} a copy of the polygon\n */\nPolygon.prototype.clone = function ()\n{\n    return new Polygon(this.points.slice());\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this polygon\n *\n * @param x {number} The X coordinate of the point to test\n * @param y {number} The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this polygon\n */\nPolygon.prototype.contains = function (x, y)\n{\n    var inside = false;\n\n    // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    var length = this.points.length / 2;\n\n    for (var i = 0, j = length - 1; i < length; j = i++)\n    {\n        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],\n            xj = this.points[j * 2], yj = this.points[j * 2 + 1],\n            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n        if (intersect)\n        {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n\n},{\"../../const\":22,\"../Point\":32}],37:[function(require,module,exports){\nvar CONST = require('../../const');\n\n/**\n * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.\n *\n * @class\n * @memberof PIXI\n * @param x {number} The X coordinate of the upper-left corner of the rectangle\n * @param y {number} The Y coordinate of the upper-left corner of the rectangle\n * @param width {number} The overall width of this rectangle\n * @param height {number} The overall height of this rectangle\n */\nfunction Rectangle(x, y, width, height)\n{\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.height = height || 0;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     */\n    this.type = CONST.SHAPES.RECT;\n}\n\nRectangle.prototype.constructor = Rectangle;\nmodule.exports = Rectangle;\n\n/**\n * A constant empty rectangle.\n *\n * @static\n * @constant\n */\nRectangle.EMPTY = new Rectangle(0, 0, 0, 0);\n\n\n/**\n * Creates a clone of this Rectangle\n *\n * @return {PIXI.Rectangle} a copy of the rectangle\n */\nRectangle.prototype.clone = function ()\n{\n    return new Rectangle(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this Rectangle\n *\n * @param x {number} The X coordinate of the point to test\n * @param y {number} The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this Rectangle\n */\nRectangle.prototype.contains = function (x, y)\n{\n    if (this.width <= 0 || this.height <= 0)\n    {\n        return false;\n    }\n\n    if (x >= this.x && x < this.x + this.width)\n    {\n        if (y >= this.y && y < this.y + this.height)\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n},{\"../../const\":22}],38:[function(require,module,exports){\nvar CONST = require('../../const');\n\n/**\n * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its top-left corner point (x, y) and by its width and its height and its radius.\n *\n * @class\n * @memberof PIXI\n * @param x {number} The X coordinate of the upper-left corner of the rounded rectangle\n * @param y {number} The Y coordinate of the upper-left corner of the rounded rectangle\n * @param width {number} The overall width of this rounded rectangle\n * @param height {number} The overall height of this rounded rectangle\n * @param radius {number} Controls the radius of the rounded corners\n */\nfunction RoundedRectangle(x, y, width, height, radius)\n{\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.height = height || 0;\n\n    /**\n     * @member {number}\n     * @default 20\n     */\n    this.radius = radius || 20;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     */\n    this.type = CONST.SHAPES.RREC;\n}\n\nRoundedRectangle.prototype.constructor = RoundedRectangle;\nmodule.exports = RoundedRectangle;\n\n/**\n * Creates a clone of this Rounded Rectangle\n *\n * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle\n */\nRoundedRectangle.prototype.clone = function ()\n{\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n};\n\n/**\n * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n *\n * @param x {number} The X coordinate of the point to test\n * @param y {number} The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle\n */\nRoundedRectangle.prototype.contains = function (x, y)\n{\n    if (this.width <= 0 || this.height <= 0)\n    {\n        return false;\n    }\n\n    if (x >= this.x && x <= this.x + this.width)\n    {\n        if (y >= this.y && y <= this.y + this.height)\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n},{\"../../const\":22}],39:[function(require,module,exports){\nvar Container = require('../display/Container'),\n    CONST = require('../const');\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced\n * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).\n * Any other functionality like tinting, masking, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * var container = new ParticleContainer();\n *\n * for (var i = 0; i < 100; ++i)\n * {\n *     var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be renderer at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n * @param [maxSize=15000] {number} The maximum number of particles that can be renderer by the container.\n * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.\n * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.\n * @param [properties.position=true] {boolean} When true, position be uploaded and applied.\n * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.\n * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.\n * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.\n * @param [batchSize=15000] {number} Number of particles per batch.\n */\nfunction ParticleContainer(maxSize, properties, batchSize)\n{\n    Container.call(this);\n\n    batchSize = batchSize || 15000; //CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n    maxSize = maxSize || 15000;\n\n    // Making sure the batch size is valid\n    // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n    // so max number of particles is 65536 / 4 = 16384\n    var maxBatchSize = 16384;\n    if (batchSize > maxBatchSize) {\n        batchSize = maxBatchSize;\n    }\n\n    if (batchSize > maxSize) {\n        batchSize = maxSize;\n    }\n\n    /**\n     * Set properties to be dynamic (true) / static (false)\n     *\n     * @member {boolean[]}\n     * @private\n     */\n    this._properties = [false, true, false, false, false];\n\n    /**\n     * @member {number}\n     * @private\n     */\n    this._maxSize = maxSize;\n\n    /**\n     * @member {number}\n     * @private\n     */\n    this._batchSize = batchSize;\n\n    /**\n     * @member {WebGLBuffer}\n     * @private\n     */\n    this._buffers = null;\n\n    /**\n     * @member {number}\n     * @private\n     */\n    this._bufferToUpdate = 0;\n\n    /**\n     * @member {boolean}\n     *\n     */\n    this.interactiveChildren = false;\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     * @see PIXI.BLEND_MODES\n     */\n    this.blendMode = CONST.BLEND_MODES.NORMAL;\n\n    /**\n     * Used for canvas renderering. If true then the elements will be positioned at the nearest pixel. This provides a nice speed boost.\n     *\n     * @member {boolean}\n     * @default true;\n     */\n    this.roundPixels = true;\n\n    this.setProperties(properties);\n}\n\nParticleContainer.prototype = Object.create(Container.prototype);\nParticleContainer.prototype.constructor = ParticleContainer;\nmodule.exports = ParticleContainer;\n\n/**\n * Sets the private properties array to dynamic / static based on the passed properties object\n *\n * @param properties {object} The properties to be uploaded\n */\nParticleContainer.prototype.setProperties = function(properties)\n{\n    if ( properties ) {\n        this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];\n        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];\n    }\n};\n\n/**\n * Updates the object transform for rendering\n *\n * @private\n */\nParticleContainer.prototype.updateTransform = function ()\n{\n\n    // TODO don't need to!\n    this.displayObjectUpdateTransform();\n    //  PIXI.Container.prototype.updateTransform.call( this );\n};\n\n/**\n * Renders the container using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer} The webgl renderer\n * @private\n */\nParticleContainer.prototype.renderWebGL = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n    {\n        return;\n    }\n\n    renderer.setObjectRenderer( renderer.plugins.particle );\n    renderer.plugins.particle.render( this );\n};\n\n/**\n * Set the flag that static data should be updated to true\n *\n * @private\n */\nParticleContainer.prototype.onChildrenChange = function (smallestChildIndex)\n{\n    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n    if (bufferIndex < this._bufferToUpdate) {\n        this._bufferToUpdate = bufferIndex;\n    }\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {PIXI.CanvasRenderer} The canvas renderer\n * @private\n */\nParticleContainer.prototype.renderCanvas = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n    {\n        return;\n    }\n\n    var context = renderer.context;\n    var transform = this.worldTransform;\n    var isRotated = true;\n\n    var positionX = 0;\n    var positionY = 0;\n\n    var finalWidth = 0;\n    var finalHeight = 0;\n\n    var compositeOperation = renderer.blendModes[this.blendMode];\n    if (compositeOperation !== context.globalCompositeOperation)\n    {\n        context.globalCompositeOperation = compositeOperation;\n    }\n\n    context.globalAlpha = this.worldAlpha;\n\n    this.displayObjectUpdateTransform();\n\n    for (var i = 0; i < this.children.length; ++i)\n    {\n        var child = this.children[i];\n\n        if (!child.visible)\n        {\n            continue;\n        }\n\n        var frame = child.texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if (child.rotation % (Math.PI * 2) === 0)\n        {\n            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            if (isRotated)\n            {\n                context.setTransform(\n                    transform.a,\n                    transform.b,\n                    transform.c,\n                    transform.d,\n                    transform.tx,\n                    transform.ty\n                );\n\n                isRotated = false;\n            }\n\n            positionX = ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5);\n            positionY = ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5);\n\n            finalWidth = frame.width * child.scale.x;\n            finalHeight = frame.height * child.scale.y;\n\n        }\n        else\n        {\n            if (!isRotated)\n            {\n                isRotated = true;\n            }\n\n            child.displayObjectUpdateTransform();\n\n            var childTransform = child.worldTransform;\n\n            if (renderer.roundPixels)\n            {\n                context.setTransform(\n                    childTransform.a,\n                    childTransform.b,\n                    childTransform.c,\n                    childTransform.d,\n                    childTransform.tx | 0,\n                    childTransform.ty | 0\n                );\n            }\n            else\n            {\n                context.setTransform(\n                    childTransform.a,\n                    childTransform.b,\n                    childTransform.c,\n                    childTransform.d,\n                    childTransform.tx,\n                    childTransform.ty\n                );\n            }\n\n            positionX = ((child.anchor.x) * (-frame.width) + 0.5);\n            positionY = ((child.anchor.y) * (-frame.height) + 0.5);\n\n            finalWidth = frame.width;\n            finalHeight = frame.height;\n        }\n\n        context.drawImage(\n            child.texture.baseTexture.source,\n            frame.x,\n            frame.y,\n            frame.width,\n            frame.height,\n            positionX,\n            positionY,\n            finalWidth,\n            finalHeight\n        );\n    }\n};\n\n/**\n * Destroys the container\n *\n * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well\n */\nParticleContainer.prototype.destroy = function () {\n    Container.prototype.destroy.apply(this, arguments);\n\n    if (this._buffers) {\n        for (var i = 0; i < this._buffers.length; ++i) {\n            this._buffers[i].destroy();\n        }\n    }\n\n    this._properties = null;\n    this._buffers = null;\n};\n\n},{\"../const\":22,\"../display/Container\":23}],40:[function(require,module,exports){\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleBuffer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java\n */\n\n/**\n * The particle buffer manages the static and dynamic buffers for a particle container.\n *\n * @class\n * @private\n * @memberof PIXI\n */\nfunction ParticleBuffer(gl, properties, dynamicPropertyFlags, size)\n{\n    /**\n     * The current WebGL drawing context.\n     *\n     * @member {WebGLRenderingContext}\n     */\n    this.gl = gl;\n\n    /**\n     * Size of a single vertex.\n     *\n     * @member {number}\n     */\n    this.vertSize = 2;\n\n    /**\n     * Size of a single vertex in bytes.\n     *\n     * @member {number}\n     */\n    this.vertByteSize = this.vertSize * 4;\n\n    /**\n     * The number of particles the buffer can hold\n     *\n     * @member {number}\n     */\n    this.size = size;\n\n    /**\n     * A list of the properties that are dynamic.\n     *\n     * @member {object[]}\n     */\n    this.dynamicProperties = [];\n\n    /**\n     * A list of the properties that are static.\n     *\n     * @member {object[]}\n     */\n    this.staticProperties = [];\n\n    for (var i = 0; i < properties.length; i++)\n    {\n        var property = properties[i];\n\n        if(dynamicPropertyFlags[i])\n        {\n            this.dynamicProperties.push(property);\n        }\n        else\n        {\n            this.staticProperties.push(property);\n        }\n    }\n\n    this.staticStride = 0;\n    this.staticBuffer = null;\n    this.staticData = null;\n\n    this.dynamicStride = 0;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n\n    this.initBuffers();\n\n}\n\nParticleBuffer.prototype.constructor = ParticleBuffer;\nmodule.exports = ParticleBuffer;\n\n/**\n * Sets up the renderer context and necessary buffers.\n *\n * @private\n */\nParticleBuffer.prototype.initBuffers = function ()\n{\n    var gl = this.gl;\n    var i;\n    var property;\n\n    var dynamicOffset = 0;\n    this.dynamicStride = 0;\n\n    for (i = 0; i < this.dynamicProperties.length; i++)\n    {\n        property = this.dynamicProperties[i];\n\n        property.offset = dynamicOffset;\n        dynamicOffset += property.size;\n        this.dynamicStride += property.size;\n    }\n\n    this.dynamicData = new Float32Array( this.size * this.dynamicStride * 4);\n    this.dynamicBuffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.dynamicData, gl.DYNAMIC_DRAW);\n\n\n    // static //\n    var staticOffset = 0;\n    this.staticStride = 0;\n\n    for (i = 0; i < this.staticProperties.length; i++)\n    {\n        property = this.staticProperties[i];\n\n        property.offset = staticOffset;\n        staticOffset += property.size;\n        this.staticStride += property.size;\n    }\n\n    this.staticData = new Float32Array( this.size * this.staticStride * 4);\n    this.staticBuffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.staticData, gl.DYNAMIC_DRAW);\n};\n\n/**\n * Uploads the dynamic properties.\n *\n */\nParticleBuffer.prototype.uploadDynamic = function(children, startIndex, amount)\n{\n    var gl = this.gl;\n\n    for (var i = 0; i < this.dynamicProperties.length; i++)\n    {\n        var property = this.dynamicProperties[i];\n        property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dynamicData);\n};\n\n/**\n * Uploads the static properties.\n *\n */\nParticleBuffer.prototype.uploadStatic = function(children, startIndex, amount)\n{\n    var gl = this.gl;\n\n    for (var i = 0; i < this.staticProperties.length; i++)\n    {\n        var property = this.staticProperties[i];\n        property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.staticData);\n};\n\n/**\n * Binds the buffers to the GPU\n *\n */\nParticleBuffer.prototype.bind = function ()\n{\n    var gl = this.gl;\n    var i, property;\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);\n\n    for (i = 0; i < this.dynamicProperties.length; i++)\n    {\n        property = this.dynamicProperties[i];\n        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.dynamicStride * 4, property.offset * 4);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);\n\n    for (i = 0; i < this.staticProperties.length; i++)\n    {\n        property = this.staticProperties[i];\n        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.staticStride * 4, property.offset * 4);\n    }\n};\n\n/**\n * Destroys the ParticleBuffer.\n *\n */\nParticleBuffer.prototype.destroy = function ()\n{\n    this.dynamicProperties = null;\n    this.dynamicData = null;\n    this.gl.deleteBuffer(this.dynamicBuffer);\n\n    this.staticProperties = null;\n    this.staticData = null;\n    this.gl.deleteBuffer(this.staticBuffer);\n};\n\n},{}],41:[function(require,module,exports){\nvar ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),\n    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),\n    ParticleShader = require('./ParticleShader'),\n    ParticleBuffer = require('./ParticleBuffer'),\n    math            = require('../../math');\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction ParticleRenderer(renderer)\n{\n    ObjectRenderer.call(this, renderer);\n\n    // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n    // so max number of particles is 65536 / 4 = 16384\n    // and max number of element in the index buffer is 16384 * 6 = 98304\n    // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n    var numIndices = 98304;\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * The default shader that is used if a sprite doesn't have a more specific one.\n     *\n     * @member {PIXI.Shader}\n     */\n    this.shader = null;\n\n    this.indexBuffer = null;\n\n    this.properties = null;\n\n    this.tempMatrix = new math.Matrix();\n}\n\nParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);\nParticleRenderer.prototype.constructor = ParticleRenderer;\nmodule.exports = ParticleRenderer;\n\nWebGLRenderer.registerPlugin('particle', ParticleRenderer);\n\n/**\n * When there is a WebGL context change\n *\n * @private\n */\nParticleRenderer.prototype.onContextChange = function ()\n{\n    var gl = this.renderer.gl;\n\n    // setup default shader\n    this.shader = new ParticleShader(this.renderer.shaderManager);\n\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    this.properties = [\n        // verticesData\n        {\n            attribute:this.shader.attributes.aVertexPosition,\n            size:2,\n            uploadFunction:this.uploadVertices,\n            offset:0\n        },\n        // positionData\n        {\n            attribute:this.shader.attributes.aPositionCoord,\n            size:2,\n            uploadFunction:this.uploadPosition,\n            offset:0\n        },\n        // rotationData\n        {\n            attribute:this.shader.attributes.aRotation,\n            size:1,\n            uploadFunction:this.uploadRotation,\n            offset:0\n        },\n        // uvsData\n        {\n            attribute:this.shader.attributes.aTextureCoord,\n            size:2,\n            uploadFunction:this.uploadUvs,\n            offset:0\n        },\n        // alphaData\n        {\n            attribute:this.shader.attributes.aColor,\n            size:1,\n            uploadFunction:this.uploadAlpha,\n            offset:0\n        }\n    ];\n};\n\n/**\n * Starts a new particle batch.\n *\n */\nParticleRenderer.prototype.start = function ()\n{\n    var gl = this.renderer.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    var shader = this.shader;\n\n    this.renderer.shaderManager.setShader(shader);\n};\n\n\n/**\n * Renders the particle container object.\n *\n * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer\n */\nParticleRenderer.prototype.render = function (container)\n{\n    var children = container.children,\n        totalChildren = children.length,\n        maxSize = container._maxSize,\n        batchSize = container._batchSize;\n\n    if(totalChildren === 0)\n    {\n        return;\n    }\n    else if(totalChildren > maxSize)\n    {\n        totalChildren = maxSize;\n    }\n\n    if(!container._buffers)\n    {\n        container._buffers = this.generateBuffers( container );\n    }\n\n    // if the uvs have not updated then no point rendering just yet!\n    this.renderer.blendModeManager.setBlendMode(container.blendMode);\n\n    var gl = this.renderer.gl;\n\n    var m =  container.worldTransform.copy( this.tempMatrix );\n    m.prepend( this.renderer.currentRenderTarget.projectionMatrix );\n    gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));\n    gl.uniform1f(this.shader.uniforms.uAlpha._location, container.worldAlpha);\n\n\n    // make sure the texture is bound..\n    var baseTexture = children[0]._texture.baseTexture;\n\n    if (!baseTexture._glTextures[gl.id])\n    {\n        // if the texture has not updated then lets not upload any static properties\n        if(!this.renderer.updateTexture(baseTexture))\n        {\n            return;\n        }\n\n        if(!container._properties[0] || !container._properties[3])\n        {\n            container._bufferToUpdate = 0;\n        }\n    }\n    else\n    {\n        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);\n    }\n\n    // now lets upload and render the buffers..\n    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n    {\n        var amount = ( totalChildren - i);\n        if(amount > batchSize)\n        {\n            amount = batchSize;\n        }\n\n        var buffer = container._buffers[j];\n\n        // we always upload the dynamic\n        buffer.uploadDynamic(children, i, amount);\n\n        // we only upload the static content when we have to!\n        if(container._bufferToUpdate === j)\n        {\n            buffer.uploadStatic(children, i, amount);\n            container._bufferToUpdate = j + 1;\n        }\n\n        // bind the buffer\n        buffer.bind( this.shader );\n\n         // now draw those suckas!\n        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n        this.renderer.drawCount++;\n    }\n};\n\n/**\n * Creates one particle buffer for each child in the container we want to render and updates internal properties\n *\n * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer\n */\nParticleRenderer.prototype.generateBuffers = function (container)\n{\n    var gl = this.renderer.gl,\n        buffers = [],\n        size = container._maxSize,\n        batchSize = container._batchSize,\n        dynamicPropertyFlags = container._properties,\n        i;\n\n    for (i = 0; i < size; i += batchSize)\n    {\n        buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));\n    }\n\n    return buffers;\n};\n\n/**\n * Uploads the verticies.\n *\n * @param children {PIXI.DisplayObject[]} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their vertices uploaded\n * @param array {number[]}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset)\n{\n    var sprite,\n        texture,\n        trim,\n        sx,\n        sy,\n        w0, w1, h0, h1;\n\n    for (var i = 0; i < amount; i++) {\n\n        sprite = children[startIndex + i];\n        texture = sprite._texture;\n        sx = sprite.scale.x;\n        sy = sprite.scale.y;\n\n        if (texture.trim)\n        {\n            // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n            trim = texture.trim;\n\n            w1 = trim.x - sprite.anchor.x * trim.width;\n            w0 = w1 + texture.crop.width;\n\n            h1 = trim.y - sprite.anchor.y * trim.height;\n            h0 = h1 + texture.crop.height;\n        }\n        else\n        {\n            w0 = (texture._frame.width ) * (1-sprite.anchor.x);\n            w1 = (texture._frame.width ) * -sprite.anchor.x;\n\n            h0 = texture._frame.height * (1-sprite.anchor.y);\n            h1 = texture._frame.height * -sprite.anchor.y;\n        }\n\n        array[offset] = w1 * sx;\n        array[offset + 1] = h1 * sy;\n\n        array[offset + stride] = w0 * sx;\n        array[offset + stride + 1] = h1 * sy;\n\n        array[offset + stride * 2] = w0 * sx;\n        array[offset + stride * 2 + 1] = h0 * sy;\n\n        array[offset + stride * 3] = w1 * sx;\n        array[offset + stride * 3 + 1] = h0 * sy;\n\n        offset += stride * 4;\n    }\n\n};\n\n/**\n *\n * @param children {PIXI.DisplayObject[]} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their positions uploaded\n * @param array {number[]}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadPosition = function (children,startIndex, amount, array, stride, offset)\n{\n    for (var i = 0; i < amount; i++)\n    {\n        var spritePosition = children[startIndex + i].position;\n\n        array[offset] = spritePosition.x;\n        array[offset + 1] = spritePosition.y;\n\n        array[offset + stride] = spritePosition.x;\n        array[offset + stride + 1] = spritePosition.y;\n\n        array[offset + stride * 2] = spritePosition.x;\n        array[offset + stride * 2 + 1] = spritePosition.y;\n\n        array[offset + stride * 3] = spritePosition.x;\n        array[offset + stride * 3 + 1] = spritePosition.y;\n\n        offset += stride * 4;\n    }\n\n};\n\n/**\n *\n * @param children {PIXI.DisplayObject[]} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their rotation uploaded\n * @param array {number[]}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadRotation = function (children,startIndex, amount, array, stride, offset)\n{\n    for (var i = 0; i < amount; i++)\n    {\n        var spriteRotation = children[startIndex + i].rotation;\n\n\n        array[offset] = spriteRotation;\n        array[offset + stride] = spriteRotation;\n        array[offset + stride * 2] = spriteRotation;\n        array[offset + stride * 3] = spriteRotation;\n\n        offset += stride * 4;\n    }\n};\n\n/**\n *\n * @param children {PIXI.DisplayObject[]} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their Uvs uploaded\n * @param array {number[]}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadUvs = function (children,startIndex, amount, array, stride, offset)\n{\n    for (var i = 0; i < amount; i++)\n    {\n        var textureUvs = children[startIndex + i]._texture._uvs;\n\n        if (textureUvs)\n        {\n            array[offset] = textureUvs.x0;\n            array[offset + 1] = textureUvs.y0;\n\n            array[offset + stride] = textureUvs.x1;\n            array[offset + stride + 1] = textureUvs.y1;\n\n            array[offset + stride * 2] = textureUvs.x2;\n            array[offset + stride * 2 + 1] = textureUvs.y2;\n\n            array[offset + stride * 3] = textureUvs.x3;\n            array[offset + stride * 3 + 1] = textureUvs.y3;\n\n            offset += stride * 4;\n        }\n        else\n        {\n            //TODO you know this can be easier!\n            array[offset] = 0;\n            array[offset + 1] = 0;\n\n            array[offset + stride] = 0;\n            array[offset + stride + 1] = 0;\n\n            array[offset + stride * 2] = 0;\n            array[offset + stride * 2 + 1] = 0;\n\n            array[offset + stride * 3] = 0;\n            array[offset + stride * 3 + 1] = 0;\n\n            offset += stride * 4;\n        }\n    }\n};\n\n/**\n *\n * @param children {PIXI.DisplayObject[]} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their alpha uploaded\n * @param array {number[]}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadAlpha = function (children,startIndex, amount, array, stride, offset)\n{\n     for (var i = 0; i < amount; i++)\n     {\n        var spriteAlpha = children[startIndex + i].alpha;\n\n        array[offset] = spriteAlpha;\n        array[offset + stride] = spriteAlpha;\n        array[offset + stride * 2] = spriteAlpha;\n        array[offset + stride * 3] = spriteAlpha;\n\n        offset += stride * 4;\n    }\n};\n\n\n/**\n * Destroys the ParticleRenderer.\n *\n */\nParticleRenderer.prototype.destroy = function ()\n{\n    if (this.renderer.gl) {\n        this.renderer.gl.deleteBuffer(this.indexBuffer);\n    }\n\n    ObjectRenderer.prototype.destroy.apply(this, arguments);\n\n    this.shader.destroy();\n\n    this.indices = null;\n    this.tempMatrix = null;\n};\n\n},{\"../../math\":33,\"../../renderers/webgl/WebGLRenderer\":49,\"../../renderers/webgl/utils/ObjectRenderer\":63,\"./ParticleBuffer\":40,\"./ParticleShader\":42}],42:[function(require,module,exports){\nvar TextureShader = require('../../renderers/webgl/shaders/TextureShader');\n\n/**\n * @class\n * @extends PIXI.TextureShader\n * @memberof PIXI\n * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.\n */\nfunction ParticleShader(shaderManager)\n{\n    TextureShader.call(this,\n        shaderManager,\n        // vertex shader\n        [\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n            'attribute float aColor;',\n\n            'attribute vec2 aPositionCoord;',\n            'attribute vec2 aScale;',\n            'attribute float aRotation;',\n\n            'uniform mat3 projectionMatrix;',\n\n            'varying vec2 vTextureCoord;',\n            'varying float vColor;',\n\n            'void main(void){',\n            '   vec2 v = aVertexPosition;',\n\n            '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);',\n            '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);',\n            '   v = v + aPositionCoord;',\n\n            '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);',\n\n            '   vTextureCoord = aTextureCoord;',\n            '   vColor = aColor;',\n            '}'\n        ].join('\\n'),\n        // hello\n         [\n            'precision lowp float;',\n\n            'varying vec2 vTextureCoord;',\n            'varying float vColor;',\n\n            'uniform sampler2D uSampler;',\n            'uniform float uAlpha;',\n\n            'void main(void){',\n            '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uAlpha;',\n            '  if (color.a == 0.0) discard;',\n            '  gl_FragColor = color;',\n            '}'\n        ].join('\\n'),\n        // custom uniforms\n        {\n            uAlpha:  { type: '1f', value: 1 }\n        },\n        // custom attributes\n        {\n            aPositionCoord: 0,\n           // aScale:         0,\n            aRotation:      0\n        }\n    );\n\n    // TEMP HACK\n\n}\n\nParticleShader.prototype = Object.create(TextureShader.prototype);\nParticleShader.prototype.constructor = ParticleShader;\n\nmodule.exports = ParticleShader;\n\n},{\"../../renderers/webgl/shaders/TextureShader\":62}],43:[function(require,module,exports){\nvar utils = require('../utils'),\n    math = require('../math'),\n    CONST = require('../const'),\n    EventEmitter = require('eventemitter3');\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @param system {string} The name of the system this renderer is for.\n * @param [width=800] {number} the width of the canvas view\n * @param [height=600] {number} the height of the canvas view\n * @param [options] {object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\n * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\n *      not before the new render pass.\n * @param [options.backgroundColor=0x000000] {number} The background color of the rendered area (shown if not transparent).\n * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n */\nfunction SystemRenderer(system, width, height, options)\n{\n    EventEmitter.call(this);\n\n    utils.sayHello(system);\n\n    // prepare options\n    if (options)\n    {\n        for (var i in CONST.DEFAULT_RENDER_OPTIONS)\n        {\n            if (typeof options[i] === 'undefined')\n            {\n                options[i] = CONST.DEFAULT_RENDER_OPTIONS[i];\n            }\n        }\n    }\n    else\n    {\n        options = CONST.DEFAULT_RENDER_OPTIONS;\n    }\n\n    /**\n     * The type of the renderer.\n     *\n     * @member {number}\n     * @default PIXI.RENDERER_TYPE.UNKNOWN\n     * @see PIXI.RENDERER_TYPE\n     */\n    this.type = CONST.RENDERER_TYPE.UNKNOWN;\n\n    /**\n     * The width of the canvas view\n     *\n     * @member {number}\n     * @default 800\n     */\n    this.width = width || 800;\n\n    /**\n     * The height of the canvas view\n     *\n     * @member {number}\n     * @default 600\n     */\n    this.height = height || 600;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @member {HTMLCanvasElement}\n     */\n    this.view = options.view || document.createElement('canvas');\n\n    /**\n     * The resolution of the renderer\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.resolution = options.resolution;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @member {boolean}\n     */\n    this.transparent = options.transparent;\n\n    /**\n     * Whether the render view should be resized automatically\n     *\n     * @member {boolean}\n     */\n    this.autoResize = options.autoResize || false;\n\n    /**\n     * Tracks the blend modes useful for this renderer.\n     *\n     * @member {object<string, mixed>}\n     */\n    this.blendModes = null;\n\n    /**\n     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.\n     *\n     * @member {boolean}\n     */\n    this.preserveDrawingBuffer = options.preserveDrawingBuffer;\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.\n     * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.\n     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.\n     *\n     * @member {boolean}\n     * @default\n     */\n    this.clearBeforeRender = options.clearBeforeRender;\n\n    /**\n     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Handy for crisp pixel art and speed on legacy devices.\n     *\n     * @member {boolean}\n     */\n    this.roundPixels = options.roundPixels;\n\n    /**\n     * The background color as a number.\n     *\n     * @member {number}\n     * @private\n     */\n    this._backgroundColor = 0x000000;\n\n    /**\n     * The background color as an [R, G, B] array.\n     *\n     * @member {number[]}\n     * @private\n     */\n    this._backgroundColorRgb = [0, 0, 0];\n\n    /**\n     * The background color as a string.\n     *\n     * @member {string}\n     * @private\n     */\n    this._backgroundColorString = '#000000';\n\n    this.backgroundColor = options.backgroundColor || this._backgroundColor; // run bg color setter\n\n    /**\n     * This temporary display object used as the parent of the currently being rendered item\n     *\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    this._tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};\n\n    /**\n     * The last root object that the renderer tried to render.\n     *\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    this._lastObjectRendered = this._tempDisplayObjectParent;\n}\n\n// constructor\nSystemRenderer.prototype = Object.create(EventEmitter.prototype);\nSystemRenderer.prototype.constructor = SystemRenderer;\nmodule.exports = SystemRenderer;\n\nObject.defineProperties(SystemRenderer.prototype, {\n    /**\n     * The background color to fill if not transparent\n     *\n     * @member {number}\n     * @memberof PIXI.SystemRenderer#\n     */\n    backgroundColor:\n    {\n        get: function ()\n        {\n            return this._backgroundColor;\n        },\n        set: function (val)\n        {\n            this._backgroundColor = val;\n            this._backgroundColorString = utils.hex2string(val);\n            utils.hex2rgb(val, this._backgroundColorRgb);\n        }\n    }\n});\n\n/**\n * Resizes the canvas view to the specified width and height\n *\n * @param width {number} the new width of the canvas view\n * @param height {number} the new height of the canvas view\n */\nSystemRenderer.prototype.resize = function (width, height) {\n    this.width = width * this.resolution;\n    this.height = height * this.resolution;\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    if (this.autoResize)\n    {\n        this.view.style.width = this.width / this.resolution + 'px';\n        this.view.style.height = this.height / this.resolution + 'px';\n    }\n};\n\n/**\n * Removes everything from the renderer and optionally removes the Canvas DOM element.\n *\n * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.\n */\nSystemRenderer.prototype.destroy = function (removeView) {\n    if (removeView && this.view.parentNode)\n    {\n        this.view.parentNode.removeChild(this.view);\n    }\n\n    this.type = CONST.RENDERER_TYPE.UNKNOWN;\n\n    this.width = 0;\n    this.height = 0;\n\n    this.view = null;\n\n    this.resolution = 0;\n\n    this.transparent = false;\n\n    this.autoResize = false;\n\n    this.blendModes = null;\n\n    this.preserveDrawingBuffer = false;\n    this.clearBeforeRender = false;\n\n    this.roundPixels = false;\n\n    this._backgroundColor = 0;\n    this._backgroundColorRgb = null;\n    this._backgroundColorString = null;\n};\n\n},{\"../const\":22,\"../math\":33,\"../utils\":77,\"eventemitter3\":10}],44:[function(require,module,exports){\nvar SystemRenderer = require('../SystemRenderer'),\n    CanvasMaskManager = require('./utils/CanvasMaskManager'),\n    utils = require('../../utils'),\n    math = require('../../math'),\n    CONST = require('../../const');\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n * @param [width=800] {number} the width of the canvas view\n * @param [height=600] {number} the height of the canvas view\n * @param [options] {object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\n * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\n *      not before the new render pass.\n * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n */\nfunction CanvasRenderer(width, height, options)\n{\n    options = options || {};\n\n    SystemRenderer.call(this, 'Canvas', width, height, options);\n\n    this.type = CONST.RENDERER_TYPE.CANVAS;\n\n    /**\n     * The canvas 2d context that everything is drawn with.\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n    this.context = this.view.getContext('2d', { alpha: this.transparent });\n\n    /**\n     * Boolean flag controlling canvas refresh.\n     *\n     * @member {boolean}\n     */\n    this.refresh = true;\n\n    /**\n     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n     *\n     * @member {PIXI.CanvasMaskManager}\n     */\n    this.maskManager = new CanvasMaskManager();\n\n    /**\n     * The canvas property used to set the canvas smoothing property.\n     *\n     * @member {string}\n     */\n    this.smoothProperty = 'imageSmoothingEnabled';\n\n    if (!this.context.imageSmoothingEnabled)\n    {\n        if (this.context.webkitImageSmoothingEnabled)\n        {\n            this.smoothProperty = 'webkitImageSmoothingEnabled';\n        }\n        else if (this.context.mozImageSmoothingEnabled)\n        {\n            this.smoothProperty = 'mozImageSmoothingEnabled';\n        }\n        else if (this.context.oImageSmoothingEnabled)\n        {\n            this.smoothProperty = 'oImageSmoothingEnabled';\n        }\n        else if (this.context.msImageSmoothingEnabled)\n        {\n            this.smoothProperty = 'msImageSmoothingEnabled';\n        }\n    }\n\n    this.initPlugins();\n\n    this._mapBlendModes();\n\n    /**\n     * This temporary display object used as the parent of the currently being rendered item\n     *\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    this._tempDisplayObjectParent = {\n        worldTransform: new math.Matrix(),\n        worldAlpha: 1\n    };\n\n\n    this.resize(width, height);\n}\n\n// constructor\nCanvasRenderer.prototype = Object.create(SystemRenderer.prototype);\nCanvasRenderer.prototype.constructor = CanvasRenderer;\nmodule.exports = CanvasRenderer;\nutils.pluginTarget.mixin(CanvasRenderer);\n\n/**\n * Renders the object to this canvas view\n *\n * @param object {PIXI.DisplayObject} the object to be rendered\n */\nCanvasRenderer.prototype.render = function (object)\n{\n    this.emit('prerender');\n\n    var cacheParent = object.parent;\n\n    this._lastObjectRendered = object;\n\n    object.parent = this._tempDisplayObjectParent;\n\n    // update the scene graph\n    object.updateTransform();\n\n    object.parent = cacheParent;\n\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n\n    this.context.globalAlpha = 1;\n\n    this.context.globalCompositeOperation = this.blendModes[CONST.BLEND_MODES.NORMAL];\n\n    if (navigator.isCocoonJS && this.view.screencanvas)\n    {\n        this.context.fillStyle = 'black';\n        this.context.clear();\n    }\n\n    if (this.clearBeforeRender)\n    {\n        if (this.transparent)\n        {\n            this.context.clearRect(0, 0, this.width, this.height);\n        }\n        else\n        {\n            this.context.fillStyle = this._backgroundColorString;\n            this.context.fillRect(0, 0, this.width , this.height);\n        }\n    }\n\n    this.renderDisplayObject(object, this.context);\n\n    this.emit('postrender');\n};\n\n/**\n * Removes everything from the renderer and optionally removes the Canvas DOM element.\n *\n * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.\n */\nCanvasRenderer.prototype.destroy = function (removeView)\n{\n    this.destroyPlugins();\n\n    // call the base destroy\n    SystemRenderer.prototype.destroy.call(this, removeView);\n\n    this.context = null;\n\n    this.refresh = true;\n\n    this.maskManager.destroy();\n    this.maskManager = null;\n\n    this.smoothProperty = null;\n};\n\n/**\n * Renders a display object\n *\n * @param displayObject {PIXI.DisplayObject} The displayObject to render\n * @private\n */\nCanvasRenderer.prototype.renderDisplayObject = function (displayObject, context)\n{\n    var tempContext = this.context;\n\n    this.context = context;\n    displayObject.renderCanvas(this);\n    this.context = tempContext;\n};\n\n/**\n * @extends PIXI.SystemRenderer#resize\n *\n * @param {number} w\n * @param {number} h\n */\nCanvasRenderer.prototype.resize = function (w, h)\n{\n    SystemRenderer.prototype.resize.call(this, w, h);\n\n    //reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n    //surely a browser bug?? Let pixi fix that for you..\n    if(this.smoothProperty)\n    {\n        this.context[this.smoothProperty] = (CONST.SCALE_MODES.DEFAULT === CONST.SCALE_MODES.LINEAR);\n    }\n\n};\n\n/**\n * Maps Pixi blend modes to canvas blend modes.\n *\n * @private\n */\nCanvasRenderer.prototype._mapBlendModes = function ()\n{\n    if (!this.blendModes)\n    {\n        this.blendModes = {};\n\n        if (utils.canUseNewCanvasBlendModes())\n        {\n            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???\n            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'multiply';\n            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'screen';\n            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'overlay';\n            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'darken';\n            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'lighten';\n            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'color-dodge';\n            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'color-burn';\n            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'hard-light';\n            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'soft-light';\n            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'difference';\n            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'exclusion';\n            this.blendModes[CONST.BLEND_MODES.HUE]           = 'hue';\n            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'saturate';\n            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'color';\n            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'luminosity';\n        }\n        else\n        {\n            // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'\n            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???\n            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.HUE]           = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'source-over';\n            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'source-over';\n        }\n    }\n};\n\n},{\"../../const\":22,\"../../math\":33,\"../../utils\":77,\"../SystemRenderer\":43,\"./utils/CanvasMaskManager\":47}],45:[function(require,module,exports){\n/**\n * Creates a Canvas element of the given size.\n *\n * @class\n * @memberof PIXI\n * @param width {number} the width for the newly created canvas\n * @param height {number} the height for the newly created canvas\n */\nfunction CanvasBuffer(width, height)\n{\n    /**\n     * The Canvas object that belongs to this CanvasBuffer.\n     *\n     * @member {HTMLCanvasElement}\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n    this.context = this.canvas.getContext('2d');\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n}\n\nCanvasBuffer.prototype.constructor = CanvasBuffer;\nmodule.exports = CanvasBuffer;\n\nObject.defineProperties(CanvasBuffer.prototype, {\n    /**\n     * The width of the canvas buffer in pixels.\n     *\n     * @member {number}\n     * @memberof PIXI.CanvasBuffer#\n     */\n    width: {\n        get: function ()\n        {\n            return this.canvas.width;\n        },\n        set: function (val)\n        {\n            this.canvas.width = val;\n        }\n    },\n    /**\n     * The height of the canvas buffer in pixels.\n     *\n     * @member {number}\n     * @memberof PIXI.CanvasBuffer#\n     */\n    height: {\n        get: function ()\n        {\n            return this.canvas.height;\n        },\n        set: function (val)\n        {\n            this.canvas.height = val;\n        }\n    }\n});\n\n/**\n * Clears the canvas that was created by the CanvasBuffer class.\n *\n * @private\n */\nCanvasBuffer.prototype.clear = function ()\n{\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n    this.context.clearRect(0,0, this.canvas.width, this.canvas.height);\n};\n\n/**\n * Resizes the canvas to the specified width and height.\n *\n * @param width {number} the new width of the canvas\n * @param height {number} the new height of the canvas\n */\nCanvasBuffer.prototype.resize = function (width, height)\n{\n    this.canvas.width = width;\n    this.canvas.height = height;\n};\n\n/**\n * Destroys this canvas.\n *\n */\nCanvasBuffer.prototype.destroy = function ()\n{\n    this.context = null;\n    this.canvas = null;\n};\n\n},{}],46:[function(require,module,exports){\nvar CONST = require('../../../const');\n\n/**\n * A set of functions used by the canvas renderer to draw the primitive graphics data.\n * @static\n * @class\n * @memberof PIXI\n */\nvar CanvasGraphics = {};\nmodule.exports = CanvasGraphics;\n\n/*\n * Renders a Graphics object to a canvas.\n *\n * @param graphics {PIXI.Graphics} the actual graphics object to render\n * @param context {CanvasRenderingContext2D} the 2d drawing method of the canvas\n */\nCanvasGraphics.renderGraphics = function (graphics, context)\n{\n    var worldAlpha = graphics.worldAlpha;\n\n    if (graphics.dirty)\n    {\n        this.updateGraphicsTint(graphics);\n        graphics.dirty = false;\n    }\n\n    for (var i = 0; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var shape = data.shape;\n\n        var fillColor = data._fillTint;\n        var lineColor = data._lineTint;\n\n        context.lineWidth = data.lineWidth;\n\n        if (data.type === CONST.SHAPES.POLY)\n        {\n            context.beginPath();\n\n            var points = shape.points;\n\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            if (shape.closed)\n            {\n                context.lineTo(points[0], points[1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n            if (data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n        else if (data.type === CONST.SHAPES.RECT)\n        {\n\n            if (data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fillRect(shape.x, shape.y, shape.width, shape.height);\n\n            }\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n            }\n        }\n        else if (data.type === CONST.SHAPES.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);\n            context.closePath();\n\n            if (data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n        else if (data.type === CONST.SHAPES.ELIP)\n        {\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var w = shape.width * 2;\n            var h = shape.height * 2;\n\n            var x = shape.x - w/2;\n            var y = shape.y - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n            context.closePath();\n\n            if (data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n        else if (data.type === CONST.SHAPES.RREC)\n        {\n            var rx = shape.x;\n            var ry = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var radius = shape.radius;\n\n            var maxRadius = Math.min(width, height) / 2 | 0;\n            radius = radius > maxRadius ? maxRadius : radius;\n\n            context.beginPath();\n            context.moveTo(rx, ry + radius);\n            context.lineTo(rx, ry + height - radius);\n            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n            context.lineTo(rx + width - radius, ry + height);\n            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n            context.lineTo(rx + width, ry + radius);\n            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n            context.lineTo(rx + radius, ry);\n            context.quadraticCurveTo(rx, ry, rx, ry + radius);\n            context.closePath();\n\n            if (data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n\n            }\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n    }\n};\n\n/*\n * Renders a graphics mask\n *\n * @private\n * @param graphics {PIXI.Graphics} the graphics which will be used as a mask\n * @param context {CanvasRenderingContext2D} the context 2d method of the canvas\n */\nCanvasGraphics.renderGraphicsMask = function (graphics, context)\n{\n    var len = graphics.graphicsData.length;\n\n    if (len === 0)\n    {\n        return;\n    }\n\n    context.beginPath();\n\n    for (var i = 0; i < len; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var shape = data.shape;\n\n        if (data.type === CONST.SHAPES.POLY)\n        {\n\n            var points = shape.points;\n\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n        }\n        else if (data.type === CONST.SHAPES.RECT)\n        {\n            context.rect(shape.x, shape.y, shape.width, shape.height);\n            context.closePath();\n        }\n        else if (data.type === CONST.SHAPES.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n            context.closePath();\n        }\n        else if (data.type === CONST.SHAPES.ELIP)\n        {\n\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var w = shape.width * 2;\n            var h = shape.height * 2;\n\n            var x = shape.x - w/2;\n            var y = shape.y - h/2;\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n            context.closePath();\n        }\n        else if (data.type === CONST.SHAPES.RREC)\n        {\n\n            var rx = shape.x;\n            var ry = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var radius = shape.radius;\n\n            var maxRadius = Math.min(width, height) / 2 | 0;\n            radius = radius > maxRadius ? maxRadius : radius;\n\n            context.moveTo(rx, ry + radius);\n            context.lineTo(rx, ry + height - radius);\n            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n            context.lineTo(rx + width - radius, ry + height);\n            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n            context.lineTo(rx + width, ry + radius);\n            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n            context.lineTo(rx + radius, ry);\n            context.quadraticCurveTo(rx, ry, rx, ry + radius);\n            context.closePath();\n        }\n    }\n};\n\n/*\n * Updates the tint of a graphics object\n *\n * @private\n * @param graphics {PIXI.Graphics} the graphics that will have its tint updated\n *\n */\nCanvasGraphics.updateGraphicsTint = function (graphics)\n{\n    if (graphics.tint === 0xFFFFFF && graphics._prevTint === graphics.tint)\n    {\n        return;\n    }\n    graphics._prevTint = graphics.tint;\n\n    var tintR = (graphics.tint >> 16 & 0xFF) / 255;\n    var tintG = (graphics.tint >> 8 & 0xFF) / 255;\n    var tintB = (graphics.tint & 0xFF)/ 255;\n\n    for (var i = 0; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n\n        var fillColor = data.fillColor | 0;\n        var lineColor = data.lineColor | 0;\n\n        /*\n        var colorR = (fillColor >> 16 & 0xFF) / 255;\n        var colorG = (fillColor >> 8 & 0xFF) / 255;\n        var colorB = (fillColor & 0xFF) / 255;\n\n        colorR *= tintR;\n        colorG *= tintG;\n        colorB *= tintB;\n\n        fillColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);\n\n        colorR = (lineColor >> 16 & 0xFF) / 255;\n        colorG = (lineColor >> 8 & 0xFF) / 255;\n        colorB = (lineColor & 0xFF) / 255;\n\n        colorR *= tintR;\n        colorG *= tintG;\n        colorB *= tintB;\n\n        lineColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);\n        */\n\n        // super inline cos im an optimization NAZI :)\n        data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (fillColor & 0xFF) / 255 * tintB*255);\n        data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (lineColor & 0xFF) / 255 * tintB*255);\n\n    }\n};\n\n\n},{\"../../../const\":22}],47:[function(require,module,exports){\nvar CanvasGraphics = require('./CanvasGraphics');\n\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\nfunction CanvasMaskManager()\n{}\n\nCanvasMaskManager.prototype.constructor = CanvasMaskManager;\nmodule.exports = CanvasMaskManager;\n\n/**\n * This method adds it to the current stack of masks.\n *\n * @param maskData {object} the maskData that will be pushed\n * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.\n */\nCanvasMaskManager.prototype.pushMask = function (maskData, renderer)\n{\n\n    renderer.context.save();\n\n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.worldTransform;\n    var resolution = renderer.resolution;\n\n    renderer.context.setTransform(\n        transform.a * resolution,\n        transform.b * resolution,\n        transform.c * resolution,\n        transform.d * resolution,\n        transform.tx * resolution,\n        transform.ty * resolution\n    );\n\n    //TODO suport sprite alpha masks??\n    //lots of effort required. If demand is great enough..\n    if(!maskData.texture)\n    {\n        CanvasGraphics.renderGraphicsMask(maskData, renderer.context);\n        renderer.context.clip();\n    }\n\n    maskData.worldAlpha = cacheAlpha;\n};\n\n/**\n * Restores the current drawing context to the state it was before the mask was applied.\n *\n * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.\n */\nCanvasMaskManager.prototype.popMask = function (renderer)\n{\n    renderer.context.restore();\n};\n\nCanvasMaskManager.prototype.destroy = function () {};\n\n},{\"./CanvasGraphics\":46}],48:[function(require,module,exports){\nvar utils = require('../../../utils');\n\n/**\n * Utility methods for Sprite/Texture tinting.\n * @static\n * @class\n * @memberof PIXI\n */\nvar CanvasTinter = {};\nmodule.exports = CanvasTinter;\n\n/**\n * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n *\n * @param sprite {PIXI.Sprite} the sprite to tint\n * @param color {number} the color to use to tint the sprite with\n * @return {HTMLCanvasElement} The tinted canvas\n */\nCanvasTinter.getTintedTexture = function (sprite, color)\n{\n    var texture = sprite.texture;\n\n    color = CanvasTinter.roundColor(color);\n\n    var stringColor = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);\n\n    texture.tintCache = texture.tintCache || {};\n\n    if (texture.tintCache[stringColor])\n    {\n        return texture.tintCache[stringColor];\n    }\n\n     // clone texture..\n    var canvas = CanvasTinter.canvas || document.createElement('canvas');\n\n    //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n    CanvasTinter.tintMethod(texture, color, canvas);\n\n    if (CanvasTinter.convertTintToImage)\n    {\n        // is this better?\n        var tintImage = new Image();\n        tintImage.src = canvas.toDataURL();\n\n        texture.tintCache[stringColor] = tintImage;\n    }\n    else\n    {\n        texture.tintCache[stringColor] = canvas;\n        // if we are not converting the texture to an image then we need to lose the reference to the canvas\n        CanvasTinter.canvas = null;\n    }\n\n    return canvas;\n};\n\n/**\n * Tint a texture using the 'multiply' operation.\n *\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nCanvasTinter.tintWithMultiply = function (texture, color, canvas)\n{\n    var context = canvas.getContext( '2d' );\n\n    var resolution = texture.baseTexture.resolution;\n\n    var crop = texture.crop.clone();\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n\n    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);\n\n    context.fillRect(0, 0, crop.width, crop.height);\n\n    context.globalCompositeOperation = 'multiply';\n\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n\n    context.globalCompositeOperation = 'destination-atop';\n\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n};\n\n/**\n * Tint a texture using the 'overlay' operation.\n *\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nCanvasTinter.tintWithOverlay = function (texture, color, canvas)\n{\n    var context = canvas.getContext( '2d' );\n\n    var resolution = texture.baseTexture.resolution;\n\n    var crop = texture.crop.clone();\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n\n    context.globalCompositeOperation = 'copy';\n    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n\n    // context.globalCompositeOperation = 'copy';\n};\n\n/**\n * Tint a texture pixel per pixel.\n *\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nCanvasTinter.tintWithPerPixel = function (texture, color, canvas)\n{\n    var context = canvas.getContext( '2d' );\n\n    var resolution = texture.baseTexture.resolution;\n\n    var crop = texture.crop.clone();\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n\n    context.globalCompositeOperation = 'copy';\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n\n    var rgbValues = utils.hex2rgb(color);\n    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];\n\n    var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4)\n    {\n        pixels[i+0] *= r;\n        pixels[i+1] *= g;\n        pixels[i+2] *= b;\n    }\n\n    context.putImageData(pixelData, 0, 0);\n};\n\n/**\n * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n *\n * @param color {number} the color to round, should be a hex color\n */\nCanvasTinter.roundColor = function (color)\n{\n    var step = CanvasTinter.cacheStepsPerColorChannel;\n\n    var rgbValues = utils.hex2rgb(color);\n\n    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n    return utils.rgb2hex(rgbValues);\n};\n\n/**\n * Number of steps which will be used as a cap when rounding colors.\n *\n * @member\n */\nCanvasTinter.cacheStepsPerColorChannel = 8;\n\n/**\n * Tint cache boolean flag.\n *\n * @member\n */\nCanvasTinter.convertTintToImage = false;\n\n/**\n * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n *\n * @member\n */\nCanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();\n\n/**\n * The tinting method that will be used.\n *\n */\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply :  CanvasTinter.tintWithPerPixel;\n\n},{\"../../../utils\":77}],49:[function(require,module,exports){\nvar SystemRenderer = require('../SystemRenderer'),\n    ShaderManager = require('./managers/ShaderManager'),\n    MaskManager = require('./managers/MaskManager'),\n    StencilManager = require('./managers/StencilManager'),\n    FilterManager = require('./managers/FilterManager'),\n    BlendModeManager = require('./managers/BlendModeManager'),\n    RenderTarget = require('./utils/RenderTarget'),\n    ObjectRenderer = require('./utils/ObjectRenderer'),\n    FXAAFilter = require('./filters/FXAAFilter'),\n    utils = require('../../utils'),\n    CONST = require('../../const');\n\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n * @param [width=0] {number} the width of the canvas view\n * @param [height=0] {number} the height of the canvas view\n * @param [options] {object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always look as great\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\n *      not before the new render pass. If you wish to set this to false, you *must* set preserveDrawingBuffer to `true`.\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\n *      you need to call toDataUrl on the webgl context.\n * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n */\nfunction WebGLRenderer(width, height, options)\n{\n    options = options || {};\n\n    SystemRenderer.call(this, 'WebGL', width, height, options);\n\n    /**\n     * The type of this renderer as a standardised const\n     *\n     * @member {number}\n     *\n     */\n    this.type = CONST.RENDERER_TYPE.WEBGL;\n\n    this.handleContextLost = this.handleContextLost.bind(this);\n    this.handleContextRestored = this.handleContextRestored.bind(this);\n\n    this.view.addEventListener('webglcontextlost', this.handleContextLost, false);\n    this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n\n    //TODO possibility to force FXAA as it may offer better performance?\n    /**\n     * Does it use FXAA ?\n     *\n     * @member {boolean}\n     * @private\n     */\n    this._useFXAA = !!options.forceFXAA && options.antialias;\n\n    /**\n     * The fxaa filter\n     *\n     * @member {PIXI.FXAAFilter}\n     * @private\n     */\n    this._FXAAFilter = null;\n\n    /**\n     * The options passed in to create a new webgl context.\n     *\n     * @member {object}\n     * @private\n     */\n    this._contextOptions = {\n        alpha: this.transparent,\n        antialias: options.antialias,\n        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',\n        stencil: true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer\n    };\n\n    /**\n     * Counter for the number of draws made each frame\n     *\n     * @member {number}\n     */\n    this.drawCount = 0;\n\n    /**\n     * Deals with managing the shader programs and their attribs.\n     *\n     * @member {PIXI.ShaderManager}\n     */\n    this.shaderManager = new ShaderManager(this);\n\n    /**\n     * Manages the masks using the stencil buffer.\n     *\n     * @member {PIXI.MaskManager}\n     */\n    this.maskManager = new MaskManager(this);\n\n    /**\n     * Manages the stencil buffer.\n     *\n     * @member {PIXI.StencilManager}\n     */\n    this.stencilManager = new StencilManager(this);\n\n    /**\n     * Manages the filters.\n     *\n     * @member {PIXI.FilterManager}\n     */\n    this.filterManager = new FilterManager(this);\n\n\n    /**\n     * Manages the blendModes\n     *\n     * @member {PIXI.BlendModeManager}\n     */\n    this.blendModeManager = new BlendModeManager(this);\n\n    /**\n     * Holds the current render target\n     *\n     * @member {PIXI.RenderTarget}\n     */\n    this.currentRenderTarget = null;\n\n    /**\n     * The currently active ObjectRenderer.\n     *\n     * @member {PIXI.ObjectRenderer}\n     */\n    this.currentRenderer = new ObjectRenderer(this);\n\n    this.initPlugins();\n\n    // initialize the context so it is ready for the managers.\n    this._createContext();\n    this._initContext();\n\n    // map some webGL blend modes..\n    this._mapGlModes();\n\n    // track textures in the renderer so we can no longer listen to them on destruction.\n    this._managedTextures = [];\n\n    /**\n     * An array of render targets\n     * @member {PIXI.RenderTarget[]}\n     * @private\n     */\n    this._renderTargetStack = [];\n}\n\n// constructor\nWebGLRenderer.prototype = Object.create(SystemRenderer.prototype);\nWebGLRenderer.prototype.constructor = WebGLRenderer;\nmodule.exports = WebGLRenderer;\nutils.pluginTarget.mixin(WebGLRenderer);\n\nWebGLRenderer.glContextId = 0;\n\n/**\n * Creates the gl context.\n *\n * @private\n */\nWebGLRenderer.prototype._createContext = function () {\n    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);\n    this.gl = gl;\n\n    if (!gl)\n    {\n        // fail, not able to get a context\n        throw new Error('This browser does not support webGL. Try using the canvas renderer');\n    }\n\n    this.glContextId = WebGLRenderer.glContextId++;\n    gl.id = this.glContextId;\n    gl.renderer = this;\n};\n\n/**\n * Creates the WebGL context\n *\n * @private\n */\nWebGLRenderer.prototype._initContext = function ()\n{\n    var gl = this.gl;\n\n    // set up the default pixi settings..\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.enable(gl.BLEND);\n\n    this.renderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);\n\n    this.setRenderTarget(this.renderTarget);\n\n    this.emit('context', gl);\n\n    // setup the width/height properties and gl viewport\n    this.resize(this.width, this.height);\n\n    if(!this._useFXAA)\n    {\n        this._useFXAA = (this._contextOptions.antialias && ! gl.getContextAttributes().antialias);\n    }\n\n\n    if(this._useFXAA)\n    {\n        window.console.warn('FXAA antialiasing being used instead of native antialiasing');\n        this._FXAAFilter = [new FXAAFilter()];\n    }\n};\n\n/**\n * Renders the object to its webGL view\n *\n * @param object {PIXI.DisplayObject} the object to be rendered\n */\nWebGLRenderer.prototype.render = function (object)\n{\n\n    this.emit('prerender');\n\n    // no point rendering if our context has been blown up!\n    if (this.gl.isContextLost())\n    {\n        return;\n    }\n\n    this.drawCount = 0;\n\n    this._lastObjectRendered = object;\n\n    if(this._useFXAA)\n    {\n        this._FXAAFilter[0].uniforms.resolution.value.x = this.width;\n        this._FXAAFilter[0].uniforms.resolution.value.y = this.height;\n        object.filterArea = this.renderTarget.size;\n        object.filters = this._FXAAFilter;\n    }\n\n    var cacheParent = object.parent;\n    object.parent = this._tempDisplayObjectParent;\n\n    // update the scene graph\n    object.updateTransform();\n\n    object.parent = cacheParent;\n\n    var gl = this.gl;\n\n    // make sure we are bound to the main frame buffer\n    this.setRenderTarget(this.renderTarget);\n\n    if (this.clearBeforeRender)\n    {\n        if (this.transparent)\n        {\n            gl.clearColor(0, 0, 0, 0);\n        }\n        else\n        {\n            gl.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1);\n        }\n\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    this.renderDisplayObject(object, this.renderTarget);//this.projection);\n\n    this.emit('postrender');\n};\n\n/**\n * Renders a Display Object.\n *\n * @param displayObject {PIXI.DisplayObject} The DisplayObject to render\n * @param renderTarget {PIXI.RenderTarget} The render target to use to render this display object\n *\n */\nWebGLRenderer.prototype.renderDisplayObject = function (displayObject, renderTarget, clear)//projection, buffer)\n{\n    // TODO is this needed...\n    //this.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);\n    this.setRenderTarget(renderTarget);\n\n    if(clear)\n    {\n        renderTarget.clear();\n    }\n\n    // start the filter manager\n    this.filterManager.setFilterStack( renderTarget.filterStack );\n\n    // render the scene!\n    displayObject.renderWebGL(this);\n\n    // finish the current renderer..\n    this.currentRenderer.flush();\n};\n\n/**\n * Changes the current renderer to the one given in parameter\n *\n * @param objectRenderer {PIXI.ObjectRenderer} The object renderer to use.\n */\nWebGLRenderer.prototype.setObjectRenderer = function (objectRenderer)\n{\n    if (this.currentRenderer === objectRenderer)\n    {\n        return;\n    }\n\n    this.currentRenderer.stop();\n    this.currentRenderer = objectRenderer;\n    this.currentRenderer.start();\n};\n\n/**\n * Changes the current render target to the one given in parameter\n *\n * @param renderTarget {PIXI.RenderTarget} the new render target\n */\nWebGLRenderer.prototype.setRenderTarget = function (renderTarget)\n{\n    if( this.currentRenderTarget === renderTarget)\n    {\n        return;\n    }\n    // TODO - maybe down the line this should be a push pos thing? Leaving for now though.\n    this.currentRenderTarget = renderTarget;\n    this.currentRenderTarget.activate();\n    this.stencilManager.setMaskStack( renderTarget.stencilMaskStack );\n};\n\n\n/**\n * Resizes the webGL view to the specified width and height.\n *\n * @param width {number} the new width of the webGL view\n * @param height {number} the new height of the webGL view\n */\nWebGLRenderer.prototype.resize = function (width, height)\n{\n    SystemRenderer.prototype.resize.call(this, width, height);\n\n    this.filterManager.resize(width, height);\n    this.renderTarget.resize(width, height);\n\n    if(this.currentRenderTarget === this.renderTarget)\n    {\n        this.renderTarget.activate();\n        this.gl.viewport(0, 0, this.width, this.height);\n    }\n};\n\n/**\n * Updates and/or Creates a WebGL texture for the renderer's context.\n *\n * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to update\n */\nWebGLRenderer.prototype.updateTexture = function (texture)\n{\n    texture = texture.baseTexture || texture;\n\n    if (!texture.hasLoaded)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    if (!texture._glTextures[gl.id])\n    {\n        texture._glTextures[gl.id] = gl.createTexture();\n        texture.on('update', this.updateTexture, this);\n        texture.on('dispose', this.destroyTexture, this);\n        this._managedTextures.push(texture);\n    }\n\n\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n\n    if (texture.mipmap && texture.isPowerOfTwo)\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    if (!texture.isPowerOfTwo)\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    }\n\n    return  texture._glTextures[gl.id];\n};\n\n/**\n * Deletes the texture from WebGL\n *\n * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to destroy\n */\nWebGLRenderer.prototype.destroyTexture = function (texture, _skipRemove)\n{\n    texture = texture.baseTexture || texture;\n\n    if (!texture.hasLoaded)\n    {\n        return;\n    }\n\n    if (texture._glTextures[this.gl.id])\n    {\n        this.gl.deleteTexture(texture._glTextures[this.gl.id]);\n        delete texture._glTextures[this.gl.id];\n\n        if (!_skipRemove)\n        {\n            var i = this._managedTextures.indexOf(texture);\n            if (i !== -1) {\n                utils.removeItems(this._managedTextures, i, 1);\n            }\n        }\n    }\n};\n\n/**\n * Handles a lost webgl context\n *\n * @private\n */\nWebGLRenderer.prototype.handleContextLost = function (event)\n{\n    event.preventDefault();\n};\n\n/**\n * Handles a restored webgl context\n *\n * @private\n */\nWebGLRenderer.prototype.handleContextRestored = function ()\n{\n    this._initContext();\n\n    // empty all the old gl textures as they are useless now\n    for (var i = 0; i < this._managedTextures.length; ++i)\n    {\n        var texture = this._managedTextures[i];\n        if (texture._glTextures[this.gl.id])\n        {\n            delete texture._glTextures[this.gl.id];\n        }\n    }\n};\n\n/**\n * Removes everything from the renderer (event listeners, spritebatch, etc...)\n *\n * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.\n */\nWebGLRenderer.prototype.destroy = function (removeView)\n{\n    this.destroyPlugins();\n\n    // remove listeners\n    this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n    // destroy managed textures\n    for (var i = 0; i < this._managedTextures.length; ++i)\n    {\n        var texture = this._managedTextures[i];\n        this.destroyTexture(texture, true);\n        texture.off('update', this.updateTexture, this);\n        texture.off('dispose', this.destroyTexture, this);\n    }\n\n    // call base destroy\n    SystemRenderer.prototype.destroy.call(this, removeView);\n\n    this.uid = 0;\n\n    // destroy the managers\n    this.shaderManager.destroy();\n    this.maskManager.destroy();\n    this.stencilManager.destroy();\n    this.filterManager.destroy();\n    this.blendModeManager.destroy();\n\n    this.shaderManager = null;\n    this.maskManager = null;\n    this.filterManager = null;\n    this.blendModeManager = null;\n    this.currentRenderer = null;\n\n    this.handleContextLost = null;\n    this.handleContextRestored = null;\n\n    this._contextOptions = null;\n\n    this._managedTextures = null;\n\n    this.drawCount = 0;\n\n    this.gl.useProgram(null);\n\n    this.gl.flush();\n\n    this.gl = null;\n};\n\n/**\n * Maps Pixi blend modes to WebGL blend modes. It works only for pre-multiplied textures.\n *\n * @private\n */\nWebGLRenderer.prototype._mapGlModes = function ()\n{\n    var gl = this.gl;\n\n    if (!this.blendModes)\n    {\n        this.blendModes = {};\n\n        this.blendModes[CONST.BLEND_MODES.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.ADD]           = [gl.ONE,       gl.DST_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.SCREEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_COLOR];\n        this.blendModes[CONST.BLEND_MODES.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n    }\n\n    if (!this.drawModes)\n    {\n        this.drawModes = {};\n\n        this.drawModes[CONST.DRAW_MODES.POINTS]         = gl.POINTS;\n        this.drawModes[CONST.DRAW_MODES.LINES]          = gl.LINES;\n        this.drawModes[CONST.DRAW_MODES.LINE_LOOP]      = gl.LINE_LOOP;\n        this.drawModes[CONST.DRAW_MODES.LINE_STRIP]     = gl.LINE_STRIP;\n        this.drawModes[CONST.DRAW_MODES.TRIANGLES]      = gl.TRIANGLES;\n        this.drawModes[CONST.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;\n        this.drawModes[CONST.DRAW_MODES.TRIANGLE_FAN]   = gl.TRIANGLE_FAN;\n    }\n};\n\n},{\"../../const\":22,\"../../utils\":77,\"../SystemRenderer\":43,\"./filters/FXAAFilter\":51,\"./managers/BlendModeManager\":53,\"./managers/FilterManager\":54,\"./managers/MaskManager\":55,\"./managers/ShaderManager\":56,\"./managers/StencilManager\":57,\"./utils/ObjectRenderer\":63,\"./utils/RenderTarget\":65}],50:[function(require,module,exports){\nvar DefaultShader = require('../shaders/TextureShader');\n\n/**\n * This is the base class for creating a PIXI filter. Currently only WebGL supports filters.\n * If you want to make a custom filter this should be your base class.\n *\n * @class\n * @memberof PIXI\n * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.\n * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.\n * @param uniforms {object} An object containing the uniforms for this filter.\n */\nfunction AbstractFilter(vertexSrc, fragmentSrc, uniforms)\n{\n\n    /**\n     * An array of shaders\n     * @member {PIXI.Shader[]}\n     * @private\n     */\n    this.shaders = [];\n\n    /**\n     * The extra padding that the filter might need\n     * @member {number}\n     */\n    this.padding = 0;\n\n    /**\n     * The uniforms as an object\n     * @member {object}\n     */\n    this.uniforms = uniforms || {};\n\n\n    /**\n     * The code of the vertex shader\n     * @member {string[]}\n     * @private\n     */\n    this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;\n\n    /**\n     * The code of the frament shader\n     * @member {string[]}\n     * @private\n     */\n    this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc;\n\n    //TODO a reminder - would be cool to have lower res filters as this would give better performance.\n\n    //typeof fragmentSrc === 'string' ? fragmentSrc.split('') : (fragmentSrc || []);\n\n}\n\nAbstractFilter.prototype.constructor = AbstractFilter;\nmodule.exports = AbstractFilter;\n\n/**\n * Grabs a shader from the current renderer\n *\n * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the shader from\n */\nAbstractFilter.prototype.getShader = function (renderer)\n{\n    var gl = renderer.gl;\n\n    var shader = this.shaders[gl.id];\n\n    if (!shader)\n    {\n        shader = new DefaultShader(renderer.shaderManager,\n            this.vertexSrc,\n            this.fragmentSrc,\n            this.uniforms,\n            this.attributes\n        );\n\n        this.shaders[gl.id] = shader;\n    }\n\n    return shader;\n};\n\n/**\n * Applies the filter\n *\n * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from\n * @param input {PIXI.RenderTarget}\n * @param output {PIXI.RenderTarget}\n * @param clear {boolean} Whether or not we want to clear the outputTarget\n */\nAbstractFilter.prototype.applyFilter = function (renderer, input, output, clear)\n{\n    var shader = this.getShader(renderer);\n\n    renderer.filterManager.applyFilter(shader, input, output, clear);\n};\n\n/**\n * Syncs a uniform between the class object and the shaders.\n *\n */\nAbstractFilter.prototype.syncUniform = function (uniform)\n{\n    for (var i = 0, j = this.shaders.length; i < j; ++i)\n    {\n        this.shaders[i].syncUniform(uniform);\n    }\n};\n\n},{\"../shaders/TextureShader\":62}],51:[function(require,module,exports){\nvar AbstractFilter = require('./AbstractFilter');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n *\n * Basic FXAA implementation based on the code on geeks3d.com with the\n * modification that the texture2DLod stuff was removed since it's\n * unsupported by WebGL.\n *\n * --\n * From:\n * https://github.com/mitsuhiko/webgl-meincraft\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI\n *\n */\nfunction FXAAFilter()\n{\n    AbstractFilter.call(this,\n        // vertex shader\n        \"\\nprecision mediump float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform vec2 resolution;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nvarying vec2 vResolution;\\n\\n//texcoords computed in vertex step\\n//to avoid dependent texture reads\\nvarying vec2 v_rgbNW;\\nvarying vec2 v_rgbNE;\\nvarying vec2 v_rgbSW;\\nvarying vec2 v_rgbSE;\\nvarying vec2 v_rgbM;\\n\\n\\nvoid texcoords(vec2 fragCoord, vec2 resolution,\\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\\n            out vec2 v_rgbM) {\\n    vec2 inverseVP = 1.0 / resolution.xy;\\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\\n    v_rgbM = vec2(fragCoord * inverseVP);\\n}\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vTextureCoord = aTextureCoord;\\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\\n   vResolution = resolution;\\n\\n   //compute the texture coords and send them to varyings\\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\\n}\\n\",\n        // fragment shader\n        \"precision lowp float;\\n\\n\\n/**\\nBasic FXAA implementation based on the code on geeks3d.com with the\\nmodification that the texture2DLod stuff was removed since it's\\nunsupported by WebGL.\\n\\n--\\n\\nFrom:\\nhttps://github.com/mitsuhiko/webgl-meincraft\\n\\nCopyright (c) 2011 by Armin Ronacher.\\n\\nSome rights reserved.\\n\\nRedistribution and use in source and binary forms, with or without\\nmodification, are permitted provided that the following conditions are\\nmet:\\n\\n    * Redistributions of source code must retain the above copyright\\n      notice, this list of conditions and the following disclaimer.\\n\\n    * Redistributions in binary form must reproduce the above\\n      copyright notice, this list of conditions and the following\\n      disclaimer in the documentation and/or other materials provided\\n      with the distribution.\\n\\n    * The names of the contributors may not be used to endorse or\\n      promote products derived from this software without specific\\n      prior written permission.\\n\\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\n\\n#ifndef FXAA_REDUCE_MIN\\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\\n#endif\\n#ifndef FXAA_REDUCE_MUL\\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\\n#endif\\n#ifndef FXAA_SPAN_MAX\\n    #define FXAA_SPAN_MAX     8.0\\n#endif\\n\\n//optimized version for mobile, where dependent\\n//texture reads can be a bottleneck\\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\\n            vec2 v_rgbNW, vec2 v_rgbNE,\\n            vec2 v_rgbSW, vec2 v_rgbSE,\\n            vec2 v_rgbM) {\\n    vec4 color;\\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\\n    vec4 texColor = texture2D(tex, v_rgbM);\\n    vec3 rgbM  = texColor.xyz;\\n    vec3 luma = vec3(0.299, 0.587, 0.114);\\n    float lumaNW = dot(rgbNW, luma);\\n    float lumaNE = dot(rgbNE, luma);\\n    float lumaSW = dot(rgbSW, luma);\\n    float lumaSE = dot(rgbSE, luma);\\n    float lumaM  = dot(rgbM,  luma);\\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\n    mediump vec2 dir;\\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\\n\\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\n              dir * rcpDirMin)) * inverseVP;\\n\\n    vec3 rgbA = 0.5 * (\\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\\n\\n    float lumaB = dot(rgbB, luma);\\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\\n        color = vec4(rgbA, texColor.a);\\n    else\\n        color = vec4(rgbB, texColor.a);\\n    return color;\\n}\\n\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying vec2 vResolution;\\n\\n//texcoords computed in vertex step\\n//to avoid dependent texture reads\\nvarying vec2 v_rgbNW;\\nvarying vec2 v_rgbNE;\\nvarying vec2 v_rgbSW;\\nvarying vec2 v_rgbSE;\\nvarying vec2 v_rgbM;\\n\\nuniform sampler2D uSampler;\\n\\n\\nvoid main(void){\\n\\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\\n\\n}\\n\",\n        // uniforms\n        {\n            resolution: { type: 'v2', value: { x: 1, y: 1 } }\n        }\n    );\n\n}\n\nFXAAFilter.prototype = Object.create(AbstractFilter.prototype);\nFXAAFilter.prototype.constructor = FXAAFilter;\nmodule.exports = FXAAFilter;\n\n/**\n * Applies the filter\n *\n * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from\n * @param input {PIXI.RenderTarget}\n * @param output {PIXI.RenderTarget}\n */\nFXAAFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var filterManager = renderer.filterManager;\n\n    var shader = this.getShader( renderer );\n     // draw the filter...\n    filterManager.applyFilter(shader, input, output);\n};\n\n},{\"./AbstractFilter\":50}],52:[function(require,module,exports){\nvar AbstractFilter = require('./AbstractFilter'),\n    math =  require('../../../math');\n\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI\n * @param sprite {PIXI.Sprite} the target sprite\n */\nfunction SpriteMaskFilter(sprite)\n{\n    var maskMatrix = new math.Matrix();\n\n    AbstractFilter.call(this,\n        \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 otherMatrix;\\n\\nvarying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\\n}\\n\",\n        \"precision lowp float;\\n\\nvarying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\nuniform float alpha;\\nuniform sampler2D mask;\\n\\nvoid main(void)\\n{\\n    // check clip! this will stop the mask bleeding out from the edges\\n    vec2 text = abs( vMaskCoord - 0.5 );\\n    text = step(0.5, text);\\n    float clip = 1.0 - max(text.y, text.x);\\n    vec4 original = texture2D(uSampler, vTextureCoord);\\n    vec4 masky = texture2D(mask, vMaskCoord);\\n    original *= (masky.r * masky.a * alpha * clip);\\n    gl_FragColor = original;\\n}\\n\",\n        {\n            mask:           { type: 'sampler2D', value: sprite._texture },\n            alpha:          { type: 'f', value: 1},\n            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) }\n        }\n    );\n\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n}\n\nSpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);\nSpriteMaskFilter.prototype.constructor = SpriteMaskFilter;\nmodule.exports = SpriteMaskFilter;\n\n/**\n * Applies the filter\n *\n * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from\n * @param input {PIXI.RenderTarget}\n * @param output {PIXI.RenderTarget}\n */\nSpriteMaskFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var filterManager = renderer.filterManager;\n\n    this.uniforms.mask.value = this.maskSprite._texture;\n\n    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);\n\n    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);\n    this.uniforms.alpha.value = this.maskSprite.worldAlpha;\n\n    var shader = this.getShader(renderer);\n     // draw the filter...\n    filterManager.applyFilter(shader, input, output);\n};\n\n\nObject.defineProperties(SpriteMaskFilter.prototype, {\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.SpriteMaskFilter#\n     */\n    map: {\n        get: function ()\n        {\n            return this.uniforms.mask.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.mask.value = value;\n        }\n    },\n\n    /**\n     * The offset used to move the displacement map.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.SpriteMaskFilter#\n     */\n    offset: {\n        get: function()\n        {\n            return this.uniforms.offset.value;\n        },\n        set: function(value)\n        {\n            this.uniforms.offset.value = value;\n        }\n    }\n});\n\n},{\"../../../math\":33,\"./AbstractFilter\":50}],53:[function(require,module,exports){\nvar WebGLManager = require('./WebGLManager');\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGlManager\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\n */\nfunction BlendModeManager(renderer)\n{\n    WebGLManager.call(this, renderer);\n\n    /**\n     * @member {number}\n     */\n    this.currentBlendMode = 99999;\n}\n\nBlendModeManager.prototype = Object.create(WebGLManager.prototype);\nBlendModeManager.prototype.constructor = BlendModeManager;\nmodule.exports = BlendModeManager;\n\n/**\n * Sets-up the given blendMode from WebGL's point of view.\n *\n * @param blendMode {number} the blendMode, should be a Pixi const, such as `PIXI.BLEND_MODES.ADD`. See\n *  {@link PIXI.BLEND_MODES} for possible values.\n */\nBlendModeManager.prototype.setBlendMode = function (blendMode)\n{\n    if (this.currentBlendMode === blendMode)\n    {\n        return false;\n    }\n\n    this.currentBlendMode = blendMode;\n\n    var mode = this.renderer.blendModes[this.currentBlendMode];\n    this.renderer.gl.blendFunc(mode[0], mode[1]);\n\n    return true;\n};\n\n},{\"./WebGLManager\":58}],54:[function(require,module,exports){\nvar WebGLManager = require('./WebGLManager'),\n    RenderTarget = require('../utils/RenderTarget'),\n    CONST = require('../../../const'),\n    Quad = require('../utils/Quad'),\n    math =  require('../../../math');\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\n */\nfunction FilterManager(renderer)\n{\n    WebGLManager.call(this, renderer);\n\n    /**\n     * @member {object[]}\n     */\n    this.filterStack = [];\n\n    this.filterStack.push({\n        renderTarget:renderer.currentRenderTarget,\n        filter:[],\n        bounds:null\n    });\n\n    /**\n     * @member {PIXI.RenderTarget[]}\n     */\n    this.texturePool = [];\n\n    /**\n     * The size of the texture\n     *\n     * @member {PIXI.Rectangle}\n     */\n    // listen for context and update necessary buffers\n    //TODO make this dynamic!\n    //TODO test this out by forces power of two?\n    this.textureSize = new math.Rectangle(0, 0, renderer.width, renderer.height);\n\n    /**\n     * The current frame\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.currentFrame = null;\n}\n\nFilterManager.prototype = Object.create(WebGLManager.prototype);\nFilterManager.prototype.constructor = FilterManager;\nmodule.exports = FilterManager;\n\n\n/**\n * Called when there is a WebGL context change.\n *\n */\nFilterManager.prototype.onContextChange = function ()\n{\n    this.texturePool.length = 0;\n\n    var gl = this.renderer.gl;\n    this.quad = new Quad(gl);\n};\n\n/**\n * @param renderer {PIXI.WebGLRenderer}\n * @param buffer {ArrayBuffer}\n */\nFilterManager.prototype.setFilterStack = function ( filterStack )\n{\n    this.filterStack = filterStack;\n};\n\n/**\n * Applies the filter and adds it to the current filter stack.\n *\n * @param target {PIXI.DisplayObject}\n * @param filters {PIXI.AbstractFiler[]} the filters that will be pushed to the current filter stack\n */\nFilterManager.prototype.pushFilter = function (target, filters)\n{\n    // get the bounds of the object..\n    // TODO replace clone with a copy to save object creation\n    var bounds = target.filterArea ? target.filterArea.clone() : target.getBounds();\n\n    //bounds = bounds.clone();\n\n    // round off the rectangle to get a nice smoooooooth filter :)\n    bounds.x = bounds.x | 0;\n    bounds.y = bounds.y | 0;\n    bounds.width = bounds.width | 0;\n    bounds.height = bounds.height | 0;\n\n\n    // padding!\n    var padding = filters[0].padding | 0;\n    bounds.x -= padding;\n    bounds.y -= padding;\n    bounds.width += padding * 2;\n    bounds.height += padding * 2;\n\n\n    if(this.renderer.currentRenderTarget.transform)\n    {\n        //TODO this will break if the renderTexture transform is anything other than a translation.\n        //Will need to take the full matrix transform into acount..\n        var transform = this.renderer.currentRenderTarget.transform;\n\n        bounds.x += transform.tx;\n        bounds.y += transform.ty;\n\n        this.capFilterArea( bounds );\n\n        bounds.x -= transform.tx;\n        bounds.y -= transform.ty;\n    }\n    else\n    {\n         this.capFilterArea( bounds );\n    }\n\n    if(bounds.width > 0 && bounds.height > 0)\n    {\n        this.currentFrame = bounds;\n\n        var texture = this.getRenderTarget();\n\n        this.renderer.setRenderTarget(texture);\n\n        // clear the texture..\n        texture.clear();\n\n        // TODO get rid of object creation!\n        this.filterStack.push({\n            renderTarget: texture,\n            filter: filters\n        });\n\n    }\n    else\n    {\n        // push somthing on to the stack that is empty\n        this.filterStack.push({\n            renderTarget: null,\n            filter: filters\n        });\n    }\n};\n\n\n/**\n * Removes the last filter from the filter stack and returns it.\n *\n */\nFilterManager.prototype.popFilter = function ()\n{\n    var filterData = this.filterStack.pop();\n    var previousFilterData = this.filterStack[this.filterStack.length-1];\n\n    var input = filterData.renderTarget;\n\n    // if the renderTarget is null then we don't apply the filter as its offscreen\n    if(!filterData.renderTarget)\n    {\n        return;\n    }\n\n    var output = previousFilterData.renderTarget;\n\n    // use program\n    var gl = this.renderer.gl;\n\n\n    this.currentFrame = input.frame;\n\n    this.quad.map(this.textureSize, input.frame);\n\n\n    // TODO.. this probably only needs to be done once!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);\n\n    var filters = filterData.filter;\n\n    // assuming all filters follow the correct format??\n    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);\n    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);\n\n    // restore the normal blendmode!\n    this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);\n\n    if (filters.length === 1)\n    {\n        // TODO (cengler) - There has to be a better way then setting this each time?\n        if (filters[0].uniforms.dimensions)\n        {\n            filters[0].uniforms.dimensions.value[0] = this.renderer.width;\n            filters[0].uniforms.dimensions.value[1] = this.renderer.height;\n            filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];\n            filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];\n        }\n\n        filters[0].applyFilter( this.renderer, input, output );\n        this.returnRenderTarget( input );\n\n    }\n    else\n    {\n        var flipTexture = input;\n        var flopTexture = this.getRenderTarget(true);\n\n        for (var i = 0; i < filters.length-1; i++)\n        {\n            var filter = filters[i];\n\n            // TODO (cengler) - There has to be a better way then setting this each time?\n            if (filter.uniforms.dimensions)\n            {\n                filter.uniforms.dimensions.value[0] = this.renderer.width;\n                filter.uniforms.dimensions.value[1] = this.renderer.height;\n                filter.uniforms.dimensions.value[2] = this.quad.vertices[0];\n                filter.uniforms.dimensions.value[3] = this.quad.vertices[5];\n            }\n\n            filter.applyFilter( this.renderer, flipTexture, flopTexture );\n\n            var temp = flipTexture;\n            flipTexture = flopTexture;\n            flopTexture = temp;\n        }\n\n        filters[filters.length-1].applyFilter( this.renderer, flipTexture, output );\n\n        this.returnRenderTarget( flipTexture );\n        this.returnRenderTarget( flopTexture );\n    }\n\n    return filterData.filter;\n};\n\n/**\n * Grabs an render target from the internal pool\n *\n * @param clear {boolean} Whether or not we need to clear the RenderTarget\n * @return {RenderTarget}\n */\nFilterManager.prototype.getRenderTarget = function ( clear )\n{\n    var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);\n    renderTarget.frame = this.currentFrame;\n\n    if (clear)\n    {\n        renderTarget.clear(true);\n    }\n\n    return renderTarget;\n};\n\n/*\n * Returns a RenderTarget to the internal pool\n * @param renderTarget {RenderTarget} The RenderTarget we want to return to the pool\n */\nFilterManager.prototype.returnRenderTarget = function (renderTarget)\n{\n    this.texturePool.push( renderTarget );\n};\n\n/*\n * Applies the filter\n * @param shader {Shader} The shader to upload\n * @param inputTarget {RenderTarget}\n * @param outputTarget {RenderTarget}\n * @param clear {boolean} Whether or not we want to clear the outputTarget\n */\nFilterManager.prototype.applyFilter = function (shader, inputTarget, outputTarget, clear)\n{\n    var gl = this.renderer.gl;\n\n    this.renderer.setRenderTarget(outputTarget);\n\n    if (clear)\n    {\n        outputTarget.clear();\n    }\n\n    // set the shader\n    this.renderer.shaderManager.setShader(shader);\n\n    // TODO (cengler) - Can this be cached and not `toArray`ed each frame?\n    shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);\n\n    //TODO can this be optimised?\n    shader.syncUniforms();\n/*\n    gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n    gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);\n    gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);\n*/\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);\n\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n    this.renderer.drawCount++;\n};\n\n/*\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\nFilterManager.prototype.calculateMappedMatrix = function (filterArea, sprite, outputMatrix)\n{\n    var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),\n    texture = sprite._texture.baseTexture;\n\n    var mappedMatrix = outputMatrix.identity();\n\n    // scale..\n    var ratio = this.textureSize.height / this.textureSize.width;\n\n    mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height );\n\n    mappedMatrix.scale(1 , ratio);\n\n    var translateScaleX = (this.textureSize.width / texture.width);\n    var translateScaleY = (this.textureSize.height / texture.height);\n\n    worldTransform.tx /= texture.width * translateScaleX;\n    worldTransform.ty /= texture.width * translateScaleX;\n\n    worldTransform.invert();\n\n    mappedMatrix.prepend(worldTransform);\n\n    // apply inverse scale..\n    mappedMatrix.scale(1 , 1/ratio);\n\n    mappedMatrix.scale( translateScaleX , translateScaleY );\n\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n    return mappedMatrix;\n\n    // Keeping the orginal as a reminder to me on how this works!\n    //\n    // var m = new math.Matrix();\n\n    // // scale..\n    // var ratio = this.textureSize.height / this.textureSize.width;\n\n    // m.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);\n\n\n    // m.scale(1 , ratio);\n\n\n    // var transform = wt.clone();\n\n    // var translateScaleX = (this.textureSize.width / 620);\n    // var translateScaleY = (this.textureSize.height / 380);\n\n    // transform.tx /= 620 * translateScaleX;\n    // transform.ty /= 620 * translateScaleX;\n\n    // transform.invert();\n\n    // transform.append(m);\n\n    // // apply inverse scale..\n    // transform.scale(1 , 1/ratio);\n\n    // transform.scale( translateScaleX , translateScaleY );\n\n    // return transform;\n};\n\n/*\n * Constrains the filter area to the texture size\n * @param filterArea {Rectangle} The filter area we want to cap\n */\nFilterManager.prototype.capFilterArea = function (filterArea)\n{\n    if (filterArea.x < 0)\n    {\n        filterArea.width += filterArea.x;\n        filterArea.x = 0;\n    }\n\n    if (filterArea.y < 0)\n    {\n        filterArea.height += filterArea.y;\n        filterArea.y = 0;\n    }\n\n    if ( filterArea.x + filterArea.width > this.textureSize.width )\n    {\n        filterArea.width = this.textureSize.width - filterArea.x;\n    }\n\n    if ( filterArea.y + filterArea.height > this.textureSize.height )\n    {\n        filterArea.height = this.textureSize.height - filterArea.y;\n    }\n};\n\n/*\n * Resizes all the render targets in the pool\n * @param width {number} the new width\n * @param height {number} the new height\n */\nFilterManager.prototype.resize = function ( width, height )\n{\n    this.textureSize.width = width;\n    this.textureSize.height = height;\n\n    for (var i = 0; i < this.texturePool.length; i++)\n    {\n        this.texturePool[i].resize( width, height );\n    }\n};\n\n/**\n * Destroys the filter and removes it from the filter stack.\n *\n */\nFilterManager.prototype.destroy = function ()\n{\n    this.quad.destroy();\n    \n    WebGLManager.prototype.destroy.call(this);\n    \n    this.filterStack = null;\n    this.offsetY = 0;\n\n    // destroy textures\n    for (var i = 0; i < this.texturePool.length; i++)\n    {\n        this.texturePool[i].destroy();\n    }\n\n    this.texturePool = null;\n};\n\n},{\"../../../const\":22,\"../../../math\":33,\"../utils/Quad\":64,\"../utils/RenderTarget\":65,\"./WebGLManager\":58}],55:[function(require,module,exports){\nvar WebGLManager = require('./WebGLManager'),\n    AlphaMaskFilter = require('../filters/SpriteMaskFilter');\n\n/**\n * @class\n * @memberof PIXI\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\n */\nfunction MaskManager(renderer)\n{\n    WebGLManager.call(this, renderer);\n\n    this.stencilStack = [];\n    this.reverse = true;\n    this.count = 0;\n\n    this.alphaMaskPool = [];\n}\n\nMaskManager.prototype = Object.create(WebGLManager.prototype);\nMaskManager.prototype.constructor = MaskManager;\nmodule.exports = MaskManager;\n\n/**\n * Applies the Mask and adds it to the current filter stack.\n *\n * @param graphics {PIXI.Graphics}\n * @param webGLData {any[]}\n */\nMaskManager.prototype.pushMask = function (target, maskData)\n{\n    if (maskData.texture)\n    {\n        this.pushSpriteMask(target, maskData);\n    }\n    else\n    {\n        this.pushStencilMask(target, maskData);\n    }\n\n};\n\n/**\n * Removes the last mask from the mask stack and doesn't return it.\n *\n * @param target {PIXI.RenderTarget}\n * @param maskData {any[]}\n */\nMaskManager.prototype.popMask = function (target, maskData)\n{\n    if (maskData.texture)\n    {\n        this.popSpriteMask(target, maskData);\n    }\n    else\n    {\n        this.popStencilMask(target, maskData);\n    }\n};\n\n/**\n * Applies the Mask and adds it to the current filter stack.\n *\n * @param target {PIXI.RenderTarget}\n * @param maskData {any[]}\n */\nMaskManager.prototype.pushSpriteMask = function (target, maskData)\n{\n    var alphaMaskFilter = this.alphaMaskPool.pop();\n\n    if (!alphaMaskFilter)\n    {\n        alphaMaskFilter = [new AlphaMaskFilter(maskData)];\n    }\n\n    alphaMaskFilter[0].maskSprite = maskData;\n    this.renderer.filterManager.pushFilter(target, alphaMaskFilter);\n};\n\n/**\n * Removes the last filter from the filter stack and doesn't return it.\n *\n */\nMaskManager.prototype.popSpriteMask = function ()\n{\n    var filters = this.renderer.filterManager.popFilter();\n\n    this.alphaMaskPool.push(filters);\n};\n\n\n/**\n * Applies the Mask and adds it to the current filter stack.\n *\n * @param target {PIXI.RenderTarget}\n * @param maskData {any[]}\n */\nMaskManager.prototype.pushStencilMask = function (target, maskData)\n{\n    this.renderer.stencilManager.pushMask(maskData);\n};\n\n/**\n * Removes the last filter from the filter stack and doesn't return it.\n *\n * @param target {PIXI.RenderTarget}\n * @param maskData {any[]}\n */\nMaskManager.prototype.popStencilMask = function (target, maskData)\n{\n    this.renderer.stencilManager.popMask(maskData);\n};\n\n\n},{\"../filters/SpriteMaskFilter\":52,\"./WebGLManager\":58}],56:[function(require,module,exports){\nvar WebGLManager = require('./WebGLManager'),\n    TextureShader = require('../shaders/TextureShader'),\n    ComplexPrimitiveShader = require('../shaders/ComplexPrimitiveShader'),\n    PrimitiveShader = require('../shaders/PrimitiveShader'),\n    utils = require('../../../utils');\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\n */\nfunction ShaderManager(renderer)\n{\n    WebGLManager.call(this, renderer);\n\n    /**\n     * @member {number}\n     */\n    this.maxAttibs = 10;\n\n    /**\n     * @member {any[]}\n     */\n    this.attribState = [];\n\n    /**\n     * @member {any[]}\n     */\n    this.tempAttribState = [];\n\n    for (var i = 0; i < this.maxAttibs; i++)\n    {\n        this.attribState[i] = false;\n    }\n\n    /**\n     * @member {any[]}\n     */\n    this.stack = [];\n\n    /**\n     * @member {number}\n     * @private\n     */\n    this._currentId = -1;\n\n    /**\n     * @member {PIXI.Shader}\n     * @private\n     */\n    this.currentShader = null;\n\n//    this.initPlugins();\n}\n\nShaderManager.prototype = Object.create(WebGLManager.prototype);\nShaderManager.prototype.constructor = ShaderManager;\nutils.pluginTarget.mixin(ShaderManager);\n\nmodule.exports = ShaderManager;\n\n/**\n * Called when there is a WebGL context change.\n *\n */\nShaderManager.prototype.onContextChange = function ()\n{\n    this.initPlugins();\n\n    var gl = this.renderer.gl;\n\n    // get the maximum number of attribute correctly as this tends to vary\n    this.maxAttibs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\n    this.attribState = [];\n\n    for (var i = 0; i < this.maxAttibs; i++)\n    {\n        this.attribState[i] = false;\n    }\n\n    // TODO - Why are these not plugins? We can't decouple primitives unless they are....\n    this.defaultShader = new TextureShader(this);\n    this.primitiveShader = new PrimitiveShader(this);\n    this.complexPrimitiveShader = new ComplexPrimitiveShader(this);\n};\n\n/**\n * Takes the attributes given in parameters and uploads them.\n *\n * @param attribs {any[]} attribs\n */\nShaderManager.prototype.setAttribs = function (attribs)\n{\n    // reset temp state\n    var i;\n\n    for (i = 0; i < this.tempAttribState.length; i++)\n    {\n        this.tempAttribState[i] = false;\n    }\n\n    // set the new attribs\n    for (var a in attribs)\n    {\n        this.tempAttribState[attribs[a]] = true;\n    }\n\n    var gl = this.renderer.gl;\n\n    for (i = 0; i < this.attribState.length; i++)\n    {\n        if (this.attribState[i] !== this.tempAttribState[i])\n        {\n            this.attribState[i] = this.tempAttribState[i];\n\n            if (this.attribState[i])\n            {\n                gl.enableVertexAttribArray(i);\n            }\n            else\n            {\n                gl.disableVertexAttribArray(i);\n            }\n        }\n    }\n};\n\n/**\n * Sets the current shader.\n *\n * @param shader {PIXI.Shader} the shader to upload\n */\nShaderManager.prototype.setShader = function (shader)\n{\n    if (this._currentId === shader.uid)\n    {\n        return false;\n    }\n\n    this._currentId = shader.uid;\n\n    this.currentShader = shader;\n\n    this.renderer.gl.useProgram(shader.program);\n    this.setAttribs(shader.attributes);\n\n    return true;\n};\n\n/**\n * Destroys this object.\n *\n */\nShaderManager.prototype.destroy = function ()\n{\n    this.primitiveShader.destroy();\n    this.complexPrimitiveShader.destroy();\n    WebGLManager.prototype.destroy.call(this);\n\n    this.destroyPlugins();\n\n    this.attribState = null;\n\n    this.tempAttribState = null;\n};\n\n},{\"../../../utils\":77,\"../shaders/ComplexPrimitiveShader\":59,\"../shaders/PrimitiveShader\":60,\"../shaders/TextureShader\":62,\"./WebGLManager\":58}],57:[function(require,module,exports){\nvar WebGLManager = require('./WebGLManager'),\n    utils = require('../../../utils');\n\n/**\n * @class\n * @memberof PIXI\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\n */\nfunction WebGLMaskManager(renderer)\n{\n    WebGLManager.call(this, renderer);\n    this.stencilMaskStack = null;\n}\n\nWebGLMaskManager.prototype = Object.create(WebGLManager.prototype);\nWebGLMaskManager.prototype.constructor = WebGLMaskManager;\nmodule.exports = WebGLMaskManager;\n\n/**\n * Changes the mask stack that is used by this manager.\n *\n * @param stencilMaskStack {PIXI.StencilMaskStack} The mask stack\n */\nWebGLMaskManager.prototype.setMaskStack = function ( stencilMaskStack )\n{\n    this.stencilMaskStack = stencilMaskStack;\n\n    var gl = this.renderer.gl;\n\n    if (stencilMaskStack.stencilStack.length === 0)\n    {\n        gl.disable(gl.STENCIL_TEST);\n    }\n    else\n    {\n        gl.enable(gl.STENCIL_TEST);\n    }\n};\n\n/**\n * Applies the Mask and adds it to the current filter stack. @alvin\n *\n * @param graphics {PIXI.Graphics}\n * @param webGLData {any[]}\n */\nWebGLMaskManager.prototype.pushStencil = function (graphics, webGLData)\n{\n    this.renderer.currentRenderTarget.attachStencilBuffer();\n\n    var gl = this.renderer.gl,\n        sms = this.stencilMaskStack;\n\n    this.bindGraphics(graphics, webGLData);\n\n    if (sms.stencilStack.length === 0)\n    {\n        gl.enable(gl.STENCIL_TEST);\n        gl.clear(gl.STENCIL_BUFFER_BIT);\n        sms.reverse = true;\n        sms.count = 0;\n    }\n\n    sms.stencilStack.push(webGLData);\n\n    var level = sms.count;\n\n    gl.colorMask(false, false, false, false);\n\n    gl.stencilFunc(gl.ALWAYS,0,0xFF);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n    // draw the triangle strip!\n\n    if (webGLData.mode === 1)\n    {\n        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );\n\n        if (sms.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        // draw a quad to increment..\n        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n\n        if (sms.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n        }\n\n        sms.reverse = !sms.reverse;\n    }\n    else\n    {\n        if (!sms.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n        if (!sms.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n        }\n    }\n\n    gl.colorMask(true, true, true, true);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n    sms.count++;\n};\n\n/**\n * TODO this does not belong here!\n *\n * @param graphics {PIXI.Graphics}\n * @param webGLData {any[]}\n */\nWebGLMaskManager.prototype.bindGraphics = function (graphics, webGLData)\n{\n    //if (this._currentGraphics === graphics)return;\n    var gl = this.renderer.gl;\n\n     // bind the graphics object..\n    var shader;// = this.renderer.shaderManager.plugins.primitiveShader;\n\n    if (webGLData.mode === 1)\n    {\n        shader = this.renderer.shaderManager.complexPrimitiveShader;\n\n        this.renderer.shaderManager.setShader(shader);\n\n        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));\n\n        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));\n\n        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));\n\n        gl.uniform3fv(shader.uniforms.color._location, webGLData.color);\n\n        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);\n\n\n        // now do the rest..\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n    else\n    {\n        //this.renderer.shaderManager.activatePrimitiveShader();\n        shader = this.renderer.shaderManager.primitiveShader;\n\n        this.renderer.shaderManager.setShader(shader);\n\n        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));\n\n        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));\n\n        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));\n\n        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n        gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n};\n\n/**\n * TODO @alvin\n * @param graphics {PIXI.Graphics}\n * @param webGLData {any[]}\n */\nWebGLMaskManager.prototype.popStencil = function (graphics, webGLData)\n{\n    var gl = this.renderer.gl,\n        sms = this.stencilMaskStack;\n\n    sms.stencilStack.pop();\n\n    sms.count--;\n\n    if (sms.stencilStack.length === 0)\n    {\n        // the stack is empty!\n        gl.disable(gl.STENCIL_TEST);\n\n    }\n    else\n    {\n\n        var level = sms.count;\n\n        this.bindGraphics(graphics, webGLData);\n\n        gl.colorMask(false, false, false, false);\n\n        if (webGLData.mode === 1)\n        {\n            sms.reverse = !sms.reverse;\n\n            if (sms.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            // draw a quad to increment..\n            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n\n            gl.stencilFunc(gl.ALWAYS,0,0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n            // draw the triangle strip!\n            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );\n\n            this.renderer.drawCount += 2;\n\n            if (!sms.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n\n        }\n        else\n        {\n          //  console.log(\"<<>>\")\n            if (!sms.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n            this.renderer.drawCount++;\n\n            if (!sms.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n        }\n\n        gl.colorMask(true, true, true, true);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n\n    }\n};\n\n/**\n * Destroys the mask stack.\n *\n */\nWebGLMaskManager.prototype.destroy = function ()\n{\n    WebGLManager.prototype.destroy.call(this);\n\n    this.stencilMaskStack.stencilStack = null;\n};\n\n/**\n * Applies the Mask and adds it to the current filter stack.\n *\n * @param maskData {any[]} The mask data structure to use\n */\nWebGLMaskManager.prototype.pushMask = function (maskData)\n{\n\n\n    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);\n\n    if (maskData.dirty)\n    {\n        this.renderer.plugins.graphics.updateGraphics(maskData, this.renderer.gl);\n    }\n\n    if (!maskData._webGL[this.renderer.gl.id].data.length)\n    {\n        return;\n    }\n\n    this.pushStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);\n};\n\n/**\n * Removes the last filter from the filter stack and doesn't return it.\n *\n * @param maskData {any[]}\n */\nWebGLMaskManager.prototype.popMask = function (maskData)\n{\n    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);\n\n    this.popStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);\n};\n\n\n},{\"../../../utils\":77,\"./WebGLManager\":58}],58:[function(require,module,exports){\n/**\n * @class\n * @memberof PIXI\n * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.\n */\nfunction WebGLManager(renderer)\n{\n    /**\n     * The renderer this manager works for.\n     *\n     * @member {PIXI.WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    this.renderer.on('context', this.onContextChange, this);\n}\n\nWebGLManager.prototype.constructor = WebGLManager;\nmodule.exports = WebGLManager;\n\n/**\n * Generic method called when there is a WebGL context change.\n *\n */\nWebGLManager.prototype.onContextChange = function ()\n{\n\t// do some codes init!\n};\n\n/**\n * Generic destroy methods to be overridden by the subclass\n *\n */\nWebGLManager.prototype.destroy = function ()\n{\n    this.renderer.off('context', this.onContextChange, this);\n\n    this.renderer = null;\n};\n\n},{}],59:[function(require,module,exports){\nvar Shader = require('./Shader');\n\n/**\n * This shader is used to draw complex primitive shapes for {@link PIXI.Graphics}.\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.\n */\nfunction ComplexPrimitiveShader(shaderManager)\n{\n    Shader.call(this,\n        shaderManager,\n        // vertex shader\n        [\n            'attribute vec2 aVertexPosition;',\n\n            'uniform mat3 translationMatrix;',\n            'uniform mat3 projectionMatrix;',\n\n            'uniform vec3 tint;',\n            'uniform float alpha;',\n            'uniform vec3 color;',\n\n            'varying vec4 vColor;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vColor = vec4(color * alpha * tint, alpha);',//\" * vec4(tint * alpha, alpha);',\n            '}'\n        ].join('\\n'),\n        // fragment shader\n        [\n            'precision mediump float;',\n\n            'varying vec4 vColor;',\n\n            'void main(void){',\n            '   gl_FragColor = vColor;',\n            '}'\n        ].join('\\n'),\n        // custom uniforms\n        {\n            tint:   { type: '3f', value: [0, 0, 0] },\n            alpha:  { type: '1f', value: 0 },\n            color:  { type: '3f', value: [0,0,0] },\n            translationMatrix: { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }\n        },\n        // attributes\n        {\n            aVertexPosition:0\n        }\n    );\n}\n\nComplexPrimitiveShader.prototype = Object.create(Shader.prototype);\nComplexPrimitiveShader.prototype.constructor = ComplexPrimitiveShader;\nmodule.exports = ComplexPrimitiveShader;\n\n},{\"./Shader\":61}],60:[function(require,module,exports){\nvar Shader = require('./Shader');\n\n/**\n * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.\n */\nfunction PrimitiveShader(shaderManager)\n{\n    Shader.call(this,\n        shaderManager,\n        // vertex shader\n        [\n            'attribute vec2 aVertexPosition;',\n            'attribute vec4 aColor;',\n\n            'uniform mat3 translationMatrix;',\n            'uniform mat3 projectionMatrix;',\n\n            'uniform float alpha;',\n            'uniform float flipY;',\n            'uniform vec3 tint;',\n\n            'varying vec4 vColor;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vColor = aColor * vec4(tint * alpha, alpha);',\n            '}'\n        ].join('\\n'),\n        // fragment shader\n        [\n            'precision mediump float;',\n\n            'varying vec4 vColor;',\n\n            'void main(void){',\n            '   gl_FragColor = vColor;',\n            '}'\n        ].join('\\n'),\n        // custom uniforms\n        {\n            tint:   { type: '3f', value: [0, 0, 0] },\n            alpha:  { type: '1f', value: 0 },\n            translationMatrix: { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }\n        },\n        // custom attributes\n        {\n            aVertexPosition:0,\n            aColor:0\n        }\n    );\n}\n\nPrimitiveShader.prototype = Object.create(Shader.prototype);\nPrimitiveShader.prototype.constructor = PrimitiveShader;\nmodule.exports = PrimitiveShader;\n\n},{\"./Shader\":61}],61:[function(require,module,exports){\n/*global console */\nvar utils = require('../../../utils');\n\n/**\n * Base shader class for PIXI managed shaders.\n *\n * @class\n * @memberof PIXI\n * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.\n * @param [vertexSrc] {string} The source of the vertex shader.\n * @param [fragmentSrc] {string} The source of the fragment shader.\n * @param [uniforms] {object} Uniforms for this shader.\n * @param [attributes] {object} Attributes for this shader.\n */\nfunction Shader(shaderManager, vertexSrc, fragmentSrc, uniforms, attributes)\n{\n    if (!vertexSrc || !fragmentSrc)\n    {\n         throw new Error('Pixi.js Error. Shader requires vertexSrc and fragmentSrc');\n    }\n\n    /**\n     * A unique id\n     * @member {number}\n     * @readonly\n     */\n    this.uid = utils.uid();\n\n    /**\n     * The current WebGL drawing context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    this.gl = shaderManager.renderer.gl;\n\n    //TODO maybe we should pass renderer rather than shader manger?? food for thought..\n    this.shaderManager = shaderManager;\n\n    /**\n     * The WebGL program.\n     *\n     * @member {WebGLProgram}\n     * @readonly\n     */\n    this.program = null;\n\n    /**\n     * The uniforms as an object\n     * @member {object}\n     * @private\n     */\n    this.uniforms = uniforms || {};\n\n    /**\n     * The attributes as an object\n     * @member {object}\n     * @private\n     */\n    this.attributes = attributes || {};\n\n    /**\n     * Internal texture counter\n     * @member {number}\n     * @private\n     */\n    this.textureCount = 1;\n\n    /**\n     * The vertex shader as an array of strings\n     *\n     * @member {string}\n     */\n    this.vertexSrc = vertexSrc;\n\n    /**\n     * The fragment shader as an array of strings\n     *\n     * @member {string}\n     */\n    this.fragmentSrc = fragmentSrc;\n\n    this.init();\n}\n\nShader.prototype.constructor = Shader;\nmodule.exports = Shader;\n\n/**\n * Creates the shader and uses it\n *\n */\nShader.prototype.init = function ()\n{\n    this.compile();\n\n    this.gl.useProgram(this.program);\n\n    this.cacheUniformLocations(Object.keys(this.uniforms));\n    this.cacheAttributeLocations(Object.keys(this.attributes));\n};\n\n/**\n * Caches the locations of the uniform for reuse.\n *\n * @param keys {string} the uniforms to cache\n */\nShader.prototype.cacheUniformLocations = function (keys)\n{\n    for (var i = 0; i < keys.length; ++i)\n    {\n        this.uniforms[keys[i]]._location = this.gl.getUniformLocation(this.program, keys[i]);\n    }\n};\n\n/**\n * Caches the locations of the attribute for reuse.\n *\n * @param keys {string} the attributes to cache\n */\nShader.prototype.cacheAttributeLocations = function (keys)\n{\n    for (var i = 0; i < keys.length; ++i)\n    {\n        this.attributes[keys[i]] = this.gl.getAttribLocation(this.program, keys[i]);\n    }\n\n    // TODO: Check if this is needed anymore...\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its something to do with the current state of the gl context.\n    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    // if (this.attributes.aColor === -1){\n    //     this.attributes.aColor = 2;\n    // }\n\n    // End worst hack eva //\n};\n\n/**\n * Attaches the shaders and creates the program.\n *\n * @return {WebGLProgram}\n */\nShader.prototype.compile = function ()\n{\n    var gl = this.gl;\n\n    var glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexSrc);\n    var glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentSrc);\n\n    var program = gl.createProgram();\n\n    gl.attachShader(program, glVertShader);\n    gl.attachShader(program, glFragShader);\n    gl.linkProgram(program);\n\n    // if linking fails, then log and cleanup\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n    {\n        console.error('Pixi.js Error: Could not initialize shader.');\n        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));\n        console.error('gl.getError()', gl.getError());\n\n        // if there is a program info log, log it\n        if (gl.getProgramInfoLog(program) !== '')\n        {\n            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));\n        }\n\n        gl.deleteProgram(program);\n        program = null;\n    }\n\n    // clean up some shaders\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    return (this.program = program);\n};\n\n/*\nShader.prototype.buildSync = function ()\n{\n   // var str = \"\"\n\n   // str =  \"Shader.prototype.syncUniforms = function()\";\n   // str += \"{\\n\";\n\n    for (var key in this.uniforms)\n    {\n        var uniform = this.uniforms[key];\n\n        Object.defineProperty(this, key, {\n\n            get: function ()\n            {\n                return uniform.value\n            },\n            set: function (value)\n            {\n                this.setUniform(uniform, value);\n            }\n        });\n\n        console.log( makePropSetter( key, \" bloop\", uniform.type )  )\n  //      Object.def\n        //    location = uniform._location,\n          //  value = uniform.value,\n            //i, il;\n\n    //    str += \"gl.uniform1i(this.uniforms.\"+ key +\"._location, this.uniforms.\" + key + \".value );\\n\"\n\n    }\n\n}*/\n\n/**\n* Adds a new uniform\n*\n* @param uniform {object} the new uniform to attach\n*/\nShader.prototype.syncUniform = function (uniform)\n{\n    var location = uniform._location,\n        value = uniform.value,\n        gl = this.gl,\n        i, il;\n\n    switch (uniform.type)\n    {\n        case 'b':\n        case 'bool':\n        case 'boolean':\n            gl.uniform1i(location, value ? 1 : 0);\n            break;\n\n        // single int value\n        case 'i':\n        case '1i':\n            gl.uniform1i(location, value);\n            break;\n\n        // single float value\n        case 'f':\n        case '1f':\n            gl.uniform1f(location, value);\n            break;\n\n        // Float32Array(2) or JS Arrray\n        case '2f':\n            gl.uniform2f(location, value[0], value[1]);\n            break;\n\n        // Float32Array(3) or JS Arrray\n        case '3f':\n            gl.uniform3f(location, value[0], value[1], value[2]);\n            break;\n\n        // Float32Array(4) or JS Arrray\n        case '4f':\n            gl.uniform4f(location, value[0], value[1], value[2], value[3]);\n            break;\n\n        // a 2D Point object\n        case 'v2':\n            gl.uniform2f(location, value.x, value.y);\n            break;\n\n        // a 3D Point object\n        case 'v3':\n            gl.uniform3f(location, value.x, value.y, value.z);\n            break;\n\n        // a 4D Point object\n        case 'v4':\n            gl.uniform4f(location, value.x, value.y, value.z, value.w);\n            break;\n\n        // Int32Array or JS Array\n        case '1iv':\n            gl.uniform1iv(location, value);\n            break;\n\n        // Int32Array or JS Array\n        case '2iv':\n            gl.uniform2iv(location, value);\n            break;\n\n        // Int32Array or JS Array\n        case '3iv':\n            gl.uniform3iv(location, value);\n            break;\n\n        // Int32Array or JS Array\n        case '4iv':\n            gl.uniform4iv(location, value);\n            break;\n\n        // Float32Array or JS Array\n        case '1fv':\n            gl.uniform1fv(location, value);\n            break;\n\n        // Float32Array or JS Array\n        case '2fv':\n            gl.uniform2fv(location, value);\n            break;\n\n        // Float32Array or JS Array\n        case '3fv':\n            gl.uniform3fv(location, value);\n            break;\n\n        // Float32Array or JS Array\n        case '4fv':\n            gl.uniform4fv(location, value);\n            break;\n\n        // Float32Array or JS Array\n        case 'm2':\n        case 'mat2':\n        case 'Matrix2fv':\n            gl.uniformMatrix2fv(location, uniform.transpose, value);\n            break;\n\n        // Float32Array or JS Array\n        case 'm3':\n        case 'mat3':\n        case 'Matrix3fv':\n\n            gl.uniformMatrix3fv(location, uniform.transpose, value);\n            break;\n\n        // Float32Array or JS Array\n        case 'm4':\n        case 'mat4':\n        case 'Matrix4fv':\n            gl.uniformMatrix4fv(location, uniform.transpose, value);\n            break;\n\n        // a Color Value\n        case 'c':\n            if (typeof value === 'number')\n            {\n                value = utils.hex2rgb(value);\n            }\n\n            gl.uniform3f(location, value[0], value[1], value[2]);\n            break;\n\n        // flat array of integers (JS or typed array)\n        case 'iv1':\n            gl.uniform1iv(location, value);\n            break;\n\n        // flat array of integers with 3 x N size (JS or typed array)\n        case 'iv':\n            gl.uniform3iv(location, value);\n            break;\n\n        // flat array of floats (JS or typed array)\n        case 'fv1':\n            gl.uniform1fv(location, value);\n            break;\n\n        // flat array of floats with 3 x N size (JS or typed array)\n        case 'fv':\n            gl.uniform3fv(location, value);\n            break;\n\n        // array of 2D Point objects\n        case 'v2v':\n            if (!uniform._array)\n            {\n                uniform._array = new Float32Array(2 * value.length);\n            }\n\n            for (i = 0, il = value.length; i < il; ++i)\n            {\n                uniform._array[i * 2]       = value[i].x;\n                uniform._array[i * 2 + 1]   = value[i].y;\n            }\n\n            gl.uniform2fv(location, uniform._array);\n            break;\n\n        // array of 3D Point objects\n        case 'v3v':\n            if (!uniform._array)\n            {\n                uniform._array = new Float32Array(3 * value.length);\n            }\n\n            for (i = 0, il = value.length; i < il; ++i)\n            {\n                uniform._array[i * 3]       = value[i].x;\n                uniform._array[i * 3 + 1]   = value[i].y;\n                uniform._array[i * 3 + 2]   = value[i].z;\n\n            }\n\n            gl.uniform3fv(location, uniform._array);\n            break;\n\n        // array of 4D Point objects\n        case 'v4v':\n            if (!uniform._array)\n            {\n                uniform._array = new Float32Array(4 * value.length);\n            }\n\n            for (i = 0, il = value.length; i < il; ++i)\n            {\n                uniform._array[i * 4]       = value[i].x;\n                uniform._array[i * 4 + 1]   = value[i].y;\n                uniform._array[i * 4 + 2]   = value[i].z;\n                uniform._array[i * 4 + 3]   = value[i].w;\n\n            }\n\n            gl.uniform4fv(location, uniform._array);\n            break;\n\n        // PIXI.Texture\n        case 't':\n        case 'sampler2D':\n\n            if (!uniform.value || !uniform.value.baseTexture.hasLoaded)\n            {\n                break;\n            }\n\n            // activate this texture\n            gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n\n            var texture = uniform.value.baseTexture._glTextures[gl.id];\n\n            if (!texture)\n            {\n                this.initSampler2D(uniform);\n\n                // set the textur to the newly created one..\n                texture = uniform.value.baseTexture._glTextures[gl.id];\n            }\n\n            // bind the texture\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n\n            // set uniform to texture index\n            gl.uniform1i(uniform._location, this.textureCount);\n\n            // increment next texture id\n            this.textureCount++;\n\n            break;\n\n        default:\n            console.warn('Pixi.js Shader Warning: Unknown uniform type: ' + uniform.type);\n    }\n};\n\n/**\n * Updates the shader uniform values.\n *\n */\nShader.prototype.syncUniforms = function ()\n{\n    this.textureCount = 1;\n\n    for (var key in this.uniforms)\n    {\n        this.syncUniform(this.uniforms[key]);\n    }\n};\n\n\n/**\n * Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)\n *\n */\nShader.prototype.initSampler2D = function (uniform)\n{\n    var gl = this.gl;\n\n    var texture = uniform.value.baseTexture;\n\n    if(!texture.hasLoaded)\n    {\n        return;\n    }\n\n\n\n    if (uniform.textureData)\n    {\n\n        //TODO move this...\n        var data = uniform.textureData;\n\n        texture._glTextures[gl.id] = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\n        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);\n        // GLTextureLinear = mag/min linear, wrap clamp\n        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat\n        // GLTextureNearest = mag/min nearest, wrap clamp\n        // AudioTexture = whatever + luminance + width 512, height 2, border 0\n        // KeyTexture = whatever + luminance + width 256, height 2, border 0\n\n        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, data.luminance ? gl.LUMINANCE : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, data.magFilter ? data.magFilter : gl.LINEAR );\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE );\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE);\n    }\n    else\n    {\n        this.shaderManager.renderer.updateTexture(texture);\n    }\n};\n\n/**\n * Destroys the shader.\n *\n */\nShader.prototype.destroy = function ()\n{\n    this.gl.deleteProgram(this.program);\n\n    this.gl = null;\n    this.uniforms = null;\n    this.attributes = null;\n\n    this.vertexSrc = null;\n    this.fragmentSrc = null;\n};\n\nShader.prototype._glCompile = function (type, src)\n{\n    var shader = this.gl.createShader(type);\n\n    this.gl.shaderSource(shader, src);\n    this.gl.compileShader(shader);\n\n    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS))\n    {\n        console.log(this.gl.getShaderInfoLog(shader));\n        return null;\n    }\n\n    return shader;\n};\n\n},{\"../../../utils\":77}],62:[function(require,module,exports){\nvar Shader = require('./Shader');\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.\n * @param [vertexSrc] {string} The source of the vertex shader.\n * @param [fragmentSrc] {string} The source of the fragment shader.\n * @param [customUniforms] {object} Custom uniforms to use to augment the built-in ones.\n * @param [fragmentSrc] {string} The source of the fragment shader.\n */\nfunction TextureShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes)\n{\n    var uniforms = {\n\n        uSampler:           { type: 'sampler2D', value: 0 },\n        projectionMatrix:   { type: 'mat3', value: new Float32Array([1, 0, 0,\n                                                                     0, 1, 0,\n                                                                     0, 0, 1]) }\n    };\n\n    if (customUniforms)\n    {\n        for (var u in customUniforms)\n        {\n            uniforms[u] = customUniforms[u];\n        }\n    }\n\n\n    var attributes = {\n        aVertexPosition:    0,\n        aTextureCoord:      0,\n        aColor:             0\n    };\n\n    if (customAttributes)\n    {\n        for (var a in customAttributes)\n        {\n            attributes[a] = customAttributes[a];\n        }\n    }\n\n    /**\n     * The vertex shader.\n     *\n     * @member {string}\n     */\n    vertexSrc = vertexSrc || TextureShader.defaultVertexSrc;\n\n    /**\n     * The fragment shader.\n     *\n     * @member {string}\n     */\n    fragmentSrc = fragmentSrc || TextureShader.defaultFragmentSrc;\n\n    Shader.call(this, shaderManager, vertexSrc, fragmentSrc, uniforms, attributes);\n}\n\n// constructor\nTextureShader.prototype = Object.create(Shader.prototype);\nTextureShader.prototype.constructor = TextureShader;\nmodule.exports = TextureShader;\n\n/**\n * The default vertex shader source\n *\n * @static\n * @constant\n */\nTextureShader.defaultVertexSrc = [\n    'precision lowp float;',\n    'attribute vec2 aVertexPosition;',\n    'attribute vec2 aTextureCoord;',\n    'attribute vec4 aColor;',\n\n    'uniform mat3 projectionMatrix;',\n\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n\n    'void main(void){',\n    '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n    '   vTextureCoord = aTextureCoord;',\n    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',\n    '}'\n].join('\\n');\n\n/**\n * The default fragment shader source\n *\n * @static\n * @constant\n */\nTextureShader.defaultFragmentSrc = [\n    'precision lowp float;',\n\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n\n    'uniform sampler2D uSampler;',\n\n    'void main(void){',\n    '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n    '}'\n].join('\\n');\n\n},{\"./Shader\":61}],63:[function(require,module,exports){\nvar WebGLManager = require('../managers/WebGLManager');\n\n/**\n * Base for a common object renderer that can be used as a system renderer plugin.\n *\n * @class\n * @extends PIXI.WebGLManager\n * @memberof PIXI\n * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.\n */\nfunction ObjectRenderer(renderer)\n{\n    WebGLManager.call(this, renderer);\n}\n\n\nObjectRenderer.prototype = Object.create(WebGLManager.prototype);\nObjectRenderer.prototype.constructor = ObjectRenderer;\nmodule.exports = ObjectRenderer;\n\n/**\n * Starts the renderer and sets the shader\n *\n */\nObjectRenderer.prototype.start = function ()\n{\n    // set the shader..\n};\n\n/**\n * Stops the renderer\n *\n */\nObjectRenderer.prototype.stop = function ()\n{\n    this.flush();\n};\n\n/**\n * flushes\n *\n */\nObjectRenderer.prototype.flush = function ()\n{\n    // flush!\n};\n\n/**\n * Renders an object\n *\n * @param object {PIXI.DisplayObject} The object to render.\n */\nObjectRenderer.prototype.render = function (object) // jshint unused:false\n{\n    // render the object\n};\n\n},{\"../managers/WebGLManager\":58}],64:[function(require,module,exports){\n/**\n * Helper class to create a quad\n *\n * @class\n * @memberof PIXI\n * @param gl {WebGLRenderingContext} The gl context for this quad to use.\n */\nfunction Quad(gl)\n{\n    /*\n     * the current WebGL drawing context\n     *\n     * @member {WebGLRenderingContext}\n     */\n    this.gl = gl;\n\n//    this.textures = new TextureUvs();\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = new Float32Array([\n        0,0,\n        200,0,\n        200,200,\n        0,200\n    ]);\n\n    /**\n     * The Uvs of the quad\n     *\n     * @member {Float32Array}\n     */\n    this.uvs = new Float32Array([\n        0,0,\n        1,0,\n        1,1,\n        0,1\n    ]);\n\n//    var white = (0xFFFFFF >> 16) + (0xFFFFFF & 0xff00) + ((0xFFFFFF & 0xff) << 16) + (1 * 255 << 24);\n    //TODO convert this to a 32 unsigned int array\n    /**\n     * The color components of the triangles\n     *\n     * @member {Float32Array}\n     */\n    this.colors = new Float32Array([\n        1,1,1,1,\n        1,1,1,1,\n        1,1,1,1,\n        1,1,1,1\n    ]);\n\n    /*\n     * @member {Uint16Array} An array containing the indices of the vertices\n     */\n    this.indices = new Uint16Array([\n        0, 1, 2, 0, 3, 2\n    ]);\n\n    /*\n     * @member {WebGLBuffer} The vertex buffer\n     */\n    this.vertexBuffer = gl.createBuffer();\n\n    /*\n     * @member {WebGLBuffer} The index buffer\n     */\n    this.indexBuffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    this.upload();\n}\n\nQuad.prototype.constructor = Quad;\n\n/**\n * Maps two Rectangle to the quad\n * @param rect {PIXI.Rectangle} the first rectangle\n * @param rect2 {PIXI.Rectangle} the second rectangle\n */\nQuad.prototype.map = function(rect, rect2)\n{\n    var x = 0; //rect2.x / rect.width;\n    var y = 0; //rect2.y / rect.height;\n\n    this.uvs[0] = x;\n    this.uvs[1] = y;\n\n    this.uvs[2] = x + rect2.width / rect.width;\n    this.uvs[3] = y;\n\n    this.uvs[4] = x + rect2.width / rect.width;\n    this.uvs[5] = y + rect2.height / rect.height;\n\n    this.uvs[6] = x;\n    this.uvs[7] = y + rect2.height / rect.height;\n\n    /// -----\n    x = rect2.x;\n    y = rect2.y;\n\n    this.vertices[0] = x;\n    this.vertices[1] = y;\n\n    this.vertices[2] = x + rect2.width;\n    this.vertices[3] = y;\n\n    this.vertices[4] = x + rect2.width;\n    this.vertices[5] = y + rect2.height;\n\n    this.vertices[6] = x;\n    this.vertices[7] = y + rect2.height;\n\n    this.upload();\n};\n\n/**\n * Binds the buffer and uploads the data\n */\nQuad.prototype.upload = function()\n{\n    var gl = this.gl;\n\n    // TODO could probably be pushed into one upload!\n    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this.uvs);\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this.colors);\n};\n\nQuad.prototype.destroy = function()\n{\n    var gl = this.gl;\n    \n     gl.deleteBuffer(this.vertexBuffer);\n     gl.deleteBuffer(this.indexBuffer);\n};\n\nmodule.exports = Quad;\n\n\n\n},{}],65:[function(require,module,exports){\nvar math = require('../../../math'),\n    utils = require('../../../utils'),\n    CONST = require('../../../const'),\n    //StencilManager = require('../managers/StencilManager'),\n    StencilMaskStack = require('./StencilMaskStack');\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @class\n * @memberof PIXI\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\n * @param width {number} the horizontal range of the filter\n * @param height {number} the vertical range of the filter\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @param resolution {number} the current resolution\n * @param root {boolean} Whether this object is the root element or not\n */\nvar RenderTarget = function(gl, width, height, scaleMode, resolution, root)\n{\n    //TODO Resolution could go here ( eg low res blurs )\n\n    /**\n     * The current WebGL drawing context.\n     *\n     * @member {WebGLRenderingContext}\n     */\n    this.gl = gl;\n\n    // next time to create a frame buffer and texture\n\n    /**\n     * A frame buffer\n     *\n     * @member {WebGLFrameBuffer}\n     */\n    this.frameBuffer = null;\n\n    /**\n     * The texture\n     *\n     * @member {PIXI.Texture}\n     */\n    this.texture = null;\n\n    /**\n     * The size of the object as a rectangle\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.size = new math.Rectangle(0, 0, 1, 1);\n\n    /**\n     * The current resolution\n     *\n     * @member {number}\n     */\n    this.resolution = resolution || CONST.RESOLUTION;\n\n    /**\n     * The projection matrix\n     *\n     * @member {PIXI.Matrix}\n     */\n    this.projectionMatrix = new math.Matrix();\n\n    /**\n     * The object's transform\n     *\n     * @member {PIXI.Matrix}\n     */\n    this.transform = null;\n\n    /**\n     * The frame.\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.frame = null;\n\n    /**\n     * The stencil buffer stores masking data for the render target\n     *\n     * @member {WebGLRenderBuffer}\n     */\n    this.stencilBuffer = null;\n\n    /**\n     * The data structure for the stencil masks\n     *\n     * @member {PIXI.StencilMaskStack}\n     */\n    this.stencilMaskStack = new StencilMaskStack();\n\n    /**\n     * Stores filter data for the render target\n     *\n     * @member {object[]}\n     */\n    this.filterStack = [\n        {\n            renderTarget:this,\n            filter:[],\n            bounds:this.size\n        }\n    ];\n\n\n    /**\n     * The scale mode.\n     *\n     * @member {number}\n     * @default PIXI.SCALE_MODES.DEFAULT\n     * @see PIXI.SCALE_MODES\n     */\n    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n\n    /**\n     * Whether this object is the root element or not\n     *\n     * @member {boolean}\n     */\n    this.root = root;\n\n    if (!this.root)\n    {\n       // this.flipY = true;\n        this.frameBuffer = gl.createFramebuffer();\n\n        /*\n            A frame buffer needs a target to render to..\n            create a texture and bind it attach it to the framebuffer..\n         */\n\n        this.texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n\n        // set the scale properties of the texture..\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n        // check to see if the texture is a power of two!\n        var isPowerOfTwo = utils.isPowerOfTwo(width, height);\n\n        //TODO for 99% of use cases if a texture is power of two we should tile the texture...\n         if (!isPowerOfTwo)\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        }\n        else\n        {\n\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n        }\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n    }\n\n    this.resize(width, height);\n};\n\nRenderTarget.prototype.constructor = RenderTarget;\nmodule.exports = RenderTarget;\n\n/**\n * Clears the filter texture.\n *\n * @param [bind=false] {boolean} Should we bind our framebuffer before clearing?\n */\nRenderTarget.prototype.clear = function(bind)\n{\n    var gl = this.gl;\n    if(bind)\n    {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);\n    }\n\n    gl.clearColor(0,0,0,0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n};\n\n/**\n * Binds the stencil buffer.\n *\n */\nRenderTarget.prototype.attachStencilBuffer = function()\n{\n\n    if (this.stencilBuffer)\n    {\n        return;\n    }\n\n    /**\n     * The stencil buffer is used for masking in pixi\n     * lets create one and then add attach it to the framebuffer..\n     */\n    if (!this.root)\n    {\n        var gl = this.gl;\n\n        this.stencilBuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencilBuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.size.width * this.resolution  , this.size.height * this.resolution );\n    }\n};\n\n/**\n * Binds the buffers and initialises the viewport.\n *\n */\nRenderTarget.prototype.activate = function()\n{\n    //TOOD refactor usage of frame..\n    var gl = this.gl;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);\n\n    var projectionFrame = this.frame || this.size;\n\n    // TODO add a dirty flag to this of a setter for the frame?\n    this.calculateProjection( projectionFrame );\n\n    if(this.transform)\n    {\n        this.projectionMatrix.append(this.transform);\n    }\n\n    gl.viewport(0,0, projectionFrame.width * this.resolution, projectionFrame.height * this.resolution);\n};\n\n/**\n * Updates the projection matrix based on a projection frame (which is a rectangle)\n *\n */\nRenderTarget.prototype.calculateProjection = function (projectionFrame)\n{\n    var pm = this.projectionMatrix;\n\n    pm.identity();\n\n    if (!this.root)\n    {\n        pm.a = 1 / projectionFrame.width*2;\n        pm.d = 1 / projectionFrame.height*2;\n\n        pm.tx = -1 - projectionFrame.x * pm.a;\n        pm.ty = -1 - projectionFrame.y * pm.d;\n    }\n    else\n    {\n        pm.a = 1 / projectionFrame.width*2;\n        pm.d = -1 / projectionFrame.height*2;\n\n        pm.tx = -1 - projectionFrame.x * pm.a;\n        pm.ty = 1 - projectionFrame.y * pm.d;\n    }\n};\n\n\n/**\n * Resizes the texture to the specified width and height\n *\n * @param width {Number} the new width of the texture\n * @param height {Number} the new height of the texture\n */\nRenderTarget.prototype.resize = function (width, height)\n{\n    width = width | 0;\n    height = height | 0;\n\n    if (this.size.width === width && this.size.height === height) {\n        return;\n    }\n\n    this.size.width = width;\n    this.size.height = height;\n\n    if (!this.root)\n    {\n        var gl = this.gl;\n\n        gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width * this.resolution, height * this.resolution , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        if (this.stencilBuffer )\n        {\n            // update the stencil buffer width and height\n            gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  width * this.resolution, height * this.resolution );\n        }\n    }\n\n    var projectionFrame = this.frame || this.size;\n\n    this.calculateProjection( projectionFrame );\n};\n\n/**\n * Destroys the render target.\n *\n */\nRenderTarget.prototype.destroy = function ()\n{\n    var gl = this.gl;\n    gl.deleteRenderbuffer( this.stencilBuffer );\n    gl.deleteFramebuffer( this.frameBuffer );\n    gl.deleteTexture( this.texture );\n\n    this.frameBuffer = null;\n    this.texture = null;\n};\n\n},{\"../../../const\":22,\"../../../math\":33,\"../../../utils\":77,\"./StencilMaskStack\":66}],66:[function(require,module,exports){\n/**\n * Generic Mask Stack data structure\n * @class\n * @memberof PIXI\n */\nfunction StencilMaskStack()\n{\n\t/**\n     * The actual stack\n     *\n     * @member {any[]}\n     */\n    this.stencilStack = [];\n\n    /**\n     * TODO @alvin\n     *\n     * @member {boolean}\n     */\n    this.reverse = true;\n\n    /**\n     * Internal count\n     *\n     * @member {number}\n     */\n    this.count = 0;\n}\n\nStencilMaskStack.prototype.constructor = StencilMaskStack;\nmodule.exports = StencilMaskStack;\n\n},{}],67:[function(require,module,exports){\nvar math = require('../math'),\n    Texture = require('../textures/Texture'),\n    Container = require('../display/Container'),\n    CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),\n    utils = require('../utils'),\n    CONST = require('../const'),\n    tempPoint = new math.Point(),\n    GroupD8 = math.GroupD8,\n    canvasRenderWorldTransform = new math.Matrix();\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * var sprite = new PIXI.Sprite.fromImage('assets/image.png');\n * ```\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n * @param texture {PIXI.Texture} The texture for this sprite\n */\nfunction Sprite(texture)\n{\n    Container.call(this);\n\n    /**\n     * The anchor sets the origin point of the texture.\n     * The default is 0,0 this means the texture's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the texture's origin is centered\n     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point}\n     */\n    this.anchor = new math.Point();\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {PIXI.Texture}\n     * @private\n     */\n    this._texture = null;\n\n    /**\n     * The width of the sprite (this is initially set by the texture)\n     *\n     * @member {number}\n     * @private\n     */\n    this._width = 0;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     *\n     * @member {number}\n     * @private\n     */\n    this._height = 0;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     * @see PIXI.BLEND_MODES\n     */\n    this.blendMode = CONST.BLEND_MODES.NORMAL;\n\n    /**\n     * The shader that will be used to render the sprite. Set to null to remove a current shader.\n     *\n     * @member {PIXI.AbstractFilter|PIXI.Shader}\n     */\n    this.shader = null;\n\n    /**\n     * An internal cached value of the tint.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    this.cachedTint = 0xFFFFFF;\n\n    // call texture setter\n    this.texture = texture || Texture.EMPTY;\n}\n\n// constructor\nSprite.prototype = Object.create(Container.prototype);\nSprite.prototype.constructor = Sprite;\nmodule.exports = Sprite;\n\nObject.defineProperties(Sprite.prototype, {\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Sprite#\n     */\n    width: {\n        get: function ()\n        {\n            return Math.abs(this.scale.x) * this.texture._frame.width;\n        },\n        set: function (value)\n        {\n            var sign = utils.sign(this.scale.x) || 1;\n            this.scale.x = sign * value / this.texture._frame.width;\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Sprite#\n     */\n    height: {\n        get: function ()\n        {\n            return  Math.abs(this.scale.y) * this.texture._frame.height;\n        },\n        set: function (value)\n        {\n            var sign = utils.sign(this.scale.y) || 1;\n            this.scale.y = sign * value / this.texture._frame.height;\n            this._height = value;\n        }\n    },\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.Sprite#\n     */\n    texture: {\n        get: function ()\n        {\n            return  this._texture;\n        },\n        set: function (value)\n        {\n            if (this._texture === value)\n            {\n                return;\n            }\n\n            this._texture = value;\n            this.cachedTint = 0xFFFFFF;\n\n            if (value)\n            {\n                // wait for the texture to load\n                if (value.baseTexture.hasLoaded)\n                {\n                    this._onTextureUpdate();\n                }\n                else\n                {\n                    value.once('update', this._onTextureUpdate, this);\n                }\n            }\n        }\n    }\n});\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @private\n */\nSprite.prototype._onTextureUpdate = function ()\n{\n    // so if _width is 0 then width was not set..\n    if (this._width)\n    {\n        this.scale.x = utils.sign(this.scale.x) * this._width / this.texture.frame.width;\n    }\n\n    if (this._height)\n    {\n        this.scale.y = utils.sign(this.scale.y) * this._height / this.texture.frame.height;\n    }\n};\n\n/**\n*\n* Renders the object using the WebGL renderer\n*\n* @param renderer {PIXI.WebGLRenderer}\n* @private\n*/\nSprite.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render(this);\n};\n\n/**\n * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {PIXI.Matrix} the transformation matrix of the sprite\n * @return {PIXI.Rectangle} the framing rectangle\n */\nSprite.prototype.getBounds = function (matrix)\n{\n    if(!this._currentBounds)\n    {\n\n        var width = this._texture._frame.width;\n        var height = this._texture._frame.height;\n\n        var w0 = width * (1-this.anchor.x);\n        var w1 = width * -this.anchor.x;\n\n        var h0 = height * (1-this.anchor.y);\n        var h1 = height * -this.anchor.y;\n\n        var worldTransform = matrix || this.worldTransform ;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var minX,\n            maxX,\n            minY,\n            maxY;\n\n        //TODO - I am SURE this can be optimised, but the below is not accurate enough..\n        /*\n        if (b === 0 && c === 0)\n        {\n            // scale may be negative!\n            if (a < 0)\n            {\n                a *= -1;\n            }\n\n            if (d < 0)\n            {\n                d *= -1;\n            }\n\n            // this means there is no rotation going on right? RIGHT?\n            // if thats the case then we can avoid checking the bound values! yay\n            minX = a * w1 + tx;\n            maxX = a * w0 + tx;\n            minY = d * h1 + ty;\n            maxY = d * h0 + ty;\n        }\n        else\n        {\n        */\n\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 =  a * w1 + c * h0 + tx;\n        var y4 =  d * h0 + b * w1 + ty;\n\n        minX = x1;\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y1;\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x1;\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y1;\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n\n        //}\n\n        // check for children\n        if(this.children.length)\n        {\n            var childBounds = this.containerGetBounds();\n\n            w0 = childBounds.x;\n            w1 = childBounds.x + childBounds.width;\n            h0 = childBounds.y;\n            h1 = childBounds.y + childBounds.height;\n\n            minX = (minX < w0) ? minX : w0;\n            minY = (minY < h0) ? minY : h0;\n\n            maxX = (maxX > w1) ? maxX : w1;\n            maxY = (maxY > h1) ? maxY : h1;\n        }\n\n        var bounds = this._bounds;\n\n        bounds.x = minX;\n        bounds.width = maxX - minX;\n\n        bounds.y = minY;\n        bounds.height = maxY - minY;\n\n        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n        this._currentBounds = bounds;\n    }\n\n    return this._currentBounds;\n};\n\n/**\n * Gets the local bounds of the sprite object.\n *\n */\nSprite.prototype.getLocalBounds = function ()\n{\n    this._bounds.x = -this._texture._frame.width * this.anchor.x;\n    this._bounds.y = -this._texture._frame.height * this.anchor.y;\n    this._bounds.width = this._texture._frame.width;\n    this._bounds.height = this._texture._frame.height;\n    return this._bounds;\n};\n\n/**\n* Tests if a point is inside this sprite\n*\n* @param point {PIXI.Point} the point to test\n* @return {boolean} the result of the test\n*/\nSprite.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var width = this._texture._frame.width;\n    var height = this._texture._frame.height;\n    var x1 = -width * this.anchor.x;\n    var y1;\n\n    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )\n    {\n        y1 = -height * this.anchor.y;\n\n        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @param renderer {PIXI.CanvasRenderer} The renderer\n* @private\n*/\nSprite.prototype._renderCanvas = function (renderer)\n{\n    if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0)\n    {\n        return;\n    }\n\n    var compositeOperation = renderer.blendModes[this.blendMode];\n    if (compositeOperation !== renderer.context.globalCompositeOperation)\n    {\n        renderer.context.globalCompositeOperation = compositeOperation;\n    }\n\n    //  Ignore null sources\n    if (this.texture.valid)\n    {\n        var texture = this._texture,\n            wt = this.worldTransform,\n            dx,\n            dy,\n            width = texture.crop.width,\n            height = texture.crop.height;\n\n        renderer.context.globalAlpha = this.worldAlpha;\n\n        // If smoothingEnabled is supported and we need to change the smoothing property for this texture\n        var smoothingEnabled = texture.baseTexture.scaleMode === CONST.SCALE_MODES.LINEAR;\n        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)\n        {\n            renderer.context[renderer.smoothProperty] = smoothingEnabled;\n        }\n\n        //inline GroupD8.isSwapWidthHeight\n        if ((texture.rotate & 3) === 2) {\n            width = texture.crop.height;\n            height = texture.crop.width;\n        }\n        if (texture.trim) {\n            dx = texture.crop.width/2 + texture.trim.x - this.anchor.x * texture.trim.width;\n            dy = texture.crop.height/2 + texture.trim.y - this.anchor.y * texture.trim.height;\n        } else {\n            dx = (0.5 - this.anchor.x) * texture._frame.width;\n            dy = (0.5 - this.anchor.y) * texture._frame.height;\n        }\n        if(texture.rotate) {\n            wt.copy(canvasRenderWorldTransform);\n            wt = canvasRenderWorldTransform;\n            GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n            // the anchor has already been applied above, so lets set it to zero\n            dx = 0;\n            dy = 0;\n        }\n        dx -= width/2;\n        dy -= height/2;\n        // Allow for pixel rounding\n        if (renderer.roundPixels)\n        {\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                (wt.tx * renderer.resolution) | 0,\n                (wt.ty * renderer.resolution) | 0\n            );\n\n            dx = dx | 0;\n            dy = dy | 0;\n        }\n        else\n        {\n\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n\n\n        }\n\n        var resolution = texture.baseTexture.resolution;\n\n        if (this.tint !== 0xFFFFFF)\n        {\n            if (this.cachedTint !== this.tint)\n            {\n                this.cachedTint = this.tint;\n\n                // TODO clean up caching - how to clean up the caches?\n                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n            }\n\n            renderer.context.drawImage(\n                this.tintedTexture,\n                0,\n                0,\n                width * resolution,\n                height * resolution,\n                dx * renderer.resolution,\n                dy * renderer.resolution,\n                width * renderer.resolution,\n                height * renderer.resolution\n            );\n        }\n        else\n        {\n            renderer.context.drawImage(\n                texture.baseTexture.source,\n                texture.crop.x * resolution,\n                texture.crop.y * resolution,\n                width * resolution,\n                height * resolution,\n                dx  * renderer.resolution,\n                dy  * renderer.resolution,\n                width * renderer.resolution,\n                height * renderer.resolution\n            );\n        }\n    }\n};\n\n/**\n * Destroys this sprite and optionally its texture\n *\n * @param [destroyTexture=false] {boolean} Should it destroy the current texture of the sprite as well\n * @param [destroyBaseTexture=false] {boolean} Should it destroy the base texture of the sprite as well\n */\nSprite.prototype.destroy = function (destroyTexture, destroyBaseTexture)\n{\n    Container.prototype.destroy.call(this);\n\n    this.anchor = null;\n\n    if (destroyTexture)\n    {\n        this._texture.destroy(destroyBaseTexture);\n    }\n\n    this._texture = null;\n    this.shader = null;\n};\n\n// some helper functions..\n\n/**\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {string} The frame Id of the texture in the cache\n * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter\n * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId\n */\nSprite.fromFrame = function (frameId)\n{\n    var texture = utils.TextureCache[frameId];\n\n    if (!texture)\n    {\n        throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n    }\n\n    return new Sprite(texture);\n};\n\n/**\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @static\n * @param imageId {string} The image url of the texture\n * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id\n */\nSprite.fromImage = function (imageId, crossorigin, scaleMode)\n{\n    return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));\n};\n\n},{\"../const\":22,\"../display/Container\":23,\"../math\":33,\"../renderers/canvas/utils/CanvasTinter\":48,\"../textures/Texture\":72,\"../utils\":77}],68:[function(require,module,exports){\nvar ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),\n    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),\n    CONST = require('../../const');\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's SpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction SpriteRenderer(renderer)\n{\n    ObjectRenderer.call(this, renderer);\n\n    /**\n     * Number of values sent in the vertex buffer.\n     * positionX, positionY, colorR, colorG, colorB = 5\n     *\n     * @member {number}\n     */\n    this.vertSize = 5;\n\n    /**\n     * The size of the vertex information in bytes.\n     *\n     * @member {number}\n     */\n    this.vertByteSize = this.vertSize * 4;\n\n    /**\n     * The number of images in the SpriteBatch before it flushes.\n     *\n     * @member {number}\n     */\n    this.size = CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n    // the total number of bytes in our batch\n    var numVerts = (this.size * 4) * this.vertByteSize;\n\n    // the total number of indices in our batch, there are 6 points per quad.\n    var numIndices = this.size * 6;\n\n    /**\n     * Holds the vertex data that will be sent to the vertex shader.\n     *\n     * @member {ArrayBuffer}\n     */\n    this.vertices = new ArrayBuffer(numVerts);\n\n    /**\n     * View on the vertices as a Float32Array for positions\n     *\n     * @member {Float32Array}\n     */\n    this.positions = new Float32Array(this.vertices);\n\n    /**\n     * View on the vertices as a Uint32Array for colors\n     *\n     * @member {Uint32Array}\n     */\n    this.colors = new Uint32Array(this.vertices);\n\n    /**\n     * Holds the indices of the geometry (quads) to draw\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    // fill the indices with the quads to draw\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * The current size of the batch, each render() call adds to this number.\n     *\n     * @member {number}\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * The current sprites in the batch.\n     *\n     * @member {PIXI.Sprite[]}\n     */\n    this.sprites = [];\n\n    /**\n     * The default shader that is used if a sprite doesn't have a more specific one.\n     *\n     * @member {PIXI.Shader}\n     */\n    this.shader = null;\n}\n\nSpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);\nSpriteRenderer.prototype.constructor = SpriteRenderer;\nmodule.exports = SpriteRenderer;\n\nWebGLRenderer.registerPlugin('sprite', SpriteRenderer);\n\n/**\n * Sets up the renderer context and necessary buffers.\n *\n * @private\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\n */\nSpriteRenderer.prototype.onContextChange = function ()\n{\n    var gl = this.renderer.gl;\n\n    // setup default shader\n    this.shader = this.renderer.shaderManager.defaultShader;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n};\n\n/**\n * Renders the sprite object.\n *\n * @param sprite {PIXI.Sprite} the sprite to render when using this spritebatch\n */\nSpriteRenderer.prototype.render = function (sprite)\n{\n    var texture = sprite._texture;\n\n    //TODO set blend modes..\n    // check texture..\n    if (this.currentBatchSize >= this.size)\n    {\n        this.flush();\n    }\n\n    // get the uvs for the texture\n    var uvs = texture._uvs;\n\n    // if the uvs have not updated then no point rendering just yet!\n    if (!uvs)\n    {\n        return;\n    }\n\n    // TODO trim??\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n\n    var w0, w1, h0, h1;\n\n    if (texture.trim && sprite.tileScale === undefined)\n    {\n        // if the sprite is trimmed and is not a tilingsprite then we need to add the extra space before transforming the sprite coords..\n        var trim = texture.trim;\n\n        w1 = trim.x - aX * trim.width;\n        w0 = w1 + texture.crop.width;\n\n        h1 = trim.y - aY * trim.height;\n        h0 = h1 + texture.crop.height;\n\n    }\n    else\n    {\n        w0 = (texture._frame.width ) * (1-aX);\n        w1 = (texture._frame.width ) * -aX;\n\n        h0 = texture._frame.height * (1-aY);\n        h1 = texture._frame.height * -aY;\n    }\n\n    var index = this.currentBatchSize * this.vertByteSize;\n\n    var worldTransform = sprite.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var colors = this.colors;\n    var positions = this.positions;\n\n    if (this.renderer.roundPixels)\n    {\n        var resolution = this.renderer.resolution;\n\n        // xy\n        positions[index] = (((a * w1 + c * h1 + tx) * resolution) | 0) / resolution;\n        positions[index+1] = (((d * h1 + b * w1 + ty) * resolution) | 0) / resolution;\n\n        // xy\n        positions[index+5] = (((a * w0 + c * h1 + tx) * resolution) | 0) / resolution;\n        positions[index+6] = (((d * h1 + b * w0 + ty) * resolution) | 0) / resolution;\n\n         // xy\n        positions[index+10] = (((a * w0 + c * h0 + tx) * resolution) | 0) / resolution;\n        positions[index+11] = (((d * h0 + b * w0 + ty) * resolution) | 0) / resolution;\n\n        // xy\n        positions[index+15] = (((a * w1 + c * h0 + tx) * resolution) | 0) / resolution;\n        positions[index+16] = (((d * h0 + b * w1 + ty) * resolution) | 0) / resolution;\n    }\n    else\n    {\n\n        // xy\n        positions[index] = a * w1 + c * h1 + tx;\n        positions[index+1] = d * h1 + b * w1 + ty;\n\n        // xy\n        positions[index+5] = a * w0 + c * h1 + tx;\n        positions[index+6] = d * h1 + b * w0 + ty;\n\n         // xy\n        positions[index+10] = a * w0 + c * h0 + tx;\n        positions[index+11] = d * h0 + b * w0 + ty;\n\n        // xy\n        positions[index+15] = a * w1 + c * h0 + tx;\n        positions[index+16] = d * h0 + b * w1 + ty;\n    }\n\n    // uv\n    positions[index+2] = uvs.x0;\n    positions[index+3] = uvs.y0;\n\n    // uv\n    positions[index+7] = uvs.x1;\n    positions[index+8] = uvs.y1;\n\n     // uv\n    positions[index+12] = uvs.x2;\n    positions[index+13] = uvs.y2;\n\n    // uv\n    positions[index+17] = uvs.x3;\n    positions[index+18] = uvs.y3;\n\n    // color and alpha\n    var tint = sprite.tint;\n    colors[index+4] = colors[index+9] = colors[index+14] = colors[index+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);\n\n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = sprite;\n};\n\n/**\n * Renders the content and empties the current batch.\n *\n */\nSpriteRenderer.prototype.flush = function ()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize === 0)\n    {\n        return;\n    }\n\n    var gl = this.renderer.gl;\n    var shader;\n\n    // upload the verts to the buffer\n    if (this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n    var nextTexture, nextBlendMode, nextShader;\n    var batchSize = 0;\n    var start = 0;\n\n    var currentBaseTexture = null;\n    var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;\n    var currentShader = null;\n\n    var blendSwap = false;\n    var shaderSwap = false;\n    var sprite;\n\n    for (var i = 0, j = this.currentBatchSize; i < j; i++)\n    {\n\n        sprite = this.sprites[i];\n\n        nextTexture = sprite._texture.baseTexture;\n        nextBlendMode = sprite.blendMode;\n        nextShader = sprite.shader || this.shader;\n\n        blendSwap = currentBlendMode !== nextBlendMode;\n        shaderSwap = currentShader !== nextShader; // should I use uidS???\n\n        if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap)\n        {\n            this.renderBatch(currentBaseTexture, batchSize, start);\n\n            start = i;\n            batchSize = 0;\n            currentBaseTexture = nextTexture;\n\n            if (blendSwap)\n            {\n                currentBlendMode = nextBlendMode;\n                this.renderer.blendModeManager.setBlendMode( currentBlendMode );\n            }\n\n            if (shaderSwap)\n            {\n                currentShader = nextShader;\n\n\n\n                shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;\n\n                if (!shader)\n                {\n                    shader = currentShader.getShader(this.renderer);\n\n                }\n\n                // set shader function???\n                this.renderer.shaderManager.setShader(shader);\n\n                //TODO - i KNOW this can be optimised! Once v3 is stable il look at this next...\n                shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);\n                //Make this a little more dynamic / intelligent!\n                shader.syncUniforms();\n\n                //TODO investigate some kind of texture state managment??\n                // need to make sure this texture is the active one for all the batch swaps..\n                gl.activeTexture(gl.TEXTURE0);\n\n                // both thease only need to be set if they are changing..\n                // set the projection\n                //gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));\n\n\n            }\n        }\n\n        batchSize++;\n    }\n\n    this.renderBatch(currentBaseTexture, batchSize, start);\n\n    // then reset the batch!\n    this.currentBatchSize = 0;\n};\n\n/**\n * Draws the currently batches sprites.\n *\n * @private\n * @param texture {PIXI.Texture}\n * @param size {number}\n * @param startIndex {number}\n */\nSpriteRenderer.prototype.renderBatch = function (texture, size, startIndex)\n{\n    if (size === 0)\n    {\n        return;\n    }\n\n    var gl = this.renderer.gl;\n\n    if (!texture._glTextures[gl.id])\n    {\n        this.renderer.updateTexture(texture);\n    }\n    else\n    {\n        // bind the current texture\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n    }\n\n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);\n\n    // increment the draw count\n    this.renderer.drawCount++;\n};\n\n/**\n * Starts a new sprite batch.\n *\n */\nSpriteRenderer.prototype.start = function ()\n{\n    var gl = this.renderer.gl;\n\n    // bind the main texture\n\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // this is the same for each shader?\n    var stride =  this.vertByteSize;\n    gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n\n    // color attributes will be interpreted as unsigned bytes and normalized\n    gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);\n};\n\n/**\n * Destroys the SpriteBatch.\n *\n */\nSpriteRenderer.prototype.destroy = function ()\n{\n    this.renderer.gl.deleteBuffer(this.vertexBuffer);\n    this.renderer.gl.deleteBuffer(this.indexBuffer);\n\n    ObjectRenderer.prototype.destroy.call(this);\n\n    this.shader.destroy();\n\n    this.renderer = null;\n\n    this.vertices = null;\n    this.positions = null;\n    this.colors = null;\n    this.indices = null;\n\n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n\n    this.sprites = null;\n    this.shader = null;\n};\n\n},{\"../../const\":22,\"../../renderers/webgl/WebGLRenderer\":49,\"../../renderers/webgl/utils/ObjectRenderer\":63}],69:[function(require,module,exports){\nvar Sprite = require('../sprites/Sprite'),\n    Texture = require('../textures/Texture'),\n    math = require('../math'),\n    utils = require('../utils'),\n    CONST = require('../const');\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object\n *\n * ```js\n * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n * @param text {string} The copy that you would like the text to display\n * @param [style] {object} The style parameters\n * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true\n * @param [style.letterSpacing=0] {number} The amount of spacing between letters, default is 0\n * @param [style.breakWords=false] {boolean} Indicates if lines can be wrapped within words, it needs wordWrap to be set to true\n * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius\n * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n *      prevent this from happening by adding padding to the top and bottom of text height.\n * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n *      spiked text issues. Default is 'miter' (creates a sharp corner).\n * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n *      or increase the spikiness of rendered text.\n */\nfunction Text(text, style, resolution)\n{\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @member {HTMLCanvasElement}\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @member {HTMLCanvasElement}\n     */\n    this.context = this.canvas.getContext('2d');\n\n    /**\n     * The resolution of the canvas.\n     * @member {number}\n     */\n    this.resolution = resolution || CONST.RESOLUTION;\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n    this._text = null;\n\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n    this._style = null;\n\n    var texture = Texture.fromCanvas(this.canvas);\n    texture.trim = new math.Rectangle();\n    Sprite.call(this, texture);\n\n    this.text = text;\n    this.style = style;\n}\n\n// constructor\nText.prototype = Object.create(Sprite.prototype);\nText.prototype.constructor = Text;\nmodule.exports = Text;\n\nText.fontPropertiesCache = {};\nText.fontPropertiesCanvas = document.createElement('canvas');\nText.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');\n\nObject.defineProperties(Text.prototype, {\n    /**\n     * The width of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Text#\n     */\n    width: {\n        get: function ()\n        {\n            if (this.dirty)\n            {\n                this.updateText();\n            }\n\n            return this.scale.x * this._texture._frame.width;\n        },\n        set: function (value)\n        {\n            this.scale.x = value / this._texture._frame.width;\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Text#\n     */\n    height: {\n        get: function ()\n        {\n            if (this.dirty)\n            {\n                this.updateText();\n            }\n\n            return  this.scale.y * this._texture._frame.height;\n        },\n        set: function (value)\n        {\n            this.scale.y = value / this._texture._frame.height;\n            this._height = value;\n        }\n    },\n\n    /**\n     * Set the style of the text\n     *\n     * @param [style] {object} The style parameters\n     * @param [style.font='bold 20pt Arial'] {string} The style and size of the font\n     * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n     * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n     * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n     * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n     * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n     * @param [style.wordWrapWidth=100] {number} The width at which text will wrap\n     * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n     * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n     * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n     * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow\n     * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n     * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius\n     * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n     *      prevent this from happening by adding padding to the top and bottom of text height.\n     * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n     * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n     *      spiked text issues. Default is 'miter' (creates a sharp corner).\n     * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n     *      or increase the spikiness of rendered text.\n     * @memberof PIXI.Text#\n     */\n    style: {\n        get: function ()\n        {\n            return this._style;\n        },\n        set: function (style)\n        {\n            style = style || {};\n\n            if (typeof style.fill === 'number') {\n                style.fill = utils.hex2string(style.fill);\n            }\n\n            if (typeof style.stroke === 'number') {\n                style.stroke = utils.hex2string(style.stroke);\n            }\n\n            if (typeof style.dropShadowColor === 'number') {\n                style.dropShadowColor = utils.hex2string(style.dropShadowColor);\n            }\n\n            style.font = style.font || 'bold 20pt Arial';\n            style.fill = style.fill || 'black';\n            style.align = style.align || 'left';\n            style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/pixijs/pixi.js/issues/136\n            style.strokeThickness = style.strokeThickness || 0;\n            style.wordWrap = style.wordWrap || false;\n            style.wordWrapWidth = style.wordWrapWidth || 100;\n            style.breakWords = style.breakWords || false;\n            style.letterSpacing = style.letterSpacing || 0;\n\n            style.dropShadow = style.dropShadow || false;\n            style.dropShadowColor = style.dropShadowColor || '#000000';\n            style.dropShadowAngle = style.dropShadowAngle !== undefined ? style.dropShadowAngle : Math.PI / 6;\n            style.dropShadowDistance = style.dropShadowDistance !== undefined ? style.dropShadowDistance : 5;\n            style.dropShadowBlur = style.dropShadowBlur !== undefined ? style.dropShadowBlur : 0; //shadowBlur is '0' by default according to HTML\n\n            style.padding = style.padding || 0;\n\n            style.textBaseline = style.textBaseline || 'alphabetic';\n\n            style.lineJoin = style.lineJoin || 'miter';\n            style.miterLimit = style.miterLimit || 10;\n\n            this._style = style;\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @param text {string} The copy that you would like the text to display\n     * @memberof PIXI.Text#\n     */\n    text: {\n        get: function()\n        {\n            return this._text;\n        },\n        set: function (text){\n            text = text.toString() || ' ';\n            if (this._text === text)\n            {\n                return;\n            }\n            this._text = text;\n            this.dirty = true;\n        }\n    }\n});\n\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\nText.prototype.updateText = function ()\n{\n    var style = this._style;\n    this.context.font = style.font;\n\n    // word wrap\n    // preserve original text\n    var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;\n\n    // split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    // calculate text width\n    var lineWidths = new Array(lines.length);\n    var maxLineWidth = 0;\n    var fontProperties = this.determineFontProperties(style.font);\n    for (var i = 0; i < lines.length; i++)\n    {\n        var lineWidth = this.context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    var width = maxLineWidth + style.strokeThickness;\n    if (style.dropShadow)\n    {\n        width += style.dropShadowDistance;\n    }\n\n    this.canvas.width = Math.ceil( ( width + this.context.lineWidth ) * this.resolution );\n\n    // calculate text height\n    var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n\n    var height = lineHeight * lines.length;\n    if (style.dropShadow)\n    {\n        height += style.dropShadowDistance;\n    }\n\n    this.canvas.height = Math.ceil( ( height + this._style.padding * 2 ) * this.resolution );\n\n    this.context.scale( this.resolution, this.resolution);\n\n    if (navigator.isCocoonJS)\n    {\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    }\n\n    //this.context.fillStyle=\"#FF0000\";\n    //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.context.font = style.font;\n    this.context.strokeStyle = style.stroke;\n    this.context.lineWidth = style.strokeThickness;\n    this.context.textBaseline = style.textBaseline;\n    this.context.lineJoin = style.lineJoin;\n    this.context.miterLimit = style.miterLimit;\n\n    var linePositionX;\n    var linePositionY;\n\n    if (style.dropShadow)\n    {\n        if (style.dropShadowBlur > 0) {\n            this.context.shadowColor = style.dropShadowColor;\n            this.context.shadowBlur = style.dropShadowBlur;\n        } else {\n            this.context.fillStyle = style.dropShadowColor;\n        }\n\n        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n        for (i = 0; i < lines.length; i++)\n        {\n            linePositionX = style.strokeThickness / 2;\n            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n            if (style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if (style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if (style.fill)\n            {\n                this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + style.padding);\n            }\n        }\n    }\n\n    //set canvas text styles\n    this.context.fillStyle = style.fill;\n\n    //draw lines line by line\n    for (i = 0; i < lines.length; i++)\n    {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n        if (style.align === 'right')\n        {\n            linePositionX += maxLineWidth - lineWidths[i];\n        }\n        else if (style.align === 'center')\n        {\n            linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if (style.stroke && style.strokeThickness)\n        {\n            this.drawLetterSpacing(lines[i], linePositionX, linePositionY + style.padding, true);\n        }\n\n        if (style.fill)\n        {\n            this.drawLetterSpacing(lines[i], linePositionX, linePositionY + style.padding);\n        }\n    }\n\n    this.updateTexture();\n};\n\n/**\n * Render the text with letter-spacing.\n *\n * @private\n */\nText.prototype.drawLetterSpacing = function(text, x, y, isStroke)\n{\n    var style = this._style;\n\n    // letterSpacing of 0 means normal\n    var letterSpacing = style.letterSpacing;\n\n    if (letterSpacing === 0)\n    {\n        if (isStroke)\n        {\n            this.context.strokeText(text, x, y);\n        }\n        else\n        {\n            this.context.fillText(text, x, y);\n        }\n        return;\n    }\n\n    var characters = String.prototype.split.call(text, ''),\n        index = 0,\n        current,\n        currentPosition = x;\n\n    while (index < text.length)\n    {\n        current = characters[index++];\n        if (isStroke) \n        {\n            this.context.strokeText(current, currentPosition, y);\n        }\n        else\n        {\n            this.context.fillText(current, currentPosition, y);\n        }\n        currentPosition += this.context.measureText(current).width + letterSpacing;\n    }\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\nText.prototype.updateTexture = function ()\n{\n    var texture = this._texture;\n    var style = this._style;\n\n    texture.baseTexture.hasLoaded = true;\n    texture.baseTexture.resolution = this.resolution;\n\n    texture.baseTexture.width = this.canvas.width / this.resolution;\n    texture.baseTexture.height = this.canvas.height / this.resolution;\n    texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;\n    texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;\n\n    texture.trim.x = 0;\n    texture.trim.y = -style.padding;\n\n    texture.trim.width = texture._frame.width;\n    texture.trim.height = texture._frame.height - style.padding*2;\n\n    this._width = this.canvas.width / this.resolution;\n    this._height = this.canvas.height / this.resolution;\n\n    texture.baseTexture.emit('update',  texture.baseTexture);\n\n    this.dirty = false;\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer}\n */\nText.prototype.renderWebGL = function (renderer)\n{\n    if (this.dirty)\n    {\n        //this.resolution = 1//renderer.resolution;\n\n        this.updateText();\n    }\n\n    Sprite.prototype.renderWebGL.call(this, renderer);\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {PIXI.CanvasRenderer}\n * @private\n */\nText.prototype._renderCanvas = function (renderer)\n{\n    if (this.dirty)\n    {\n     //   this.resolution = 1//renderer.resolution;\n\n        this.updateText();\n    }\n\n    Sprite.prototype._renderCanvas.call(this, renderer);\n};\n\n/**\n * Calculates the ascent, descent and fontSize of a given fontStyle\n *\n * @param fontStyle {object}\n * @private\n */\nText.prototype.determineFontProperties = function (fontStyle)\n{\n    var properties = Text.fontPropertiesCache[fontStyle];\n\n    if (!properties)\n    {\n        properties = {};\n\n        var canvas = Text.fontPropertiesCanvas;\n        var context = Text.fontPropertiesContext;\n\n        context.font = fontStyle;\n\n        var width = Math.ceil(context.measureText('|M  q').width);\n        var baseline = Math.ceil(context.measureText('M').width);\n        var height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = fontStyle;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|M  q', 0, baseline);\n\n        var imagedata = context.getImageData(0, 0, width, height).data;\n        var pixels = imagedata.length;\n        var line = width * 4;\n\n        var i, j;\n\n        var idx = 0;\n        var stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; i++)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; i--)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        Text.fontPropertiesCache[fontStyle] = properties;\n    }\n\n    return properties;\n};\n\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @param text {string}\n * @private\n */\nText.prototype.wordWrap = function (text)\n{\n    // Greedy wrapping algorithm that will wrap words as the line grows longer\n    // than its horizontal bounds.\n    var result = '';\n    var lines = text.split('\\n');\n    var wordWrapWidth = this._style.wordWrapWidth;\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = wordWrapWidth;\n        var words = lines[i].split(' ');\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            if (this._style.breakWords && wordWidth > wordWrapWidth) \n            {\n                // Word should be split in the middle\n                var characters = words[j].split('');\n                for (var c = 0; c < characters.length; c++) \n                {\n                  var characterWidth = this.context.measureText(characters[c]).width;\n                  if (characterWidth > spaceLeft) \n                  {\n                    result += '\\n' + characters[c];\n                    spaceLeft = wordWrapWidth - characterWidth;\n                  } \n                  else \n                  {\n                    if (c === 0) \n                    {\n                      result += ' ';\n                    }\n                    result += characters[c];\n                    spaceLeft -= characterWidth;\n                  }\n                }\n            }\n            else \n            {\n                var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n                if (j === 0 || wordWidthWithSpace > spaceLeft)\n                {\n                    // Skip printing the newline if it's the first word of the line that is\n                    // greater than the word wrap width.\n                    if (j > 0)\n                    {\n                        result += '\\n';\n                    }\n                    result += words[j];\n                    spaceLeft = wordWrapWidth - wordWidth;\n                }\n                else\n                {\n                    spaceLeft -= wordWidthWithSpace;\n                    result += ' ' + words[j];\n                }\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n    return result;\n};\n\n/**\n * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {PIXI.Matrix} the transformation matrix of the Text\n * @return {PIXI.Rectangle} the framing rectangle\n */\nText.prototype.getBounds = function (matrix)\n{\n    if (this.dirty)\n    {\n        this.updateText();\n    }\n\n    return Sprite.prototype.getBounds.call(this, matrix);\n};\n\n/**\n * Destroys this text object.\n *\n * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well\n */\nText.prototype.destroy = function (destroyBaseTexture)\n{\n    // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n    this.context = null;\n    this.canvas = null;\n\n    this._style = null;\n\n    this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);\n};\n\n},{\"../const\":22,\"../math\":33,\"../sprites/Sprite\":67,\"../textures/Texture\":72,\"../utils\":77}],70:[function(require,module,exports){\nvar utils = require('../utils'),\n    CONST = require('../const'),\n    EventEmitter = require('eventemitter3');\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class\n * @memberof PIXI\n * @param source {Image|Canvas} the source object of the texture.\n * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values\n * @param resolution {number} the resolution of the texture for devices with different pixel ratios\n */\nfunction BaseTexture(source, scaleMode, resolution)\n{\n    EventEmitter.call(this);\n\n    this.uid = utils.uid();\n\n    /**\n     * The Resolution of the texture.\n     *\n     * @member {number}\n     */\n    this.resolution = resolution || 1;\n\n    /**\n     * The width of the base texture set when the image has loaded\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * The height of the base texture set when the image has loaded\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.height = 100;\n\n    // TODO docs\n    // used to store the actual dimensions of the source\n    /**\n     * Used to store the actual width of the source of this texture\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.realWidth = 100;\n    /**\n     * Used to store the actual height of the source of this texture\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.realHeight = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     *\n     * @member {number}\n     * @default PIXI.SCALE_MODES.LINEAR\n     * @see PIXI.SCALE_MODES\n     */\n    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n\n    /**\n     * Set to true once the base texture has successfully loaded.\n     *\n     * This is never true if the underlying source fails to load or has no texture data.\n     *\n     * @member {boolean}\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * Set to true if the source is currently loading.\n     *\n     * If an Image source is loading the 'loaded' or 'error' event will be\n     * dispatched when the operation ends. An underyling source that is\n     * immediately-available bypasses loading entirely.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    this.isLoading = false;\n\n    /**\n     * The image source that is used to create the texture.\n     *\n     * TODO: Make this a setter that calls loadSource();\n     *\n     * @member {Image|Canvas}\n     * @readonly\n     */\n    this.source = null; // set in loadSource, if at all\n\n    /**\n     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n     * All blend modes, and shaders written for default value. Change it on your own risk.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.premultipliedAlpha = true;\n\n    /**\n     * @member {string}\n     */\n    this.imageUrl = null;\n\n    /**\n     * Wether or not the texture is a power of two, try to use power of two textures as much as you can\n     * @member {boolean}\n     * @private\n     */\n    this.isPowerOfTwo = false;\n\n    // used for webGL\n\n    /**\n     *\n     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used\n     * Also the texture must be a power of two size to work\n     *\n     * @member {boolean}\n     */\n    this.mipmap = false;\n\n    /**\n     * A map of renderer IDs to webgl textures\n     *\n     * @member {object<number, WebGLTexture>}\n     * @private\n     */\n    this._glTextures = {};\n\n    // if no source passed don't try to load\n    if (source)\n    {\n        this.loadSource(source);\n    }\n\n    /**\n     * Fired when a not-immediately-available source finishes loading.\n     *\n     * @event loaded\n     * @memberof PIXI.BaseTexture#\n     * @protected\n     */\n\n    /**\n     * Fired when a not-immediately-available source fails to load.\n     *\n     * @event error\n     * @memberof PIXI.BaseTexture#\n     * @protected\n     */\n}\n\nBaseTexture.prototype = Object.create(EventEmitter.prototype);\nBaseTexture.prototype.constructor = BaseTexture;\nmodule.exports = BaseTexture;\n\n/**\n * Updates the texture on all the webgl renderers, this also assumes the src has changed.\n *\n * @fires update\n */\nBaseTexture.prototype.update = function ()\n{\n    this.realWidth = this.source.naturalWidth || this.source.width;\n    this.realHeight = this.source.naturalHeight || this.source.height;\n\n    this.width = this.realWidth / this.resolution;\n    this.height = this.realHeight / this.resolution;\n\n    this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);\n\n    this.emit('update', this);\n};\n\n/**\n * Load a source.\n *\n * If the source is not-immediately-available, such as an image that needs to be\n * downloaded, then the 'loaded' or 'error' event will be dispatched in the future\n * and `hasLoaded` will remain false after this call.\n *\n * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:\n *\n *     if (texture.hasLoaded)\n {\n *        // texture ready for use\n *     } else if (texture.isLoading)\n {\n *        // listen to 'loaded' and/or 'error' events on texture\n *     } else {\n *        // not loading, not going to load UNLESS the source is reloaded\n *        // (it may still make sense to listen to the events)\n *     }\n *\n * @protected\n * @param source {Image|Canvas} the source object of the texture.\n */\nBaseTexture.prototype.loadSource = function (source)\n{\n    var wasLoading = this.isLoading;\n    this.hasLoaded = false;\n    this.isLoading = false;\n\n    if (wasLoading && this.source)\n    {\n        this.source.onload = null;\n        this.source.onerror = null;\n    }\n\n    this.source = source;\n\n    // Apply source if loaded. Otherwise setup appropriate loading monitors.\n    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)\n    {\n        this._sourceLoaded();\n    }\n    else if (!source.getContext)\n    {\n\n        // Image fail / not ready\n        this.isLoading = true;\n\n        var scope = this;\n\n        source.onload = function ()\n        {\n            source.onload = null;\n            source.onerror = null;\n\n            if (!scope.isLoading)\n            {\n                return;\n            }\n\n            scope.isLoading = false;\n            scope._sourceLoaded();\n\n            scope.emit('loaded', scope);\n        };\n\n        source.onerror = function ()\n        {\n            source.onload = null;\n            source.onerror = null;\n\n            if (!scope.isLoading)\n            {\n                return;\n            }\n\n            scope.isLoading = false;\n            scope.emit('error', scope);\n        };\n\n        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element\n        //   \"The value of `complete` can thus change while a script is executing.\"\n        // So complete needs to be re-checked after the callbacks have been added..\n        // NOTE: complete will be true if the image has no src so best to check if the src is set.\n        if (source.complete && source.src)\n        {\n            this.isLoading = false;\n\n            // ..and if we're complete now, no need for callbacks\n            source.onload = null;\n            source.onerror = null;\n\n            if (source.width && source.height)\n            {\n                this._sourceLoaded();\n\n                // If any previous subscribers possible\n                if (wasLoading)\n                {\n                    this.emit('loaded', this);\n                }\n            }\n            else\n            {\n                // If any previous subscribers possible\n                if (wasLoading)\n                {\n                    this.emit('error', this);\n                }\n            }\n        }\n    }\n};\n\n/**\n * Used internally to update the width, height, and some other tracking vars once\n * a source has successfully loaded.\n *\n * @private\n */\nBaseTexture.prototype._sourceLoaded = function ()\n{\n    this.hasLoaded = true;\n    this.update();\n};\n\n/**\n * Destroys this base texture\n *\n */\nBaseTexture.prototype.destroy = function ()\n{\n    if (this.imageUrl)\n    {\n        delete utils.BaseTextureCache[this.imageUrl];\n        delete utils.TextureCache[this.imageUrl];\n\n        this.imageUrl = null;\n\n        if (!navigator.isCocoonJS)\n        {\n            this.source.src = '';\n        }\n    }\n    else if (this.source && this.source._pixiId)\n    {\n        delete utils.BaseTextureCache[this.source._pixiId];\n    }\n\n    this.source = null;\n\n    this.dispose();\n};\n\n/**\n * Frees the texture from WebGL memory without destroying this texture object.\n * This means you can still use the texture later which will upload it to GPU\n * memory again.\n *\n */\nBaseTexture.prototype.dispose = function ()\n{\n    this.emit('dispose', this);\n\n    // this should no longer be needed, the renderers should cleanup all the gl textures.\n    // this._glTextures = {};\n};\n\n/**\n * Changes the source image of the texture.\n * The original source must be an Image element.\n *\n * @param newSrc {string} the path of the image\n */\nBaseTexture.prototype.updateSourceImage = function (newSrc)\n{\n    this.source.src = newSrc;\n\n    this.loadSource(this.source);\n};\n\n/**\n * Helper function that creates a base texture from the given image url.\n * If the image is not in the base texture cache it will be created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return PIXI.BaseTexture\n */\nBaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)\n{\n    var baseTexture = utils.BaseTextureCache[imageUrl];\n\n    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)\n    {\n        crossorigin = true;\n    }\n\n    if (!baseTexture)\n    {\n        // new Image() breaks tex loading in some versions of Chrome.\n        // See https://code.google.com/p/chromium/issues/detail?id=238071\n        var image = new Image();//document.createElement('img');\n        if (crossorigin)\n        {\n            image.crossOrigin = '';\n        }\n\n        baseTexture = new BaseTexture(image, scaleMode);\n        baseTexture.imageUrl = imageUrl;\n\n        image.src = imageUrl;\n\n        utils.BaseTextureCache[imageUrl] = baseTexture;\n\n        // if there is an @2x at the end of the url we are going to assume its a highres image\n        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);\n    }\n\n    return baseTexture;\n};\n\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return PIXI.BaseTexture\n */\nBaseTexture.fromCanvas = function (canvas, scaleMode)\n{\n    if (!canvas._pixiId)\n    {\n        canvas._pixiId = 'canvas_' + utils.uid();\n    }\n\n    var baseTexture = utils.BaseTextureCache[canvas._pixiId];\n\n    if (!baseTexture)\n    {\n        baseTexture = new BaseTexture(canvas, scaleMode);\n        utils.BaseTextureCache[canvas._pixiId] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\n},{\"../const\":22,\"../utils\":77,\"eventemitter3\":10}],71:[function(require,module,exports){\nvar BaseTexture = require('./BaseTexture'),\n    Texture = require('./Texture'),\n    RenderTarget = require('../renderers/webgl/utils/RenderTarget'),\n    FilterManager = require('../renderers/webgl/managers/FilterManager'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempMatrix = new math.Matrix();\n\n/**\n * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * var renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });\n * var renderTexture = new PIXI.RenderTexture(renderer, 800, 600);\n * var sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderTexture.render(sprite);\n * ```\n *\n * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual\n * position a Container should be used:\n *\n * ```js\n * var doc = new PIXI.Container();\n *\n * doc.addChild(sprite);\n *\n * renderTexture.render(doc);  // Renders to center of renderTexture\n * ```\n *\n * @class\n * @extends PIXI.Texture\n * @memberof PIXI\n * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used for this RenderTexture\n * @param [width=100] {number} The width of the render texture\n * @param [height=100] {number} The height of the render texture\n * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values\n * @param [resolution=1] {number} The resolution of the texture being generated\n */\nfunction RenderTexture(renderer, width, height, scaleMode, resolution)\n{\n    if (!renderer)\n    {\n        throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');\n    }\n\n    width = width || 100;\n    height = height || 100;\n    resolution = resolution || CONST.RESOLUTION;\n\n    /**\n     * The base texture object that this texture uses\n     *\n     * @member {BaseTexture}\n     */\n    var baseTexture = new BaseTexture();\n    baseTexture.width = width;\n    baseTexture.height = height;\n    baseTexture.resolution = resolution;\n    baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n    baseTexture.hasLoaded = true;\n\n\n    Texture.call(this,\n        baseTexture,\n        new math.Rectangle(0, 0, width, height)\n    );\n\n\n    /**\n     * The with of the render texture\n     *\n     * @member {number}\n     */\n    this.width = width;\n\n    /**\n     * The height of the render texture\n     *\n     * @member {number}\n     */\n    this.height = height;\n\n    /**\n     * The Resolution of the texture.\n     *\n     * @member {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * Draw/render the given DisplayObject onto the texture.\n     *\n     * The displayObject and descendents are transformed during this operation.\n     * If `updateTransform` is true then the transformations will be restored before the\n     * method returns. Otherwise it is up to the calling code to correctly use or reset\n     * the transformed display objects.\n     *\n     * The display object is always rendered with a worldAlpha value of 1.\n     *\n     * @method\n     * @param displayObject {PIXI.DisplayObject} The display object to render this texture on\n     * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.\n     * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn\n     * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children\n     *  transformations will be restored. Not restoring this information will be a little faster.\n     */\n    this.render = null;\n\n    /**\n     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.\n     *\n     * @member {PIXI.CanvasRenderer|PIXI.WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n\n        this.textureBuffer = new RenderTarget(gl, this.width, this.height, baseTexture.scaleMode, this.resolution);//, this.baseTexture.scaleMode);\n        this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;\n\n        //TODO refactor filter manager.. as really its no longer a manager if we use it here..\n        this.filterManager = new FilterManager(this.renderer);\n        this.filterManager.onContextChange();\n        this.filterManager.resize(width, height);\n        this.render = this.renderWebGL;\n\n        // the creation of a filter manager unbinds the buffers..\n        this.renderer.currentRenderer.start();\n        this.renderer.currentRenderTarget.activate();\n    }\n    else\n    {\n\n        this.render = this.renderCanvas;\n        this.textureBuffer = new CanvasBuffer(this.width* this.resolution, this.height* this.resolution);\n        this.baseTexture.source = this.textureBuffer.canvas;\n    }\n\n    /**\n     * @member {boolean}\n     */\n    this.valid = true;\n\n    this._updateUvs();\n}\n\nRenderTexture.prototype = Object.create(Texture.prototype);\nRenderTexture.prototype.constructor = RenderTexture;\nmodule.exports = RenderTexture;\n\n/**\n * Resizes the RenderTexture.\n *\n * @param width {number} The width to resize to.\n * @param height {number} The height to resize to.\n * @param updateBase {boolean} Should the baseTexture.width and height values be resized as well?\n */\nRenderTexture.prototype.resize = function (width, height, updateBase)\n{\n    if (width === this.width && height === this.height)\n    {\n        return;\n    }\n\n    this.valid = (width > 0 && height > 0);\n\n    this.width = this._frame.width = this.crop.width = width;\n    this.height =  this._frame.height = this.crop.height = height;\n\n    if (updateBase)\n    {\n        this.baseTexture.width = this.width;\n        this.baseTexture.height = this.height;\n    }\n\n    if (!this.valid)\n    {\n        return;\n    }\n\n    this.textureBuffer.resize(this.width, this.height);\n\n    if(this.filterManager)\n    {\n        this.filterManager.resize(this.width, this.height);\n    }\n};\n\n/**\n * Clears the RenderTexture.\n *\n */\nRenderTexture.prototype.clear = function ()\n{\n    if (!this.valid)\n    {\n        return;\n    }\n\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n    }\n\n    this.textureBuffer.clear();\n};\n\n/**\n * Internal method assigned to the `render` property if using a CanvasRenderer.\n *\n * @private\n * @param displayObject {PIXI.DisplayObject} The display object to render this texture on\n * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn\n * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children\n *  transformations will be restored. Not restoring this information will be a little faster.\n */\nRenderTexture.prototype.renderWebGL = function (displayObject, matrix, clear, updateTransform)\n{\n    if (!this.valid)\n    {\n        return;\n    }\n\n\n    updateTransform = (updateTransform !== undefined) ? updateTransform : true;//!updateTransform;\n\n    this.textureBuffer.transform = matrix;\n\n    //TODO not a fan that this is here... it will move!\n    this.textureBuffer.activate();\n\n    // setWorld Alpha to ensure that the object is renderer at full opacity\n    displayObject.worldAlpha = 1;\n\n    if (updateTransform)\n    {\n\n        // reset the matrix of the displatyObject..\n        displayObject.worldTransform.identity();\n\n        displayObject.currentBounds = null;\n\n        // Time to update all the children of the displayObject with the new matrix..\n        var children = displayObject.children;\n        var i, j;\n\n        for (i = 0, j = children.length; i < j; ++i)\n        {\n            children[i].updateTransform();\n        }\n    }\n\n    //TODO rename textureBuffer to renderTarget..\n    var temp =  this.renderer.filterManager;\n\n    this.renderer.filterManager = this.filterManager;\n    this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);\n\n    this.renderer.filterManager = temp;\n};\n\n\n/**\n * Internal method assigned to the `render` property if using a CanvasRenderer.\n *\n * @private\n * @param displayObject {PIXI.DisplayObject} The display object to render this texture on\n * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear] {boolean} If true the texture will be cleared before the displayObject is drawn\n */\nRenderTexture.prototype.renderCanvas = function (displayObject, matrix, clear, updateTransform)\n{\n    if (!this.valid)\n    {\n        return;\n    }\n\n    updateTransform = !!updateTransform;\n\n    var wt = tempMatrix;\n\n    wt.identity();\n\n    if (matrix)\n    {\n        wt.append(matrix);\n    }\n\n    var cachedWt = displayObject.worldTransform;\n    displayObject.worldTransform = wt;\n\n    // setWorld Alpha to ensure that the object is renderer at full opacity\n    displayObject.worldAlpha = 1;\n\n    // Time to update all the children of the displayObject with the new matrix..\n    var children = displayObject.children;\n    var i, j;\n\n    for (i = 0, j = children.length; i < j; ++i)\n    {\n        children[i].updateTransform();\n    }\n\n    if (clear)\n    {\n        this.textureBuffer.clear();\n    }\n\n\n//    this.textureBuffer.\n    var context = this.textureBuffer.context;\n\n    var realResolution = this.renderer.resolution;\n\n    this.renderer.resolution = this.resolution;\n\n    this.renderer.renderDisplayObject(displayObject, context);\n\n    this.renderer.resolution = realResolution;\n\n    if(displayObject.worldTransform === wt)\n    {\n        // fixes cacheAsBitmap Happening during the above..\n        displayObject.worldTransform = cachedWt;\n    }\n\n};\n\n/**\n * Destroys this texture\n *\n * @param destroyBase {boolean} Whether to destroy the base texture as well\n */\nRenderTexture.prototype.destroy = function ()\n{\n    Texture.prototype.destroy.call(this, true);\n\n    this.textureBuffer.destroy();\n\n    // destroy the filtermanager..\n    if(this.filterManager)\n    {\n        this.filterManager.destroy();\n    }\n\n    this.renderer = null;\n};\n\n/**\n * Will return a HTML Image of the texture\n *\n * @return {Image}\n */\nRenderTexture.prototype.getImage = function ()\n{\n    var image = new Image();\n    image.src = this.getBase64();\n    return image;\n};\n\n/**\n * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.\n *\n * @return {string} A base64 encoded string of the texture.\n */\nRenderTexture.prototype.getBase64 = function ()\n{\n    return this.getCanvas().toDataURL();\n};\n\n/**\n * Creates a Canvas element, renders this RenderTexture to it and then returns it.\n *\n * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n */\nRenderTexture.prototype.getCanvas = function ()\n{\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n        var width = this.textureBuffer.size.width;\n        var height = this.textureBuffer.size.height;\n\n        var webGLPixels = new Uint8Array(4 * width * height);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        var tempCanvas = new CanvasBuffer(width, height);\n        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);\n        canvasData.data.set(webGLPixels);\n\n        tempCanvas.context.putImageData(canvasData, 0, 0);\n\n        return tempCanvas.canvas;\n    }\n    else\n    {\n        return this.textureBuffer.canvas;\n    }\n};\n\n/**\n * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA order, with integer values between 0 and 255 (included).\n *\n * @return {Uint8ClampedArray}\n */\nRenderTexture.prototype.getPixels = function ()\n{\n    var width, height;\n\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n        width = this.textureBuffer.size.width;\n        height = this.textureBuffer.size.height;\n\n        var webGLPixels = new Uint8Array(4 * width * height);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return webGLPixels;\n    }\n    else\n    {\n        width = this.textureBuffer.canvas.width;\n        height = this.textureBuffer.canvas.height;\n\n        return this.textureBuffer.canvas.getContext('2d').getImageData(0, 0, width, height).data;\n    }\n};\n\n/**\n * Will return a one-dimensional array containing the pixel data of a pixel within the texture in RGBA order, with integer values between 0 and 255 (included).\n *\n * @param x {number} The x coordinate of the pixel to retrieve.\n * @param y {number} The y coordinate of the pixel to retrieve.\n * @return {Uint8ClampedArray}\n */\nRenderTexture.prototype.getPixel = function (x, y)\n{\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n\n        var webGLPixels = new Uint8Array(4);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return webGLPixels;\n    }\n    else\n    {\n        return this.textureBuffer.canvas.getContext('2d').getImageData(x, y, 1, 1).data;\n    }\n};\n\n},{\"../const\":22,\"../math\":33,\"../renderers/canvas/utils/CanvasBuffer\":45,\"../renderers/webgl/managers/FilterManager\":54,\"../renderers/webgl/utils/RenderTarget\":65,\"./BaseTexture\":70,\"./Texture\":72}],72:[function(require,module,exports){\nvar BaseTexture = require('./BaseTexture'),\n    VideoBaseTexture = require('./VideoBaseTexture'),\n    TextureUvs = require('./TextureUvs'),\n    EventEmitter = require('eventemitter3'),\n    math = require('../math'),\n    utils = require('../utils');\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.png');\n * var sprite1 = new PIXI.Sprite(texture);\n * var sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * @class\n * @memberof PIXI\n * @param baseTexture {PIXI.BaseTexture} The base texture source to create the texture from\n * @param [frame] {PIXI.Rectangle} The rectangle frame of the texture to show\n * @param [crop] {PIXI.Rectangle} The area of original texture\n * @param [trim] {PIXI.Rectangle} Trimmed texture rectangle\n * @param [rotate] {number} indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}\n */\nfunction Texture(baseTexture, frame, crop, trim, rotate)\n{\n    EventEmitter.call(this);\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * @member {boolean}\n     */\n    this.noFrame = false;\n\n    if (!frame)\n    {\n        this.noFrame = true;\n        frame = new math.Rectangle(0, 0, 1, 1);\n    }\n\n    if (baseTexture instanceof Texture)\n    {\n        baseTexture = baseTexture.baseTexture;\n    }\n\n    /**\n     * The base texture that this texture uses.\n     *\n     * @member {PIXI.BaseTexture}\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n    this._frame = frame;\n\n    /**\n     * The texture trim data.\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.trim = trim;\n\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @member {boolean}\n     */\n    this.valid = false;\n\n    /**\n     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n     *\n     * @member {boolean}\n     */\n    this.requiresUpdate = false;\n\n    /**\n     * The WebGL UV data cache.\n     *\n     * @member {PIXI.TextureUvs}\n     * @private\n     */\n    this._uvs = null;\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    this.height = 0;\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.crop = crop || frame;//new math.Rectangle(0, 0, 1, 1);\n\n    this._rotate = +(rotate || 0);\n\n    if (rotate === true) {\n        // this is old texturepacker legacy, some games/libraries are passing \"true\" for rotated textures\n        this._rotate = 2;\n    } else {\n        if (this._rotate % 2 !== 0) {\n            throw 'attempt to use diamond-shaped UVs. If you are sure, set rotation manually';\n        }\n    }\n\n    if (baseTexture.hasLoaded)\n    {\n        if (this.noFrame)\n        {\n            frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n\n            // if there is no frame we should monitor for any base texture changes..\n            baseTexture.on('update', this.onBaseTextureUpdated, this);\n        }\n        this.frame = frame;\n    }\n    else\n    {\n        baseTexture.once('loaded', this.onBaseTextureLoaded, this);\n    }\n\n    /**\n     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n     *\n     * @event update\n     * @memberof PIXI.Texture#\n     * @protected\n     */\n}\n\nTexture.prototype = Object.create(EventEmitter.prototype);\nTexture.prototype.constructor = Texture;\nmodule.exports = Texture;\n\nObject.defineProperties(Texture.prototype, {\n    /**\n     * The frame specifies the region of the base texture that this texture uses.\n     *\n     * @member {PIXI.Rectangle}\n     * @memberof PIXI.Texture#\n     */\n    frame: {\n        get: function ()\n        {\n            return this._frame;\n        },\n        set: function (frame)\n        {\n            this._frame = frame;\n\n            this.noFrame = false;\n\n            this.width = frame.width;\n            this.height = frame.height;\n\n            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))\n            {\n                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n            }\n\n            //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;\n            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;\n\n            if (this.trim)\n            {\n                this.width = this.trim.width;\n                this.height = this.trim.height;\n                this._frame.width = this.trim.width;\n                this._frame.height = this.trim.height;\n            }\n            else\n            {\n                this.crop = frame;\n            }\n\n            if (this.valid)\n            {\n                this._updateUvs();\n            }\n        }\n    },\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.GroupD8} for explanation\n     *\n     * @member {number}\n     */\n    rotate: {\n        get: function ()\n        {\n            return this._rotate;\n        },\n        set: function (rotate)\n        {\n            this._rotate = rotate;\n            if (this.valid)\n            {\n                this._updateUvs();\n            }\n        }\n    }\n});\n\n/**\n * Updates this texture on the gpu.\n *\n */\nTexture.prototype.update = function ()\n{\n    this.baseTexture.update();\n};\n\n/**\n * Called when the base texture is loaded\n *\n * @private\n */\nTexture.prototype.onBaseTextureLoaded = function (baseTexture)\n{\n    // TODO this code looks confusing.. boo to abusing getters and setterss!\n    if (this.noFrame)\n    {\n        this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n    }\n    else\n    {\n        this.frame = this._frame;\n    }\n\n    this.emit('update', this);\n};\n\n/**\n * Called when the base texture is updated\n *\n * @private\n */\nTexture.prototype.onBaseTextureUpdated = function (baseTexture)\n{\n    this._frame.width = baseTexture.width;\n    this._frame.height = baseTexture.height;\n\n    this.emit('update', this);\n};\n\n/**\n * Destroys this texture\n *\n * @param [destroyBase=false] {boolean} Whether to destroy the base texture as well\n */\nTexture.prototype.destroy = function (destroyBase)\n{\n    if (this.baseTexture)\n    {\n        if (destroyBase)\n        {\n            this.baseTexture.destroy();\n        }\n\n        this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n\n        this.baseTexture = null;\n    }\n\n    this._frame = null;\n    this._uvs = null;\n    this.trim = null;\n    this.crop = null;\n\n    this.valid = false;\n\n    this.off('dispose', this.dispose, this);\n    this.off('update', this.update, this);\n};\n\n/**\n * Creates a new texture object that acts the same as this one.\n *\n * @return {PIXI.Texture}\n */\nTexture.prototype.clone = function ()\n{\n    return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);\n};\n\n/**\n * Updates the internal WebGL UV cache.\n *\n * @private\n */\nTexture.prototype._updateUvs = function ()\n{\n    if (!this._uvs)\n    {\n        this._uvs = new TextureUvs();\n    }\n\n    this._uvs.set(this.crop, this.baseTexture, this.rotate);\n};\n\n/**\n * Helper function that creates a Texture object from the given image url.\n * If the image is not in the texture cache it will be  created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param crossorigin {boolean} Whether requests should be treated as crossorigin\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.Texture} The newly created texture\n */\nTexture.fromImage = function (imageUrl, crossorigin, scaleMode)\n{\n    var texture = utils.TextureCache[imageUrl];\n\n    if (!texture)\n    {\n        texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));\n        utils.TextureCache[imageUrl] = texture;\n    }\n\n    return texture;\n};\n\n/**\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {string} The frame Id of the texture in the cache\n * @return {PIXI.Texture} The newly created texture\n */\nTexture.fromFrame = function (frameId)\n{\n    var texture = utils.TextureCache[frameId];\n\n    if (!texture)\n    {\n        throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n    }\n\n    return texture;\n};\n\n/**\n * Helper function that creates a new Texture based on the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.Texture}\n */\nTexture.fromCanvas = function (canvas, scaleMode)\n{\n    return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));\n};\n\n/**\n * Helper function that creates a new Texture based on the given video element.\n *\n * @static\n * @param video {HTMLVideoElement}\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.Texture} A Texture\n */\nTexture.fromVideo = function (video, scaleMode)\n{\n    if (typeof video === 'string')\n    {\n        return Texture.fromVideoUrl(video, scaleMode);\n    }\n    else\n    {\n        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));\n    }\n};\n\n/**\n * Helper function that creates a new Texture based on the video url.\n *\n * @static\n * @param videoUrl {string}\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.Texture} A Texture\n */\nTexture.fromVideoUrl = function (videoUrl, scaleMode)\n{\n    return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));\n};\n\n/**\n * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.\n *\n * @static\n * @param texture {PIXI.Texture} The Texture to add to the cache.\n * @param id {string} The id that the texture will be stored against.\n */\nTexture.addTextureToCache = function (texture, id)\n{\n    utils.TextureCache[id] = texture;\n};\n\n/**\n * Remove a texture from the global utils.TextureCache.\n *\n * @static\n * @param id {string} The id of the texture to be removed\n * @return {PIXI.Texture} The texture that was removed\n */\nTexture.removeTextureFromCache = function (id)\n{\n    var texture = utils.TextureCache[id];\n\n    delete utils.TextureCache[id];\n    delete utils.BaseTextureCache[id];\n\n    return texture;\n};\n\n/**\n * An empty texture, used often to not have to create multiple empty textures.\n *\n * @static\n * @constant\n */\nTexture.EMPTY = new Texture(new BaseTexture());\n\n},{\"../math\":33,\"../utils\":77,\"./BaseTexture\":70,\"./TextureUvs\":73,\"./VideoBaseTexture\":74,\"eventemitter3\":10}],73:[function(require,module,exports){\n\n/**\n * A standard object to store the Uvs of a texture\n *\n * @class\n * @private\n * @memberof PIXI\n */\nfunction TextureUvs()\n{\n    this.x0 = 0;\n    this.y0 = 0;\n\n    this.x1 = 1;\n    this.y1 = 0;\n\n    this.x2 = 1;\n    this.y2 = 1;\n\n    this.x3 = 0;\n    this.y3 = 1;\n}\n\nmodule.exports = TextureUvs;\n\nvar GroupD8 = require('../math/GroupD8');\n\n/**\n * Sets the texture Uvs based on the given frame information\n * @param frame {PIXI.Rectangle}\n * @param baseFrame {PIXI.Rectangle}\n * @param rotate {number} Rotation of frame, see {@link PIXI.GroupD8}\n * @private\n */\nTextureUvs.prototype.set = function (frame, baseFrame, rotate)\n{\n    var tw = baseFrame.width;\n    var th = baseFrame.height;\n\n    if(rotate)\n    {\n        //width and height div 2 div baseFrame size\n        var swapWidthHeight = GroupD8.isSwapWidthHeight(rotate);\n        var w2 = (swapWidthHeight ? frame.height : frame.width) / 2 / tw;\n        var h2 = (swapWidthHeight ? frame.width : frame.height) / 2 / th;\n        //coordinates of center\n        var cX = frame.x / tw + w2;\n        var cY = frame.y / th + h2;\n        rotate = GroupD8.add(rotate, GroupD8.NW); //NW is top-left corner\n        this.x0 = cX + w2 * GroupD8.uX(rotate);\n        this.y0 = cY + h2 * GroupD8.uY(rotate);\n        rotate = GroupD8.add(rotate, 2); //rotate 90 degrees clockwise\n        this.x1 = cX + w2 * GroupD8.uX(rotate);\n        this.y1 = cY + h2 * GroupD8.uY(rotate);\n        rotate = GroupD8.add(rotate, 2);\n        this.x2 = cX + w2 * GroupD8.uX(rotate);\n        this.y2 = cY + h2 * GroupD8.uY(rotate);\n        rotate = GroupD8.add(rotate, 2);\n        this.x3 = cX + w2 * GroupD8.uX(rotate);\n        this.y3 = cY + h2 * GroupD8.uY(rotate);\n    }\n    else\n    {\n\n        this.x0 = frame.x / tw;\n        this.y0 = frame.y / th;\n\n        this.x1 = (frame.x + frame.width) / tw;\n        this.y1 = frame.y / th;\n\n        this.x2 = (frame.x + frame.width) / tw;\n        this.y2 = (frame.y + frame.height) / th;\n\n        this.x3 = frame.x / tw;\n        this.y3 = (frame.y + frame.height) / th;\n    }\n};\n\n},{\"../math/GroupD8\":30}],74:[function(require,module,exports){\nvar BaseTexture = require('./BaseTexture'),\n    utils = require('../utils');\n\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * var texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n * @param source {HTMLVideoElement}\n * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values\n */\nfunction VideoBaseTexture(source, scaleMode)\n{\n    if (!source)\n    {\n        throw new Error('No video source element specified.');\n    }\n\n    // hook in here to check if video is already available.\n    // BaseTexture looks for a source.complete boolean, plus width & height.\n\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height)\n    {\n        source.complete = true;\n    }\n\n    BaseTexture.call(this, source, scaleMode);\n\n    /**\n     * Should the base texture automatically update itself, set to true by default\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.autoUpdate = false;\n\n    this._onUpdate = this._onUpdate.bind(this);\n    this._onCanPlay = this._onCanPlay.bind(this);\n\n    if (!source.complete)\n    {\n        source.addEventListener('canplay', this._onCanPlay);\n        source.addEventListener('canplaythrough', this._onCanPlay);\n\n        // started playing..\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n    }\n\n    this.__loaded = false;\n}\n\nVideoBaseTexture.prototype = Object.create(BaseTexture.prototype);\nVideoBaseTexture.prototype.constructor = VideoBaseTexture;\nmodule.exports = VideoBaseTexture;\n\n/**\n * The internal update loop of the video base texture, only runs when autoUpdate is set to true\n *\n * @private\n */\nVideoBaseTexture.prototype._onUpdate = function ()\n{\n    if (this.autoUpdate)\n    {\n        window.requestAnimationFrame(this._onUpdate);\n        this.update();\n    }\n};\n\n/**\n * Runs the update loop when the video is ready to play\n *\n * @private\n */\nVideoBaseTexture.prototype._onPlayStart = function ()\n{\n    if (!this.autoUpdate)\n    {\n        window.requestAnimationFrame(this._onUpdate);\n        this.autoUpdate = true;\n    }\n};\n\n/**\n * Fired when a pause event is triggered, stops the update loop\n *\n * @private\n */\nVideoBaseTexture.prototype._onPlayStop = function ()\n{\n    this.autoUpdate = false;\n};\n\n/**\n * Fired when the video is loaded and ready to play\n *\n * @private\n */\nVideoBaseTexture.prototype._onCanPlay = function ()\n{\n    this.hasLoaded = true;\n\n    if (this.source)\n    {\n        this.source.removeEventListener('canplay', this._onCanPlay);\n        this.source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        this.width = this.source.videoWidth;\n        this.height = this.source.videoHeight;\n\n        this.source.play();\n\n        // prevent multiple loaded dispatches..\n        if (!this.__loaded)\n        {\n            this.__loaded = true;\n            this.emit('loaded', this);\n        }\n    }\n};\n\n/**\n * Destroys this texture\n *\n */\nVideoBaseTexture.prototype.destroy = function ()\n{\n    if (this.source && this.source._pixiId)\n    {\n        delete utils.BaseTextureCache[ this.source._pixiId ];\n        delete this.source._pixiId;\n    }\n\n    BaseTexture.prototype.destroy.call(this);\n};\n\n/**\n * Mimic Pixi BaseTexture.from.... method.\n *\n * @static\n * @param video {HTMLVideoElement}\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.VideoBaseTexture}\n */\nVideoBaseTexture.fromVideo = function (video, scaleMode)\n{\n    if (!video._pixiId)\n    {\n        video._pixiId = 'video_' + utils.uid();\n    }\n\n    var baseTexture = utils.BaseTextureCache[video._pixiId];\n\n    if (!baseTexture)\n    {\n        baseTexture = new VideoBaseTexture(video, scaleMode);\n        utils.BaseTextureCache[ video._pixiId ] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\n/**\n * Helper function that creates a new BaseTexture based on the given video element.\n * This BaseTexture can then be used to create a texture\n *\n * @static\n * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.\n * @param [videoSrc.src] {string} One of the source urls for the video\n * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified\n *  the url's extension will be used as the second part of the mime type.\n * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.VideoBaseTexture}\n */\nVideoBaseTexture.fromUrl = function (videoSrc, scaleMode)\n{\n    var video = document.createElement('video');\n\n    // array of objects or strings\n    if (Array.isArray(videoSrc))\n    {\n        for (var i = 0; i < videoSrc.length; ++i)\n        {\n            video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n        }\n    }\n    // single object or string\n    else\n    {\n        video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));\n    }\n\n    video.load();\n    video.play();\n\n    return VideoBaseTexture.fromVideo(video, scaleMode);\n};\n\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type)\n{\n    if (!type)\n    {\n        type = 'video/' + path.substr(path.lastIndexOf('.') + 1);\n    }\n\n    var source = document.createElement('source');\n\n    source.src = path;\n    source.type = type;\n\n    return source;\n}\n\n},{\"../utils\":77,\"./BaseTexture\":70}],75:[function(require,module,exports){\nvar CONST = require('../const'),\n    EventEmitter = require('eventemitter3'),\n    // Internal event used by composed emitter\n    TICK = 'tick';\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around an EventEmitter object to add listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\nfunction Ticker()\n{\n    var _this = this;\n\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     *\n     * @private\n     */\n    this._tick = function _tick(time) {\n\n        _this._requestId = null;\n\n        if (_this.started)\n        {\n            // Invoke listeners now\n            _this.update(time);\n            // Listener side effects may have modified ticker state.\n            if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true))\n            {\n                _this._requestId = requestAnimationFrame(_this._tick);\n            }\n        }\n    };\n\n    /**\n     * Internal emitter used to fire 'tick' event\n     * @private\n     */\n    this._emitter = new EventEmitter();\n\n    /**\n     * Internal current frame request ID\n     * @private\n     */\n    this._requestId = null;\n\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     * @private\n     */\n    this._maxElapsedMS = 100;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link PIXI.ticker.Ticker#start} automatically\n     * when a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoStart = false;\n\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n     * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.deltaTime = 1;\n\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1   s.\n     *\n     * @member {DOMHighResTimeStamp|number}\n     * @default 1 / TARGET_FPMS\n     */\n    this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time\n\n    /**\n     * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1   s.\n     *\n     * @member {DOMHighResTimeStamp|number}\n     * @default 0\n     */\n    this.lastTime = 0;\n\n    /**\n     * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.speed = 1;\n\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n     * and a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.started = false;\n}\n\nObject.defineProperties(Ticker.prototype, {\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link PIXI.ticker.Ticker#speed}, which is specific\n     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n     *\n     * @member\n     * @memberof PIXI.ticker.Ticker#\n     * @readonly\n     */\n    FPS: {\n        get: function()\n        {\n            return 1000 / this.elapsedMS;\n        }\n    },\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `PIXI.TARGET_FPMS * 1000`.\n     *\n     * @member\n     * @memberof PIXI.ticker.Ticker#\n     * @default 10\n     */\n    minFPS: {\n        get: function()\n        {\n            return 1000 / this._maxElapsedMS;\n        },\n        set: function(fps)\n        {\n            // Clamp: 0 to TARGET_FPMS\n            var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);\n            this._maxElapsedMS = 1 / minFPMS;\n        }\n    }\n});\n\n/**\n * Conditionally requests a new animation frame.\n * If a frame has not already been requested, and if the internal\n * emitter has listeners, a new frame is requested.\n *\n * @private\n */\nTicker.prototype._requestIfNeeded = function _requestIfNeeded()\n{\n    if (this._requestId === null && this._emitter.listeners(TICK, true))\n    {\n        // ensure callbacks get correct delta\n        this.lastTime = performance.now();\n        this._requestId = requestAnimationFrame(this._tick);\n    }\n};\n\n/**\n * Conditionally cancels a pending animation frame.\n *\n * @private\n */\nTicker.prototype._cancelIfNeeded = function _cancelIfNeeded()\n{\n    if (this._requestId !== null)\n    {\n        cancelAnimationFrame(this._requestId);\n        this._requestId = null;\n    }\n};\n\n/**\n * Conditionally requests a new animation frame.\n * If the ticker has been started it checks if a frame has not already\n * been requested, and if the internal emitter has listeners. If these\n * conditions are met, a new frame is requested. If the ticker has not\n * been started, but autoStart is `true`, then the ticker starts now,\n * and continues with the previous conditions to request a new frame.\n *\n * @private\n */\nTicker.prototype._startIfPossible = function _startIfPossible()\n{\n    if (this.started)\n    {\n        this._requestIfNeeded();\n    }\n    else if (this.autoStart)\n    {\n        this.start();\n    }\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#on} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for updates\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.add = function add(fn, context)\n{\n    this._emitter.on(TICK, fn, context);\n\n    this._startIfPossible();\n\n    return this;\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#once} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for one update\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.addOnce = function addOnce(fn, context)\n{\n    this._emitter.once(TICK, fn, context);\n\n    this._startIfPossible();\n\n    return this;\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.\n * It checks if the emitter has listeners for 'tick' event.\n * If it does, then it cancels the animation frame.\n *\n * @param [fn] {Function} The listener function to be removed\n * @param [context] {Function} The listener context to be removed\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.remove = function remove(fn, context)\n{\n    this._emitter.off(TICK, fn, context);\n\n    if (!this._emitter.listeners(TICK, true))\n    {\n        this._cancelIfNeeded();\n    }\n\n    return this;\n};\n\n/**\n * Starts the ticker. If the ticker has listeners\n * a new animation frame is requested at this point.\n */\nTicker.prototype.start = function start()\n{\n    if (!this.started)\n    {\n        this.started = true;\n        this._requestIfNeeded();\n    }\n};\n\n/**\n * Stops the ticker. If the ticker has requested\n * an animation frame it is canceled at this point.\n */\nTicker.prototype.stop = function stop()\n{\n    if (this.started)\n    {\n        this.started = false;\n        this._cancelIfNeeded();\n    }\n};\n\n/**\n * Triggers an update. An update entails setting the\n * current {@link PIXI.ticker.Ticker#elapsedMS},\n * the current {@link PIXI.ticker.Ticker#deltaTime},\n * invoking all listeners with current deltaTime,\n * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n * with the value of currentTime that was provided.\n * This method will be called automatically by animation\n * frame callbacks if the ticker instance has been started\n * and listeners are added.\n *\n * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution\n */\nTicker.prototype.update = function update(currentTime)\n{\n    var elapsedMS;\n\n    // Allow calling update directly with default currentTime.\n    currentTime = currentTime || performance.now();\n    // Save uncapped elapsedMS for measurement\n    elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n    // cap the milliseconds elapsed used for deltaTime\n    if (elapsedMS > this._maxElapsedMS)\n    {\n        elapsedMS = this._maxElapsedMS;\n    }\n\n    this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed;\n\n    // Invoke listeners added to internal emitter\n    this._emitter.emit(TICK, this.deltaTime);\n\n    this.lastTime = currentTime;\n};\n\nmodule.exports = Ticker;\n\n},{\"../const\":22,\"eventemitter3\":10}],76:[function(require,module,exports){\nvar Ticker = require('./Ticker');\n\n/**\n * The shared ticker instance used by {@link PIXI.extras.MovieClip}.\n * and by {@link PIXI.interaction.InteractionManager}.\n * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`\n * for this instance. Please follow the examples for usage, including\n * how to opt-out of auto-starting the shared ticker.\n *\n * @example\n * var ticker = PIXI.ticker.shared;\n * // Set this to prevent starting this ticker when listeners are added.\n * // By default this is true only for the PIXI.ticker.shared instance.\n * ticker.autoStart = false;\n * // FYI, call this to ensure the ticker is stopped. It should be stopped\n * // if you have not attempted to render anything yet.\n * ticker.stop();\n * // Call this when you are ready for a running shared ticker.\n * ticker.start();\n *\n * @example\n * // You may use the shared ticker to render...\n * var renderer = PIXI.autoDetectRenderer(800, 600);\n * var stage = new PIXI.Container();\n * var interactionManager = PIXI.interaction.InteractionManager(renderer);\n * document.body.appendChild(renderer.view);\n * ticker.add(function (time) {\n *     renderer.render(stage);\n * });\n *\n * @example\n * // Or you can just update it manually.\n * ticker.autoStart = false;\n * ticker.stop();\n * function animate(time) {\n *     ticker.update(time);\n *     renderer.render(stage);\n *     requestAnimationFrame(animate);\n * }\n * animate(performance.now());\n *\n * @type {PIXI.ticker.Ticker}\n * @memberof PIXI.ticker\n */\nvar shared = new Ticker();\nshared.autoStart = true;\n\n/**\n * @namespace PIXI.ticker\n */\nmodule.exports = {\n    shared: shared,\n    Ticker: Ticker\n};\n\n},{\"./Ticker\":75}],77:[function(require,module,exports){\nvar CONST = require('../const');\n\n/**\n * @namespace PIXI.utils\n */\nvar utils = module.exports = {\n    _uid: 0,\n    _saidHello: false,\n\n    EventEmitter:   require('eventemitter3'),\n    pluginTarget:   require('./pluginTarget'),\n    async:          require('async'),\n\n    /**\n     * Gets the next unique identifier\n     *\n     * @return {number} The next unique identifier to use.\n     */\n    uid: function ()\n    {\n        return ++utils._uid;\n    },\n\n    /**\n     * Converts a hex color number to an [R, G, B] array\n     *\n     * @param hex {number}\n     * @param  {number[]} [out=[]]\n     * @return {number[]} An array representing the [R, G, B] of the color.\n     */\n    hex2rgb: function (hex, out)\n    {\n        out = out || [];\n\n        out[0] = (hex >> 16 & 0xFF) / 255;\n        out[1] = (hex >> 8 & 0xFF) / 255;\n        out[2] = (hex & 0xFF) / 255;\n\n        return out;\n    },\n\n    /**\n     * Converts a hex color number to a string.\n     *\n     * @param hex {number}\n     * @return {string} The string color.\n     */\n    hex2string: function (hex)\n    {\n        hex = hex.toString(16);\n        hex = '000000'.substr(0, 6 - hex.length) + hex;\n\n        return '#' + hex;\n    },\n\n    /**\n     * Converts a color as an [R, G, B] array to a hex number\n     *\n     * @param rgb {number[]}\n     * @return {number} The color number\n     */\n    rgb2hex: function (rgb)\n    {\n        return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);\n    },\n\n    /**\n     * Checks whether the Canvas BlendModes are supported by the current browser\n     *\n     * @return {boolean} whether they are supported\n     */\n    canUseNewCanvasBlendModes: function ()\n    {\n        if (typeof document === 'undefined')\n        {\n            return false;\n        }\n\n        var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';\n        var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';\n\n        var magenta = new Image();\n        magenta.src = pngHead + 'AP804Oa6' + pngEnd;\n\n        var yellow = new Image();\n        yellow.src = pngHead + '/wCKxvRF' + pngEnd;\n\n        var canvas = document.createElement('canvas');\n        canvas.width = 6;\n        canvas.height = 1;\n\n        var context = canvas.getContext('2d');\n        context.globalCompositeOperation = 'multiply';\n        context.drawImage(magenta, 0, 0);\n        context.drawImage(yellow, 2, 0);\n\n        var data = context.getImageData(2,0,1,1).data;\n\n        return (data[0] === 255 && data[1] === 0 && data[2] === 0);\n    },\n\n    /**\n     * Given a number, this function returns the closest number that is a power of two\n     * this function is taken from Starling Framework as its pretty neat ;)\n     *\n     * @param number {number}\n     * @return {number} the closest number that is a power of two\n     */\n    getNextPowerOfTwo: function (number)\n    {\n        // see: http://en.wikipedia.org/wiki/Power_of_two#Fast_algorithm_to_check_if_a_positive_number_is_a_power_of_two\n        if (number > 0 && (number & (number - 1)) === 0)\n        {\n            return number;\n        }\n        else\n        {\n            var result = 1;\n\n            while (result < number)\n            {\n                result <<= 1;\n            }\n\n            return result;\n        }\n    },\n\n    /**\n     * checks if the given width and height make a power of two rectangle\n     *\n     * @param width {number}\n     * @param height {number}\n     * @return {boolean}\n     */\n    isPowerOfTwo: function (width, height)\n    {\n        return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);\n    },\n\n    /**\n     * get the resolution of an asset by looking for the prefix\n     * used by spritesheets and image urls\n     *\n     * @param url {string} the image path\n     * @return {number}\n     */\n    getResolutionOfUrl: function (url)\n    {\n        var resolution = CONST.RETINA_PREFIX.exec(url);\n\n        if (resolution)\n        {\n           return parseFloat(resolution[1]);\n        }\n\n        return 1;\n    },\n\n    /**\n     * Logs out the version and renderer information for this running instance of PIXI.\n     * If you don't want to see this message you can set `PIXI.utils._saidHello = true;`\n     * so the library thinks it already said it. Keep in mind that doing that will forever\n     * makes you a jerk face.\n     *\n     * @param {string} type - The string renderer type to log.\n     * @constant\n     * @static\n     */\n    sayHello: function (type)\n    {\n        if (utils._saidHello)\n        {\n            return;\n        }\n\n        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1)\n        {\n            var args = [\n                '\\n %c %c %c Pixi.js ' + CONST.VERSION + ' -     ' + type + '      %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c    %c   %c    \\n\\n',\n                'background: #ff66a5; padding:5px 0;',\n                'background: #ff66a5; padding:5px 0;',\n                'color: #ff66a5; background: #030307; padding:5px 0;',\n                'background: #ff66a5; padding:5px 0;',\n                'background: #ffc3dc; padding:5px 0;',\n                'background: #ff66a5; padding:5px 0;',\n                'color: #ff2424; background: #fff; padding:5px 0;',\n                'color: #ff2424; background: #fff; padding:5px 0;',\n                'color: #ff2424; background: #fff; padding:5px 0;'\n            ];\n\n            window.console.log.apply(console, args); //jshint ignore:line\n        }\n        else if (window.console)\n        {\n            window.console.log('Pixi.js ' + CONST.VERSION + ' - ' + type + ' - http://www.pixijs.com/'); //jshint ignore:line\n        }\n\n        utils._saidHello = true;\n    },\n\n    /**\n     * Helper for checking for webgl support\n     *\n     * @return {boolean}\n     */\n    isWebGLSupported: function ()\n    {\n        var contextOptions = { stencil: true };\n        try\n        {\n            if (!window.WebGLRenderingContext)\n            {\n                return false;\n            }\n\n            var canvas = document.createElement('canvas'),\n                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);\n\n            return !!(gl && gl.getContextAttributes().stencil);\n        }\n        catch (e)\n        {\n            return false;\n        }\n    },\n\n    /**\n     * Returns sign of number\n     *\n     * @param n {number}\n     * @returns {number} 0 if n is 0, -1 if n is negative, 1 if n i positive\n     */\n    sign: function (n)\n    {\n        return n ? (n < 0 ? -1 : 1) : 0;\n    },\n\n    /**\n     * removeItems\n     *\n     * @param {array} arr The target array\n     * @param {number} startIdx The index to begin removing from (inclusive)\n     * @param {number} removeCount How many items to remove\n     */\n    removeItems: function (arr, startIdx, removeCount)\n    {\n        var length = arr.length;\n\n        if (startIdx >= length || removeCount === 0)\n        {\n            return;\n        }\n\n        removeCount = (startIdx+removeCount > length ? length-startIdx : removeCount);\n        for (var i = startIdx, len = length-removeCount; i < len; ++i)\n        {\n            arr[i] = arr[i + removeCount];\n        }\n\n        arr.length = len;\n    },\n\n    /**\n     * @todo Describe property usage\n     * @private\n     */\n    TextureCache: {},\n\n    /**\n     * @todo Describe property usage\n     * @private\n     */\n    BaseTextureCache: {}\n};\n\n},{\"../const\":22,\"./pluginTarget\":78,\"async\":1,\"eventemitter3\":10}],78:[function(require,module,exports){\n/**\n * Mixins functionality to make an object have \"plugins\".\n *\n * @mixin\n * @memberof PIXI.utils\n * @param obj {object} The object to mix into.\n * @example\n *      function MyObject() {}\n *\n *      pluginTarget.mixin(MyObject);\n */\nfunction pluginTarget(obj)\n{\n    obj.__plugins = {};\n\n    /**\n     * Adds a plugin to an object\n     *\n     * @param pluginName {string} The events that should be listed.\n     * @param ctor {Function} The constructor function for the plugin.\n     */\n    obj.registerPlugin = function (pluginName, ctor)\n    {\n        obj.__plugins[pluginName] = ctor;\n    };\n\n    /**\n     * Instantiates all the plugins of this object\n     *\n     */\n    obj.prototype.initPlugins = function ()\n    {\n        this.plugins = this.plugins || {};\n\n        for (var o in obj.__plugins)\n        {\n            this.plugins[o] = new (obj.__plugins[o])(this);\n        }\n    };\n\n    /**\n     * Removes all the plugins of this object\n     *\n     */\n    obj.prototype.destroyPlugins = function ()\n    {\n        for (var o in this.plugins)\n        {\n            this.plugins[o].destroy();\n            this.plugins[o] = null;\n        }\n\n        this.plugins = null;\n    };\n}\n\n\nmodule.exports = {\n    /**\n     * Mixes in the properties of the pluginTarget into another object\n     *\n     * @param object {object} The obj to mix into\n     */\n    mixin: function mixin(obj)\n    {\n        pluginTarget(obj);\n    }\n};\n\n},{}],79:[function(require,module,exports){\n/*global console */\nvar core = require('./core'),\n    mesh = require('./mesh'),\n    extras = require('./extras'),\n    filters = require('./filters');\n\n/**\n * @class\n * @private\n * @name SpriteBatch\n * @memberof PIXI\n * @see PIXI.ParticleContainer\n * @throws {ReferenceError} SpriteBatch does not exist any more, please use the new ParticleContainer instead.\n * @deprecated since version 3.0.0\n */\ncore.SpriteBatch = function()\n{\n    throw new ReferenceError('SpriteBatch does not exist any more, please use the new ParticleContainer instead.');\n};\n\n/**\n * @class\n * @private\n * @name AssetLoader\n * @memberof PIXI\n * @see PIXI.loaders.Loader\n * @throws {ReferenceError} The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.\n * @deprecated since version 3.0.0\n */\ncore.AssetLoader = function()\n{\n    throw new ReferenceError('The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.');\n};\n\nObject.defineProperties(core, {\n\n    /**\n     * @class\n     * @private\n     * @name Stage\n     * @memberof PIXI\n     * @see PIXI.Container\n     * @deprecated since version 3.0.0\n     */\n    Stage: {\n        get: function()\n        {\n            console.warn('You do not need to use a PIXI Stage any more, you can simply render any container.');\n            return core.Container;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name DisplayObjectContainer\n     * @memberof PIXI\n     * @see PIXI.Container\n     * @deprecated since version 3.0.0\n     */\n    DisplayObjectContainer: {\n        get: function()\n        {\n            console.warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.');\n            return core.Container;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name Strip\n     * @memberof PIXI\n     * @see PIXI.mesh.Mesh\n     * @deprecated since version 3.0.0\n     */\n    Strip: {\n        get: function()\n        {\n            console.warn('The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.');\n            return mesh.Mesh;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name Rope\n     * @memberof PIXI\n     * @see PIXI.mesh.Rope\n     * @deprecated since version 3.0.0\n     */\n    Rope: {\n        get: function()\n        {\n            console.warn('The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.');\n            return mesh.Rope;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name MovieClip\n     * @memberof PIXI\n     * @see PIXI.extras.MovieClip\n     * @deprecated since version 3.0.0\n     */\n    MovieClip: {\n        get: function()\n        {\n            console.warn('The MovieClip class has been moved to extras.MovieClip, please use extras.MovieClip from now on.');\n            return extras.MovieClip;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name TilingSprite\n     * @memberof PIXI\n     * @see PIXI.extras.TilingSprite\n     * @deprecated since version 3.0.0\n     */\n    TilingSprite: {\n        get: function()\n        {\n            console.warn('The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on.');\n            return extras.TilingSprite;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name BitmapText\n     * @memberof PIXI\n     * @see PIXI.extras.BitmapText\n     * @deprecated since version 3.0.0\n     */\n    BitmapText: {\n        get: function()\n        {\n            console.warn('The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on.');\n            return extras.BitmapText;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name blendModes\n     * @memberof PIXI\n     * @see PIXI.BLEND_MODES\n     * @deprecated since version 3.0.0\n     */\n    blendModes: {\n        get: function()\n        {\n            console.warn('The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.');\n            return core.BLEND_MODES;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name scaleModes\n     * @memberof PIXI\n     * @see PIXI.SCALE_MODES\n     * @deprecated since version 3.0.0\n     */\n    scaleModes: {\n        get: function()\n        {\n            console.warn('The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.');\n            return core.SCALE_MODES;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name BaseTextureCache\n     * @memberof PIXI\n     * @see PIXI.utils.BaseTextureCache\n     * @deprecated since version 3.0.0\n     */\n    BaseTextureCache: {\n        get: function ()\n        {\n            console.warn('The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on.');\n            return core.utils.BaseTextureCache;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name TextureCache\n     * @memberof PIXI\n     * @see PIXI.utils.TextureCache\n     * @deprecated since version 3.0.0\n     */\n    TextureCache: {\n        get: function ()\n        {\n            console.warn('The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on.');\n            return core.utils.TextureCache;\n        }\n    },\n\n    /**\n     * @namespace\n     * @private\n     * @name math\n     * @memberof PIXI\n     * @see PIXI\n     * @deprecated since version 3.0.6\n     */\n    math: {\n        get: function ()\n        {\n            console.warn('The math namespace is deprecated, please access members already accessible on PIXI.');\n            return core;\n        }\n    }\n});\n\n/**\n * @method\n * @private\n * @name PIXI.Sprite#setTexture\n * @see PIXI.Sprite#texture\n * @deprecated since version 3.0.0\n */\ncore.Sprite.prototype.setTexture = function(texture)\n{\n    this.texture = texture;\n    console.warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;');\n};\n\n/**\n * @method\n * @name PIXI.extras.BitmapText#setText\n * @see PIXI.extras.BitmapText#text\n * @deprecated since version 3.0.0\n */\nextras.BitmapText.prototype.setText = function(text)\n{\n    this.text = text;\n    console.warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \\'my text\\';');\n};\n\n/**\n * @method\n * @name PIXI.Text#setText\n * @see PIXI.Text#text\n * @deprecated since version 3.0.0\n */\ncore.Text.prototype.setText = function(text)\n{\n    this.text = text;\n    console.warn('setText is now deprecated, please use the text property, e.g : myText.text = \\'my text\\';');\n};\n\n/**\n * @method\n * @name PIXI.Text#setStyle\n * @see PIXI.Text#style\n * @deprecated since version 3.0.0\n */\ncore.Text.prototype.setStyle = function(style)\n{\n    this.style = style;\n    console.warn('setStyle is now deprecated, please use the style property, e.g : myText.style = style;');\n};\n\n/**\n * @method\n * @name PIXI.Texture#setFrame\n * @see PIXI.Texture#setFrame\n * @deprecated since version 3.0.0\n */\ncore.Texture.prototype.setFrame = function(frame)\n{\n    this.frame = frame;\n    console.warn('setFrame is now deprecated, please use the frame property, e.g : myTexture.frame = frame;');\n};\n\nObject.defineProperties(filters, {\n\n    /**\n     * @class\n     * @private\n     * @name PIXI.filters.AbstractFilter\n     * @see PIXI.AbstractFilter\n     * @deprecated since version 3.0.6\n     */\n    AbstractFilter: {\n        get: function()\n        {\n            console.warn('filters.AbstractFilter is an undocumented alias, please use AbstractFilter from now on.');\n            return core.AbstractFilter;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name PIXI.filters.FXAAFilter\n     * @see PIXI.FXAAFilter\n     * @deprecated since version 3.0.6\n     */\n    FXAAFilter: {\n        get: function()\n        {\n            console.warn('filters.FXAAFilter is an undocumented alias, please use FXAAFilter from now on.');\n            return core.FXAAFilter;\n        }\n    },\n\n    /**\n     * @class\n     * @private\n     * @name PIXI.filters.SpriteMaskFilter\n     * @see PIXI.SpriteMaskFilter\n     * @deprecated since version 3.0.6\n     */\n    SpriteMaskFilter: {\n        get: function()\n        {\n            console.warn('filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.');\n            return core.SpriteMaskFilter;\n        }\n    }\n});\n\n/**\n * @method\n * @name PIXI.utils.uuid\n * @see PIXI.utils.uid\n * @deprecated since version 3.0.6\n */\ncore.utils.uuid = function ()\n{\n    console.warn('utils.uuid() is deprecated, please use utils.uid() from now on.');\n    return core.utils.uid();\n};\n\n},{\"./core\":29,\"./extras\":86,\"./filters\":103,\"./mesh\":128}],80:[function(require,module,exports){\nvar core = require('../core');\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * var bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n * @param text {string} The copy that you would like the text to display\n * @param style {object} The style parameters\n * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form\n *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n * @param [style.font.name] {string} The bitmap font id\n * @param [style.font.size] {number} The size of the font in pixels, e.g. 24\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect\n *      single line text\n * @param [style.tint=0xFFFFFF] {number} The tint color\n */\nfunction BitmapText(text, style)\n{\n    core.Container.call(this);\n\n    style = style || {};\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.textWidth = 0;\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.textHeight = 0;\n\n    /**\n     * Private tracker for the letter sprite pool.\n     *\n     * @member {PIXI.Sprite[]}\n     * @private\n     */\n    this._glyphs = [];\n\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n    this._font = {\n        tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n        align: style.align || 'left',\n        name: null,\n        size: 0\n    };\n\n    /**\n     * Private tracker for the current font.\n     *\n     * @member {object}\n     * @private\n     */\n    this.font = style.font; // run font setter\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n    this._text = text;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     */\n    this.maxWidth = 0;\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text, ie: when trying to vertically align.\n     *\n     * @member {number}\n     */\n    this.maxLineHeight = 0;\n\n    /**\n     * The dirty state of this object.\n     *\n     * @member {boolean}\n     */\n    this.dirty = false;\n\n    this.updateText();\n}\n\n// constructor\nBitmapText.prototype = Object.create(core.Container.prototype);\nBitmapText.prototype.constructor = BitmapText;\nmodule.exports = BitmapText;\n\nObject.defineProperties(BitmapText.prototype, {\n    /**\n     * The tint of the BitmapText object\n     *\n     * @member {number}\n     * @memberof PIXI.extras.BitmapText#\n     */\n    tint: {\n        get: function ()\n        {\n            return this._font.tint;\n        },\n        set: function (value)\n        {\n            this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;\n\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     * @memberof PIXI.extras.BitmapText#\n     */\n    align: {\n        get: function ()\n        {\n            return this._font.align;\n        },\n        set: function (value)\n        {\n            this._font.align = value || 'left';\n\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {Font}\n     * @memberof PIXI.extras.BitmapText#\n     */\n    font: {\n        get: function ()\n        {\n            return this._font;\n        },\n        set: function (value)\n        {\n            if (!value) {\n                return;\n            }\n\n            if (typeof value === 'string') {\n                value = value.split(' ');\n\n                this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n                this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n            }\n            else {\n                this._font.name = value.name;\n                this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n            }\n\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     * @memberof PIXI.extras.BitmapText#\n     */\n    text: {\n        get: function ()\n        {\n            return this._text;\n        },\n        set: function (value)\n        {\n            value = value.toString() || ' ';\n            if (this._text === value)\n            {\n                return;\n            }\n            this._text = value;\n            this.dirty = true;\n        }\n    }\n});\n\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\nBitmapText.prototype.updateText = function ()\n{\n    var data = BitmapText.fonts[this._font.name];\n    var pos = new core.Point();\n    var prevCharCode = null;\n    var chars = [];\n    var lastLineWidth = 0;\n    var maxLineWidth = 0;\n    var lineWidths = [];\n    var line = 0;\n    var scale = this._font.size / data.size;\n    var lastSpace = -1;\n    var maxLineHeight = 0;\n\n    for (var i = 0; i < this.text.length; i++)\n    {\n        var charCode = this.text.charCodeAt(i);\n        lastSpace = /(\\s)/.test(this.text.charAt(i)) ? i : lastSpace;\n\n        if (/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n        {\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n\n        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)\n        {\n            core.utils.removeItems(chars, lastSpace, i - lastSpace);\n            i = lastSpace;\n            lastSpace = -1;\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n\n        var charData = data.chars[charCode];\n\n        if (!charData)\n        {\n            continue;\n        }\n\n        if (prevCharCode && charData.kerning[prevCharCode])\n        {\n            pos.x += charData.kerning[prevCharCode];\n        }\n\n        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});\n        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);\n        pos.x += charData.xAdvance;\n        maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n        prevCharCode = charCode;\n    }\n\n    lineWidths.push(lastLineWidth);\n    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n\n    var lineAlignOffsets = [];\n\n    for (i = 0; i <= line; i++)\n    {\n        var alignOffset = 0;\n\n        if (this._font.align === 'right')\n        {\n            alignOffset = maxLineWidth - lineWidths[i];\n        }\n        else if (this._font.align === 'center')\n        {\n            alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        lineAlignOffsets.push(alignOffset);\n    }\n\n    var lenChars = chars.length;\n    var tint = this.tint;\n\n    for (i = 0; i < lenChars; i++)\n    {\n        var c = this._glyphs[i]; // get the next glyph sprite\n\n        if (c)\n        {\n            c.texture = chars[i].texture;\n        }\n        else\n        {\n            c = new core.Sprite(chars[i].texture);\n            this._glyphs.push(c);\n        }\n\n        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n        c.position.y = chars[i].position.y * scale;\n        c.scale.x = c.scale.y = scale;\n        c.tint = tint;\n\n        if (!c.parent)\n        {\n            this.addChild(c);\n        }\n    }\n\n    // remove unnecessary children.\n    for (i = lenChars; i < this._glyphs.length; ++i)\n    {\n        this.removeChild(this._glyphs[i]);\n    }\n\n    this.textWidth = maxLineWidth * scale;\n    this.textHeight = (pos.y + data.lineHeight) * scale;\n    this.maxLineHeight = maxLineHeight * scale;\n};\n\n/**\n * Updates the transform of this object\n *\n * @private\n */\nBitmapText.prototype.updateTransform = function ()\n{\n    this.validate();\n    this.containerUpdateTransform();\n};\n\n/**\n * Validates text before calling parent's getLocalBounds\n *\n * @return {PIXI.Rectangle} The rectangular bounding area\n */\n\nBitmapText.prototype.getLocalBounds = function()\n{\n    this.validate();\n    return core.Container.prototype.getLocalBounds.call(this);\n};\n\n/**\n * Updates text when needed\n *\n * @private\n */\nBitmapText.prototype.validate = function()\n{\n    if (this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n};\n\nBitmapText.fonts = {};\n\n},{\"../core\":29}],81:[function(require,module,exports){\nvar core = require('../core');\n\n/**\n * A MovieClip is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * var alienImages = [\"image_sequence_01.png\",\"image_sequence_02.png\",\"image_sequence_03.png\",\"image_sequence_04.png\"];\n * var textureArray = [];\n *\n * for (var i=0; i < 4; i++)\n * {\n *      var texture = PIXI.Texture.fromImage(alienImages[i]);\n *      textureArray.push(texture);\n * };\n *\n * var mc = new PIXI.MovieClip(textureArray);\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n * @param textures {PIXI.Texture[]|Object[]} an array of {@link PIXI.Texture} or frame objects that make up the animation\n * @param textures[].texture {PIXI.Texture} the {@link PIXI.Texture} of the frame\n * @param textures[].time {number} the duration of the frame in ms\n */\nfunction MovieClip(textures)\n{\n    core.Sprite.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);\n\n    /**\n     * @private\n     */\n    this._textures = null;\n\n    /**\n     * @private\n     */\n    this._durations = null;\n\n    this.textures = textures;\n\n    /**\n     * The speed that the MovieClip will play at. Higher is faster, lower is slower\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.animationSpeed = 1;\n\n    /**\n     * Whether or not the movie clip repeats after playing.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.loop = true;\n\n    /**\n     * Function to call when a MovieClip finishes playing\n     *\n     * @method\n     * @memberof PIXI.extras.MovieClip#\n     */\n    this.onComplete = null;\n\n    /**\n     * Elapsed time since animation has been started, used internally to display current texture\n     *\n     * @member {number}\n     * @private\n     */\n    this._currentTime = 0;\n\n    /**\n     * Indicates if the MovieClip is currently playing\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    this.playing = false;\n}\n\n// constructor\nMovieClip.prototype = Object.create(core.Sprite.prototype);\nMovieClip.prototype.constructor = MovieClip;\nmodule.exports = MovieClip;\n\nObject.defineProperties(MovieClip.prototype, {\n    /**\n     * totalFrames is the total number of frames in the MovieClip. This is the same as number of textures\n     * assigned to the MovieClip.\n     *\n     * @member {number}\n     * @memberof PIXI.extras.MovieClip#\n     * @default 0\n     * @readonly\n     */\n    totalFrames: {\n        get: function()\n        {\n            return this._textures.length;\n        }\n    },\n\n    /**\n     * The array of textures used for this MovieClip\n     *\n     * @member {PIXI.Texture[]}\n     * @memberof PIXI.extras.MovieClip#\n     *\n     */\n    textures: {\n        get: function ()\n        {\n            return this._textures;\n        },\n        set: function (value)\n        {\n            if(value[0] instanceof core.Texture)\n            {\n                this._textures = value;\n                this._durations = null;\n            }\n            else\n            {\n                this._textures = [];\n                this._durations = [];\n                for(var i = 0; i < value.length; i++)\n                {\n                    this._textures.push(value[i].texture);\n                    this._durations.push(value[i].time);\n                }\n            }\n        }\n    },\n\n    /**\n    * The MovieClips current frame index\n    *\n    * @member {number}\n    * @memberof PIXI.extras.MovieClip#\n    * @readonly\n    */\n    currentFrame: {\n        get: function ()\n        {\n            var currentFrame = Math.floor(this._currentTime) % this._textures.length;\n            if (currentFrame < 0)\n            {\n                currentFrame += this._textures.length;\n            }\n            return currentFrame;\n        }\n    }\n\n});\n\n/**\n * Stops the MovieClip\n *\n */\nMovieClip.prototype.stop = function ()\n{\n    if(!this.playing)\n    {\n        return;\n    }\n\n    this.playing = false;\n    core.ticker.shared.remove(this.update, this);\n};\n\n/**\n * Plays the MovieClip\n *\n */\nMovieClip.prototype.play = function ()\n{\n    if(this.playing)\n    {\n        return;\n    }\n\n    this.playing = true;\n    core.ticker.shared.add(this.update, this);\n};\n\n/**\n * Stops the MovieClip and goes to a specific frame\n *\n * @param frameNumber {number} frame index to stop at\n */\nMovieClip.prototype.gotoAndStop = function (frameNumber)\n{\n    this.stop();\n\n    this._currentTime = frameNumber;\n\n    this._texture = this._textures[this.currentFrame];\n};\n\n/**\n * Goes to a specific frame and begins playing the MovieClip\n *\n * @param frameNumber {number} frame index to start at\n */\nMovieClip.prototype.gotoAndPlay = function (frameNumber)\n{\n    this._currentTime = frameNumber;\n\n    this.play();\n};\n\n/*\n * Updates the object transform for rendering\n * @private\n */\nMovieClip.prototype.update = function (deltaTime)\n{\n    var elapsed = this.animationSpeed * deltaTime;\n\n    if (this._durations !== null)\n    {\n        var lag = this._currentTime % 1 * this._durations[this.currentFrame];\n\n        lag += elapsed / 60 * 1000;\n\n        while (lag < 0)\n        {\n            this._currentTime--;\n            lag += this._durations[this.currentFrame];\n        }\n\n        var sign = Math.sign(this.animationSpeed * deltaTime);\n        this._currentTime = Math.floor(this._currentTime);\n\n        while (lag >= this._durations[this.currentFrame])\n        {\n            lag -= this._durations[this.currentFrame] * sign;\n            this._currentTime += sign;\n        }\n\n        this._currentTime += lag / this._durations[this.currentFrame];\n    }\n    else\n    {\n        this._currentTime += elapsed;\n    }\n\n    if (this._currentTime < 0 && !this.loop)\n    {\n        this.gotoAndStop(0);\n\n        if (this.onComplete)\n        {\n            this.onComplete();\n        }\n    }\n    else if (this._currentTime >= this._textures.length && !this.loop)\n    {\n        this.gotoAndStop(this._textures.length - 1);\n\n        if (this.onComplete)\n        {\n            this.onComplete();\n        }\n    }\n    else\n    {\n        this._texture = this._textures[this.currentFrame];\n    }\n\n};\n\n/*\n * Stops the MovieClip and destroys it\n *\n */\nMovieClip.prototype.destroy = function ( )\n{\n    this.stop();\n    core.Sprite.prototype.destroy.call(this);\n};\n\n/**\n * A short hand way of creating a movieclip from an array of frame ids\n *\n * @static\n * @param frames {string[]} the array of frames ids the movieclip will use as its texture frames\n */\nMovieClip.fromFrames = function (frames)\n{\n    var textures = [];\n\n    for (var i = 0; i < frames.length; ++i)\n    {\n        textures.push(new core.Texture.fromFrame(frames[i]));\n    }\n\n    return new MovieClip(textures);\n};\n\n/**\n * A short hand way of creating a movieclip from an array of image ids\n *\n * @static\n * @param images {string[]} the array of image urls the movieclip will use as its texture frames\n */\nMovieClip.fromImages = function (images)\n{\n    var textures = [];\n\n    for (var i = 0; i < images.length; ++i)\n    {\n        textures.push(new core.Texture.fromImage(images[i]));\n    }\n\n    return new MovieClip(textures);\n};\n},{\"../core\":29}],82:[function(require,module,exports){\nvar core = require('../core'),\n    // a sprite use dfor rendering textures..\n    tempPoint = new core.Point(),\n    CanvasTinter = require('../core/renderers/canvas/utils/CanvasTinter');\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n * @param texture {Texture} the texture of the tiling sprite\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n */\nfunction TilingSprite(texture, width, height)\n{\n    core.Sprite.call(this, texture);\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.Point}\n     */\n    this.tileScale = new core.Point(1,1);\n\n\n    /**\n     * The offset position of the image that is being tiled\n     *\n     * @member {PIXI.Point}\n     */\n    this.tilePosition = new core.Point(0,0);\n\n    ///// private\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n    this._width = width || 100;\n\n    /**\n     * The height of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n    this._height = height || 100;\n\n    /**\n     * An internal WebGL UV cache.\n     *\n     * @member {PIXI.TextureUvs}\n     * @private\n     */\n    this._uvs = new core.TextureUvs();\n\n    this._canvasPattern = null;\n\n    //TODO move..\n    this.shader = new core.AbstractFilter(\n\n      [\n        'precision lowp float;',\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aTextureCoord;',\n        'attribute vec4 aColor;',\n\n        'uniform mat3 projectionMatrix;',\n\n        'uniform vec4 uFrame;',\n        'uniform vec4 uTransform;',\n\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n\n        'void main(void){',\n        '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n\n        '   vec2 coord = aTextureCoord;',\n        '   coord -= uTransform.xy;',\n        '   coord /= uTransform.zw;',\n        '   vTextureCoord = coord;',\n\n        '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',\n        '}'\n      ].join('\\n'),\n      [\n        'precision lowp float;',\n\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n\n        'uniform sampler2D uSampler;',\n        'uniform vec4 uFrame;',\n        'uniform vec2 uPixelSize;',\n\n        'void main(void){',\n\n        '   vec2 coord = mod(vTextureCoord, uFrame.zw);',\n        '   coord = clamp(coord, uPixelSize, uFrame.zw - uPixelSize);',\n        '   coord += uFrame.xy;',\n\n        '   gl_FragColor =  texture2D(uSampler, coord) * vColor ;',\n        '}'\n      ].join('\\n'),\n\n            // set the uniforms\n            {\n                uFrame: { type: '4fv', value: [0,0,1,1] },\n                uTransform: { type: '4fv', value: [0,0,1,1] },\n                uPixelSize : { type : '2fv', value: [1, 1]}\n            }\n      );\n}\n\nTilingSprite.prototype = Object.create(core.Sprite.prototype);\nTilingSprite.prototype.constructor = TilingSprite;\nmodule.exports = TilingSprite;\n\n\nObject.defineProperties(TilingSprite.prototype, {\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.extras.TilingSprite#\n     */\n    width: {\n        get: function ()\n        {\n            return this._width;\n        },\n        set: function (value)\n        {\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.extras.TilingSprite#\n     */\n    height: {\n        get: function ()\n        {\n            return this._height;\n        },\n        set: function (value)\n        {\n            this._height = value;\n        }\n    }\n});\n\nTilingSprite.prototype._onTextureUpdate = function ()\n{\n    return;\n};\n\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer}\n * @private\n */\nTilingSprite.prototype._renderWebGL = function (renderer)\n{\n    // tweak our texture temporarily..\n    var texture = this._texture;\n\n    if(!texture || !texture._uvs)\n    {\n        return;\n    }\n\n    var tempUvs = texture._uvs,\n        tempWidth = texture._frame.width,\n        tempHeight = texture._frame.height,\n        tw = texture.baseTexture.width,\n        th = texture.baseTexture.height;\n\n    texture._uvs = this._uvs;\n    texture._frame.width = this.width;\n    texture._frame.height = this.height;\n\n    this.shader.uniforms.uPixelSize.value[0] = 1.0/tw;\n    this.shader.uniforms.uPixelSize.value[1] = 1.0/th;\n\n    this.shader.uniforms.uFrame.value[0] = tempUvs.x0;\n    this.shader.uniforms.uFrame.value[1] = tempUvs.y0;\n    this.shader.uniforms.uFrame.value[2] = tempUvs.x1 - tempUvs.x0;\n    this.shader.uniforms.uFrame.value[3] = tempUvs.y2 - tempUvs.y0;\n\n    this.shader.uniforms.uTransform.value[0] = (this.tilePosition.x % (tempWidth * this.tileScale.x)) / this._width;\n    this.shader.uniforms.uTransform.value[1] = (this.tilePosition.y % (tempHeight * this.tileScale.y)) / this._height;\n    this.shader.uniforms.uTransform.value[2] = ( tw / this._width ) * this.tileScale.x;\n    this.shader.uniforms.uTransform.value[3] = ( th / this._height ) * this.tileScale.y;\n\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render(this);\n\n    texture._uvs = tempUvs;\n    texture._frame.width = tempWidth;\n    texture._frame.height = tempHeight;\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {PIXI.CanvasRenderer} a reference to the canvas renderer\n * @private\n */\nTilingSprite.prototype._renderCanvas = function (renderer)\n{\n    var texture = this._texture;\n\n    if (!texture.baseTexture.hasLoaded)\n    {\n      return;\n    }\n\n    var context = renderer.context,\n        transform = this.worldTransform,\n        resolution = renderer.resolution,\n        baseTexture = texture.baseTexture,\n        modX = (this.tilePosition.x / this.tileScale.x) % texture._frame.width,\n        modY = (this.tilePosition.y / this.tileScale.y) % texture._frame.height;\n\n    // create a nice shiny pattern!\n    // TODO this needs to be refreshed if texture changes..\n    if(!this._canvasPattern)\n    {\n        // cut an object from a spritesheet..\n        var tempCanvas = new core.CanvasBuffer(texture._frame.width * resolution, texture._frame.height * resolution);\n\n        // Tint the tiling sprite\n        if (this.tint !== 0xFFFFFF)\n        {\n            if (this.cachedTint !== this.tint)\n            {\n                this.cachedTint = this.tint;\n\n                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n            }\n            tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x * resolution, -texture._frame.y * resolution);\n        }\n        this._canvasPattern = tempCanvas.context.createPattern( tempCanvas.canvas, 'repeat' );\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    context.setTransform(transform.a * resolution,\n                       transform.b * resolution,\n                       transform.c * resolution,\n                       transform.d * resolution,\n                       transform.tx * resolution,\n                       transform.ty * resolution);\n\n    // TODO - this should be rolled into the setTransform above..\n    context.scale(this.tileScale.x / resolution, this.tileScale.y / resolution);\n\n    context.translate(modX + (this.anchor.x * -this._width ),\n                      modY + (this.anchor.y * -this._height));\n\n    // check blend mode\n    var compositeOperation = renderer.blendModes[this.blendMode];\n    if (compositeOperation !== renderer.context.globalCompositeOperation)\n    {\n        context.globalCompositeOperation = compositeOperation;\n    }\n\n    // fill the pattern!\n    context.fillStyle = this._canvasPattern;\n    context.fillRect(-modX,\n                     -modY,\n                     this._width * resolution / this.tileScale.x,\n                     this._height * resolution / this.tileScale.y);\n\n\n    //TODO - pretty sure this can be deleted...\n    //context.translate(-this.tilePosition.x + (this.anchor.x * this._width), -this.tilePosition.y + (this.anchor.y * this._height));\n    //context.scale(1 / this.tileScale.x, 1 / this.tileScale.y);\n};\n\n\n/**\n * Returns the framing rectangle of the sprite as a Rectangle object\n*\n * @return {PIXI.Rectangle} the framing rectangle\n */\nTilingSprite.prototype.getBounds = function ()\n{\n    var width = this._width;\n    var height = this._height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var minX,\n        maxX,\n        minY,\n        maxY;\n\n    minX = x1;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n * Checks if a point is inside this tiling sprite\n * @param point {PIXI.Point} the point to check\n */\nTilingSprite.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor.x;\n    var y1;\n\n    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )\n    {\n        y1 = -height * this.anchor.y;\n\n        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Destroys this tiling sprite\n *\n */\nTilingSprite.prototype.destroy = function () {\n    core.Sprite.prototype.destroy.call(this);\n\n    this.tileScale = null;\n    this._tileScaleOffset = null;\n    this.tilePosition = null;\n\n    this._uvs = null;\n};\n\n/**\n * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {string} The frame Id of the texture in the cache\n * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n */\nTilingSprite.fromFrame = function (frameId,width,height)\n{\n    var texture = core.utils.TextureCache[frameId];\n\n    if (!texture)\n    {\n        throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ' + this);\n    }\n\n    return new TilingSprite(texture,width,height);\n};\n\n/**\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @static\n * @param imageId {string} The image url of the texture\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter\n * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values\n * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n */\nTilingSprite.fromImage = function (imageId, width, height, crossorigin, scaleMode)\n{\n    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode),width,height);\n};\n\n},{\"../core\":29,\"../core/renderers/canvas/utils/CanvasTinter\":48}],83:[function(require,module,exports){\nvar core = require('../core'),\n    DisplayObject = core.DisplayObject,\n    _tempMatrix = new core.Matrix();\n\nDisplayObject.prototype._cacheAsBitmap = false;\nDisplayObject.prototype._originalRenderWebGL = null;\nDisplayObject.prototype._originalRenderCanvas = null;\n\nDisplayObject.prototype._originalUpdateTransform = null;\nDisplayObject.prototype._originalHitTest = null;\nDisplayObject.prototype._originalDestroy = null;\nDisplayObject.prototype._cachedSprite = null;\n\nObject.defineProperties(DisplayObject.prototype, {\n\n    /**\n     * Set this to true if you want this display object to be cached as a bitmap.\n     * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.\n     * To remove simply set this property to 'false'\n     *\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     */\n    cacheAsBitmap: {\n        get: function ()\n        {\n            return this._cacheAsBitmap;\n        },\n        set: function (value)\n        {\n            if (this._cacheAsBitmap === value)\n            {\n                return;\n            }\n\n            this._cacheAsBitmap = value;\n\n            if (value)\n            {\n                this._originalRenderWebGL = this.renderWebGL;\n                this._originalRenderCanvas = this.renderCanvas;\n\n                this._originalUpdateTransform = this.updateTransform;\n                this._originalGetBounds = this.getBounds;\n\n                this._originalDestroy = this.destroy;\n\n                this._originalContainsPoint = this.containsPoint;\n\n                this.renderWebGL = this._renderCachedWebGL;\n                this.renderCanvas = this._renderCachedCanvas;\n\n                this.destroy = this._cacheAsBitmapDestroy;\n\n            }\n            else\n            {\n                if (this._cachedSprite)\n                {\n                    this._destroyCachedDisplayObject();\n                }\n\n                this.renderWebGL = this._originalRenderWebGL;\n                this.renderCanvas = this._originalRenderCanvas;\n                this.getBounds = this._originalGetBounds;\n\n                this.destroy = this._originalDestroy;\n\n                this.updateTransform = this._originalUpdateTransform;\n                this.containsPoint = this._originalContainsPoint;\n            }\n        }\n    }\n});\n/**\n* Renders a cached version of the sprite with WebGL\n*\n* @param renderer {PIXI.WebGLRenderer} the WebGL renderer\n* @private\n*/\nDisplayObject.prototype._renderCachedWebGL = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    this._initCachedDisplayObject( renderer );\n\n    this._cachedSprite.worldAlpha = this.worldAlpha;\n\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render( this._cachedSprite );\n};\n\n/**\n* Prepares the WebGL renderer to cache the sprite\n*\n* @param renderer {PIXI.WebGLRenderer} the WebGL renderer\n* @private\n*/\nDisplayObject.prototype._initCachedDisplayObject = function (renderer)\n{\n    if(this._cachedSprite)\n    {\n        return;\n    }\n\n    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)\n    renderer.currentRenderer.flush();\n    //this.filters= [];\n    // next we find the dimensions of the untransformed object\n    // this function also calls updatetransform on all its children as part of the measuring. This means we don't need to update the transform again in this function\n    // TODO pass an object to clone too? saves having to create a new one each time!\n    var bounds = this.getLocalBounds().clone();\n\n    // add some padding!\n    if(this._filters)\n    {\n        var padding = this._filters[0].padding;\n        bounds.x -= padding;\n        bounds.y -= padding;\n\n        bounds.width += padding * 2;\n        bounds.height += padding * 2;\n    }\n\n    // for now we cache the current renderTarget that the webGL renderer is currently using.\n    // this could be more elegent..\n    var cachedRenderTarget = renderer.currentRenderTarget;\n    // We also store the filter stack - I will definitely look to change how this works a little later down the line.\n    var stack = renderer.filterManager.filterStack;\n\n    // this renderTexture will be used to store the cached DisplayObject\n    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);\n\n    // need to set //\n    var m = _tempMatrix;\n\n    m.tx = -bounds.x;\n    m.ty = -bounds.y;\n\n\n\n    // set all properties to there original so we can render to a texture\n    this.renderWebGL = this._originalRenderWebGL;\n\n    renderTexture.render(this, m, true, true);\n\n    // now restore the state be setting the new properties\n    renderer.setRenderTarget(cachedRenderTarget);\n    renderer.filterManager.filterStack = stack;\n\n    this.renderWebGL     = this._renderCachedWebGL;\n    this.updateTransform = this.displayObjectUpdateTransform;\n    this.getBounds       = this._getCachedBounds;\n\n\n    // create our cached sprite\n    this._cachedSprite = new core.Sprite(renderTexture);\n    this._cachedSprite.worldTransform = this.worldTransform;\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    // restore the transform of the cached sprite to avoid the nasty flicker..\n    this.updateTransform();\n\n    // map the hit test..\n    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);\n};\n\n/**\n* Renders a cached version of the sprite with canvas\n*\n* @param renderer {PIXI.CanvasRenderer} the Canvas renderer\n* @private\n*/\nDisplayObject.prototype._renderCachedCanvas = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    this._initCachedDisplayObjectCanvas( renderer );\n\n    this._cachedSprite.worldAlpha = this.worldAlpha;\n\n    this._cachedSprite.renderCanvas(renderer);\n};\n\n//TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..\n/**\n* Prepares the Canvas renderer to cache the sprite\n*\n* @param renderer {PIXI.CanvasRenderer} the Canvas renderer\n* @private\n*/\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer)\n{\n    if(this._cachedSprite)\n    {\n        return;\n    }\n\n    //get bounds actually transforms the object for us already!\n    var bounds = this.getLocalBounds();\n\n    var cachedRenderTarget = renderer.context;\n\n    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);\n\n    // need to set //\n    var m = _tempMatrix;\n\n    m.tx = -bounds.x;\n    m.ty = -bounds.y;\n\n    // set all properties to there original so we can render to a texture\n    this.renderCanvas = this._originalRenderCanvas;\n\n    renderTexture.render(this, m, true);\n\n    // now restore the state be setting the new properties\n    renderer.context = cachedRenderTarget;\n\n    this.renderCanvas = this._renderCachedCanvas;\n    this.updateTransform = this.displayObjectUpdateTransform;\n    this.getBounds  = this._getCachedBounds;\n\n\n    // create our cached sprite\n    this._cachedSprite = new core.Sprite(renderTexture);\n    this._cachedSprite.worldTransform = this.worldTransform;\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    this.updateTransform();\n\n    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);\n};\n\n/**\n* Calculates the bounds of the cached sprite\n*\n* @private\n*/\nDisplayObject.prototype._getCachedBounds = function ()\n{\n    this._cachedSprite._currentBounds = null;\n\n    return this._cachedSprite.getBounds();\n};\n\n/**\n* Destroys the cached sprite.\n*\n* @private\n*/\nDisplayObject.prototype._destroyCachedDisplayObject = function ()\n{\n    this._cachedSprite._texture.destroy();\n    this._cachedSprite = null;\n};\n\nDisplayObject.prototype._cacheAsBitmapDestroy = function ()\n{\n    this.cacheAsBitmap = false;\n    this._originalDestroy();\n};\n\n},{\"../core\":29}],84:[function(require,module,exports){\nvar core = require('../core');\n\n/**\n * The instance name of the object.\n *\n * @memberof PIXI.DisplayObject#\n * @member {string}\n */\ncore.DisplayObject.prototype.name = null;\n\n/**\n* Returns the display object in the container\n*\n* @memberof PIXI.Container#\n* @param name {string} instance name\n* @return {PIXI.DisplayObject}\n*/\ncore.Container.prototype.getChildByName = function (name)\n{\n    for (var i = 0; i < this.children.length; i++)\n    {\n        if (this.children[i].name === name)\n        {\n            return this.children[i];\n        }\n    }\n    return null;\n};\n\n},{\"../core\":29}],85:[function(require,module,exports){\nvar core = require('../core');\n\n/**\n* Returns the global position of the displayObject\n*\n* @memberof PIXI.DisplayObject#\n* @param point {Point} the point to write the global value to. If null a new point will be returned\n* @return {Point}\n*/\ncore.DisplayObject.prototype.getGlobalPosition = function (point)\n{\n    point = point || new core.Point();\n\n    if(this.parent)\n    {\n        this.displayObjectUpdateTransform();\n\n        point.x = this.worldTransform.tx;\n        point.y = this.worldTransform.ty;\n    }\n    else\n    {\n        point.x = this.position.x;\n        point.y = this.position.y;\n    }\n\n    return point;\n};\n\n},{\"../core\":29}],86:[function(require,module,exports){\n/**\n * @file        Main export of the PIXI extras library\n * @author      Mat Groves <mat@goodboydigital.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}\n */\n\nrequire('./cacheAsBitmap');\nrequire('./getChildByName');\nrequire('./getGlobalPosition');\n\n/**\n * @namespace PIXI.extras\n */\nmodule.exports = {\n    MovieClip:      require('./MovieClip'),\n    TilingSprite:   require('./TilingSprite'),\n    BitmapText:     require('./BitmapText')\n};\n\n},{\"./BitmapText\":80,\"./MovieClip\":81,\"./TilingSprite\":82,\"./cacheAsBitmap\":83,\"./getChildByName\":84,\"./getGlobalPosition\":85}],87:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n// TODO (cengler) - The Y is flipped in this shader for some reason.\n\n/**\n * @author Vico @vicocotea\n * original shader : https://www.shadertoy.com/view/lssGDj by @movAX13h\n */\n\n/**\n * An ASCII filter.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction AsciiFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nuniform vec4 dimensions;\\nuniform float pixelSize;\\nuniform sampler2D uSampler;\\n\\nfloat character(float n, vec2 p)\\n{\\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\\n    {\\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\\n    }\\n    return 0.0;\\n}\\n\\nvoid main()\\n{\\n    vec2 uv = gl_FragCoord.xy;\\n\\n    vec3 col = texture2D(uSampler, floor( uv / pixelSize ) * pixelSize / dimensions.xy).rgb;\\n\\n    float gray = (col.r + col.g + col.b) / 3.0;\\n\\n    float n =  65536.0;             // .\\n    if (gray > 0.2) n = 65600.0;    // :\\n    if (gray > 0.3) n = 332772.0;   // *\\n    if (gray > 0.4) n = 15255086.0; // o\\n    if (gray > 0.5) n = 23385164.0; // &\\n    if (gray > 0.6) n = 15252014.0; // 8\\n    if (gray > 0.7) n = 13199452.0; // @\\n    if (gray > 0.8) n = 11512810.0; // #\\n\\n    vec2 p = mod( uv / ( pixelSize * 0.5 ), 2.0) - vec2(1.0);\\n    col = col * character(n, p);\\n\\n    gl_FragColor = vec4(col, 1.0);\\n}\\n\",\n        // custom uniforms\n        {\n            dimensions: { type: '4fv', value: new Float32Array([0, 0, 0, 0]) },\n            pixelSize:  { type: '1f', value: 8 }\n        }\n    );\n}\n\nAsciiFilter.prototype = Object.create(core.AbstractFilter.prototype);\nAsciiFilter.prototype.constructor = AsciiFilter;\nmodule.exports = AsciiFilter;\n\nObject.defineProperties(AsciiFilter.prototype, {\n    /**\n     * The pixel size used by the filter.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.AsciiFilter#\n     */\n    size: {\n        get: function ()\n        {\n            return this.uniforms.pixelSize.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.pixelSize.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],88:[function(require,module,exports){\nvar core = require('../../core'),\n    BlurXFilter = require('../blur/BlurXFilter'),\n    BlurYFilter = require('../blur/BlurYFilter');\n\n/**\n * The BloomFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for x- and y-axis separately.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction BloomFilter()\n{\n    core.AbstractFilter.call(this);\n\n    this.blurXFilter = new BlurXFilter();\n    this.blurYFilter = new BlurYFilter();\n\n    this.defaultFilter = new core.AbstractFilter();\n}\n\nBloomFilter.prototype = Object.create(core.AbstractFilter.prototype);\nBloomFilter.prototype.constructor = BloomFilter;\nmodule.exports = BloomFilter;\n\nBloomFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var renderTarget = renderer.filterManager.getRenderTarget(true);\n\n    //TODO - copyTexSubImage2D could be used here?\n    this.defaultFilter.applyFilter(renderer, input, output);\n\n    this.blurXFilter.applyFilter(renderer, input, renderTarget);\n\n    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.SCREEN);\n\n    this.blurYFilter.applyFilter(renderer, renderTarget, output);\n\n    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);\n\n    renderer.filterManager.returnRenderTarget(renderTarget);\n};\n\nObject.defineProperties(BloomFilter.prototype, {\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.BloomFilter#\n     * @default 2\n     */\n    blur: {\n        get: function ()\n        {\n            return this.blurXFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurXFilter.blur = this.blurYFilter.blur = value;\n        }\n    },\n\n    /**\n     * Sets the strength of the blurX property\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.BloomFilter#\n     * @default 2\n     */\n    blurX: {\n        get: function ()\n        {\n            return this.blurXFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurXFilter.blur = value;\n        }\n    },\n\n    /**\n     * Sets the strength of the blurY property\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.BloomFilter#\n     * @default 2\n     */\n    blurY: {\n        get: function ()\n        {\n            return this.blurYFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurYFilter.blur = value;\n        }\n    }\n});\n\n},{\"../../core\":29,\"../blur/BlurXFilter\":91,\"../blur/BlurYFilter\":92}],89:[function(require,module,exports){\nvar core = require('../../core');\n\n\n/**\n * The BlurDirFilter applies a Gaussian blur toward a direction to an object.\n *\n * @class\n * @param {number} dirX\n * @param {number} dirY\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction BlurDirFilter(dirX, dirY)\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform float strength;\\nuniform float dirX;\\nuniform float dirY;\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying vec2 vBlurTexCoords[3];\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n\\n    vBlurTexCoords[0] = aTextureCoord + vec2( (0.004 * strength) * dirX, (0.004 * strength) * dirY );\\n    vBlurTexCoords[1] = aTextureCoord + vec2( (0.008 * strength) * dirX, (0.008 * strength) * dirY );\\n    vBlurTexCoords[2] = aTextureCoord + vec2( (0.012 * strength) * dirX, (0.012 * strength) * dirY );\\n\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\\n}\\n\",\n        // fragment shader\n        \"precision lowp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vBlurTexCoords[3];\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = vec4(0.0);\\n\\n    gl_FragColor += texture2D(uSampler, vTextureCoord     ) * 0.3989422804014327;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0]) * 0.2419707245191454;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1]) * 0.05399096651318985;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2]) * 0.004431848411938341;\\n}\\n\",\n        // set the uniforms\n        {\n            strength: { type: '1f', value: 1 },\n            dirX: { type: '1f', value: dirX || 0 },\n            dirY: { type: '1f', value: dirY || 0 }\n        }\n    );\n\n    this.defaultFilter = new core.AbstractFilter();\n\n    /**\n     * Sets the number of passes for blur. More passes means higher quaility bluring.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.passes = 1;\n\n    /**\n     * Sets the X direction of the blur\n     *\n     * @member {number}\n     * @default 0\n     */\n    this.dirX = dirX || 0;\n\n    /**\n     * Sets the Y direction of the blur\n     *\n     * @member {number}\n     * @default 0\n     */\n    this.dirY = dirY || 0;\n\n    this.strength = 4;\n}\n\nBlurDirFilter.prototype = Object.create(core.AbstractFilter.prototype);\nBlurDirFilter.prototype.constructor = BlurDirFilter;\nmodule.exports = BlurDirFilter;\n\nBlurDirFilter.prototype.applyFilter = function (renderer, input, output, clear) {\n\n    var shader = this.getShader(renderer);\n\n    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);\n\n    if (this.passes === 1) {\n        renderer.filterManager.applyFilter(shader, input, output, clear);\n    } else {\n        var renderTarget = renderer.filterManager.getRenderTarget(true);\n\n        renderer.filterManager.applyFilter(shader, input, renderTarget, clear);\n\n        for(var i = 0; i < this.passes-2; i++)\n        {\n            //this.uniforms.strength.value = this.strength / 4 / (this.passes+(i*2)) * (input.frame.width / input.size.width);\n            renderer.filterManager.applyFilter(shader, renderTarget, renderTarget, clear);\n        }\n\n        renderer.filterManager.applyFilter(shader, renderTarget, output, clear);\n\n        renderer.filterManager.returnRenderTarget(renderTarget);\n    }\n};\n\n\nObject.defineProperties(BlurDirFilter.prototype, {\n    /**\n     * Sets the strength of both the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.BlurDirFilter#\n     * @default 2\n     */\n    blur: {\n        get: function ()\n        {\n            return this.strength;\n        },\n        set: function (value)\n        {\n            this.padding = value * 0.5;\n            this.strength = value;\n        }\n    },\n    /**\n     * Sets the X direction of the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.BlurYFilter#\n     * @default 0\n     */\n    dirX: {\n        get: function ()\n        {\n            return this.dirX;\n        },\n        set: function (value)\n        {\n            this.uniforms.dirX.value = value;\n        }\n    },\n    /**\n     * Sets the Y direction of the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.BlurDirFilter#\n     * @default 0\n     */\n    dirY: {\n        get: function ()\n        {\n            return this.dirY;\n        },\n        set: function (value)\n        {\n            this.uniforms.dirY.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],90:[function(require,module,exports){\nvar core = require('../../core'),\n    BlurXFilter = require('./BlurXFilter'),\n    BlurYFilter = require('./BlurYFilter');\n\n/**\n * The BlurFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for x- and y-axis separately.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction BlurFilter()\n{\n    core.AbstractFilter.call(this);\n\n    this.blurXFilter = new BlurXFilter();\n    this.blurYFilter = new BlurYFilter();\n}\n\nBlurFilter.prototype = Object.create(core.AbstractFilter.prototype);\nBlurFilter.prototype.constructor = BlurFilter;\nmodule.exports = BlurFilter;\n\nBlurFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var renderTarget = renderer.filterManager.getRenderTarget(true);\n\n    this.blurXFilter.applyFilter(renderer, input, renderTarget);\n    this.blurYFilter.applyFilter(renderer, renderTarget, output);\n\n    renderer.filterManager.returnRenderTarget(renderTarget);\n};\n\nObject.defineProperties(BlurFilter.prototype, {\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.BlurFilter#\n     * @default 2\n     */\n    blur: {\n        get: function ()\n        {\n            return this.blurXFilter.blur;\n        },\n        set: function (value)\n        {\n            this.padding = Math.abs(value) * 0.5;\n            this.blurXFilter.blur = this.blurYFilter.blur = value;\n        }\n    },\n\n    /**\n     * Sets the number of passes for blur. More passes means higher quaility bluring.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.BlurYFilter#\n     * @default 1\n     */\n    passes: {\n        get: function ()\n        {\n            return  this.blurXFilter.passes;\n        },\n        set: function (value)\n        {\n            this.blurXFilter.passes = this.blurYFilter.passes = value;\n        }\n    },\n\n    /**\n     * Sets the strength of the blurX property\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.BlurFilter#\n     * @default 2\n     */\n    blurX: {\n        get: function ()\n        {\n            return this.blurXFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurXFilter.blur = value;\n        }\n    },\n\n    /**\n     * Sets the strength of the blurY property\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.BlurFilter#\n     * @default 2\n     */\n    blurY: {\n        get: function ()\n        {\n            return this.blurYFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurYFilter.blur = value;\n        }\n    }\n});\n\n},{\"../../core\":29,\"./BlurXFilter\":91,\"./BlurYFilter\":92}],91:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The BlurXFilter applies a horizontal Gaussian blur to an object.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction BlurXFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform float strength;\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying vec2 vBlurTexCoords[6];\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n\\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\\n\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\\n}\\n\",\n        // fragment shader\n        \"precision lowp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vBlurTexCoords[6];\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = vec4(0.0);\\n\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\\n}\\n\",\n        // set the uniforms\n        {\n            strength: { type: '1f', value: 1 }\n        }\n    );\n\n    /**\n     * Sets the number of passes for blur. More passes means higher quaility bluring.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.passes = 1;\n\n    this.strength = 4;\n}\n\nBlurXFilter.prototype = Object.create(core.AbstractFilter.prototype);\nBlurXFilter.prototype.constructor = BlurXFilter;\nmodule.exports = BlurXFilter;\n\nBlurXFilter.prototype.applyFilter = function (renderer, input, output, clear)\n{\n    var shader = this.getShader(renderer);\n\n    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);\n\n    if(this.passes === 1)\n    {\n        renderer.filterManager.applyFilter(shader, input, output, clear);\n    }\n    else\n    {\n        var renderTarget = renderer.filterManager.getRenderTarget(true);\n        var flip = input;\n        var flop = renderTarget;\n\n        for(var i = 0; i < this.passes-1; i++)\n        {\n            renderer.filterManager.applyFilter(shader, flip, flop, true);\n\n           var temp = flop;\n           flop = flip;\n           flip = temp;\n        }\n\n        renderer.filterManager.applyFilter(shader, flip, output, clear);\n\n        renderer.filterManager.returnRenderTarget(renderTarget);\n    }\n};\n\n\nObject.defineProperties(BlurXFilter.prototype, {\n    /**\n     * Sets the strength of both the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.BlurXFilter#\n     * @default 2\n     */\n    blur: {\n        get: function ()\n        {\n            return  this.strength;\n        },\n        set: function (value)\n        {\n            this.padding =  Math.abs(value) * 0.5;\n            this.strength = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],92:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The BlurYFilter applies a horizontal Gaussian blur to an object.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction BlurYFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform float strength;\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying vec2 vBlurTexCoords[6];\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n\\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\\n\\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\\n}\\n\",\n        // fragment shader\n        \"precision lowp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vBlurTexCoords[6];\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = vec4(0.0);\\n\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\\n}\\n\",\n        // set the uniforms\n        {\n            strength: { type: '1f', value: 1 }\n        }\n    );\n\n    this.passes = 1;\n    this.strength = 4;\n}\n\nBlurYFilter.prototype = Object.create(core.AbstractFilter.prototype);\nBlurYFilter.prototype.constructor = BlurYFilter;\nmodule.exports = BlurYFilter;\n\nBlurYFilter.prototype.applyFilter = function (renderer, input, output, clear)\n{\n    var shader = this.getShader(renderer);\n\n    this.uniforms.strength.value = Math.abs(this.strength) / 4 / this.passes * (input.frame.height / input.size.height);\n\n    if(this.passes === 1)\n    {\n        renderer.filterManager.applyFilter(shader, input, output, clear);\n    }\n    else\n    {\n        var renderTarget = renderer.filterManager.getRenderTarget(true);\n        var flip = input;\n        var flop = renderTarget;\n\n        for(var i = 0; i < this.passes-1; i++)\n        {\n            renderer.filterManager.applyFilter(shader, flip, flop, true);\n\n           var temp = flop;\n           flop = flip;\n           flip = temp;\n        }\n\n        renderer.filterManager.applyFilter(shader, flip, output, clear);\n\n        renderer.filterManager.returnRenderTarget(renderTarget);\n    }\n};\n\n\nObject.defineProperties(BlurYFilter.prototype, {\n    /**\n     * Sets the strength of both the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.BlurYFilter#\n     * @default 2\n     */\n    blur: {\n        get: function ()\n        {\n            return  this.strength;\n        },\n        set: function (value)\n        {\n            this.padding = Math.abs(value) * 0.5;\n            this.strength = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],93:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * A Smart Blur Filter.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction SmartBlurFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec2 delta;\\n\\nfloat random(vec3 scale, float seed)\\n{\\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\\n}\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n    float total = 0.0;\\n\\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\\n\\n    for (float t = -30.0; t <= 30.0; t++)\\n    {\\n        float percent = (t + offset - 0.5) / 30.0;\\n        float weight = 1.0 - abs(percent);\\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta * percent);\\n        sample.rgb *= sample.a;\\n        color += sample * weight;\\n        total += weight;\\n    }\\n\\n    gl_FragColor = color / total;\\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\\n}\\n\",\n        // uniforms\n        {\n          delta: { type: 'v2', value: { x: 0.1, y: 0.0 } }\n        }\n    );\n}\n\nSmartBlurFilter.prototype = Object.create(core.AbstractFilter.prototype);\nSmartBlurFilter.prototype.constructor = SmartBlurFilter;\nmodule.exports = SmartBlurFilter;\n\n},{\"../../core\":29}],94:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The ColorMatrixFilter class lets you apply a 5x4 matrix transformation on the RGBA\n * color and alpha values of every pixel on your displayObject to produce a result\n * with a new set of RGBA color and alpha values. It's pretty powerful!\n *\n * ```js\n *  var colorMatrix = new PIXI.ColorMatrixFilter();\n *  container.filters = [colorMatrix];\n *  colorMatrix.contrast(2);\n * ```\n * @author Cl  ment Chenebault <clement@goodboydigital.com>\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction ColorMatrixFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform float m[25];\\n\\nvoid main(void)\\n{\\n\\n    vec4 c = texture2D(uSampler, vTextureCoord);\\n\\n    gl_FragColor.r = (m[0] * c.r);\\n        gl_FragColor.r += (m[1] * c.g);\\n        gl_FragColor.r += (m[2] * c.b);\\n        gl_FragColor.r += (m[3] * c.a);\\n        gl_FragColor.r += m[4] * c.a;\\n\\n    gl_FragColor.g = (m[5] * c.r);\\n        gl_FragColor.g += (m[6] * c.g);\\n        gl_FragColor.g += (m[7] * c.b);\\n        gl_FragColor.g += (m[8] * c.a);\\n        gl_FragColor.g += m[9] * c.a;\\n\\n     gl_FragColor.b = (m[10] * c.r);\\n        gl_FragColor.b += (m[11] * c.g);\\n        gl_FragColor.b += (m[12] * c.b);\\n        gl_FragColor.b += (m[13] * c.a);\\n        gl_FragColor.b += m[14] * c.a;\\n\\n     gl_FragColor.a = (m[15] * c.r);\\n        gl_FragColor.a += (m[16] * c.g);\\n        gl_FragColor.a += (m[17] * c.b);\\n        gl_FragColor.a += (m[18] * c.a);\\n        gl_FragColor.a += m[19] * c.a;\\n\\n}\\n\",\n        // custom uniforms\n        {\n            m: {\n                type: '1fv', value: [\n                    1, 0, 0, 0, 0,\n                    0, 1, 0, 0, 0,\n                    0, 0, 1, 0, 0,\n                    0, 0, 0, 1, 0\n                ]\n            }\n        }\n    );\n}\n\nColorMatrixFilter.prototype = Object.create(core.AbstractFilter.prototype);\nColorMatrixFilter.prototype.constructor = ColorMatrixFilter;\nmodule.exports = ColorMatrixFilter;\n\n\n/**\n * Transforms current matrix and set the new one\n *\n * @param matrix {number[]} (mat 5x4)\n * @param multiply {boolean} if true, current matrix and matrix are multiplied. If false, just set the current matrix with @param matrix\n */\nColorMatrixFilter.prototype._loadMatrix = function (matrix, multiply)\n{\n    multiply = !!multiply;\n\n    var newMatrix = matrix;\n\n    if (multiply) {\n        this._multiply(newMatrix, this.uniforms.m.value, matrix);\n        newMatrix = this._colorMatrix(newMatrix);\n    }\n\n    // set the new matrix\n    this.uniforms.m.value = newMatrix;\n};\n\n/**\n * Multiplies two mat5's\n *\n * @param out {number[]} (mat 5x4) the receiving matrix\n * @param a {number[]} (mat 5x4) the first operand\n * @param b {number[]} (mat 5x4) the second operand\n * @returns out {number[]} (mat 5x4)\n */\nColorMatrixFilter.prototype._multiply = function (out, a, b)\n{\n\n    // Red Channel\n    out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);\n    out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);\n    out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);\n    out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);\n    out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]);\n\n    // Green Channel\n    out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);\n    out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);\n    out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);\n    out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);\n    out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]);\n\n    // Blue Channel\n    out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);\n    out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);\n    out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);\n    out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);\n    out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]);\n\n    // Alpha Channel\n    out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);\n    out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);\n    out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);\n    out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);\n    out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]);\n\n    return out;\n};\n\n/**\n * Create a Float32 Array and normalize the offset component to 0-1\n *\n * @param matrix {number[]} (mat 5x4)\n * @return m {number[]} (mat 5x4) with all values between 0-1\n */\nColorMatrixFilter.prototype._colorMatrix = function (matrix)\n{\n    // Create a Float32 Array and normalize the offset component to 0-1\n    var m = new Float32Array(matrix);\n    m[4] /= 255;\n    m[9] /= 255;\n    m[14] /= 255;\n    m[19] /= 255;\n\n    return m;\n};\n\n/**\n * Adjusts brightness\n *\n * @param b {number} value of the brigthness (0 is black)\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.brightness = function (b, multiply)\n{\n    var matrix = [\n        b, 0, 0, 0, 0,\n        0, b, 0, 0, 0,\n        0, 0, b, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Set the matrices in grey scales\n *\n * @param scale {number} value of the grey (0 is black)\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.greyscale = function (scale, multiply)\n{\n    var matrix = [\n        scale, scale, scale, 0, 0,\n        scale, scale, scale, 0, 0,\n        scale, scale, scale, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n//Americanized alias\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n\n/**\n * Set the black and white matrice\n * Multiply the current matrix\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.blackAndWhite = function (multiply)\n{\n    var matrix = [\n        0.3, 0.6, 0.1, 0, 0,\n        0.3, 0.6, 0.1, 0, 0,\n        0.3, 0.6, 0.1, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Set the hue property of the color\n *\n * @param rotation {number} in degrees\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.hue = function (rotation, multiply)\n{\n    rotation = (rotation || 0) / 180 * Math.PI;\n    var cos = Math.cos(rotation),\n        sin = Math.sin(rotation);\n\n    // luminanceRed, luminanceGreen, luminanceBlue\n    var lumR = 0.213, // or 0.3086\n        lumG = 0.715, // or 0.6094\n        lumB = 0.072; // or 0.0820\n\n    var matrix = [\n        lumR + cos * (1 - lumR) + sin * (-lumR), lumG + cos * (-lumG) + sin * (-lumG), lumB + cos * (-lumB) + sin * (1 - lumB), 0, 0,\n        lumR + cos * (-lumR) + sin * (0.143), lumG + cos * (1 - lumG) + sin * (0.140), lumB + cos * (-lumB) + sin * (-0.283), 0, 0,\n        lumR + cos * (-lumR) + sin * (-(1 - lumR)), lumG + cos * (-lumG) + sin * (lumG), lumB + cos * (1 - lumB) + sin * (lumB), 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n\n/**\n * Set the contrast matrix, increase the separation between dark and bright\n * Increase contrast : shadows darker and highlights brighter\n * Decrease contrast : bring the shadows up and the highlights down\n *\n * @param amount {number} value of the contrast\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.contrast = function (amount, multiply)\n{\n    var v = (amount || 0) + 1;\n    var o = -128 * (v - 1);\n\n    var matrix = [\n        v, 0, 0, 0, o,\n        0, v, 0, 0, o,\n        0, 0, v, 0, o,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Set the saturation matrix, increase the separation between colors\n * Increase saturation : increase contrast, brightness, and sharpness\n *\n * @param amount {number}\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.saturate = function (amount, multiply)\n{\n    var x = (amount || 0) * 2 / 3 + 1;\n    var y = ((x - 1) * -0.5);\n\n    var matrix = [\n        x, y, y, 0, 0,\n        y, x, y, 0, 0,\n        y, y, x, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Desaturate image (remove color)\n *\n * Call the saturate function\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.desaturate = function (multiply) // jshint unused:false\n{\n    this.saturate(-1);\n};\n\n/**\n * Negative image (inverse of classic rgb matrix)\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.negative = function (multiply)\n{\n    var matrix = [\n        0, 1, 1, 0, 0,\n        1, 0, 1, 0, 0,\n        1, 1, 0, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Sepia image\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.sepia = function (multiply)\n{\n    var matrix = [\n        0.393, 0.7689999, 0.18899999, 0, 0,\n        0.349, 0.6859999, 0.16799999, 0, 0,\n        0.272, 0.5339999, 0.13099999, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Color motion picture process invented in 1916 (thanks Dominic Szablewski)\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.technicolor = function (multiply)\n{\n    var matrix = [\n        1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,\n        -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,\n        -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Polaroid filter\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.polaroid = function (multiply)\n{\n    var matrix = [\n        1.438, -0.062, -0.062, 0, 0,\n        -0.122, 1.378, -0.122, 0, 0,\n        -0.016, -0.016, 1.483, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Filter who transforms : Red -> Blue and Blue -> Red\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.toBGR = function (multiply)\n{\n    var matrix = [\n        0, 0, 1, 0, 0,\n        0, 1, 0, 0, 0,\n        1, 0, 0, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.kodachrome = function (multiply)\n{\n    var matrix = [\n        1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n        -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n        -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/**\n * Brown delicious browni filter (thanks Dominic Szablewski)\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.browni = function (multiply)\n{\n    var matrix = [\n        0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,\n        -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,\n        0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/*\n * Vintage filter (thanks Dominic Szablewski)\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.vintage = function (multiply)\n{\n    var matrix = [\n        0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,\n        0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,\n        0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/*\n * We don't know exactly what it does, kind of gradient map, but funny to play with!\n *\n * @param desaturation {number}\n * @param toned {number}\n * @param lightColor {string} (example : \"0xFFE580\")\n * @param darkColor {string}  (example : \"0xFFE580\")\n *\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.colorTone = function (desaturation, toned, lightColor, darkColor, multiply)\n{\n    desaturation = desaturation || 0.2;\n    toned = toned || 0.15;\n    lightColor = lightColor || 0xFFE580;\n    darkColor = darkColor || 0x338000;\n\n    var lR = ((lightColor >> 16) & 0xFF) / 255;\n    var lG = ((lightColor >> 8) & 0xFF) / 255;\n    var lB = (lightColor & 0xFF) / 255;\n\n    var dR = ((darkColor >> 16) & 0xFF) / 255;\n    var dG = ((darkColor >> 8) & 0xFF) / 255;\n    var dB = (darkColor & 0xFF) / 255;\n\n    var matrix = [\n        0.3, 0.59, 0.11, 0, 0,\n        lR, lG, lB, desaturation, 0,\n        dR, dG, dB, toned, 0,\n        lR - dR, lG - dG, lB - dB, 0, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/*\n * Night effect\n *\n * @param intensity {number}\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.night = function (intensity, multiply)\n{\n    intensity = intensity || 0.1;\n    var matrix = [\n        intensity * ( -2.0), -intensity, 0, 0, 0,\n        -intensity, 0, intensity, 0, 0,\n        0, intensity, intensity * 2.0, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n\n/*\n * Predator effect\n *\n * Erase the current matrix by setting a new indepent one\n *\n * @param amount {number} how much the predator feels his future victim\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.predator = function (amount, multiply)\n{\n    var matrix = [\n        11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount,\n        -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount,\n        -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/*\n * LSD effect\n *\n * Multiply the current matrix\n *\n * @param amount {number} How crazy is your effect\n * @param multiply {boolean} refer to ._loadMatrix() method\n */\nColorMatrixFilter.prototype.lsd = function (multiply)\n{\n    var matrix = [\n        2, -0.4, 0.5, 0, 0,\n        -0.5, 2, -0.4, 0, 0,\n        -0.4, -0.5, 3, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, multiply);\n};\n\n/*\n * Erase the current matrix by setting the default one\n *\n */\nColorMatrixFilter.prototype.reset = function ()\n{\n    var matrix = [\n        1, 0, 0, 0, 0,\n        0, 1, 0, 0, 0,\n        0, 0, 1, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n\n    this._loadMatrix(matrix, false);\n};\n\n\nObject.defineProperties(ColorMatrixFilter.prototype, {\n    /**\n     * Sets the matrix of the color matrix filter\n     *\n     * @member {number[]}\n     * @memberof PIXI.filters.ColorMatrixFilter#\n     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n     */\n    matrix: {\n        get: function ()\n        {\n            return this.uniforms.m.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.m.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],95:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction ColorStepFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform float step;\\n\\nvoid main(void)\\n{\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n\\n    color = floor(color * step) / step;\\n\\n    gl_FragColor = color;\\n}\\n\",\n        // custom uniforms\n        {\n            step: { type: '1f', value: 5 }\n        }\n    );\n}\n\nColorStepFilter.prototype = Object.create(core.AbstractFilter.prototype);\nColorStepFilter.prototype.constructor = ColorStepFilter;\nmodule.exports = ColorStepFilter;\n\nObject.defineProperties(ColorStepFilter.prototype, {\n    /**\n     * The number of steps to reduce the palette by.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.ColorStepFilter#\n     */\n    step: {\n        get: function ()\n        {\n            return this.uniforms.step.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.step.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],96:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The ConvolutionFilter class applies a matrix convolution filter effect.\n * A convolution combines pixels in the input image with neighboring pixels to produce a new image.\n * A wide variety of image effects can be achieved through convolutions, including blurring, edge\n * detection, sharpening, embossing, and beveling. The matrix should be specified as a 9 point Array.\n * See http://docs.gimp.org/en/plug-in-convmatrix.html for more info.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n * @param matrix {number[]} An array of values used for matrix transformation. Specified as a 9 point Array.\n * @param width {number} Width of the object you are transforming\n * @param height {number} Height of the object you are transforming\n */\nfunction ConvolutionFilter(matrix, width, height)\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying mediump vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec2 texelSize;\\nuniform float matrix[9];\\n\\nvoid main(void)\\n{\\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\\n\\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\\n\\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\\n\\n   gl_FragColor =\\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\\n\\n   gl_FragColor.a = c22.a;\\n}\\n\",\n        // custom uniforms\n        {\n            matrix:     { type: '1fv', value: new Float32Array(matrix) },\n            texelSize:  { type: 'v2', value: { x: 1 / width, y: 1 / height } }\n        }\n    );\n}\n\nConvolutionFilter.prototype = Object.create(core.AbstractFilter.prototype);\nConvolutionFilter.prototype.constructor = ConvolutionFilter;\nmodule.exports = ConvolutionFilter;\n\nObject.defineProperties(ConvolutionFilter.prototype, {\n    /**\n     * An array of values used for matrix transformation. Specified as a 9 point Array.\n     *\n     * @member {number[]}\n     * @memberof PIXI.filters.ConvolutionFilter#\n     */\n    matrix: {\n        get: function ()\n        {\n            return this.uniforms.matrix.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.matrix.value = new Float32Array(value);\n        }\n    },\n\n    /**\n     * Width of the object you are transforming\n     *\n     * @member {number}\n     * @memberof PIXI.filters.ConvolutionFilter#\n     */\n    width: {\n        get: function ()\n        {\n            return 1/this.uniforms.texelSize.value.x;\n        },\n        set: function (value)\n        {\n            this.uniforms.texelSize.value.x = 1/value;\n        }\n    },\n\n    /**\n     * Height of the object you are transforming\n     *\n     * @member {number}\n     * @memberof PIXI.filters.ConvolutionFilter#\n     */\n    height: {\n        get: function ()\n        {\n            return 1/this.uniforms.texelSize.value.y;\n        },\n        set: function (value)\n        {\n            this.uniforms.texelSize.value.y = 1/value;\n        }\n    }\n});\n\n},{\"../../core\":29}],97:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * A Cross Hatch effect filter.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction CrossHatchFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\\n\\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n    if (lum < 1.00)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.75)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.50)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.3)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n}\\n\"\n    );\n}\n\nCrossHatchFilter.prototype = Object.create(core.AbstractFilter.prototype);\nCrossHatchFilter.prototype.constructor = CrossHatchFilter;\nmodule.exports = CrossHatchFilter;\n\n},{\"../../core\":29}],98:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.\n * You can use this filter to apply all manor of crazy warping effects\n * Currently the r property of the texture is used to offset the x and the g property of the texture is used to offset the y.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n * @param sprite {PIXI.Sprite} the sprite used for the displacement map. (make sure its added to the scene!)\n */\nfunction DisplacementFilter(sprite, scale)\n{\n    var maskMatrix = new core.Matrix();\n    sprite.renderable = false;\n\n    core.AbstractFilter.call(this,\n        // vertex shader\n        \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 otherMatrix;\\n\\nvarying vec2 vMapCoord;\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nvoid main(void)\\n{\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vTextureCoord = aTextureCoord;\\n   vMapCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\\n}\\n\",\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vMapCoord;\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform vec2 scale;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D mapSampler;\\n\\nvoid main(void)\\n{\\n   vec4 map =  texture2D(mapSampler, vMapCoord);\\n\\n   map -= 0.5;\\n   map.xy *= scale;\\n\\n   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y));\\n}\\n\",\n        // uniforms\n        {\n            mapSampler:     { type: 'sampler2D', value: sprite.texture },\n            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) },\n            scale:          { type: 'v2', value: { x: 1, y: 1 } }\n        }\n    );\n\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n\n    if (scale === null || scale === undefined)\n    {\n        scale = 20;\n    }\n\n    this.scale = new core.Point(scale, scale);\n}\n\nDisplacementFilter.prototype = Object.create(core.AbstractFilter.prototype);\nDisplacementFilter.prototype.constructor = DisplacementFilter;\nmodule.exports = DisplacementFilter;\n\nDisplacementFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var filterManager = renderer.filterManager;\n\n    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);\n\n    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);\n    this.uniforms.scale.value.x = this.scale.x * (1/input.frame.width);\n    this.uniforms.scale.value.y = this.scale.y * (1/input.frame.height);\n\n    var shader = this.getShader(renderer);\n     // draw the filter...\n    filterManager.applyFilter(shader, input, output);\n};\n\n\nObject.defineProperties(DisplacementFilter.prototype, {\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.filters.DisplacementFilter#\n     */\n    map: {\n        get: function ()\n        {\n            return this.uniforms.mapSampler.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.mapSampler.value = value;\n\n        }\n    }\n});\n\n},{\"../../core\":29}],99:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js\n */\n\n/**\n * This filter applies a dotscreen effect making display objects appear to be made out of\n * black and white halftone dots like an old printer.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction DotScreenFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform vec4 dimensions;\\nuniform sampler2D uSampler;\\n\\nuniform float angle;\\nuniform float scale;\\n\\nfloat pattern()\\n{\\n   float s = sin(angle), c = cos(angle);\\n   vec2 tex = vTextureCoord * dimensions.xy;\\n   vec2 point = vec2(\\n       c * tex.x - s * tex.y,\\n       s * tex.x + c * tex.y\\n   ) * scale;\\n   return (sin(point.x) * sin(point.y)) * 4.0;\\n}\\n\\nvoid main()\\n{\\n   vec4 color = texture2D(uSampler, vTextureCoord);\\n   float average = (color.r + color.g + color.b) / 3.0;\\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\\n}\\n\",\n        // custom uniforms\n        {\n            scale:      { type: '1f', value: 1 },\n            angle:      { type: '1f', value: 5 },\n            dimensions: { type: '4fv', value: [0, 0, 0, 0] }\n        }\n    );\n}\n\nDotScreenFilter.prototype = Object.create(core.AbstractFilter.prototype);\nDotScreenFilter.prototype.constructor = DotScreenFilter;\nmodule.exports = DotScreenFilter;\n\nObject.defineProperties(DotScreenFilter.prototype, {\n    /**\n     * The scale of the effect.\n     * @member {number}\n     * @memberof PIXI.filters.DotScreenFilter#\n     */\n    scale: {\n        get: function ()\n        {\n            return this.uniforms.scale.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.scale.value = value;\n        }\n    },\n\n    /**\n     * The radius of the effect.\n     * @member {number}\n     * @memberof PIXI.filters.DotScreenFilter#\n     */\n    angle: {\n        get: function ()\n        {\n            return this.uniforms.angle.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.angle.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],100:[function(require,module,exports){\nvar core = require('../../core');\n\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The BlurYTintFilter applies a vertical Gaussian blur to an object.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction BlurYTintFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform float strength;\\nuniform vec2 offset;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying vec2 vBlurTexCoords[6];\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition+offset), 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n\\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\\n\\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\\n}\\n\",\n        // fragment shader\n        \"precision lowp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vBlurTexCoords[6];\\nvarying vec4 vColor;\\n\\nuniform vec3 color;\\nuniform float alpha;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    vec4 sum = vec4(0.0);\\n\\n    sum += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\\n    sum += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\\n    sum += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\\n    sum += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\\n    sum += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\\n    sum += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\\n    sum += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\\n\\n    gl_FragColor = vec4( color.rgb * sum.a * alpha, sum.a * alpha );\\n}\\n\",\n        // set the uniforms\n        {\n            blur: { type: '1f', value: 1 / 512 },\n            color: { type: 'c', value: [0,0,0]},\n            alpha: { type: '1f', value: 0.7 },\n            offset: { type: '2f', value:[5, 5]},\n            strength: { type: '1f', value:1}\n        }\n    );\n\n    this.passes = 1;\n    this.strength = 4;\n}\n\nBlurYTintFilter.prototype = Object.create(core.AbstractFilter.prototype);\nBlurYTintFilter.prototype.constructor = BlurYTintFilter;\nmodule.exports = BlurYTintFilter;\n\nBlurYTintFilter.prototype.applyFilter = function (renderer, input, output, clear)\n{\n    var shader = this.getShader(renderer);\n\n    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.height / input.size.height);\n\n    if(this.passes === 1)\n    {\n        renderer.filterManager.applyFilter(shader, input, output, clear);\n    }\n    else\n    {\n        var renderTarget = renderer.filterManager.getRenderTarget(true);\n        var flip = input;\n        var flop = renderTarget;\n\n        for(var i = 0; i < this.passes-1; i++)\n        {\n            renderer.filterManager.applyFilter(shader, flip, flop, clear);\n\n           var temp = flop;\n           flop = flip;\n           flip = temp;\n        }\n\n        renderer.filterManager.applyFilter(shader, flip, output, clear);\n\n        renderer.filterManager.returnRenderTarget(renderTarget);\n    }\n};\n\n\nObject.defineProperties(BlurYTintFilter.prototype, {\n    /**\n     * Sets the strength of both the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.BlurYTintFilter#\n     * @default 2\n     */\n    blur: {\n        get: function ()\n        {\n            return  this.strength;\n        },\n        set: function (value)\n        {\n            this.padding = value * 0.5;\n            this.strength = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],101:[function(require,module,exports){\nvar core = require('../../core'),\n    BlurXFilter = require('../blur/BlurXFilter'),\n    BlurYTintFilter = require('./BlurYTintFilter');\n\n/**\n * The DropShadowFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for x- and y-axis separately.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction DropShadowFilter()\n{\n    core.AbstractFilter.call(this);\n\n    this.blurXFilter = new BlurXFilter();\n    this.blurYTintFilter = new BlurYTintFilter();\n\n    this.defaultFilter = new core.AbstractFilter();\n\n    this.padding = 30;\n\n    this._dirtyPosition = true;\n    this._angle = 45 * Math.PI / 180;\n    this._distance = 10;\n    this.alpha = 0.75;\n    this.hideObject = false;\n    this.blendMode = core.BLEND_MODES.MULTIPLY;\n}\n\nDropShadowFilter.prototype = Object.create(core.AbstractFilter.prototype);\nDropShadowFilter.prototype.constructor = DropShadowFilter;\nmodule.exports = DropShadowFilter;\n\nDropShadowFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var renderTarget = renderer.filterManager.getRenderTarget(true);\n\n    //TODO - copyTexSubImage2D could be used here?\n    if(this._dirtyPosition)\n    {\n        this._dirtyPosition = false;\n\n        this.blurYTintFilter.uniforms.offset.value[0] = Math.sin(this._angle) * this._distance;\n        this.blurYTintFilter.uniforms.offset.value[1] = Math.cos(this._angle) * this._distance;\n    }\n\n    this.blurXFilter.applyFilter(renderer, input, renderTarget);\n\n    renderer.blendModeManager.setBlendMode(this.blendMode);\n\n    this.blurYTintFilter.applyFilter(renderer, renderTarget, output);\n\n    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);\n\n    if(!this.hideObject)\n    {\n\n        this.defaultFilter.applyFilter(renderer, input, output);\n    }\n\n\n    renderer.filterManager.returnRenderTarget(renderTarget);\n};\n\nObject.defineProperties(DropShadowFilter.prototype, {\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.DropShadowFilter#\n     * @default 2\n     */\n    blur: {\n        get: function ()\n        {\n            return this.blurXFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurXFilter.blur = this.blurYTintFilter.blur = value;\n        }\n    },\n\n    /**\n     * Sets the strength of the blurX property\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.DropShadowFilter#\n     * @default 2\n     */\n    blurX: {\n        get: function ()\n        {\n            return this.blurXFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurXFilter.blur = value;\n        }\n    },\n\n    /**\n     * Sets the strength of the blurY property\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.DropShadowFilter#\n     * @default 2\n     */\n    blurY: {\n        get: function ()\n        {\n            return this.blurYTintFilter.blur;\n        },\n        set: function (value)\n        {\n            this.blurYTintFilter.blur = value;\n        }\n    },\n\n    /**\n     * Sets the color of the shadow\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.DropShadowFilter#\n     */\n    color: {\n        get: function ()\n        {\n            return  core.utils.rgb2hex( this.blurYTintFilter.uniforms.color.value );\n        },\n        set: function (value)\n        {\n            this.blurYTintFilter.uniforms.color.value = core.utils.hex2rgb(value);\n        }\n    },\n\n    /**\n     * Sets the alpha of the shadow\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.DropShadowFilter#\n     */\n    alpha: {\n        get: function ()\n        {\n            return  this.blurYTintFilter.uniforms.alpha.value;\n        },\n        set: function (value)\n        {\n            this.blurYTintFilter.uniforms.alpha.value = value;\n        }\n    },\n\n    /**\n     * Sets the distance of the shadow\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.DropShadowFilter#\n     */\n    distance: {\n        get: function ()\n        {\n            return  this._distance;\n        },\n        set: function (value)\n        {\n            this._dirtyPosition = true;\n            this._distance = value;\n        }\n    },\n\n    /**\n     * Sets the angle of the shadow\n     *\n     * @member {number}\n     * @memberOf PIXI.filters.DropShadowFilter#\n     */\n    angle: {\n        get: function ()\n        {\n            return  this._angle;\n        },\n        set: function (value)\n        {\n            this._dirtyPosition = true;\n            this._angle = value;\n        }\n    }\n});\n\n},{\"../../core\":29,\"../blur/BlurXFilter\":91,\"./BlurYTintFilter\":100}],102:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * This greyscales the palette of your Display Objects.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction GrayFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\nuniform float gray;\\n\\nvoid main(void)\\n{\\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\\n   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);\\n}\\n\",\n        // set the uniforms\n        {\n            gray: { type: '1f', value: 1 }\n        }\n    );\n}\n\nGrayFilter.prototype = Object.create(core.AbstractFilter.prototype);\nGrayFilter.prototype.constructor = GrayFilter;\nmodule.exports = GrayFilter;\n\nObject.defineProperties(GrayFilter.prototype, {\n    /**\n     * The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.GrayFilter#\n     */\n    gray: {\n        get: function ()\n        {\n            return this.uniforms.gray.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.gray.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],103:[function(require,module,exports){\n/**\n * @file        Main export of the PIXI filters library\n * @author      Mat Groves <mat@goodboydigital.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI.filters\n */\nmodule.exports = {\n    AsciiFilter:        require('./ascii/AsciiFilter'),\n    BloomFilter:        require('./bloom/BloomFilter'),\n    BlurFilter:         require('./blur/BlurFilter'),\n    BlurXFilter:        require('./blur/BlurXFilter'),\n    BlurYFilter:        require('./blur/BlurYFilter'),\n    BlurDirFilter:      require('./blur/BlurDirFilter'),\n    ColorMatrixFilter:  require('./color/ColorMatrixFilter'),\n    ColorStepFilter:    require('./color/ColorStepFilter'),\n    ConvolutionFilter:  require('./convolution/ConvolutionFilter'),\n    CrossHatchFilter:   require('./crosshatch/CrossHatchFilter'),\n    DisplacementFilter: require('./displacement/DisplacementFilter'),\n    DotScreenFilter:    require('./dot/DotScreenFilter'),\n    GrayFilter:         require('./gray/GrayFilter'),\n    DropShadowFilter:   require('./dropshadow/DropShadowFilter'),\n    InvertFilter:       require('./invert/InvertFilter'),\n    NoiseFilter:        require('./noise/NoiseFilter'),\n    PixelateFilter:     require('./pixelate/PixelateFilter'),\n    RGBSplitFilter:     require('./rgb/RGBSplitFilter'),\n    ShockwaveFilter:    require('./shockwave/ShockwaveFilter'),\n    SepiaFilter:        require('./sepia/SepiaFilter'),\n    SmartBlurFilter:    require('./blur/SmartBlurFilter'),\n    TiltShiftFilter:    require('./tiltshift/TiltShiftFilter'),\n    TiltShiftXFilter:   require('./tiltshift/TiltShiftXFilter'),\n    TiltShiftYFilter:   require('./tiltshift/TiltShiftYFilter'),\n    TwistFilter:        require('./twist/TwistFilter')\n};\n\n},{\"./ascii/AsciiFilter\":87,\"./bloom/BloomFilter\":88,\"./blur/BlurDirFilter\":89,\"./blur/BlurFilter\":90,\"./blur/BlurXFilter\":91,\"./blur/BlurYFilter\":92,\"./blur/SmartBlurFilter\":93,\"./color/ColorMatrixFilter\":94,\"./color/ColorStepFilter\":95,\"./convolution/ConvolutionFilter\":96,\"./crosshatch/CrossHatchFilter\":97,\"./displacement/DisplacementFilter\":98,\"./dot/DotScreenFilter\":99,\"./dropshadow/DropShadowFilter\":101,\"./gray/GrayFilter\":102,\"./invert/InvertFilter\":104,\"./noise/NoiseFilter\":105,\"./pixelate/PixelateFilter\":106,\"./rgb/RGBSplitFilter\":107,\"./sepia/SepiaFilter\":108,\"./shockwave/ShockwaveFilter\":109,\"./tiltshift/TiltShiftFilter\":111,\"./tiltshift/TiltShiftXFilter\":112,\"./tiltshift/TiltShiftYFilter\":113,\"./twist/TwistFilter\":114}],104:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * This inverts your Display Objects colors.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction InvertFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform float invert;\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\\n\\n    gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);\\n}\\n\",\n        // custom uniforms\n        {\n            invert: { type: '1f', value: 1 }\n        }\n    );\n}\n\nInvertFilter.prototype = Object.create(core.AbstractFilter.prototype);\nInvertFilter.prototype.constructor = InvertFilter;\nmodule.exports = InvertFilter;\n\nObject.defineProperties(InvertFilter.prototype, {\n    /**\n     * The strength of the invert. `1` will fully invert the colors, and\n     * `0` will make the object its normal color.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.InvertFilter#\n     */\n    invert: {\n        get: function ()\n        {\n            return this.uniforms.invert.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.invert.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],105:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * @author Vico @vicocotea\n * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\n */\n\n/**\n * A Noise effect filter.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction NoiseFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision highp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform float noise;\\nuniform sampler2D uSampler;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n\\n    float diff = (rand(vTextureCoord) - 0.5) * noise;\\n\\n    color.r += diff;\\n    color.g += diff;\\n    color.b += diff;\\n\\n    gl_FragColor = color;\\n}\\n\",\n        // custom uniforms\n        {\n            noise: { type: '1f', value: 0.5 }\n        }\n    );\n}\n\nNoiseFilter.prototype = Object.create(core.AbstractFilter.prototype);\nNoiseFilter.prototype.constructor = NoiseFilter;\nmodule.exports = NoiseFilter;\n\nObject.defineProperties(NoiseFilter.prototype, {\n    /**\n     * The amount of noise to apply.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.NoiseFilter#\n     * @default 0.5\n     */\n    noise: {\n        get: function ()\n        {\n            return this.uniforms.noise.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.noise.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],106:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * This filter applies a pixelate effect making display objects appear 'blocky'.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction PixelateFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform vec4 dimensions;\\nuniform vec2 pixelSize;\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord;\\n\\n    vec2 size = dimensions.xy / pixelSize;\\n\\n    vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;\\n\\n    gl_FragColor = texture2D(uSampler, color);\\n}\\n\",\n        // custom uniforms\n        {\n            dimensions: { type: '4fv',  value: new Float32Array([0, 0, 0, 0]) },\n            pixelSize:  { type: 'v2',   value: { x: 10, y: 10 } }\n        }\n    );\n}\n\nPixelateFilter.prototype = Object.create(core.AbstractFilter.prototype);\nPixelateFilter.prototype.constructor = PixelateFilter;\nmodule.exports = PixelateFilter;\n\nObject.defineProperties(PixelateFilter.prototype, {\n    /**\n     * This a point that describes the size of the blocks.\n     * x is the width of the block and y is the height.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.filters.PixelateFilter#\n     */\n    size: {\n        get: function ()\n        {\n            return this.uniforms.pixelSize.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.pixelSize.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],107:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * An RGB Split Filter.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction RGBSplitFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 dimensions;\\nuniform vec2 red;\\nuniform vec2 green;\\nuniform vec2 blue;\\n\\nvoid main(void)\\n{\\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;\\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;\\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;\\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\\n}\\n\",\n        // custom uniforms\n        {\n            red:        { type: 'v2', value: { x: 20, y: 20 } },\n            green:      { type: 'v2', value: { x: -20, y: 20 } },\n            blue:       { type: 'v2', value: { x: 20, y: -20 } },\n            dimensions: { type: '4fv', value: [0, 0, 0, 0] }\n        }\n    );\n}\n\nRGBSplitFilter.prototype = Object.create(core.AbstractFilter.prototype);\nRGBSplitFilter.prototype.constructor = RGBSplitFilter;\nmodule.exports = RGBSplitFilter;\n\nObject.defineProperties(RGBSplitFilter.prototype, {\n    /**\n     * Red channel offset.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.filters.RGBSplitFilter#\n     */\n    red: {\n        get: function ()\n        {\n            return this.uniforms.red.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.red.value = value;\n        }\n    },\n\n    /**\n     * Green channel offset.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.filters.RGBSplitFilter#\n     */\n    green: {\n        get: function ()\n        {\n            return this.uniforms.green.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.green.value = value;\n        }\n    },\n\n    /**\n     * Blue offset.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.filters.RGBSplitFilter#\n     */\n    blue: {\n        get: function ()\n        {\n            return this.uniforms.blue.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.blue.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],108:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * This applies a sepia effect to your Display Objects.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction SepiaFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform float sepia;\\n\\nconst mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);\\n\\nvoid main(void)\\n{\\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\\n   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);\\n}\\n\",\n        // custom uniforms\n        {\n            sepia: { type: '1f', value: 1 }\n        }\n    );\n}\n\nSepiaFilter.prototype = Object.create(core.AbstractFilter.prototype);\nSepiaFilter.prototype.constructor = SepiaFilter;\nmodule.exports = SepiaFilter;\n\nObject.defineProperties(SepiaFilter.prototype, {\n    /**\n     * The strength of the sepia. `1` will apply the full sepia effect, and\n     * `0` will make the object its normal color.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.SepiaFilter#\n     */\n    sepia: {\n        get: function ()\n        {\n            return this.uniforms.sepia.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.sepia.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],109:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA\n * color and alpha values of every pixel on your displayObject to produce a result\n * with a new set of RGBA color and alpha values. It's pretty powerful!\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction ShockwaveFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nuniform vec2 center;\\nuniform vec3 params; // 10.0, 0.8, 0.1\\nuniform float time;\\n\\nvoid main()\\n{\\n    vec2 uv = vTextureCoord;\\n    vec2 texCoord = uv;\\n\\n    float dist = distance(uv, center);\\n\\n    if ( (dist <= (time + params.z)) && (dist >= (time - params.z)) )\\n    {\\n        float diff = (dist - time);\\n        float powDiff = 1.0 - pow(abs(diff*params.x), params.y);\\n\\n        float diffTime = diff  * powDiff;\\n        vec2 diffUV = normalize(uv - center);\\n        texCoord = uv + (diffUV * diffTime);\\n    }\\n\\n    gl_FragColor = texture2D(uSampler, texCoord);\\n}\\n\",\n        // custom uniforms\n        {\n            center: { type: 'v2', value: { x: 0.5, y: 0.5 } },\n            params: { type: 'v3', value: { x: 10, y: 0.8, z: 0.1 } },\n            time: { type: '1f', value: 0 }\n        }\n    );\n}\n\nShockwaveFilter.prototype = Object.create(core.AbstractFilter.prototype);\nShockwaveFilter.prototype.constructor = ShockwaveFilter;\nmodule.exports = ShockwaveFilter;\n\nObject.defineProperties(ShockwaveFilter.prototype, {\n    /**\n     * Sets the center of the shockwave in normalized screen coords. That is\n     * (0,0) is the top-left and (1,1) is the bottom right.\n     *\n     * @member {object<string, number>}\n     * @memberof PIXI.filters.ShockwaveFilter#\n     */\n    center: {\n        get: function ()\n        {\n            return this.uniforms.center.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.center.value = value;\n        }\n    },\n    /**\n     * Sets the params of the shockwave. These modify the look and behavior of\n     * the shockwave as it ripples out.\n     *\n     * @member {object<string, number>}\n     * @memberof PIXI.filters.ShockwaveFilter#\n     */\n    params: {\n        get: function ()\n        {\n            return this.uniforms.params.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.params.value = value;\n        }\n    },\n    /**\n     * Sets the elapsed time of the shockwave. This controls the speed at which\n     * the shockwave ripples out.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.ShockwaveFilter#\n     */\n    time: {\n        get: function ()\n        {\n            return this.uniforms.time.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.time.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],110:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * @author Vico @vicocotea\n * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/\n */\n\n/**\n * A TiltShiftAxisFilter.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction TiltShiftAxisFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform float blur;\\nuniform float gradientBlur;\\nuniform vec2 start;\\nuniform vec2 end;\\nuniform vec2 delta;\\nuniform vec2 texSize;\\n\\nfloat random(vec3 scale, float seed)\\n{\\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\\n}\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n    float total = 0.0;\\n\\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\\n\\n    for (float t = -30.0; t <= 30.0; t++)\\n    {\\n        float percent = (t + offset - 0.5) / 30.0;\\n        float weight = 1.0 - abs(percent);\\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\\n        sample.rgb *= sample.a;\\n        color += sample * weight;\\n        total += weight;\\n    }\\n\\n    gl_FragColor = color / total;\\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\\n}\\n\",\n        // custom uniforms\n        {\n            blur:           { type: '1f', value: 100 },\n            gradientBlur:   { type: '1f', value: 600 },\n            start:          { type: 'v2', value: { x: 0,    y: window.innerHeight / 2 } },\n            end:            { type: 'v2', value: { x: 600,  y: window.innerHeight / 2 } },\n            delta:          { type: 'v2', value: { x: 30,   y: 30 } },\n            texSize:        { type: 'v2', value: { x: window.innerWidth, y: window.innerHeight } }\n        }\n    );\n\n    this.updateDelta();\n}\n\nTiltShiftAxisFilter.prototype = Object.create(core.AbstractFilter.prototype);\nTiltShiftAxisFilter.prototype.constructor = TiltShiftAxisFilter;\nmodule.exports = TiltShiftAxisFilter;\n\n/**\n * Updates the filter delta values.\n * This is overridden in the X and Y filters, does nothing for this class.\n *\n */\nTiltShiftAxisFilter.prototype.updateDelta = function ()\n{\n    this.uniforms.delta.value.x = 0;\n    this.uniforms.delta.value.y = 0;\n};\n\nObject.defineProperties(TiltShiftAxisFilter.prototype, {\n    /**\n     * The strength of the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TiltShiftAxisFilter#\n     */\n    blur: {\n        get: function ()\n        {\n            return this.uniforms.blur.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.blur.value = value;\n        }\n    },\n\n    /**\n     * The strength of the gradient blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TiltShiftAxisFilter#\n     */\n    gradientBlur: {\n        get: function ()\n        {\n            return this.uniforms.gradientBlur.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.gradientBlur.value = value;\n        }\n    },\n\n    /**\n     * The X value to start the effect at.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.filters.TiltShiftAxisFilter#\n     */\n    start: {\n        get: function ()\n        {\n            return this.uniforms.start.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.start.value = value;\n            this.updateDelta();\n        }\n    },\n\n    /**\n     * The X value to end the effect at.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.filters.TiltShiftAxisFilter#\n     */\n    end: {\n        get: function ()\n        {\n            return this.uniforms.end.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.end.value = value;\n            this.updateDelta();\n        }\n    }\n});\n\n},{\"../../core\":29}],111:[function(require,module,exports){\nvar core = require('../../core'),\n    TiltShiftXFilter = require('./TiltShiftXFilter'),\n    TiltShiftYFilter = require('./TiltShiftYFilter');\n\n/**\n * @author Vico @vicocotea\n * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/\n */\n\n/**\n * A TiltShift Filter. Manages the pass of both a TiltShiftXFilter and TiltShiftYFilter.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction TiltShiftFilter()\n{\n    core.AbstractFilter.call(this);\n\n    this.tiltShiftXFilter = new TiltShiftXFilter();\n    this.tiltShiftYFilter = new TiltShiftYFilter();\n}\n\nTiltShiftFilter.prototype = Object.create(core.AbstractFilter.prototype);\nTiltShiftFilter.prototype.constructor = TiltShiftFilter;\nmodule.exports = TiltShiftFilter;\n\nTiltShiftFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var renderTarget = renderer.filterManager.getRenderTarget(true);\n\n    this.tiltShiftXFilter.applyFilter(renderer, input, renderTarget);\n\n    this.tiltShiftYFilter.applyFilter(renderer, renderTarget, output);\n\n    renderer.filterManager.returnRenderTarget(renderTarget);\n};\n\nObject.defineProperties(TiltShiftFilter.prototype, {\n    /**\n     * The strength of the blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TiltShiftFilter#\n     */\n    blur: {\n        get: function ()\n        {\n            return this.tiltShiftXFilter.blur;\n        },\n        set: function (value)\n        {\n            this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = value;\n        }\n    },\n\n    /**\n     * The strength of the gradient blur.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TiltShiftFilter#\n     */\n    gradientBlur: {\n        get: function ()\n        {\n            return this.tiltShiftXFilter.gradientBlur;\n        },\n        set: function (value)\n        {\n            this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = value;\n        }\n    },\n\n    /**\n     * The Y value to start the effect at.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TiltShiftFilter#\n     */\n    start: {\n        get: function ()\n        {\n            return this.tiltShiftXFilter.start;\n        },\n        set: function (value)\n        {\n            this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = value;\n        }\n    },\n\n    /**\n     * The Y value to end the effect at.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TiltShiftFilter#\n     */\n    end: {\n        get: function ()\n        {\n            return this.tiltShiftXFilter.end;\n        },\n        set: function (value)\n        {\n            this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = value;\n        }\n    }\n});\n\n},{\"../../core\":29,\"./TiltShiftXFilter\":112,\"./TiltShiftYFilter\":113}],112:[function(require,module,exports){\nvar TiltShiftAxisFilter = require('./TiltShiftAxisFilter');\n\n/**\n * @author Vico @vicocotea\n * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/\n */\n\n/**\n * A TiltShiftXFilter.\n *\n * @class\n * @extends PIXI.TiltShiftAxisFilter\n * @memberof PIXI.filters\n */\nfunction TiltShiftXFilter()\n{\n    TiltShiftAxisFilter.call(this);\n}\n\nTiltShiftXFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);\nTiltShiftXFilter.prototype.constructor = TiltShiftXFilter;\nmodule.exports = TiltShiftXFilter;\n\n/**\n * Updates the filter delta values.\n *\n */\nTiltShiftXFilter.prototype.updateDelta = function ()\n{\n    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;\n    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;\n    var d = Math.sqrt(dx * dx + dy * dy);\n\n    this.uniforms.delta.value.x = dx / d;\n    this.uniforms.delta.value.y = dy / d;\n};\n\n},{\"./TiltShiftAxisFilter\":110}],113:[function(require,module,exports){\nvar TiltShiftAxisFilter = require('./TiltShiftAxisFilter');\n\n/**\n * @author Vico @vicocotea\n * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/\n */\n\n/**\n * A TiltShiftYFilter.\n *\n * @class\n * @extends PIXI.TiltShiftAxisFilter\n * @memberof PIXI.filters\n */\nfunction TiltShiftYFilter()\n{\n    TiltShiftAxisFilter.call(this);\n}\n\nTiltShiftYFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);\nTiltShiftYFilter.prototype.constructor = TiltShiftYFilter;\nmodule.exports = TiltShiftYFilter;\n\n/**\n * Updates the filter delta values.\n *\n */\nTiltShiftYFilter.prototype.updateDelta = function ()\n{\n    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;\n    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;\n    var d = Math.sqrt(dx * dx + dy * dy);\n\n    this.uniforms.delta.value.x = -dy / d;\n    this.uniforms.delta.value.y = dx / d;\n};\n\n},{\"./TiltShiftAxisFilter\":110}],114:[function(require,module,exports){\nvar core = require('../../core');\n// @see https://github.com/substack/brfs/issues/25\n\n\n/**\n * This filter applies a twist effect making display objects appear twisted in the given direction.\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI.filters\n */\nfunction TwistFilter()\n{\n    core.AbstractFilter.call(this,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision mediump float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform float radius;\\nuniform float angle;\\nuniform vec2 offset;\\n\\nvoid main(void)\\n{\\n   vec2 coord = vTextureCoord - offset;\\n   float dist = length(coord);\\n\\n   if (dist < radius)\\n   {\\n       float ratio = (radius - dist) / radius;\\n       float angleMod = ratio * ratio * angle;\\n       float s = sin(angleMod);\\n       float c = cos(angleMod);\\n       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\\n   }\\n\\n   gl_FragColor = texture2D(uSampler, coord+offset);\\n}\\n\",\n        // custom uniforms\n        {\n            radius:     { type: '1f', value: 0.5 },\n            angle:      { type: '1f', value: 5 },\n            offset:     { type: 'v2', value: { x: 0.5, y: 0.5 } }\n        }\n    );\n}\n\nTwistFilter.prototype = Object.create(core.AbstractFilter.prototype);\nTwistFilter.prototype.constructor = TwistFilter;\nmodule.exports = TwistFilter;\n\nObject.defineProperties(TwistFilter.prototype, {\n    /**\n     * This point describes the the offset of the twist.\n     *\n     * @member {PIXI.Point}\n     * @memberof PIXI.filters.TwistFilter#\n     */\n    offset: {\n        get: function ()\n        {\n            return this.uniforms.offset.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.offset.value = value;\n        }\n    },\n\n    /**\n     * This radius of the twist.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TwistFilter#\n     */\n    radius: {\n        get: function ()\n        {\n            return this.uniforms.radius.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.radius.value = value;\n        }\n    },\n\n    /**\n     * This angle of the twist.\n     *\n     * @member {number}\n     * @memberof PIXI.filters.TwistFilter#\n     */\n    angle: {\n        get: function ()\n        {\n            return this.uniforms.angle.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.angle.value = value;\n        }\n    }\n});\n\n},{\"../../core\":29}],115:[function(require,module,exports){\n(function (global){\n// run the polyfills\nrequire('./polyfill');\n\nvar core = module.exports = require('./core');\n\n// add core plugins.\ncore.extras         = require('./extras');\ncore.filters        = require('./filters');\ncore.interaction    = require('./interaction');\ncore.loaders        = require('./loaders');\ncore.mesh           = require('./mesh');\ncore.accessibility  = require('./accessibility');\n\n// export a premade loader instance\n/**\n * A premade instance of the loader that can be used to loader resources.\n *\n * @name loader\n * @memberof PIXI\n * @property {PIXI.loaders.Loader}\n */\ncore.loader = new core.loaders.Loader();\n\n// mixin the deprecation features.\nObject.assign(core, require('./deprecation'));\n\n// Always export pixi globally.\nglobal.PIXI = core;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./accessibility\":21,\"./core\":29,\"./deprecation\":79,\"./extras\":86,\"./filters\":103,\"./interaction\":118,\"./loaders\":121,\"./mesh\":128,\"./polyfill\":133}],116:[function(require,module,exports){\nvar core = require('../core');\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n * @memberof PIXI.interaction\n */\nfunction InteractionData()\n{\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {PIXI.Point}\n     */\n    this.global = new core.Point();\n\n    /**\n     * The target Sprite that was interacted with\n     *\n     * @member {PIXI.Sprite}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @member {Event}\n     */\n    this.originalEvent = null;\n}\n\nInteractionData.prototype.constructor = InteractionData;\nmodule.exports = InteractionData;\n\n/**\n * This will return the local coordinates of the specified displayObject for this InteractionData\n *\n * @param displayObject {PIXI.DisplayObject} The DisplayObject that you would like the local coords off\n * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new point)\n * @param [globalPos] {PIXI.Point} A Point object containing your custom global coords, optional (otherwise will use the current global coords)\n * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject\n */\nInteractionData.prototype.getLocalPosition = function (displayObject, point, globalPos)\n{\n    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n};\n\n},{\"../core\":29}],117:[function(require,module,exports){\nvar core = require('../core'),\n    InteractionData = require('./InteractionData');\n\n// Mix interactiveTarget into core.DisplayObject.prototype\nObject.assign(\n    core.DisplayObject.prototype,\n    require('./interactiveTarget')\n);\n\n/**\n * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * @class\n * @memberof PIXI.interaction\n * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer\n * @param [options] {object}\n * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.\n * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.\n */\nfunction InteractionManager(renderer, options)\n{\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {PIXI.SystemRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;\n\n    /**\n     * As this frequency increases the interaction events will be checked more often.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {PIXI.interaction.InteractionData}\n     */\n    this.mouse = new InteractionData();\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = {\n        stopped: false,\n        target: null,\n        type: null,\n        data: this.mouse,\n        stopPropagation:function(){\n            this.stopped = true;\n        }\n    };\n\n    /**\n     * Tiny little interactiveData pool !\n     *\n     * @member {PIXI.interaction.InteractionData[]}\n     */\n    this.interactiveDataPool = [];\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @member {HTMLElement}\n     * @private\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determins if mousemove and touchmove events are fired only when the cursror is over the object\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how pixi used to work. This will be set to true in future versions of pixi.\n     * @member {boolean}\n     * @private\n     */\n    this.moveWhenInside = false;\n    \n    /**\n     * Have events been attached to the dom element?\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.eventsAdded = false;\n\n    //this will make it so that you don't have to call bind all the time\n\n    /**\n     * @member {Function}\n     */\n    this.onMouseUp = this.onMouseUp.bind(this);\n    this.processMouseUp = this.processMouseUp.bind( this );\n\n\n    /**\n     * @member {Function}\n     */\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.processMouseDown = this.processMouseDown.bind( this );\n\n    /**\n     * @member {Function}\n     */\n    this.onMouseMove = this.onMouseMove.bind( this );\n    this.processMouseMove = this.processMouseMove.bind( this );\n\n    /**\n     * @member {Function}\n     */\n    this.onMouseOut = this.onMouseOut.bind(this);\n    this.processMouseOverOut = this.processMouseOverOut.bind( this );\n\n\n    /**\n     * @member {Function}\n     */\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.processTouchStart = this.processTouchStart.bind(this);\n\n    /**\n     * @member {Function}\n     */\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.processTouchEnd = this.processTouchEnd.bind(this);\n\n    /**\n     * @member {Function}\n     */\n    this.onTouchMove = this.onTouchMove.bind(this);\n    this.processTouchMove = this.processTouchMove.bind(this);\n\n    /**\n     * @member {number}\n     */\n    this.last = 0;\n\n    /**\n     * The css style of the cursor that is being used\n     * @member {string}\n     */\n    this.currentCursorStyle = 'inherit';\n\n    /**\n     * Internal cached var\n     * @member {PIXI.Point}\n     * @private\n     */\n    this._tempPoint = new core.Point();\n    \n\n    /**\n     * The current resolution\n     * @member {number}\n     */\n    this.resolution = 1;\n\n    this.setTargetElement(this.renderer.view, this.renderer.resolution);\n}\n\nInteractionManager.prototype.constructor = InteractionManager;\nmodule.exports = InteractionManager;\n\n/**\n * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n * another DOM element to receive those events.\n *\n * @param element {HTMLElement} the DOM element which will receive mouse and touch events.\n * @param [resolution=1] {number} THe resolution of the new element (relative to the canvas).\n * @private\n */\nInteractionManager.prototype.setTargetElement = function (element, resolution)\n{\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.resolution = resolution || 1;\n\n    this.addEvents();\n};\n\n/**\n * Registers all the DOM events\n *\n * @private\n */\nInteractionManager.prototype.addEvents = function ()\n{\n    if (!this.interactionDOMElement)\n    {\n        return;\n    }\n\n    core.ticker.shared.add(this.update, this);\n\n    if (window.navigator.msPointerEnabled)\n    {\n        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n        this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    }\n\n    window.document.addEventListener('mousemove',    this.onMouseMove, true);\n    this.interactionDOMElement.addEventListener('mousedown',    this.onMouseDown, true);\n    this.interactionDOMElement.addEventListener('mouseout',     this.onMouseOut, true);\n\n    this.interactionDOMElement.addEventListener('touchstart',   this.onTouchStart, true);\n    this.interactionDOMElement.addEventListener('touchend',     this.onTouchEnd, true);\n    this.interactionDOMElement.addEventListener('touchmove',    this.onTouchMove, true);\n\n    window.addEventListener('mouseup',  this.onMouseUp, true);\n\n    this.eventsAdded = true;\n};\n\n/**\n * Removes all the DOM events that were previously registered\n *\n * @private\n */\nInteractionManager.prototype.removeEvents = function ()\n{\n    if (!this.interactionDOMElement)\n    {\n        return;\n    }\n\n    core.ticker.shared.remove(this.update);\n\n    if (window.navigator.msPointerEnabled)\n    {\n        this.interactionDOMElement.style['-ms-content-zooming'] = '';\n        this.interactionDOMElement.style['-ms-touch-action'] = '';\n    }\n\n    window.document.removeEventListener('mousemove', this.onMouseMove, true);\n    this.interactionDOMElement.removeEventListener('mousedown', this.onMouseDown, true);\n    this.interactionDOMElement.removeEventListener('mouseout',  this.onMouseOut, true);\n\n    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);\n    this.interactionDOMElement.removeEventListener('touchend',  this.onTouchEnd, true);\n    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);\n\n    this.interactionDOMElement = null;\n\n    window.removeEventListener('mouseup',  this.onMouseUp, true);\n\n    this.eventsAdded = false;\n};\n\n/**\n * Updates the state of interactive objects.\n * Invoked by a throttled ticker update from\n * {@link PIXI.ticker.shared}.\n *\n * @param deltaTime {number}\n */\nInteractionManager.prototype.update = function (deltaTime)\n{\n    this._deltaTime += deltaTime;\n\n    if (this._deltaTime < this.interactionFrequency)\n    {\n        return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement)\n    {\n        return;\n    }\n\n    // if the user move the mouse this check has already been dfone using the mouse move!\n    if(this.didMove)\n    {\n        this.didMove = false;\n        return;\n    }\n\n    this.cursor = 'inherit';\n\n    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, true );\n\n    if (this.currentCursorStyle !== this.cursor)\n    {\n        this.currentCursorStyle = this.cursor;\n        this.interactionDOMElement.style.cursor = this.cursor;\n    }\n\n    //TODO\n};\n\n/**\n * Dispatches an event on the display object that was interacted with\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the display object in question\n * @param eventString {string} the name of the event (e.g, mousedown)\n * @param eventData {object} the event data object\n * @private\n */\nInteractionManager.prototype.dispatchEvent = function ( displayObject, eventString, eventData )\n{\n    if(!eventData.stopped)\n    {\n        eventData.target = displayObject;\n        eventData.type = eventString;\n\n        displayObject.emit( eventString, eventData );\n\n        if( displayObject[eventString] )\n        {\n            displayObject[eventString]( eventData );\n        }\n    }\n};\n\n/**\n * Maps x and y coords from a DOM object and maps them correctly to the pixi view. The resulting value is stored in the point.\n * This takes into account the fact that the DOM element could be scaled and positioned anywhere on the screen.\n *\n * @param  {PIXI.Point} point the point that the result will be stored in\n * @param  {number} x     the x coord of the position to map\n * @param  {number} y     the y coord of the position to map\n */\nInteractionManager.prototype.mapPositionToPoint = function ( point, x, y )\n{\n    var rect = this.interactionDOMElement.getBoundingClientRect();\n    point.x = ( ( x - rect.left ) * (this.interactionDOMElement.width  / rect.width  ) ) / this.resolution;\n    point.y = ( ( y - rect.top  ) * (this.interactionDOMElement.height / rect.height ) ) / this.resolution;\n};\n\n/**\n * This function is provides a neat way of crawling through the scene graph and running a specified function on all interactive objects it finds.\n * It will also take care of hit testing the interactive objects and passes the hit across in the function.\n *\n * @param  {PIXI.Point} point the point that is tested for collision\n * @param  {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject the displayObject that will be hit test (recurcsivly crawls its children)\n * @param  {Function} func the function that will be called on each interactive object. The displayObject and hit will be passed to the function\n * @param  {boolean} hitTest this indicates if the objects inside should be hit test against the point\n * @return {boolean} returns true if the displayObject hit the point\n */\nInteractionManager.prototype.processInteractive = function (point, displayObject, func, hitTest, interactive)\n{\n    if(!displayObject || !displayObject.visible)\n    {\n        return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    // \n    // This function will now loop through all objects and then only hit test the objects it HAS to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    // \n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    // \n    // As another little optimisation once an interactive object has been hit we can carry on through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n    \n    var hit = false,\n        interactiveParent = interactive = displayObject.interactive || interactive;\n\n    // if the displayobject has a hitArea, then it does not need to hitTest children.\n    if(displayObject.hitArea)\n    {\n        interactiveParent = false;\n    }\n\n    // ** FREE TIP **! If an object is not interacttive or has no buttons in it (such as a game scene!) set interactiveChildren to false for that displayObject.\n    // This will allow pixi to completly ignore and bypass checking the displayObjects children.\n    if(displayObject.interactiveChildren)\n    {       \n        var children = displayObject.children;\n        \n        for (var i = children.length-1; i >= 0; i--)\n        {\n            var child = children[i];\n\n            // time to get recursive.. if this function will return if somthing is hit..\n            if(this.processInteractive(point, child, func, hitTest, interactiveParent))\n            {\n                // its a good idea to check if a child has lost its parent.\n                // this means it has been removed whilst looping so its best\n                if(!child.parent)\n                {\n                    continue;\n                }\n\n                hit = true;\n\n                // we no longer need to hit test any more objects in this container as we we now know the parent has been hit\n                interactiveParent = false;\n                \n                // If the child is interactive , that means that the object hit was actually interactive and not just the child of an interactive object. \n                // This means we no longer need to hit test anything else. We still need to run through all objects, but we don't need to perform any hit tests.\n                //if(child.interactive)\n                //{\n                hitTest = false;\n                //}\n\n                // we can break now as we have hit an object.\n                //break;\n            }\n        }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if(interactive)\n    {\n        // if we are hit testing (as in we have no hit any objects yet)\n        // We also don't need to worry about hit testing if once of the displayObjects children has already been hit!\n        if(hitTest && !hit)\n        {  \n            if(displayObject.hitArea)\n            {\n                displayObject.worldTransform.applyInverse(point,  this._tempPoint);\n                hit = displayObject.hitArea.contains( this._tempPoint.x, this._tempPoint.y );\n            }\n            else if(displayObject.containsPoint)\n            {\n                hit = displayObject.containsPoint(point);\n            }\n        }\n\n        if(displayObject.interactive)\n        {\n            func(displayObject, hit); \n        }\n    }\n\n    return hit;\n  \n};\n\n\n/**\n * Is called when the mouse button is pressed down on the renderer element\n *\n * @param event {Event} The DOM event of a mouse button being pressed down\n * @private\n */\nInteractionManager.prototype.onMouseDown = function (event)\n{\n    this.mouse.originalEvent = event;\n    this.eventData.data = this.mouse;\n    this.eventData.stopped = false;\n\n    // Update internal mouse reference\n    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);\n\n    if (this.autoPreventDefault)\n    {\n        this.mouse.originalEvent.preventDefault();\n    }\n\n    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, true );\n};\n\n/**\n * Processes the result of the mouse down check and dispatches the event if need be\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested\n * @param hit {boolean} the result of the hit test on the dispay object\n * @private\n */\nInteractionManager.prototype.processMouseDown = function ( displayObject, hit )\n{\n    var e = this.mouse.originalEvent;\n    \n    var isRightButton = e.button === 2 || e.which === 3;\n\n    if(hit)\n    {\n        displayObject[ isRightButton ? '_isRightDown' : '_isLeftDown' ] = true;\n        this.dispatchEvent( displayObject, isRightButton ? 'rightdown' : 'mousedown', this.eventData );\n    }\n};\n\n\n\n/**\n * Is called when the mouse button is released on the renderer element\n *\n * @param event {Event} The DOM event of a mouse button being released\n * @private\n */\nInteractionManager.prototype.onMouseUp = function (event)\n{\n    this.mouse.originalEvent = event;\n    this.eventData.data = this.mouse;\n    this.eventData.stopped = false;\n\n    // Update internal mouse reference\n    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);\n\n    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, true );\n};\n\n/**\n * Processes the result of the mouse up check and dispatches the event if need be\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested\n * @param hit {boolean} the result of the hit test on the display object\n * @private\n */\nInteractionManager.prototype.processMouseUp = function ( displayObject, hit )\n{\n    var e = this.mouse.originalEvent;\n\n    var isRightButton = e.button === 2 || e.which === 3;\n    var isDown =  isRightButton ? '_isRightDown' : '_isLeftDown';\n\n    if(hit)\n    {\n        this.dispatchEvent( displayObject, isRightButton ? 'rightup' : 'mouseup', this.eventData );\n\n        if( displayObject[ isDown ] )\n        {\n            displayObject[ isDown ] = false;\n            this.dispatchEvent( displayObject, isRightButton ? 'rightclick' : 'click', this.eventData );\n        }\n    }\n    else\n    {\n        if( displayObject[ isDown ] )\n        {\n            displayObject[ isDown ] = false;\n            this.dispatchEvent( displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', this.eventData );\n        }\n    }\n};\n\n\n/**\n * Is called when the mouse moves across the renderer element\n *\n * @param event {Event} The DOM event of the mouse moving\n * @private\n */\nInteractionManager.prototype.onMouseMove = function (event)\n{\n    this.mouse.originalEvent = event;\n    this.eventData.data = this.mouse;\n    this.eventData.stopped = false;\n\n    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);\n\n    this.didMove = true;\n\n    this.cursor = 'inherit';\n\n    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, true );\n\n    if (this.currentCursorStyle !== this.cursor)\n    {\n        this.currentCursorStyle = this.cursor;\n        this.interactionDOMElement.style.cursor = this.cursor;\n    }\n\n    //TODO BUG for parents ineractive object (border order issue)\n};\n\n/**\n * Processes the result of the mouse move check and dispatches the event if need be\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested\n * @param hit {boolean} the result of the hit test on the display object\n * @private\n */\nInteractionManager.prototype.processMouseMove = function ( displayObject, hit )\n{\n    this.processMouseOverOut(displayObject, hit);\n    \n    // only display on mouse over\n    if(!this.moveWhenInside || hit)\n    {\n        this.dispatchEvent( displayObject, 'mousemove', this.eventData);\n    }\n};\n\n\n/**\n * Is called when the mouse is moved out of the renderer element\n *\n * @param event {Event} The DOM event of a mouse being moved out\n * @private\n */\nInteractionManager.prototype.onMouseOut = function (event)\n{\n    this.mouse.originalEvent = event;\n    this.eventData.stopped = false;\n\n    // Update internal mouse reference\n    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);\n\n    this.interactionDOMElement.style.cursor = 'inherit';\n\n    // TODO optimize by not check EVERY TIME! maybe half as often? //\n    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY );\n\n    this.processInteractive( this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, false );\n};\n\n/**\n * Processes the result of the mouse over/out check and dispatches the event if need be\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested\n * @param hit {boolean} the result of the hit test on the display object\n * @private\n */\nInteractionManager.prototype.processMouseOverOut = function ( displayObject, hit )\n{\n    if(hit)\n    {\n        if(!displayObject._over)\n        {\n            displayObject._over = true;\n            this.dispatchEvent( displayObject, 'mouseover', this.eventData );\n        }\n\n        if (displayObject.buttonMode)\n        {\n            this.cursor = displayObject.defaultCursor;\n        }\n    }\n    else\n    {\n        if(displayObject._over)\n        {\n            displayObject._over = false;\n            this.dispatchEvent( displayObject, 'mouseout', this.eventData);\n        }\n    }\n};\n\n\n/**\n * Is called when a touch is started on the renderer element\n *\n * @param event {Event} The DOM event of a touch starting on the renderer view\n * @private\n */\nInteractionManager.prototype.onTouchStart = function (event)\n{\n    if (this.autoPreventDefault)\n    {\n        event.preventDefault();\n    }\n\n    var changedTouches = event.changedTouches;\n    var cLength = changedTouches.length;\n\n    for (var i=0; i < cLength; i++)\n    {\n        var touchEvent = changedTouches[i];\n        //TODO POOL\n        var touchData = this.getTouchData( touchEvent );\n\n        touchData.originalEvent = event;\n\n        this.eventData.data = touchData;\n        this.eventData.stopped = false;\n\n        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchStart, true );\n\n        this.returnTouchData( touchData );\n    }\n};\n\n/**\n * Processes the result of a touch check and dispatches the event if need be\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested\n * @param hit {boolean} the result of the hit test on the display object\n * @private\n */\nInteractionManager.prototype.processTouchStart = function ( displayObject, hit )\n{\n    if(hit)\n    {\n        displayObject._touchDown = true;\n        this.dispatchEvent( displayObject, 'touchstart', this.eventData );\n    }\n};\n\n\n/**\n * Is called when a touch ends on the renderer element\n *\n * @param event {Event} The DOM event of a touch ending on the renderer view\n */\nInteractionManager.prototype.onTouchEnd = function (event)\n{\n    if (this.autoPreventDefault)\n    {\n        event.preventDefault();\n    }\n\n    var changedTouches = event.changedTouches;\n    var cLength = changedTouches.length;\n\n    for (var i=0; i < cLength; i++)\n    {\n        var touchEvent = changedTouches[i];\n\n        var touchData = this.getTouchData( touchEvent );\n\n        touchData.originalEvent = event;\n\n        //TODO this should be passed along.. no set\n        this.eventData.data = touchData;\n        this.eventData.stopped = false;\n\n\n        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchEnd, true );\n\n        this.returnTouchData( touchData );\n    }\n};\n\n/**\n * Processes the result of the end of a touch and dispatches the event if need be\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested\n * @param hit {boolean} the result of the hit test on the display object\n * @private\n */\nInteractionManager.prototype.processTouchEnd = function ( displayObject, hit )\n{\n    if(hit)\n    {\n        this.dispatchEvent( displayObject, 'touchend', this.eventData );\n\n        if( displayObject._touchDown )\n        {\n            displayObject._touchDown = false;\n            this.dispatchEvent( displayObject, 'tap', this.eventData );\n        }\n    }\n    else\n    {\n        if( displayObject._touchDown )\n        {\n            displayObject._touchDown = false;\n            this.dispatchEvent( displayObject, 'touchendoutside', this.eventData );\n        }\n    }\n};\n\n/**\n * Is called when a touch is moved across the renderer element\n *\n * @param event {Event} The DOM event of a touch moving across the renderer view\n * @private\n */\nInteractionManager.prototype.onTouchMove = function (event)\n{\n    if (this.autoPreventDefault)\n    {\n        event.preventDefault();\n    }\n\n    var changedTouches = event.changedTouches;\n    var cLength = changedTouches.length;\n\n    for (var i=0; i < cLength; i++)\n    {\n        var touchEvent = changedTouches[i];\n\n        var touchData = this.getTouchData( touchEvent );\n\n        touchData.originalEvent = event;\n\n        this.eventData.data = touchData;\n        this.eventData.stopped = false;\n\n        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchMove, this.moveWhenInside );\n\n        this.returnTouchData( touchData );\n    }\n};\n\n/**\n * Processes the result of a touch move check and dispatches the event if need be\n *\n * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested\n * @param hit {boolean} the result of the hit test on the display object\n * @private\n */\nInteractionManager.prototype.processTouchMove = function ( displayObject, hit )\n{\n    if(!this.moveWhenInside || hit)\n    {\n        this.dispatchEvent( displayObject, 'touchmove', this.eventData);\n    }\n};\n\n/**\n * Grabs an interaction data object from the internal pool\n *\n * @param touchEvent {EventData} The touch event we need to pair with an interactionData object\n *\n * @private\n */\nInteractionManager.prototype.getTouchData = function (touchEvent)\n{\n    var touchData = this.interactiveDataPool.pop();\n\n    if(!touchData)\n    {\n        touchData = new InteractionData();\n    }\n\n    touchData.identifier = touchEvent.identifier;\n    this.mapPositionToPoint( touchData.global, touchEvent.clientX, touchEvent.clientY );\n\n    if(navigator.isCocoonJS)\n    {\n        touchData.global.x = touchData.global.x / this.resolution;\n        touchData.global.y = touchData.global.y / this.resolution;\n    }\n\n    touchEvent.globalX = touchData.global.x;\n    touchEvent.globalY = touchData.global.y;\n\n    return touchData;\n};\n\n/**\n * Returns an interaction data object to the internal pool\n *\n * @param touchData {PIXI.interaction.InteractionData} The touch data object we want to return to the pool\n *\n * @private\n */\nInteractionManager.prototype.returnTouchData = function ( touchData )\n{\n    this.interactiveDataPool.push( touchData );\n};\n\n/**\n * Destroys the interaction manager\n *\n */\nInteractionManager.prototype.destroy = function () {\n    this.removeEvents();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactiveDataPool = null;\n\n    this.interactionDOMElement = null;\n\n    this.onMouseUp = null;\n    this.processMouseUp = null;\n\n\n    this.onMouseDown = null;\n    this.processMouseDown = null;\n\n    this.onMouseMove = null;\n    this.processMouseMove = null;\n\n    this.onMouseOut = null;\n    this.processMouseOverOut = null;\n\n\n    this.onTouchStart = null;\n    this.processTouchStart = null;\n\n    this.onTouchEnd = null;\n    this.processTouchEnd = null;\n\n    this.onTouchMove = null;\n    this.processTouchMove = null;\n\n    this._tempPoint = null;\n};\n\ncore.WebGLRenderer.registerPlugin('interaction', InteractionManager);\ncore.CanvasRenderer.registerPlugin('interaction', InteractionManager);\n\n},{\"../core\":29,\"./InteractionData\":116,\"./interactiveTarget\":119}],118:[function(require,module,exports){\n/**\n * @file        Main export of the PIXI interactions library\n * @author      Mat Groves <mat@goodboydigital.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI.interaction\n */\nmodule.exports = {\n    InteractionData:    require('./InteractionData'),\n    InteractionManager: require('./InteractionManager'),\n    interactiveTarget:  require('./interactiveTarget')\n};\n\n},{\"./InteractionData\":116,\"./InteractionManager\":117,\"./interactiveTarget\":119}],119:[function(require,module,exports){\n/**\n * Default property values of interactive objects\n * used by {@link PIXI.interaction.InteractionManager}.\n *\n * @mixin\n * @memberof PIXI.interaction\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          MyObject.prototype,\n *          PIXI.interaction.interactiveTarget\n *      );\n */\nvar interactiveTarget = {\n    /**\n     * @todo Needs docs.\n     */\n    interactive: false,\n    /**\n     * @todo Needs docs.\n     */\n    buttonMode: false,\n    /**\n     * @todo Needs docs.\n     */\n    interactiveChildren: true,\n    /**\n     * @todo Needs docs.\n     */\n    defaultCursor: 'pointer',\n\n    // some internal checks..\n\n    /**\n     * @todo Needs docs.\n     * @private\n     */\n    _over: false,\n    /**\n     * @todo Needs docs.\n     * @private\n     */\n    _touchDown: false\n};\n\nmodule.exports = interactiveTarget;\n\n},{}],120:[function(require,module,exports){\nvar Resource = require('resource-loader').Resource,\n    core = require('../core'),\n    extras = require('../extras'),\n    path = require('path');\n\n\nfunction parse(resource, texture) {\n    var data = {};\n    var info = resource.data.getElementsByTagName('info')[0];\n    var common = resource.data.getElementsByTagName('common')[0];\n\n    data.font = info.getAttribute('face');\n    data.size = parseInt(info.getAttribute('size'), 10);\n    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n    data.chars = {};\n\n    //parse letters\n    var letters = resource.data.getElementsByTagName('char');\n\n    for (var i = 0; i < letters.length; i++)\n    {\n        var charCode = parseInt(letters[i].getAttribute('id'), 10);\n\n        var textureRect = new core.Rectangle(\n            parseInt(letters[i].getAttribute('x'), 10) + texture.frame.x,\n            parseInt(letters[i].getAttribute('y'), 10) + texture.frame.y,\n            parseInt(letters[i].getAttribute('width'), 10),\n            parseInt(letters[i].getAttribute('height'), 10)\n        );\n\n        data.chars[charCode] = {\n            xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),\n            yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),\n            xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),\n            kerning: {},\n            texture: new core.Texture(texture.baseTexture, textureRect)\n\n        };\n    }\n\n    //parse kernings\n    var kernings = resource.data.getElementsByTagName('kerning');\n    for (i = 0; i < kernings.length; i++)\n    {\n        var first = parseInt(kernings[i].getAttribute('first'), 10);\n        var second = parseInt(kernings[i].getAttribute('second'), 10);\n        var amount = parseInt(kernings[i].getAttribute('amount'), 10);\n\n        if(data.chars[second])\n        {\n            data.chars[second].kerning[first] = amount;\n        }\n    }\n\n    resource.bitmapFont = data;\n\n    // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3\n    // but it's very likely to change\n    extras.BitmapText.fonts[data.font] = data;\n}\n\n\nmodule.exports = function ()\n{\n    return function (resource, next)\n    {\n        // skip if no data or not xml data\n        if (!resource.data || !resource.isXml)\n        {\n            return next();\n        }\n\n        // skip if not bitmap font data, using some silly duck-typing\n        if (\n            resource.data.getElementsByTagName('page').length === 0 ||\n            resource.data.getElementsByTagName('info').length === 0 ||\n            resource.data.getElementsByTagName('info')[0].getAttribute('face') === null\n            )\n        {\n            return next();\n        }\n\n        var xmlUrl = path.dirname(resource.url);\n\n        if (xmlUrl === '.') {\n            xmlUrl = '';\n        }\n\n        if (this.baseUrl && xmlUrl) {\n            // if baseurl has a trailing slash then add one to xmlUrl so the replace works below\n            if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {\n                xmlUrl += '/';\n            }\n\n            // remove baseUrl from xmlUrl\n            xmlUrl = xmlUrl.replace(this.baseUrl, '');\n        }\n\n        // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.\n        if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {\n            xmlUrl += '/';\n        }\n        var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');\n        if (core.utils.TextureCache[textureUrl]) {\n            //reuse existing texture\n            parse(resource, core.utils.TextureCache[textureUrl]);\n            next();\n        }\n        else {\n            var loadOptions = {\n                crossOrigin: resource.crossOrigin,\n                loadType: Resource.LOAD_TYPE.IMAGE,\n                metadata: resource.metadata.imageMetadata\n            };\n            // load the texture for the font\n            this.add(resource.name + '_image', textureUrl, loadOptions, function (res) {\n                parse(resource, res.texture);\n                next();\n            });\n        }\n    };\n};\n\n},{\"../core\":29,\"../extras\":86,\"path\":2,\"resource-loader\":16}],121:[function(require,module,exports){\n/**\n * @file        Main export of the PIXI loaders library\n * @author      Mat Groves <mat@goodboydigital.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI.loaders\n */\nmodule.exports = {\n    Loader:             require('./loader'),\n\n    // parsers\n    bitmapFontParser:   require('./bitmapFontParser'),\n    spritesheetParser:  require('./spritesheetParser'),\n    textureParser:      require('./textureParser'),\n    Resource:           require('resource-loader').Resource\n};\n\n},{\"./bitmapFontParser\":120,\"./loader\":122,\"./spritesheetParser\":123,\"./textureParser\":124,\"resource-loader\":16}],122:[function(require,module,exports){\nvar ResourceLoader = require('resource-loader'),\n    textureParser = require('./textureParser'),\n    spritesheetParser = require('./spritesheetParser'),\n    bitmapFontParser = require('./bitmapFontParser');\n\n/**\n *\n * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader\n *\n * ```js\n * var loader = PIXI.loader; // pixi exposes a premade instance for you to use.\n * //or\n * var loader = new PIXI.loaders.Loader(); // you can also create your own if you want\n *\n * loader.add('bunny',\"data/bunny.png\");\n *\n * loader.once('complete',onAssetsLoaded);\n *\n * loader.load();\n * ```\n *\n * @class\n * @extends PIXI.ResourceLoader\n * @memberof PIXI.loaders\n * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.\n * @param [concurrency=10] {number} The number of resources to load concurrently.\n */\nfunction Loader(baseUrl, concurrency)\n{\n    ResourceLoader.call(this, baseUrl, concurrency);\n\n    for (var i = 0; i < Loader._pixiMiddleware.length; ++i) {\n        this.use(Loader._pixiMiddleware[i]());\n    }\n}\n\nLoader.prototype = Object.create(ResourceLoader.prototype);\nLoader.prototype.constructor = Loader;\n\nmodule.exports = Loader;\n\nLoader._pixiMiddleware = [\n    // parse any blob into more usable objects (e.g. Image)\n    ResourceLoader.middleware.parsing.blob,\n    // parse any Image objects into textures\n    textureParser,\n    // parse any spritesheet data into multiple textures\n    spritesheetParser,\n    // parse any spritesheet data into multiple textures\n    bitmapFontParser\n];\n\nLoader.addPixiMiddleware = function (fn) {\n    Loader._pixiMiddleware.push(fn);\n};\n\n// Add custom extentions\nvar Resource = ResourceLoader.Resource;\n\nResource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);\n\n},{\"./bitmapFontParser\":120,\"./spritesheetParser\":123,\"./textureParser\":124,\"resource-loader\":16}],123:[function(require,module,exports){\nvar Resource = require('resource-loader').Resource,\n    path = require('path'),\n    core = require('../core'),\n    async = require('async');\n\nvar BATCH_SIZE = 1000;\n\nmodule.exports = function ()\n{\n    return function (resource, next)\n    {\n        var imageResourceName = resource.name + '_image';\n\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data || !resource.isJson || !resource.data.frames || this.resources[imageResourceName])\n        {\n            return next();\n        }\n\n        var loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            loadType: Resource.LOAD_TYPE.IMAGE,\n            metadata: resource.metadata.imageMetadata\n        };\n\n        var route = path.dirname(resource.url.replace(this.baseUrl, ''));\n\n        // load the image for this sheet\n        this.add(imageResourceName, route + '/' + resource.data.meta.image, loadOptions, function (res)\n        {\n            resource.textures = {};\n\n            var frames = resource.data.frames;\n            var frameKeys = Object.keys(frames);\n            var resolution = core.utils.getResolutionOfUrl(resource.url);\n            var batchIndex = 0;\n\n            function processFrames(initialFrameIndex, maxFrames)\n            {\n                var frameIndex = initialFrameIndex;\n\n                while (frameIndex - initialFrameIndex < maxFrames && frameIndex < frameKeys.length)\n                {\n                    var frame = frames[frameKeys[frameIndex]];\n                    var rect = frame.frame;\n\n                    if (rect)\n                    {\n                        var size = null;\n                        var trim = null;\n\n                        if (frame.rotated)\n                        {\n                            size = new core.Rectangle(rect.x, rect.y, rect.h, rect.w);\n                        }\n                        else\n                        {\n                            size = new core.Rectangle(rect.x, rect.y, rect.w, rect.h);\n                        }\n\n                        //  Check to see if the sprite is trimmed\n                        if (frame.trimmed)\n                        {\n                            trim = new core.Rectangle(\n                                frame.spriteSourceSize.x / resolution,\n                                frame.spriteSourceSize.y / resolution,\n                                frame.sourceSize.w / resolution,\n                                frame.sourceSize.h / resolution\n                            );\n                        }\n\n                        // flip the width and height!\n                        if (frame.rotated)\n                        {\n                            var temp = size.width;\n                            size.width = size.height;\n                            size.height = temp;\n                        }\n\n                        size.x /= resolution;\n                        size.y /= resolution;\n                        size.width /= resolution;\n                        size.height /= resolution;\n\n                        resource.textures[frameKeys[frameIndex]] = new core.Texture(res.texture.baseTexture, size, size.clone(), trim, frame.rotated);\n\n                        // lets also add the frame to pixi's global cache for fromFrame and fromImage functions\n                        core.utils.TextureCache[frameKeys[frameIndex]] = resource.textures[frameKeys[frameIndex]];\n                    }\n                    frameIndex++;\n                }\n            }\n\n            function shouldProcessNextBatch()\n            {\n                return batchIndex * BATCH_SIZE < frameKeys.length;\n            }\n\n            function processNextBatch(done)\n            {\n                processFrames(batchIndex * BATCH_SIZE, BATCH_SIZE);\n                batchIndex++;\n                setTimeout(done, 0);\n            }\n\n            if (frameKeys.length <= BATCH_SIZE)\n            {\n                processFrames(0, BATCH_SIZE);\n                next();\n            }\n            else\n            {\n                async.whilst(shouldProcessNextBatch, processNextBatch, next);\n            }\n        });\n    };\n};\n\n},{\"../core\":29,\"async\":1,\"path\":2,\"resource-loader\":16}],124:[function(require,module,exports){\nvar core = require('../core');\n\nmodule.exports = function ()\n{\n    return function (resource, next)\n    {\n        // create a new texture if the data is an Image object\n        if (resource.data && resource.isImage)\n        {\n            var baseTexture = new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url));\n            baseTexture.imageUrl = resource.url;\n            resource.texture = new core.Texture(baseTexture);\n            // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions\n            core.utils.BaseTextureCache[resource.url] = baseTexture;\n            core.utils.TextureCache[resource.url] = resource.texture;\n        }\n\n        next();\n    };\n};\n\n},{\"../core\":29}],125:[function(require,module,exports){\nvar core = require('../core'),\n    tempPoint = new core.Point(),\n    tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n * @param texture {PIXI.Texture} The texture to use\n * @param [vertices] {Float32Array} if you want to specify the vertices\n * @param [uvs] {Float32Array} if you want to specify the uvs\n * @param [indices] {Uint16Array} if you want to specify the indices\n * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts\n */\nfunction Mesh(texture, vertices, uvs, indices, drawMode)\n{\n    core.Container.call(this);\n\n    /**\n     * The texture of the Mesh\n     *\n     * @member {PIXI.Texture}\n     * @private\n     */\n    this._texture = null;\n\n    /**\n     * The Uvs of the Mesh\n     *\n     * @member {Float32Array}\n     */\n    this.uvs = uvs || new Float32Array([0, 0,\n        1, 0,\n        1, 1,\n        0, 1]);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = vertices || new Float32Array([0, 0,\n        100, 0,\n        100, 100,\n        0, 100]);\n\n    /*\n     * @member {Uint16Array} An array containing the indices of the vertices\n     */\n    //  TODO auto generate this based on draw mode!\n    this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n\n    /**\n     * Whether the Mesh is dirty or not\n     *\n     * @member {boolean}\n     */\n    this.dirty = true;\n\n    /**\n     * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove any blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     * @see PIXI.BLEND_MODES\n     */\n    this.blendMode = core.BLEND_MODES.NORMAL;\n\n    /**\n     * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.\n     *\n     * @member {number}\n     */\n    this.canvasPadding = 0;\n\n    /**\n     * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n     *\n     * @member {number}\n     * @see PIXI.mesh.Mesh.DRAW_MODES\n     */\n    this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n    // run texture setter;\n    this.texture = texture;\n\n     /**\n     * The default shader that is used if a mesh doesn't have a more specific one.\n     *\n     * @member {PIXI.Shader}\n     */\n    this.shader = null;\n}\n\n// constructor\nMesh.prototype = Object.create(core.Container.prototype);\nMesh.prototype.constructor = Mesh;\nmodule.exports = Mesh;\n\nObject.defineProperties(Mesh.prototype, {\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.mesh.Mesh#\n     */\n    texture: {\n        get: function ()\n        {\n            return  this._texture;\n        },\n        set: function (value)\n        {\n            if (this._texture === value)\n            {\n                return;\n            }\n\n            this._texture = value;\n\n            if (value)\n            {\n                // wait for the texture to load\n                if (value.baseTexture.hasLoaded)\n                {\n                    this._onTextureUpdate();\n                }\n                else\n                {\n                    value.once('update', this._onTextureUpdate, this);\n                }\n            }\n        }\n    }\n});\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {PIXI.WebGLRenderer} a reference to the WebGL renderer\n * @private\n */\nMesh.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.mesh);\n    renderer.plugins.mesh.render(this);\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {PIXI.CanvasRenderer}\n * @private\n */\nMesh.prototype._renderCanvas = function (renderer)\n{\n    var context = renderer.context;\n\n    var transform = this.worldTransform;\n    var res = renderer.resolution;\n\n    if (renderer.roundPixels)\n    {\n        context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, (transform.tx * res) | 0, (transform.ty * res) | 0);\n    }\n    else\n    {\n        context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);\n    }\n\n    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)\n    {\n        this._renderCanvasTriangleMesh(context);\n    }\n    else\n    {\n        this._renderCanvasTriangles(context);\n    }\n};\n\n/**\n * Draws the object in Triangle Mesh mode using canvas\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @private\n */\nMesh.prototype._renderCanvasTriangleMesh = function (context)\n{\n    // draw triangles!!\n    var vertices = this.vertices;\n    var uvs = this.uvs;\n\n    var length = vertices.length / 2;\n    // this.count++;\n\n    for (var i = 0; i < length - 2; i++)\n    {\n        // draw some triangles!\n        var index = i * 2;\n        this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));\n    }\n};\n\n/**\n * Draws the object in triangle mode using canvas\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @private\n */\nMesh.prototype._renderCanvasTriangles = function (context)\n{\n    // draw triangles!!\n    var vertices = this.vertices;\n    var uvs = this.uvs;\n    var indices = this.indices;\n\n    var length = indices.length;\n    // this.count++;\n\n    for (var i = 0; i < length; i += 3)\n    {\n        // draw some triangles!\n        var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;\n        this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);\n    }\n};\n\n/**\n * Draws one of the triangles that form this Mesh\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @param vertices {Float32Array} a reference to the vertices of the Mesh\n * @param uvs {Float32Array} a reference to the uvs of the Mesh\n * @param index0 {number} the index of the first vertex\n * @param index1 {number} the index of the second vertex\n * @param index2 {number} the index of the third vertex\n * @private\n */\nMesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2)\n{\n    var base = this._texture.baseTexture;\n    var textureSource = base.source;\n    var textureWidth = base.width;\n    var textureHeight = base.height;\n\n    var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];\n    var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];\n\n    var u0 = uvs[index0] * base.width, u1 = uvs[index1] * base.width, u2 = uvs[index2] * base.width;\n    var v0 = uvs[index0 + 1] * base.height, v1 = uvs[index1 + 1] * base.height, v2 = uvs[index2 + 1] * base.height;\n\n    if (this.canvasPadding > 0)\n    {\n        var paddingX = this.canvasPadding / this.worldTransform.a;\n        var paddingY = this.canvasPadding / this.worldTransform.d;\n        var centerX = (x0 + x1 + x2) / 3;\n        var centerY = (y0 + y1 + y2) / 3;\n\n        var normX = x0 - centerX;\n        var normY = y0 - centerY;\n\n        var dist = Math.sqrt(normX * normX + normY * normY);\n        x0 = centerX + (normX / dist) * (dist + paddingX);\n        y0 = centerY + (normY / dist) * (dist + paddingY);\n\n        //\n\n        normX = x1 - centerX;\n        normY = y1 - centerY;\n\n        dist = Math.sqrt(normX * normX + normY * normY);\n        x1 = centerX + (normX / dist) * (dist + paddingX);\n        y1 = centerY + (normY / dist) * (dist + paddingY);\n\n        normX = x2 - centerX;\n        normY = y2 - centerY;\n\n        dist = Math.sqrt(normX * normX + normY * normY);\n        x2 = centerX + (normX / dist) * (dist + paddingX);\n        y2 = centerY + (normY / dist) * (dist + paddingY);\n    }\n\n    context.save();\n    context.beginPath();\n\n\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n\n    context.closePath();\n\n    context.clip();\n\n    // Compute matrix transform\n    var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2);\n    var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2);\n    var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2);\n    var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);\n    var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2);\n    var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2);\n    var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);\n\n    context.transform(deltaA / delta, deltaD / delta,\n        deltaB / delta, deltaE / delta,\n        deltaC / delta, deltaF / delta);\n\n    context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);\n    context.restore();\n};\n\n\n\n/**\n * Renders a flat Mesh\n *\n * @param Mesh {PIXI.mesh.Mesh} The Mesh to render\n * @private\n */\nMesh.prototype.renderMeshFlat = function (Mesh)\n{\n    var context = this.context;\n    var vertices = Mesh.vertices;\n\n    var length = vertices.length/2;\n    // this.count++;\n\n    context.beginPath();\n    for (var i=1; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4];\n        var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5];\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n    }\n\n    context.fillStyle = '#FF0000';\n    context.fill();\n    context.closePath();\n};\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @param event\n * @private\n */\nMesh.prototype._onTextureUpdate = function ()\n{\n    this.updateFrame = true;\n};\n\n/**\n * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {PIXI.Matrix} the transformation matrix of the sprite\n * @return {PIXI.Rectangle} the framing rectangle\n */\nMesh.prototype.getBounds = function (matrix)\n{\n    if (!this._currentBounds) {\n        var worldTransform = matrix || this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n\n        var minX = Infinity;\n        var minY = Infinity;\n\n        var vertices = this.vertices;\n        for (var i = 0, n = vertices.length; i < n; i += 2) {\n            var rawX = vertices[i], rawY = vertices[i + 1];\n            var x = (a * rawX) + (c * rawY) + tx;\n            var y = (d * rawY) + (b * rawX) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        if (minX === -Infinity || maxY === Infinity) {\n            return core.Rectangle.EMPTY;\n        }\n\n        var bounds = this._bounds;\n\n        bounds.x = minX;\n        bounds.width = maxX - minX;\n\n        bounds.y = minY;\n        bounds.height = maxY - minY;\n\n        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n        this._currentBounds = bounds;\n    }\n\n    return this._currentBounds;\n};\n\n/**\n * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n *\n * @param point {PIXI.Point} the point to test\n * @return {boolean} the result of the test\n */\nMesh.prototype.containsPoint = function( point ) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n        return false;\n    }\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var vertices = this.vertices;\n    var points = tempPolygon.points;\n    var i, len;\n\n    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {\n        var indices = this.indices;\n        len = this.indices.length;\n        //TODO: inline this.\n        for (i=0;i<len;i+=3) {\n            var ind0 = indices[i]*2, ind1 = indices[i+1]*2, ind2 = indices[i+2]*2;\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0+1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1+1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2+1];\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n                return true;\n            }\n        }\n    } else {\n        len = vertices.length;\n        for (i=0;i<len;i+=6) {\n            points[0] = vertices[i];\n            points[1] = vertices[i+1];\n            points[2] = vertices[i+2];\n            points[3] = vertices[i+3];\n            points[4] = vertices[i+4];\n            points[5] = vertices[i+5];\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @property {object} DRAW_MODES\n * @property {number} DRAW_MODES.TRIANGLE_MESH\n * @property {number} DRAW_MODES.TRIANGLES\n */\nMesh.DRAW_MODES = {\n    TRIANGLE_MESH: 0,\n    TRIANGLES: 1\n};\n\n},{\"../core\":29}],126:[function(require,module,exports){\nvar Mesh = require('./Mesh');\n\n/**\n * The Plane allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (var i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * var Plane = new PIXI.Plane(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n * @param {PIXI.Texture} texture - The texture to use on the Plane.\n * @param {int} segmentsX - The number ox x segments\n * @param {int} segmentsY - The number of y segments\n *\n */\nfunction Plane(texture, segmentsX, segmentsY)\n{\n    Mesh.call(this, texture);\n\n    /**\n     * Tracker for if the Plane is ready to be drawn. Needed because Mesh ctor can\n     * call _onTextureUpdated which could call refresh too early.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this._ready = true;\n\n    this.segmentsX =  segmentsX || 10;\n    this.segmentsY = segmentsY || 10;\n\n    this.drawMode = Mesh.DRAW_MODES.TRIANGLES;\n    this.refresh();\n\n}\n\n\n// constructor\nPlane.prototype = Object.create( Mesh.prototype );\nPlane.prototype.constructor = Plane;\nmodule.exports = Plane;\n\n/**\n * Refreshes\n *\n */\nPlane.prototype.refresh = function()\n{\n    var total = this.segmentsX * this.segmentsY;\n    var verts = [];\n    var colors = [];\n    var uvs = [];\n    var indices = [];\n    var texture = this.texture;\n\n  //  texture.width = 800 texture.width || 800;\n //   texture.height = 800//texture.height || 800;\n\n    var segmentsXSub = this.segmentsX - 1;\n    var segmentsYSub = this.segmentsY - 1;\n    var i = 0;\n\n    var sizeX = texture.width / segmentsXSub;\n    var sizeY = texture.height / segmentsYSub;\n\n    for (i = 0; i < total; i++) {\n\n        var x = (i % this.segmentsX);\n        var y = ( (i / this.segmentsX ) | 0 );\n\n\n        verts.push((x * sizeX),\n                   (y * sizeY));\n\n        // this works for rectangular textures. \n        uvs.push(texture._uvs.x0 + (texture._uvs.x1 - texture._uvs.x0) * (x / (this.segmentsX-1)), texture._uvs.y0 + (texture._uvs.y3-texture._uvs.y0) * (y/ (this.segmentsY-1)));\n      }\n\n    //  cons\n\n    var totalSub = segmentsXSub * segmentsYSub;\n\n    for (i = 0; i < totalSub; i++) {\n\n        var xpos = i % segmentsXSub;\n        var ypos = (i / segmentsXSub ) | 0;\n\n\n        var  value = (ypos * this.segmentsX) + xpos;\n        var  value2 = (ypos * this.segmentsX) + xpos + 1;\n        var  value3 = ((ypos+1) * this.segmentsX) + xpos;\n        var  value4 = ((ypos+1) * this.segmentsX) + xpos + 1;\n\n        indices.push(value, value2, value3);\n        indices.push(value2, value4, value3);\n    }\n\n\n    //console.log(indices)\n    this.vertices = new Float32Array(verts);\n    this.uvs = new Float32Array(uvs);\n    this.colors = new Float32Array(colors);\n    this.indices = new Uint16Array(indices);\n};\n\n/**\n * Clear texture UVs when new texture is set\n *\n * @private\n */\nPlane.prototype._onTextureUpdate = function ()\n{\n    Mesh.prototype._onTextureUpdate.call(this);\n\n    // wait for the Plane ctor to finish before calling refresh\n    if (this._ready) {\n        this.refresh();\n    }\n};\n\n},{\"./Mesh\":125}],127:[function(require,module,exports){\nvar Mesh = require('./Mesh');\nvar core = require('../core');\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (var i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * var rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n * @param {PIXI.Texture} texture - The texture to use on the rope.\n * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n *\n */\nfunction Rope(texture, points)\n{\n    Mesh.call(this, texture);\n\n    /*\n     * @member {PIXI.Point[]} An array of points that determine the rope\n     */\n    this.points = points;\n\n    /*\n     * @member {Float32Array} An array of vertices used to construct this rope.\n     */\n    this.vertices = new Float32Array(points.length * 4);\n\n    /*\n     * @member {Float32Array} The WebGL Uvs of the rope.\n     */\n    this.uvs = new Float32Array(points.length * 4);\n\n    /*\n     * @member {Float32Array} An array containing the color components\n     */\n    this.colors = new Float32Array(points.length * 2);\n\n    /*\n     * @member {Uint16Array} An array containing the indices of the vertices\n     */\n    this.indices = new Uint16Array(points.length * 2);\n\n    /**\n     * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can\n     * call _onTextureUpdated which could call refresh too early.\n     *\n     * @member {boolean}\n     * @private\n     */\n     this._ready = true;\n\n     this.refresh();\n}\n\n\n// constructor\nRope.prototype = Object.create(Mesh.prototype);\nRope.prototype.constructor = Rope;\nmodule.exports = Rope;\n\n/**\n * Refreshes\n *\n */\nRope.prototype.refresh = function ()\n{\n    var points = this.points;\n\n    // if too little points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1 || !this._texture._uvs)\n    {\n        return;\n    }\n\n    var uvs = this.uvs;\n\n    var indices = this.indices;\n    var colors = this.colors;\n\n    var textureUvs = this._texture._uvs;\n    var offset = new core.Point(textureUvs.x0, textureUvs.y0);\n    var factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);\n\n    uvs[0] = 0 + offset.x;\n    uvs[1] = 0 + offset.y;\n    uvs[2] = 0 + offset.x;\n    uvs[3] = 1 * factor.y + offset.y;\n\n    colors[0] = 1;\n    colors[1] = 1;\n\n    indices[0] = 0;\n    indices[1] = 1;\n\n    var total = points.length,\n        point, index, amount;\n\n    for (var i = 1; i < total; i++)\n    {\n        point = points[i];\n        index = i * 4;\n        // time to do some smart drawing!\n        amount = i / (total-1);\n\n        uvs[index] = amount * factor.x + offset.x;\n        uvs[index+1] = 0 + offset.y;\n\n        uvs[index+2] = amount * factor.x + offset.x;\n        uvs[index+3] = 1 * factor.y + offset.y;\n\n        index = i * 2;\n        colors[index] = 1;\n        colors[index+1] = 1;\n\n        index = i * 2;\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n    }\n\n    this.dirty = true;\n};\n\n/**\n * Clear texture UVs when new texture is set\n *\n * @private\n */\nRope.prototype._onTextureUpdate = function ()\n{\n    Mesh.prototype._onTextureUpdate.call(this);\n\n    // wait for the Rope ctor to finish before calling refresh\n    if (this._ready) {\n        this.refresh();\n    }\n};\n\n/**\n * Updates the object transform for rendering\n *\n * @private\n */\nRope.prototype.updateTransform = function ()\n{\n    var points = this.points;\n\n    if (points.length < 1)\n    {\n        return;\n    }\n\n    var lastPoint = points[0];\n    var nextPoint;\n    var perpX = 0;\n    var perpY = 0;\n\n    // this.count -= 0.2;\n\n    var vertices = this.vertices;\n    var total = points.length,\n        point, index, ratio, perpLength, num;\n\n    for (var i = 0; i < total; i++)\n    {\n        point = points[i];\n        index = i * 4;\n\n        if (i < points.length-1)\n        {\n            nextPoint = points[i+1];\n        }\n        else\n        {\n            nextPoint = point;\n        }\n\n        perpY = -(nextPoint.x - lastPoint.x);\n        perpX = nextPoint.y - lastPoint.y;\n\n        ratio = (1 - (i / (total-1))) * 10;\n\n        if (ratio > 1)\n        {\n            ratio = 1;\n        }\n\n        perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n        num = this._texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n        perpX /= perpLength;\n        perpY /= perpLength;\n\n        perpX *= num;\n        perpY *= num;\n\n        vertices[index] = point.x + perpX;\n        vertices[index+1] = point.y + perpY;\n        vertices[index+2] = point.x - perpX;\n        vertices[index+3] = point.y - perpY;\n\n        lastPoint = point;\n    }\n\n    this.containerUpdateTransform();\n};\n\n},{\"../core\":29,\"./Mesh\":125}],128:[function(require,module,exports){\n/**\n * @file        Main export of the PIXI extras library\n * @author      Mat Groves <mat@goodboydigital.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI.mesh\n */\nmodule.exports = {\n    Mesh:           require('./Mesh'),\n    Plane:           require('./Plane'),\n    Rope:           require('./Rope'),\n    MeshRenderer:   require('./webgl/MeshRenderer'),\n    MeshShader:     require('./webgl/MeshShader')\n};\n\n},{\"./Mesh\":125,\"./Plane\":126,\"./Rope\":127,\"./webgl/MeshRenderer\":129,\"./webgl/MeshShader\":130}],129:[function(require,module,exports){\nvar core = require('../../core'),\n    Mesh = require('../Mesh');\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's MeshRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/MeshRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI.mesh\n * @extends PIXI.ObjectRenderer\n * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction MeshRenderer(renderer)\n{\n    core.ObjectRenderer.call(this, renderer);\n\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    \n    this.indices = new Uint16Array(15000);\n\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n    for (var i=0, j=0; i < 15000; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    this.currentShader = null;\n}\n\nMeshRenderer.prototype = Object.create(core.ObjectRenderer.prototype);\nMeshRenderer.prototype.constructor = MeshRenderer;\nmodule.exports = MeshRenderer;\n\ncore.WebGLRenderer.registerPlugin('mesh', MeshRenderer);\n\n/**\n * Sets up the renderer context and necessary buffers.\n *\n * @private\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\n */\nMeshRenderer.prototype.onContextChange = function ()\n{\n\n};\n\n/**\n * Renders the sprite object.\n *\n * @param mesh {PIXI.mesh.Mesh} the mesh to render\n */\nMeshRenderer.prototype.render = function (mesh)\n{\n    if(!mesh._vertexBuffer)\n    {\n        this._initWebGL(mesh);\n    }\n\n    var renderer = this.renderer,\n        gl = renderer.gl,\n        texture = mesh._texture.baseTexture,\n        shader = mesh.shader;// || renderer.shaderManager.plugins.meshShader;\n\n    var drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;\n\n    renderer.blendModeManager.setBlendMode(mesh.blendMode);\n\n    //TODO cache custom state..\n    if (!shader)\n    {\n        shader = renderer.shaderManager.plugins.meshShader;\n    }\n    else\n    {\n        shader = shader.shaders[gl.id] || shader.getShader(renderer);// : shader;\n    }\n\n    this.renderer.shaderManager.setShader(shader);\n\n    shader.uniforms.translationMatrix.value = mesh.worldTransform.toArray(true);\n    shader.uniforms.projectionMatrix.value = renderer.currentRenderTarget.projectionMatrix.toArray(true);\n    shader.uniforms.alpha.value = mesh.worldAlpha;\n\n    shader.syncUniforms();\n\n    if (!mesh.dirty)\n    {\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, mesh.vertices);\n        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n        // update the uvs\n        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);\n        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n\n\n        gl.activeTexture(gl.TEXTURE0);\n\n       if (!texture._glTextures[gl.id])\n        {\n            this.renderer.updateTexture(texture);\n        }\n        else\n        {\n            // bind the current texture\n            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n        }\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);\n        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, mesh.indices);\n    }\n    else\n    {\n\n        mesh.dirty = false;\n        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n        // update the uvs\n        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n\n         gl.activeTexture(gl.TEXTURE0);\n\n        if (!texture._glTextures[gl.id])\n        {\n            this.renderer.updateTexture(texture);\n        }\n        else\n        {\n            // bind the current texture\n            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n        }\n\n        // dont need to upload!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);\n\n    }\n\n    gl.drawElements(drawMode, mesh.indices.length, gl.UNSIGNED_SHORT, 0);\n\n};\n\n/**\n * Prepares all the buffers to render this mesh\n * @param mesh {PIXI.mesh.Mesh} the mesh to render\n */\nMeshRenderer.prototype._initWebGL = function (mesh)\n{\n    // build the strip!\n    var gl = this.renderer.gl;\n\n    mesh._vertexBuffer = gl.createBuffer();\n    mesh._indexBuffer = gl.createBuffer();\n    mesh._uvBuffer = gl.createBuffer();\n\n\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.DYNAMIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER,  mesh.uvs, gl.STATIC_DRAW);\n\n    if(mesh.colors){\n        mesh._colorBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._colorBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.colors, gl.STATIC_DRAW);\n    }\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);\n};\n\n\n/**\n * Empties the current batch.\n *\n */\nMeshRenderer.prototype.flush = function ()\n{\n\n};\n\n/**\n * Starts a new mesh renderer.\n *\n */\nMeshRenderer.prototype.start = function ()\n{\n    \n\n    this.currentShader = null;\n};\n\n/**\n * Destroys the Mesh renderer\n *\n */\nMeshRenderer.prototype.destroy = function ()\n{\n    core.ObjectRenderer.prototype.destroy.call(this);\n};\n\n},{\"../../core\":29,\"../Mesh\":125}],130:[function(require,module,exports){\nvar core = require('../../core');\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.mesh\n * @param shaderManager {PIXI.ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction MeshShader(shaderManager)\n{\n    core.Shader.call(this,\n        shaderManager,\n        // vertex shader\n        [\n            'precision lowp float;',\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n\n            'uniform mat3 translationMatrix;',\n            'uniform mat3 projectionMatrix;',\n\n            'varying vec2 vTextureCoord;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vTextureCoord = aTextureCoord;',\n            '}'\n        ].join('\\n'),\n        [\n            'precision lowp float;',\n\n            'varying vec2 vTextureCoord;',\n            'uniform float alpha;',\n\n            'uniform sampler2D uSampler;',\n\n            'void main(void){',\n            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * alpha ;',\n            '}'\n        ].join('\\n'),\n        // custom uniforms\n        {\n            alpha:  { type: '1f', value: 0 },\n            translationMatrix: { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }\n        },\n        // custom attributes\n        {\n            aVertexPosition:0,\n            aTextureCoord:0\n        }\n    );\n}\n\nMeshShader.prototype = Object.create(core.Shader.prototype);\nMeshShader.prototype.constructor = MeshShader;\nmodule.exports = MeshShader;\n\ncore.ShaderManager.registerPlugin('meshShader', MeshShader);\n\n},{\"../../core\":29}],131:[function(require,module,exports){\n// References:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\nif (!Math.sign)\n{\n    Math.sign = function (x) {\n        x = +x;\n        if (x === 0 || isNaN(x))\n        {\n            return x;\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\n\n},{}],132:[function(require,module,exports){\n// References:\n// https://github.com/sindresorhus/object-assign\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\nif (!Object.assign)\n{\n    Object.assign = require('object-assign');\n}\n\n},{\"object-assign\":11}],133:[function(require,module,exports){\nrequire('./Object.assign');\nrequire('./requestAnimationFrame');\nrequire('./Math.sign');\n\n},{\"./Math.sign\":131,\"./Object.assign\":132,\"./requestAnimationFrame\":134}],134:[function(require,module,exports){\n(function (global){\n// References:\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// https://gist.github.com/1579671\n// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n// https://gist.github.com/timhall/4078614\n// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame\n\n// Expected to be used with Browserfiy\n// Browserify automatically detects the use of `global` and passes the\n// correct reference of `global`, `self`, and finally `window`\n\n// Date.now\nif (!(Date.now && Date.prototype.getTime)) {\n    Date.now = function now() {\n        return new Date().getTime();\n    };\n}\n\n// performance.now\nif (!(global.performance && global.performance.now)) {\n    var startTime = Date.now();\n    if (!global.performance) {\n        global.performance = {};\n    }\n    global.performance.now = function () {\n        return Date.now() - startTime;\n    };\n}\n\n// requestAnimationFrame\nvar lastTime = Date.now();\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\nfor(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {\n    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];\n    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||\n        global[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!global.requestAnimationFrame) {\n    global.requestAnimationFrame = function (callback) {\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + 'is not a function');\n        }\n\n        var currentTime = Date.now(),\n            delay = 16 + lastTime - currentTime;\n\n        if (delay < 0) {\n            delay = 0;\n        }\n\n        lastTime = currentTime;\n\n        return setTimeout(function () {\n            lastTime = Date.now();\n            callback(performance.now());\n        }, delay);\n    };\n}\n\nif (!global.cancelAnimationFrame) {\n    global.cancelAnimationFrame = function(id) {\n        clearTimeout(id);\n    };\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}]},{},[115])(115)\n});\n//# sourceMappingURL=pixi.js.map\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/pixi.dev.js"),
eval("// platform\r\n// provides various information about platform the game is running on\r\ndefine('services/platform',['jquery'], function ($) {\r\n\r\n    // current game mode\r\n    var currentMode = null;\r\n    // specifies if the mobile is handheld device\r\n    var isHandheld = null;\r\n    // available modes list\r\n    var modes = {\r\n        tablet: {\r\n            NAME: 'tablet',\r\n            IMAGE_BASE_URL: '/img/',\r\n        }\r\n    };\r\n\r\n    currentMode = modes.tablet;\r\n\r\n\r\n\r\n    var API = {\r\n        isMobile: getIsMobileOrTablet,\r\n        isVideoAvailable: isVideoAvailable,\r\n        getImageBaseUrl: getImageBaseUrl,\r\n        getMode: getMode,\r\n        isWinLineTextAllowed: isWinLineTextAllowed,\r\n        isSymbolAnimationAllowed: isSymbolAnimationAllowed,\r\n        isChrome: isChrome,\r\n        isIE: isIE,\r\n        is_iOS: is_iOS,\r\n        is_iPhone: is_iPhone,\r\n        isFirefox: isFirefox,\r\n        isWebmSupport: isWebmSupport,\r\n        isWebAudioAPISupport: isWebAudioAPISupport,\r\n        isOutdatedBrowser: isOutdatedBrowser,\r\n        isDesktopSafari: isDesktopSafari,\r\n    };\r\n\r\n    if (API.is_iPhone()) {\r\n        $('html').addClass('iphone');\r\n    }\r\n\r\n    return API;\r\n\r\n    // --- DETECTION FUNCTIONS ---\r\n\r\n    function isVideoAvailable() {\r\n        return false;\r\n    }\r\n    function getImageBaseUrl() {\r\n        return currentMode.IMAGE_BASE_URL;\r\n    }\r\n    function getMode() {\r\n        return currentMode.NAME;\r\n    }\r\n    function isWinLineTextAllowed() {\r\n        return true;\r\n    }\r\n    function isSymbolAnimationAllowed() {\r\n        return !(currentMode === modes.mobile || currentMode === modes.tablet);\r\n    }\r\n    function isWebmSupport() {\r\n        return (currentMode === modes.desktop && isChrome());\r\n    }\r\n    function isWebAudioAPISupport() {\r\n//        return false;\r\n        return true;\r\n//        return !isChrome() || getIsMobileOrTablet();\r\n    }\r\n\r\n    function isOutdatedBrowser() {\r\n        if ((window.attachEvent && !window.addEventListener)\r\n                || $('html').hasClass('lt-ie9')) {\r\n            // IE < 9\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getIsMobileOrTablet() {\r\n        if (isHandheld === null) {\r\n            var check = false;\r\n            (function (a) {\r\n                if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4)))\r\n                    check = true;\r\n            })(navigator.userAgent || navigator.vendor || window.opera);\r\n            isHandheld = check;\r\n        }\r\n        return isHandheld;\r\n    }\r\n\r\n    function isChrome() {\r\n        var check = false;\r\n        (function (a) {\r\n            if (/chrome/i.test(a))\r\n                check = true;\r\n        })(navigator.userAgent || navigator.vendor || window.opera);\r\n        return check;\r\n    }\r\n\r\n    function isDesktopSafari() {\r\n        if (!getIsMobileOrTablet()) {\r\n            var ua = navigator.userAgent.toLowerCase();\r\n            if (ua.indexOf('safari') != -1) {\r\n                if (ua.indexOf('chrome') == -1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function is_iOS() {\r\n        if (navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function is_iPhone() {\r\n        if (navigator.userAgent.match(/iPhone/i) && !navigator.userAgent.match(/like iPhone/i)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isFirefox() {\r\n        var check = false;\r\n        (function (a) {\r\n            if (/firefox/i.test(a))\r\n                check = true;\r\n        })(navigator.userAgent || navigator.vendor || window.opera);\r\n        return check;\r\n    }\r\n\r\n    function isIE() {\r\n        var ua = window.navigator.userAgent;\r\n\r\n        var msie = ua.indexOf('MSIE ');\r\n        if (msie > 0) {\r\n            // IE 10 or older => return version number\r\n//            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n            return true;\r\n        }\r\n\r\n        var trident = ua.indexOf('Trident/');\r\n        if (trident > 0) {\r\n            // IE 11 => return version number\r\n            var rv = ua.indexOf('rv:');\r\n//            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n            return true;\r\n        }\r\n\r\n        var edge = ua.indexOf('Edge/');\r\n        if (edge > 0) {\r\n            // IE 12 => return version number\r\n//            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n            return true;\r\n        }\r\n\r\n        // other browser\r\n        return false;\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/platform.js"),eval("// pause\r\n// controls timeouts and intervals\r\n// with regard to config.GAME_SPEED_MODIFIER\r\ndefine('services/pause',[], function () {\r\n\r\n    var map = {};\r\n    var nextId = 0;\r\n    var liveIds = [];\r\n    var removeIds = [];\r\n    window.liveIds = liveIds;\r\n    window.map = map;\r\n\r\n    function mUpdate(delta) {\r\n\r\n        var i, k, id, len, t;\r\n\r\n        for (i = 0, len = removeIds.length; i < len; i++) {\r\n            id = removeIds[i];\r\n            k = liveIds.indexOf(id);\r\n            if (k > -1) {\r\n                liveIds.splice(k, 1);\r\n                delete map[id];\r\n            }\r\n        }\r\n        removeIds = [];\r\n\r\n        for (i = 0, len = liveIds.length; i < len; i++) {\r\n            id = liveIds[i];\r\n            if (removeIds.indexOf(id) === -1) {\r\n                t = map[id];\r\n                t.time -= delta;\r\n                if (t.time <= 0) {\r\n                    t.func();\r\n                    if (t.sec) {\r\n                        // interval\r\n                        t.time += t.sec;\r\n                        while (t.time <= 0) {\r\n                            t.func();\r\n                            t.time += t.sec;\r\n                        }\r\n                    } else {\r\n                        // timeout\r\n                        removeIds.push(id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function mSetTimeout(func, tout) {\r\n        var t = {\r\n            id: nextId++,\r\n            time: tout / 1000,\r\n            func: func\r\n        };\r\n        map[t.id] = t;\r\n        liveIds.push(t.id);\r\n        return t.id;\r\n\r\n//        return setTimeout(func, tout / config.GAME_SPEED_MODIFIER);\r\n    }\r\n    function mSetInterval(func, tout) {\r\n        var t = {\r\n            id: nextId++,\r\n            time: tout / 1000,\r\n            sec: tout / 1000,\r\n            func: func\r\n        };\r\n        map[t.id] = t;\r\n        liveIds.push(t.id);\r\n        return t.id;\r\n\r\n//        return setInterval(func, tout / config.GAME_SPEED_MODIFIER);\r\n    }\r\n    function mClearTimeout(id) {\r\n        if (liveIds.indexOf(id) > -1) {\r\n            removeIds.push(id);\r\n            return true;\r\n        }\r\n        return false;\r\n\r\n//        if (id) {\r\n//            clearTimeout(id);\r\n//        }\r\n    }\r\n    function mClearInterval(id) {\r\n        if (liveIds.indexOf(id) > -1) {\r\n            removeIds.push(id);\r\n            return true;\r\n        }\r\n        return false;\r\n\r\n//        if (id) {\r\n//            clearInterval(id);\r\n//        }\r\n    }\r\n// helpers\r\n    var API = {\r\n        update: mUpdate,\r\n        setTimeout: mSetTimeout,\r\n        setInterval: mSetInterval,\r\n        clearTimeout: mClearTimeout,\r\n        clearInterval: mClearInterval\r\n    };\r\n    return API;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/pause.js"),eval('/*!\r\n* @license TweenJS\r\n* Visit http://createjs.com/ for documentation, updates and examples.\r\n*\r\n* Copyright (c) 2011-2015 gskinner.com, inc.\r\n*\r\n* Distributed under the terms of the MIT license.\r\n* http://www.opensource.org/licenses/mit-license.html\r\n*\r\n* This notice shall be included in all copies or substantial portions of the Software.\r\n*/\r\nthis.createjs=this.createjs||{},createjs.extend=function(a,b){"use strict";function c(){this.constructor=a}return c.prototype=b.prototype,a.prototype=new c},this.createjs=this.createjs||{},createjs.promote=function(a,b){"use strict";var c=a.prototype,d=Object.getPrototypeOf&&Object.getPrototypeOf(c)||c.__proto__;if(d){c[(b+="_")+"constructor"]=d.constructor;for(var e in d)c.hasOwnProperty(e)&&"function"==typeof d[e]&&(c[b+e]=d[e])}return a},this.createjs=this.createjs||{},function(){"use strict";function Event(a,b,c){this.type=a,this.target=null,this.currentTarget=null,this.eventPhase=0,this.bubbles=!!b,this.cancelable=!!c,this.timeStamp=(new Date).getTime(),this.defaultPrevented=!1,this.propagationStopped=!1,this.immediatePropagationStopped=!1,this.removed=!1}var a=Event.prototype;a.preventDefault=function(){this.defaultPrevented=this.cancelable&&!0},a.stopPropagation=function(){this.propagationStopped=!0},a.stopImmediatePropagation=function(){this.immediatePropagationStopped=this.propagationStopped=!0},a.remove=function(){this.removed=!0},a.clone=function(){return new Event(this.type,this.bubbles,this.cancelable)},a.set=function(a){for(var b in a)this[b]=a[b];return this},a.toString=function(){return"[Event (type="+this.type+")]"},createjs.Event=Event}(),this.createjs=this.createjs||{},function(){"use strict";function EventDispatcher(){this._listeners=null,this._captureListeners=null}var a=EventDispatcher.prototype;EventDispatcher.initialize=function(b){b.addEventListener=a.addEventListener,b.on=a.on,b.removeEventListener=b.off=a.removeEventListener,b.removeAllEventListeners=a.removeAllEventListeners,b.hasEventListener=a.hasEventListener,b.dispatchEvent=a.dispatchEvent,b._dispatchEvent=a._dispatchEvent,b.willTrigger=a.willTrigger},a.addEventListener=function(a,b,c){var d;d=c?this._captureListeners=this._captureListeners||{}:this._listeners=this._listeners||{};var e=d[a];return e&&this.removeEventListener(a,b,c),e=d[a],e?e.push(b):d[a]=[b],b},a.on=function(a,b,c,d,e,f){return b.handleEvent&&(c=c||b,b=b.handleEvent),c=c||this,this.addEventListener(a,function(a){b.call(c,a,e),d&&a.remove()},f)},a.removeEventListener=function(a,b,c){var d=c?this._captureListeners:this._listeners;if(d){var e=d[a];if(e)for(var f=0,g=e.length;g>f;f++)if(e[f]==b){1==g?delete d[a]:e.splice(f,1);break}}},a.off=a.removeEventListener,a.removeAllEventListeners=function(a){a?(this._listeners&&delete this._listeners[a],this._captureListeners&&delete this._captureListeners[a]):this._listeners=this._captureListeners=null},a.dispatchEvent=function(a,b,c){if("string"==typeof a){var d=this._listeners;if(!(b||d&&d[a]))return!0;a=new createjs.Event(a,b,c)}else a.target&&a.clone&&(a=a.clone());try{a.target=this}catch(e){}if(a.bubbles&&this.parent){for(var f=this,g=[f];f.parent;)g.push(f=f.parent);var h,i=g.length;for(h=i-1;h>=0&&!a.propagationStopped;h--)g[h]._dispatchEvent(a,1+(0==h));for(h=1;i>h&&!a.propagationStopped;h++)g[h]._dispatchEvent(a,3)}else this._dispatchEvent(a,2);return!a.defaultPrevented},a.hasEventListener=function(a){var b=this._listeners,c=this._captureListeners;return!!(b&&b[a]||c&&c[a])},a.willTrigger=function(a){for(var b=this;b;){if(b.hasEventListener(a))return!0;b=b.parent}return!1},a.toString=function(){return"[EventDispatcher]"},a._dispatchEvent=function(a,b){var c,d=1==b?this._captureListeners:this._listeners;if(a&&d){var e=d[a.type];if(!e||!(c=e.length))return;try{a.currentTarget=this}catch(f){}try{a.eventPhase=b}catch(f){}a.removed=!1,e=e.slice();for(var g=0;c>g&&!a.immediatePropagationStopped;g++){var h=e[g];h.handleEvent?h.handleEvent(a):h(a),a.removed&&(this.off(a.type,h,1==b),a.removed=!1)}}},createjs.EventDispatcher=EventDispatcher}(),this.createjs=this.createjs||{},function(){"use strict";function Ticker(){throw"Ticker cannot be instantiated."}Ticker.RAF_SYNCHED="synched",Ticker.RAF="raf",Ticker.TIMEOUT="timeout",Ticker.useRAF=!1,Ticker.timingMode=null,Ticker.maxDelta=0,Ticker.paused=!1,Ticker.removeEventListener=null,Ticker.removeAllEventListeners=null,Ticker.dispatchEvent=null,Ticker.hasEventListener=null,Ticker._listeners=null,createjs.EventDispatcher.initialize(Ticker),Ticker._addEventListener=Ticker.addEventListener,Ticker.addEventListener=function(){return!Ticker._inited&&Ticker.init(),Ticker._addEventListener.apply(Ticker,arguments)},Ticker._inited=!1,Ticker._startTime=0,Ticker._pausedTime=0,Ticker._ticks=0,Ticker._pausedTicks=0,Ticker._interval=50,Ticker._lastTime=0,Ticker._times=null,Ticker._tickTimes=null,Ticker._timerId=null,Ticker._raf=!0,Ticker.setInterval=function(a){Ticker._interval=a,Ticker._inited&&Ticker._setupTick()},Ticker.getInterval=function(){return Ticker._interval},Ticker.setFPS=function(a){Ticker.setInterval(1e3/a)},Ticker.getFPS=function(){return 1e3/Ticker._interval};try{Object.defineProperties(Ticker,{interval:{get:Ticker.getInterval,set:Ticker.setInterval},framerate:{get:Ticker.getFPS,set:Ticker.setFPS}})}catch(a){console.log(a)}Ticker.init=function(){Ticker._inited||(Ticker._inited=!0,Ticker._times=[],Ticker._tickTimes=[],Ticker._startTime=Ticker._getTime(),Ticker._times.push(Ticker._lastTime=0),Ticker.interval=Ticker._interval)},Ticker.reset=function(){if(Ticker._raf){var a=window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame;a&&a(Ticker._timerId)}else clearTimeout(Ticker._timerId);Ticker.removeAllEventListeners("tick"),Ticker._timerId=Ticker._times=Ticker._tickTimes=null,Ticker._startTime=Ticker._lastTime=Ticker._ticks=0,Ticker._inited=!1},Ticker.getMeasuredTickTime=function(a){var b=0,c=Ticker._tickTimes;if(!c||c.length<1)return-1;a=Math.min(c.length,a||0|Ticker.getFPS());for(var d=0;a>d;d++)b+=c[d];return b/a},Ticker.getMeasuredFPS=function(a){var b=Ticker._times;return!b||b.length<2?-1:(a=Math.min(b.length-1,a||0|Ticker.getFPS()),1e3/((b[0]-b[a])/a))},Ticker.setPaused=function(a){Ticker.paused=a},Ticker.getPaused=function(){return Ticker.paused},Ticker.getTime=function(a){return Ticker._startTime?Ticker._getTime()-(a?Ticker._pausedTime:0):-1},Ticker.getEventTime=function(a){return Ticker._startTime?(Ticker._lastTime||Ticker._startTime)-(a?Ticker._pausedTime:0):-1},Ticker.getTicks=function(a){return Ticker._ticks-(a?Ticker._pausedTicks:0)},Ticker._handleSynch=function(){Ticker._timerId=null,Ticker._setupTick(),Ticker._getTime()-Ticker._lastTime>=.97*(Ticker._interval-1)&&Ticker._tick()},Ticker._handleRAF=function(){Ticker._timerId=null,Ticker._setupTick(),Ticker._tick()},Ticker._handleTimeout=function(){Ticker._timerId=null,Ticker._setupTick(),Ticker._tick()},Ticker._setupTick=function(){if(null==Ticker._timerId){var a=Ticker.timingMode||Ticker.useRAF&&Ticker.RAF_SYNCHED;if(a==Ticker.RAF_SYNCHED||a==Ticker.RAF){var b=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame;if(b)return Ticker._timerId=b(a==Ticker.RAF?Ticker._handleRAF:Ticker._handleSynch),void(Ticker._raf=!0)}Ticker._raf=!1,Ticker._timerId=setTimeout(Ticker._handleTimeout,Ticker._interval)}},Ticker._tick=function(){var a=Ticker.paused,b=Ticker._getTime(),c=b-Ticker._lastTime;if(Ticker._lastTime=b,Ticker._ticks++,a&&(Ticker._pausedTicks++,Ticker._pausedTime+=c),Ticker.hasEventListener("tick")){var d=new createjs.Event("tick"),e=Ticker.maxDelta;d.delta=e&&c>e?e:c,d.paused=a,d.time=b,d.runTime=b-Ticker._pausedTime,Ticker.dispatchEvent(d)}for(Ticker._tickTimes.unshift(Ticker._getTime()-b);Ticker._tickTimes.length>100;)Ticker._tickTimes.pop();for(Ticker._times.unshift(b);Ticker._times.length>100;)Ticker._times.pop()};var b=window.performance&&(performance.now||performance.mozNow||performance.msNow||performance.oNow||performance.webkitNow);Ticker._getTime=function(){return(b&&b.call(performance)||(new Date).getTime())-Ticker._startTime},createjs.Ticker=Ticker}(),this.createjs=this.createjs||{},function(){"use strict";function Tween(a,b,c){this.ignoreGlobalPause=!1,this.loop=!1,this.duration=0,this.pluginData=c||{},this.target=a,this.position=null,this.passive=!1,this._paused=!1,this._curQueueProps={},this._initQueueProps={},this._steps=[],this._actions=[],this._prevPosition=0,this._stepPosition=0,this._prevPos=-1,this._target=a,this._useTicks=!1,this._inited=!1,this._registered=!1,b&&(this._useTicks=b.useTicks,this.ignoreGlobalPause=b.ignoreGlobalPause,this.loop=b.loop,b.onChange&&this.addEventListener("change",b.onChange),b.override&&Tween.removeTweens(a)),b&&b.paused?this._paused=!0:createjs.Tween._register(this,!0),b&&null!=b.position&&this.setPosition(b.position,Tween.NONE)}var a=createjs.extend(Tween,createjs.EventDispatcher);Tween.NONE=0,Tween.LOOP=1,Tween.REVERSE=2,Tween.IGNORE={},Tween._tweens=[],Tween._plugins={},Tween.get=function(a,b,c,d){return d&&Tween.removeTweens(a),new Tween(a,b,c)},Tween.tick=function(a,b){for(var c=Tween._tweens.slice(),d=c.length-1;d>=0;d--){var e=c[d];b&&!e.ignoreGlobalPause||e._paused||e.tick(e._useTicks?1:a)}},Tween.handleEvent=function(a){"tick"==a.type&&this.tick(a.delta,a.paused)},Tween.removeTweens=function(a){if(a.tweenjs_count){for(var b=Tween._tweens,c=b.length-1;c>=0;c--){var d=b[c];d._target==a&&(d._paused=!0,b.splice(c,1))}a.tweenjs_count=0}},Tween.removeAllTweens=function(){for(var a=Tween._tweens,b=0,c=a.length;c>b;b++){var d=a[b];d._paused=!0,d.target&&(d.target.tweenjs_count=0)}a.length=0},Tween.hasActiveTweens=function(a){return a?null!=a.tweenjs_count&&!!a.tweenjs_count:Tween._tweens&&!!Tween._tweens.length},Tween.installPlugin=function(a,b){var c=a.priority;null==c&&(a.priority=c=0);for(var d=0,e=b.length,f=Tween._plugins;e>d;d++){var g=b[d];if(f[g]){for(var h=f[g],i=0,j=h.length;j>i&&!(c<h[i].priority);i++);f[g].splice(i,0,a)}else f[g]=[a]}},Tween._register=function(a,b){var c=a._target,d=Tween._tweens;if(b&&!a._registered)c&&(c.tweenjs_count=c.tweenjs_count?c.tweenjs_count+1:1),d.push(a),!Tween._inited&&createjs.Ticker&&(createjs.Ticker.addEventListener("tick",Tween),Tween._inited=!0);else if(!b&&a._registered){c&&c.tweenjs_count--;for(var e=d.length;e--;)if(d[e]==a){d.splice(e,1);break}}a._registered=b},a.wait=function(a,b){if(null==a||0>=a)return this;var c=this._cloneProps(this._curQueueProps);return this._addStep({d:a,p0:c,e:this._linearEase,p1:c,v:b})},a.to=function(a,b,c){return(isNaN(b)||0>b)&&(b=0),this._addStep({d:b||0,p0:this._cloneProps(this._curQueueProps),e:c,p1:this._cloneProps(this._appendQueueProps(a))})},a.call=function(a,b,c){return this._addAction({f:a,p:b?b:[this],o:c?c:this._target})},a.set=function(a,b){return this._addAction({f:this._set,o:this,p:[a,b?b:this._target]})},a.play=function(a){return a||(a=this),this.call(a.setPaused,[!1],a)},a.pause=function(a){return a||(a=this),this.call(a.setPaused,[!0],a)},a.setPosition=function(a,b){0>a&&(a=0),null==b&&(b=1);var c=a,d=!1;if(c>=this.duration&&(this.loop?c%=this.duration:(c=this.duration,d=!0)),c==this._prevPos)return d;var e=this._prevPos;if(this.position=this._prevPos=c,this._prevPosition=a,this._target)if(d)this._updateTargetProps(null,1);else if(this._steps.length>0){for(var f=0,g=this._steps.length;g>f&&!(this._steps[f].t>c);f++);var h=this._steps[f-1];this._updateTargetProps(h,(this._stepPosition=c-h.t)/h.d)}return 0!=b&&this._actions.length>0&&(this._useTicks?this._runActions(c,c):1==b&&e>c?(e!=this.duration&&this._runActions(e,this.duration),this._runActions(0,c,!0)):this._runActions(e,c)),d&&this.setPaused(!0),this.dispatchEvent("change"),d},a.tick=function(a){this._paused||this.setPosition(this._prevPosition+a)},a.setPaused=function(a){return this._paused===!!a?this:(this._paused=!!a,Tween._register(this,!a),this)},a.w=a.wait,a.t=a.to,a.c=a.call,a.s=a.set,a.toString=function(){return"[Tween]"},a.clone=function(){throw"Tween can not be cloned."},a._updateTargetProps=function(a,b){var c,d,e,f,g,h;if(a||1!=b){if(this.passive=!!a.v,this.passive)return;a.e&&(b=a.e(b,0,1,1)),c=a.p0,d=a.p1}else this.passive=!1,c=d=this._curQueueProps;for(var i in this._initQueueProps){null==(f=c[i])&&(c[i]=f=this._initQueueProps[i]),null==(g=d[i])&&(d[i]=g=f),e=f==g||0==b||1==b||"number"!=typeof f?1==b?g:f:f+(g-f)*b;var j=!1;if(h=Tween._plugins[i])for(var k=0,l=h.length;l>k;k++){var m=h[k].tween(this,i,e,c,d,b,!!a&&c==d,!a);m==Tween.IGNORE?j=!0:e=m}j||(this._target[i]=e)}},a._runActions=function(a,b,c){var d=a,e=b,f=-1,g=this._actions.length,h=1;for(a>b&&(d=b,e=a,f=g,g=h=-1);(f+=h)!=g;){var i=this._actions[f],j=i.t;(j==e||j>d&&e>j||c&&j==a)&&i.f.apply(i.o,i.p)}},a._appendQueueProps=function(a){var b,c,d,e,f;for(var g in a)if(void 0===this._initQueueProps[g]){if(c=this._target[g],b=Tween._plugins[g])for(d=0,e=b.length;e>d;d++)c=b[d].init(this,g,c);this._initQueueProps[g]=this._curQueueProps[g]=void 0===c?null:c}else c=this._curQueueProps[g];for(var g in a){if(c=this._curQueueProps[g],b=Tween._plugins[g])for(f=f||{},d=0,e=b.length;e>d;d++)b[d].step&&b[d].step(this,g,c,a[g],f);this._curQueueProps[g]=a[g]}return f&&this._appendQueueProps(f),this._curQueueProps},a._cloneProps=function(a){var b={};for(var c in a)b[c]=a[c];return b},a._addStep=function(a){return a.d>0&&(this._steps.push(a),a.t=this.duration,this.duration+=a.d),this},a._addAction=function(a){return a.t=this.duration,this._actions.push(a),this},a._set=function(a,b){for(var c in a)b[c]=a[c]},createjs.Tween=createjs.promote(Tween,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function Timeline(a,b,c){this.EventDispatcher_constructor(),this.ignoreGlobalPause=!1,this.duration=0,this.loop=!1,this.position=null,this._paused=!1,this._tweens=[],this._labels=null,this._labelList=null,this._prevPosition=0,this._prevPos=-1,this._useTicks=!1,this._registered=!1,c&&(this._useTicks=c.useTicks,this.loop=c.loop,this.ignoreGlobalPause=c.ignoreGlobalPause,c.onChange&&this.addEventListener("change",c.onChange)),a&&this.addTween.apply(this,a),this.setLabels(b),c&&c.paused?this._paused=!0:createjs.Tween._register(this,!0),c&&null!=c.position&&this.setPosition(c.position,createjs.Tween.NONE)}var a=createjs.extend(Timeline,createjs.EventDispatcher);a.addTween=function(a){var b=arguments.length;if(b>1){for(var c=0;b>c;c++)this.addTween(arguments[c]);return arguments[0]}return 0==b?null:(this.removeTween(a),this._tweens.push(a),a.setPaused(!0),a._paused=!1,a._useTicks=this._useTicks,a.duration>this.duration&&(this.duration=a.duration),this._prevPos>=0&&a.setPosition(this._prevPos,createjs.Tween.NONE),a)},a.removeTween=function(a){var b=arguments.length;if(b>1){for(var c=!0,d=0;b>d;d++)c=c&&this.removeTween(arguments[d]);return c}if(0==b)return!1;for(var e=this._tweens,d=e.length;d--;)if(e[d]==a)return e.splice(d,1),a.duration>=this.duration&&this.updateDuration(),!0;return!1},a.addLabel=function(a,b){this._labels[a]=b;var c=this._labelList;if(c){for(var d=0,e=c.length;e>d&&!(b<c[d].position);d++);c.splice(d,0,{label:a,position:b})}},a.setLabels=function(a){this._labels=a?a:{}},a.getLabels=function(){var a=this._labelList;if(!a){a=this._labelList=[];var b=this._labels;for(var c in b)a.push({label:c,position:b[c]});a.sort(function(a,b){return a.position-b.position})}return a},a.getCurrentLabel=function(){var a=this.getLabels(),b=this.position,c=a.length;if(c){for(var d=0;c>d&&!(b<a[d].position);d++);return 0==d?null:a[d-1].label}return null},a.gotoAndPlay=function(a){this.setPaused(!1),this._goto(a)},a.gotoAndStop=function(a){this.setPaused(!0),this._goto(a)},a.setPosition=function(a,b){var c=this._calcPosition(a),d=!this.loop&&a>=this.duration;if(c==this._prevPos)return d;this._prevPosition=a,this.position=this._prevPos=c;for(var e=0,f=this._tweens.length;f>e;e++)if(this._tweens[e].setPosition(c,b),c!=this._prevPos)return!1;return d&&this.setPaused(!0),this.dispatchEvent("change"),d},a.setPaused=function(a){this._paused=!!a,createjs.Tween._register(this,!a)},a.updateDuration=function(){this.duration=0;for(var a=0,b=this._tweens.length;b>a;a++){var c=this._tweens[a];c.duration>this.duration&&(this.duration=c.duration)}},a.tick=function(a){this.setPosition(this._prevPosition+a)},a.resolve=function(a){var b=Number(a);return isNaN(b)&&(b=this._labels[a]),b},a.toString=function(){return"[Timeline]"},a.clone=function(){throw"Timeline can not be cloned."},a._goto=function(a){var b=this.resolve(a);null!=b&&this.setPosition(b)},a._calcPosition=function(a){return 0>a?0:a<this.duration?a:this.loop?a%this.duration:this.duration},createjs.Timeline=createjs.promote(Timeline,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function Ease(){throw"Ease cannot be instantiated."}Ease.linear=function(a){return a},Ease.none=Ease.linear,Ease.get=function(a){return-1>a&&(a=-1),a>1&&(a=1),function(b){return 0==a?b:0>a?b*(b*-a+1+a):b*((2-b)*a+(1-a))}},Ease.getPowIn=function(a){return function(b){return Math.pow(b,a)}},Ease.getPowOut=function(a){return function(b){return 1-Math.pow(1-b,a)}},Ease.getPowInOut=function(a){return function(b){return(b*=2)<1?.5*Math.pow(b,a):1-.5*Math.abs(Math.pow(2-b,a))}},Ease.quadIn=Ease.getPowIn(2),Ease.quadOut=Ease.getPowOut(2),Ease.quadInOut=Ease.getPowInOut(2),Ease.cubicIn=Ease.getPowIn(3),Ease.cubicOut=Ease.getPowOut(3),Ease.cubicInOut=Ease.getPowInOut(3),Ease.quartIn=Ease.getPowIn(4),Ease.quartOut=Ease.getPowOut(4),Ease.quartInOut=Ease.getPowInOut(4),Ease.quintIn=Ease.getPowIn(5),Ease.quintOut=Ease.getPowOut(5),Ease.quintInOut=Ease.getPowInOut(5),Ease.sineIn=function(a){return 1-Math.cos(a*Math.PI/2)},Ease.sineOut=function(a){return Math.sin(a*Math.PI/2)},Ease.sineInOut=function(a){return-.5*(Math.cos(Math.PI*a)-1)},Ease.getBackIn=function(a){return function(b){return b*b*((a+1)*b-a)}},Ease.backIn=Ease.getBackIn(1.7),Ease.getBackOut=function(a){return function(b){return--b*b*((a+1)*b+a)+1}},Ease.backOut=Ease.getBackOut(1.7),Ease.getBackInOut=function(a){return a*=1.525,function(b){return(b*=2)<1?.5*b*b*((a+1)*b-a):.5*((b-=2)*b*((a+1)*b+a)+2)}},Ease.backInOut=Ease.getBackInOut(1.7),Ease.circIn=function(a){return-(Math.sqrt(1-a*a)-1)},Ease.circOut=function(a){return Math.sqrt(1- --a*a)},Ease.circInOut=function(a){return(a*=2)<1?-.5*(Math.sqrt(1-a*a)-1):.5*(Math.sqrt(1-(a-=2)*a)+1)},Ease.bounceIn=function(a){return 1-Ease.bounceOut(1-a)},Ease.bounceOut=function(a){return 1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375},Ease.bounceInOut=function(a){return.5>a?.5*Ease.bounceIn(2*a):.5*Ease.bounceOut(2*a-1)+.5},Ease.getElasticIn=function(a,b){var c=2*Math.PI;return function(d){if(0==d||1==d)return d;var e=b/c*Math.asin(1/a);return-(a*Math.pow(2,10*(d-=1))*Math.sin((d-e)*c/b))}},Ease.elasticIn=Ease.getElasticIn(1,.3),Ease.getElasticOut=function(a,b){var c=2*Math.PI;return function(d){if(0==d||1==d)return d;var e=b/c*Math.asin(1/a);return a*Math.pow(2,-10*d)*Math.sin((d-e)*c/b)+1}},Ease.elasticOut=Ease.getElasticOut(1,.3),Ease.getElasticInOut=function(a,b){var c=2*Math.PI;return function(d){var e=b/c*Math.asin(1/a);return(d*=2)<1?-.5*a*Math.pow(2,10*(d-=1))*Math.sin((d-e)*c/b):a*Math.pow(2,-10*(d-=1))*Math.sin((d-e)*c/b)*.5+1}},Ease.elasticInOut=Ease.getElasticInOut(1,.3*1.5),createjs.Ease=Ease}(),this.createjs=this.createjs||{},function(){"use strict";function MotionGuidePlugin(){throw"MotionGuidePlugin cannot be instantiated."}MotionGuidePlugin.priority=0,MotionGuidePlugin._rotOffS,MotionGuidePlugin._rotOffE,MotionGuidePlugin._rotNormS,MotionGuidePlugin._rotNormE,MotionGuidePlugin.install=function(){return createjs.Tween.installPlugin(MotionGuidePlugin,["guide","x","y","rotation"]),createjs.Tween.IGNORE},MotionGuidePlugin.init=function(a,b,c){var d=a.target;return d.hasOwnProperty("x")||(d.x=0),d.hasOwnProperty("y")||(d.y=0),d.hasOwnProperty("rotation")||(d.rotation=0),"rotation"==b&&(a.__needsRot=!0),"guide"==b?null:c},MotionGuidePlugin.step=function(a,b,c,d,e){if("rotation"==b&&(a.__rotGlobalS=c,a.__rotGlobalE=d,MotionGuidePlugin.testRotData(a,e)),"guide"!=b)return d;var f,g=d;g.hasOwnProperty("path")||(g.path=[]);var h=g.path;if(g.hasOwnProperty("end")||(g.end=1),g.hasOwnProperty("start")||(g.start=c&&c.hasOwnProperty("end")&&c.path===h?c.end:0),g.hasOwnProperty("_segments")&&g._length)return d;var i=h.length,j=10;if(!(i>=6&&(i-2)%4==0))throw"invalid \'path\' data, please see documentation for valid paths";g._segments=[],g._length=0;for(var k=2;i>k;k+=4){for(var l,m,n=h[k-2],o=h[k-1],p=h[k+0],q=h[k+1],r=h[k+2],s=h[k+3],t=n,u=o,v=0,w=[],x=1;j>=x;x++){var y=x/j,z=1-y;l=z*z*n+2*z*y*p+y*y*r,m=z*z*o+2*z*y*q+y*y*s,v+=w[w.push(Math.sqrt((f=l-t)*f+(f=m-u)*f))-1],t=l,u=m}g._segments.push(v),g._segments.push(w),g._length+=v}f=g.orient,g.orient=!0;var A={};return MotionGuidePlugin.calc(g,g.start,A),a.__rotPathS=Number(A.rotation.toFixed(5)),MotionGuidePlugin.calc(g,g.end,A),a.__rotPathE=Number(A.rotation.toFixed(5)),g.orient=!1,MotionGuidePlugin.calc(g,g.end,e),g.orient=f,g.orient?(a.__guideData=g,MotionGuidePlugin.testRotData(a,e),d):d},MotionGuidePlugin.testRotData=function(a,b){if(void 0===a.__rotGlobalS||void 0===a.__rotGlobalE){if(a.__needsRot)return;a.__rotGlobalS=a.__rotGlobalE=void 0!==a._curQueueProps.rotation?a._curQueueProps.rotation:b.rotation=a.target.rotation||0}if(void 0!==a.__guideData){var c=a.__guideData,d=a.__rotGlobalE-a.__rotGlobalS,e=a.__rotPathE-a.__rotPathS,f=d-e;if("auto"==c.orient)f>180?f-=360:-180>f&&(f+=360);else if("cw"==c.orient){for(;0>f;)f+=360;0==f&&d>0&&180!=d&&(f+=360)}else if("ccw"==c.orient){for(f=d-(e>180?360-e:e);f>0;)f-=360;0==f&&0>d&&-180!=d&&(f-=360)}c.rotDelta=f,c.rotOffS=a.__rotGlobalS-a.__rotPathS,a.__rotGlobalS=a.__rotGlobalE=a.__guideData=a.__needsRot=void 0}},MotionGuidePlugin.tween=function(a,b,c,d,e,f,g){var h=e.guide;if(void 0==h||h===d.guide)return c;if(h.lastRatio!=f){var i=(h.end-h.start)*(g?h.end:f)+h.start;switch(MotionGuidePlugin.calc(h,i,a.target),h.orient){case"cw":case"ccw":case"auto":a.target.rotation+=h.rotOffS+h.rotDelta*f;break;case"fixed":default:a.target.rotation+=h.rotOffS}h.lastRatio=f}return"rotation"!=b||h.orient&&"false"!=h.orient?a.target[b]:c},MotionGuidePlugin.calc=function(a,b,c){if(void 0==a._segments)throw"Missing critical pre-calculated information, please file a bug";void 0==c&&(c={x:0,y:0,rotation:0});for(var d=a._segments,e=a.path,f=a._length*b,g=d.length-2,h=0;f>d[h]&&g>h;)f-=d[h],h+=2;var i=d[h+1],j=0;for(g=i.length-1;f>i[j]&&g>j;)f-=i[j],j++;var k=j/++g+f/(g*i[j]);h=2*h+2;var l=1-k;return c.x=l*l*e[h-2]+2*l*k*e[h+0]+k*k*e[h+2],c.y=l*l*e[h-1]+2*l*k*e[h+1]+k*k*e[h+3],a.orient&&(c.rotation=57.2957795*Math.atan2((e[h+1]-e[h-1])*l+(e[h+3]-e[h+1])*k,(e[h+0]-e[h-2])*l+(e[h+2]-e[h+0])*k)),c},createjs.MotionGuidePlugin=MotionGuidePlugin}(),this.createjs=this.createjs||{},function(){"use strict";var a=createjs.TweenJS=createjs.TweenJS||{};a.version="0.6.2",a.buildDate="Thu, 26 Nov 2015 20:44:31 GMT"}();\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/tweenjs-0.6.2.min.js'),
define("tweenjs",function(n){return function(){var e;return e||n.createjs}}(this)),eval("// engine service\r\n// initializes individual canvases (PIXI Renderer)\r\n// and their top level containers \r\n// handles periodical world update cycles\r\n// handles animation frame callbacks\r\ndefine('services/engine',[\r\n    'jquery',\r\n    'pubsub',\r\n    'pixi',\r\n    'services/platform',\r\n    'services/pause',\r\n    'data/config',\r\n    'tweenjs',\r\n], function ($, pubsub, PIXI, platform, pause, globalConfig, createjs) {\r\n\r\n// define vars\r\n    var layers = [\r\n        // reels\r\n        'back',\r\n        // non-interactive stuff\r\n        'top',\r\n        // interactive stuff\r\n        'ui',\r\n        // overlay\r\n        'over',\r\n    ];\r\n    var world = {};\r\n    var running = null;\r\n    var windowFocused = true;\r\n    var overlaysVisible = [];\r\n\r\n    // API\r\n    return {\r\n        initialize: mInitialize,\r\n        startFrames: mStartFrames,\r\n        getRenderer: mGetRenderer,\r\n        getContainer: mGetContainer,\r\n        getContainers: mGetContainers,\r\n        getRenderers: mGetRenderers,\r\n    };\r\n    // init\r\n    function mInitialize() {\r\n        function bindFullScreenClick() {\r\n            world.ui.container.click = world.ui.container.tap = function () {\r\n                pubsub.publish('request:setFullScreen', {\r\n                    fullScreen: true\r\n                });\r\n            };\r\n            $('#main-container').on('mousedown touchend', world.ui.container.click);\r\n        }\r\n\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n        window.PIXI = PIXI;\r\n        //>>includeEnd(\"debug\");\r\n\r\n        var $canvasWrap = $('#canvas-wrap');\r\n        var w = window.innerWidth ? window.innerWidth : $(window).width();\r\n        var h = window.innerHeight ? window.innerHeight : $(window).height();\r\n        var opts = {transparent: true};\r\n        for (var i = 0; i < layers.length; i++) {\r\n            (function () {\r\n                var layer = world[layers[i]] = {};\r\n                layer.container = new PIXI.Container();\r\n                layer.container.reorder = function () {\r\n                    reorder.call(layer.container);\r\n                };\r\n                if ((platform.isIE() && !platform.isMobile()) || // desktop IE\r\n                        (platform.isFirefox() && platform.isMobile()) ) { // mobile FF\r\n                    layer.renderer = new PIXI.CanvasRenderer(w, h, opts);\r\n                } else {\r\n                    layer.renderer = PIXI.autoDetectRenderer(w, h, opts);\r\n                }\r\n                layer.renderer.container = layer.container;\r\n                layer.renderer.repaint = function () {\r\n                    layer.renderer.render(layer.container);\r\n                };\r\n                $canvasWrap.append(layer.renderer.view);\r\n            })();\r\n        }\r\n        window.world = world;\r\n\r\n        if (globalConfig.TOGGLE_FULL_SCREEN_ON_POINTER\r\n                && !globalConfig.DUMMY_DATA) {\r\n            bindFullScreenClick();\r\n        }\r\n\r\n        // listen to events which pause or resume the gameplay\r\n        pubsub.subscribeBatch({\r\n            'notify:focusIn': function () {\r\n                windowFocused = true;\r\n                updateRunning();\r\n            },\r\n            'notify:focusOut': function () {\r\n//                windowFocused = false;\r\n                updateRunning();\r\n            },\r\n            'notify:overlayDisplayed': function (id, data) {\r\n                if (overlaysVisible.indexOf(data.type) === -1) {\r\n                    overlaysVisible.push(data.type);\r\n                    updateRunning();\r\n                }\r\n            },\r\n            'notify:overlayHidden': function (id, data) {\r\n                if (overlaysVisible.indexOf(data.type) > -1) {\r\n                    overlaysVisible.splice(overlaysVisible.indexOf(data.type), 1);\r\n                    updateRunning();\r\n                }\r\n            },\r\n        });\r\n\r\n        createjs.Ticker.paused = true;\r\n\r\n        if (!platform.isMobile()) {\r\n            // repaint UI while moving mouse to make sure hover events work\r\n            $('body').on('mousemove', function () {\r\n                world.ui.container.needsRepaint = true;\r\n            });\r\n        }\r\n    }\r\n\r\n    // set world update callbacks\r\n    function mStartFrames(onFrame) {\r\n        // single frame callback\r\n        function onFrameCallback() {\r\n            requestAnimationFrame(onFrameCallback);\r\n            now = Date.now();\r\n            delta = ((now - lastRound) / 1000) * globalConfig.GAME_SPEED_MODIFIER;\r\n            if (delta) {\r\n                onFrame(delta, running);\r\n                if (running) {\r\n                    createjs.Tween.tick((delta * 1000) / 30);\r\n                    pause.update(delta);\r\n                }\r\n            }\r\n            lastRound = now;\r\n        }\r\n        var now, delta;\r\n        var lastRound = Date.now();\r\n        running = true;\r\n        requestAnimationFrame(onFrameCallback);\r\n    }\r\n\r\n    function updateRunning() {\r\n        if (windowFocused && overlaysVisible.length === 0) {\r\n            if (!running) {\r\n                running = true;\r\n                pubsub.publish('notify:gameResumed');\r\n            }\r\n        } else if (running) {\r\n            pubsub.publish('notify:gamePaused');\r\n            running = false;\r\n        }\r\n    }\r\n    function mGetRenderer(type) {\r\n        if (!world[type]) {\r\n            throw Error('Unknown renderer type');\r\n        }\r\n        return world[type].renderer;\r\n    }\r\n    function mGetContainer(type) {\r\n        if (!world[type]) {\r\n            throw Error('Unknown container type');\r\n        }\r\n        return world[type].container;\r\n    }\r\n    function reorder() {\r\n        this.children.sort(function (a, b) {\r\n            a.wrapper.zIndex = a.wrapper.zIndex || 0;\r\n            b.wrapper.zIndex = b.wrapper.zIndex || 0;\r\n            return a.wrapper.zIndex - b.wrapper.zIndex;\r\n        });\r\n    }\r\n    function mGetRenderers() {\r\n        var arr = [];\r\n        for (var i = 0; i < layers.length; i++) {\r\n            arr.push(mGetRenderer(layers[i]));\r\n        }\r\n        return arr;\r\n    }\r\n    function mGetContainers() {\r\n        var arr = [];\r\n        for (var i = 0; i < layers.length; i++) {\r\n            arr.push(mGetContainer(layers[i]));\r\n        }\r\n        return arr;\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/engine.js"),eval("define('components/GroupCtrl',['services/engine', 'pubsub'], function (\r\n        engine, pubsub) {\r\n\r\n    // element group controller\r\n    return function create(options) {\r\n\r\n        options = options || {};\r\n        var proto = {\r\n            // reference to group view\r\n            view: null,\r\n            // display all elements in group\r\n            showAll: function (options) {\r\n                options = options || {};\r\n                for (var element in this.view.elements) {\r\n                    if (this.view.elements[element]) {\r\n                        this.view.elements[element].show(options);\r\n                    }\r\n                }\r\n            },\r\n            // hide all elements in group\r\n            hideAll: function (options) {\r\n                options = options || {};\r\n                for (var element in this.view.elements) {\r\n                    if (this.view.elements[element]) {\r\n                        this.view.elements[element].hide(options);\r\n                    }\r\n                }\r\n            },\r\n            // fade in all elements in group\r\n            fadeInAll: function (cb, time) {\r\n                for (var element in this.view.elements) {\r\n                    if (this.view.elements[element]) {\r\n                        this.view.elements[element].fadeIn(cb, time);\r\n                    }\r\n                }\r\n            },\r\n            // fade out all elements in group\r\n            fadeOutAll: function (cb, time) {\r\n                for (var element in this.view.elements) {\r\n                    if (this.view.elements[element]) {\r\n                        this.view.elements[element].fadeOut(cb, time);\r\n                    }\r\n                }\r\n            },\r\n            // render all elements in group\r\n            renderAll: function () {\r\n                for (var element in this.view.elements) {\r\n                    if (this.view.elements[element]) {\r\n                        engine.getContainer(\r\n                                this.view.elements[element].canvasLayer)\r\n                                .needsRepaint = true;\r\n                    }\r\n                }\r\n            },\r\n            // update all elements in group\r\n            update: function (delta) {\r\n                for (var element in this.view.elements) {\r\n                    if (this.view.elements[element]) {\r\n                        if (this.view.elements.hasOwnProperty(element)) {\r\n                            if (this.view.elements[element].visible\r\n                                    && this.view.elements[element].update) {\r\n                                this.view.elements[element].update(delta);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            // resize all elements in group\r\n            resize: function (options) {\r\n                for (var element in this.view.elements) {\r\n                    if (this.view.elements[element]) {\r\n                        if (this.view.elements.hasOwnProperty(element)) {\r\n                            if (this.view.elements[element].visible\r\n                                    && this.view.elements[element].resize) {\r\n                                this.view.elements[element].resize(options);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // bind to dimensions changed event\r\n        // resize all elements\r\n        pubsub.subscribe('notify:dimensionsChanged', function () {\r\n            proto.resize();\r\n        });\r\n\r\n        return proto;\r\n    };\r\n\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/GroupCtrl.js"),eval("define('data/i18n-core',{\r\n    'ENGLISH': {\r\n        'start': 'START',\r\n        'scroll-up-overlay-text': 'SWIPE UP FOR FULLSCREEN',\r\n        'loaderConnecting': 'CONNECTING   ',\r\n        'loaderDownloading': 'DOWNLOADING   ',\r\n        'rotate-overlay-text': 'ROTATE DEVICE TO PLAY',\r\n        'goodLuck': 'GOOD LUCK!',\r\n        'gameOverPlaceBet': 'PLACE YOUR BET',\r\n        'spin': 'SPIN',\r\n        'stop': 'STOP',\r\n        'takeWin': 'TAKE\\nWIN',\r\n        'takeRisk': 'TAKE\\nRISK',\r\n        'pays': 'PAYS',\r\n        'line': 'LINE',\r\n        'menu': 'MENU',\r\n        'credits': 'CREDITS',\r\n        'cash': 'CASH',\r\n        'bet': 'BET',\r\n        'win': 'WIN',\r\n        'lastWin': 'LAST WIN',\r\n        'autospin': 'AUTOSPIN',\r\n        'playedFor': 'PLAYED FOR',\r\n        'minutes': 'MINUTES',\r\n        'seconds': 'SECONDS',\r\n        'fiveOfAKind': 'FIVE OF A KIND!',\r\n        'youWonFreeGames': 'YOU WON FREE GAMES!',\r\n        'turbospin': 'TURBOSPIN',\r\n        'auto': 'AUTO',\r\n        'turbo': 'TURBO',\r\n        'stopAutoplay': 'STOP AUTOSPIN',\r\n        'dragAgainToStopAuto': 'TO STOP AUTO DRAG LEFT AGAIN',\r\n        'totalBet': 'TOTAL BET',\r\n        'showBalanceIn': 'SHOW BALANCE IN',\r\n        'totalBetInCredits': 'TOTAL BET IN CREDITS',\r\n        refreshBalance: 'REFRESH\\nBALANCE',\r\n        'lines': 'LINES',\r\n        'denom': 'COIN VALUE',\r\n        'denomination': 'DENOMINATION',\r\n        'gambleAmount': 'GAMBLE AMOUNT',\r\n        'gambleToWin': 'GAMBLE TO WIN',\r\n        'of': 'OF',\r\n        'forward': 'FORWARD',\r\n        'dealerWins': 'DEALER WINS',\r\n        'youWin': 'YOU WIN!',\r\n        'step': 'STEP',\r\n        'selectCardOrTakeWin': 'SELECT CARD OR TAKE WIN',\r\n        'next': 'NEXT',\r\n        'back': 'BACK',\r\n        paytableRules: 'RULES & PAYTABLE',\r\n        rules: 'RULES',\r\n        riskGame: 'RISK GAME (GAMBLE)',\r\n        attention: 'ATTENTION!',\r\n        scatter: 'SCATTER',\r\n        wild: 'WILD',\r\n        menuRules: 'PAYTABLE',\r\n        menuBet: 'BET',\r\n        menuLocale: 'LANGUAGE',\r\n        menuSound: 'SOUND',\r\n        menuInterface: 'GRAPHICS',\r\n        menuAutoplay: 'AUTOSPIN',\r\n        'exitMenu': 'EXIT\\nMENU',\r\n        'betSettings': 'BET SETTINGS',\r\n        'autoplaySettings': 'AUTOPLAY SETTINGS',\r\n        'graphicsSettings': 'GRAPHIC SETTINGS',\r\n        'localeSettings': 'LANGUAGE SETTINGS',\r\n        'soundSettings': 'SOUND SETTINGS',\r\n        'rounds': 'ROUNDS',\r\n        'stopAutoplayWhen': 'STOP AUTOPLAY WHEN:',\r\n        'timeHasPassed': 'TIME HAS PASSED',\r\n        'winExceeds': 'WIN EXCEEDS',\r\n        'balanceDecBy': 'BALANCE DECREASED BY',\r\n        'balanceIncBy': 'BALANCE INCREASED BY',\r\n        'bets': 'bets',\r\n        'min': 'min',\r\n        'fullscreen': 'FULLSCREEN',\r\n        'stretch': 'STRETCH',\r\n        'quality': 'QUALITY',\r\n        'leftHandMode': 'LEFT HAND MODE',\r\n        'language': 'LANGUAGE',\r\n        'low': 'LOW',\r\n        'high': 'HIGH',\r\n        'on': 'ON',\r\n        'off': 'OFF',\r\n        'soundQuality': 'SOUND QUALITY',\r\n        'masterSoundVolume': 'MASTER',\r\n        'masterSound': 'MASTER SOUND',\r\n        'effectsSoundVolume': 'EFFECTS',\r\n        'effectsSound': 'EFFECTS SOUND',\r\n        'backgroundVolume': 'BACKGROUND',\r\n        'background': 'BACKGROUND',\r\n        'ok': 'OK',\r\n        'alert': 'Alert',\r\n        'browserIsOutdated': 'You are using an outdated browser. This game is optimized for use with these browsers: \\n\\nIE 10+, Chrome 29+, Firefox 38+, Android 4.1+, Windows Phone 8, Safari iOS 7.1+',\r\n        'connectionError': 'Connection to server has been interrupted. You can continue playing when you connect again. Please reload the game or return to lobby.',\r\n        'insufficientBalanceError': 'Not enough money.<br/><br/>Sorry, but you have no funds to continue playing.<br/>Please refill your account and start the game again.',\r\n        'betInvalidError': 'Incorrect game settings.<br/><br/>Betting options has been changed?<br/>Please restart the game.',\r\n        'reload': 'RELOAD',\r\n        'home': 'HOME',\r\n        'endGame': 'END GAME',\r\n        'yes': 'YES',\r\n        'no': 'NO',\r\n        'pleasePressSpin': 'PLEASE PRESS SPIN',\r\n        'doYouWishToExitGame': 'QUIT TO LOBBY?',\r\n        'maxBetLimitReached':'TOTAL BET IN MONEY CAN NOT<br/>EXCEED',\r\n        // help\r\n        swipeLeftToEnableAutospin: 'Swipe for auto spin',\r\n        swipeLeftToEnableTurboSpin: 'Swipe for turbo spin',\r\n        tapAnywhereToStart: 'Tap anywhere to start',\r\n        tapToSpin: 'Tap to spin the reels',\r\n        tapToOpenMenu: 'Tap to open menu',\r\n        riskGameSlideP1: 'RISK GAME is your chance to increase winnings! Win can be doubled up to 10 times. To win the RISK GAME round you must beat dealer   s card choosing one of four closed cards. All closed cards can be higher than dealer   s card. All closed cards can be lower than dealer   s card. The cards can be repeated. Picking a card with same value as dealer   s means a draw, player   s win is not changed and gamble round is repeated. You can decline the RISK GAME and collect current winnings by pressing TAKE WIN button. If dealer wins round, player loses all his winnings and RISK GAME ends.',\r\n        attentionP: 'All unfinished games, untaken prizes, unused accumulated values are saved for 7 days and then will be canceled. Saved results can be canceled before 7 day expiration period in case of scheduled system update or server maintenance. Please make sure that you have collected all your wins and prizes before you quit the game. Malfunction voids all pays and plays.',\r\n    },\r\n    'RUSSIAN': {\r\n        'goodLuck': 'RGOOD LUCK!',\r\n        'gameOverPlaceBet': 'RGAME OVER, PLACE YOUR BET.',\r\n        'spin': 'RSPIN',\r\n        'stop': 'RSTOP',\r\n        'takeWin': 'RTAKE\\nWIN',\r\n        'takeRisk': 'RTAKE\\nRISK',\r\n        'auto': 'RAUTO',\r\n        'pays': 'RPAYS',\r\n        'line': 'RLINE',\r\n        'scatter': 'RSCATTER',\r\n        'menu': 'RMENU',\r\n        'credits': 'RCREDITS',\r\n        'cash': 'RCASH',\r\n        'bet': 'RBET',\r\n        'totalBet': 'RTOTAL BET',\r\n        'showBalanceIn': 'RSHOW BALANCE IN',\r\n        'totalBetInCredits': 'RTOTAL BET IN CASH',\r\n        'lines': 'RLINES',\r\n        'denom': 'RCOIN VALUE',\r\n        'denomination': 'RDENOMINATION',\r\n        'gambleAmount': 'RGAMBLE AMOUNT',\r\n        'gambleToWin': 'RGAMBLE TO WIN',\r\n        'of': 'ROF',\r\n        'forward': 'RFORWARD',\r\n        'dealerWins': 'RDEALER WINS.',\r\n        'youWin': 'RYOU WIN!',\r\n        'step': 'RSTEP',\r\n        'selectCardOrTakeWin': 'RSELECT CARD OR TAKE WIN.',\r\n        'next': 'RNEXT',\r\n        'back': 'RBACK',\r\n        'exitMenu': 'REXIT\\nMENU',\r\n        'betSettings': 'RBET SETTINGS',\r\n        'autoplaySettings': 'RAUTOPLAY SETTINGS',\r\n        'graphicsSettings': 'RGRAPHIC SETTINGS',\r\n        'soundSettings': 'RSOUND SETTINGS',\r\n        'rounds': 'RROUNDS',\r\n        'stopAutoplayWhen': 'RSTOP AUTOPLAY WHEN:',\r\n        'timeHasPassed': 'RTIME HAS PASSED',\r\n        'winExceeds': 'RWIN EXCEEDS',\r\n        'balanceDecBy': 'RBALANCE DECREASED BY',\r\n        'balanceIncBy': 'RBALANCE INCREASED BY',\r\n        'bets': 'Rbets',\r\n        'min': 'Rmin',\r\n        'fullscreen': 'RFULLSCREEN',\r\n        'stretch': 'RSTRETCH',\r\n        'quality': 'RQUALITY',\r\n        'leftHandMode': 'RLEFT HAND MODE',\r\n        'language': 'RLANGUAGE',\r\n        'low': 'RLOW',\r\n        'medium': 'RMEDIUM',\r\n        'high': 'RHIGH',\r\n        'on': 'RON',\r\n        'off': 'ROFF',\r\n        'masterSoundVolume': 'RMASTER SOUND VOLUME',\r\n        'masterSound': 'RMASTER SOUND',\r\n        'effectsSoundVolume': 'REFFECTS SOUND VOLUME',\r\n        'effectsSound': 'REFFECTS SOUND',\r\n        'backgroundVolume': 'RBACKGROUND VOLUME',\r\n        'background': 'RBACKGROUND',\r\n        'ok': 'ROK',\r\n        'alert': 'RAlert',\r\n        'browserIsOutdated': 'RYou are using an outdated browser. This game is optimized for use with these browsers: \\n\\nIE 10+, Chrome 29+, Firefox 38+, Android 4.1+, Windows Phone 8, Safari iOS 7.1+',\r\n        'connectionError': 'RYou are experiencing connection problems, please check your internet connection. If the problem persists, you can try reloading the game or return to home screen.',\r\n        'reload': 'RRELOAD',\r\n        'home': 'RHOME',\r\n    },\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/data/i18n-core.js"),eval("define('data/i18n',{\r\n    ENGLISH: {\r\n        'winnings': 'Winnings',\r\n        'freeGame': 'FREE GAME',\r\n        'youWon': 'YOU WON',\r\n        'freeGamesWelcome': ' FREE GAMES',\r\n        'moreFreeGames': ' MORE FREE GAMES',\r\n        'freeGames': 'FREE GAMES',\r\n        'rulesSlideP1': \"THE VIKINGS is a 5 reel 3 row slot game with 20 paylines. All prizes are for combinations of a kind. All prizes are for combinations of adjacent symbols on enabled paylines. All prizes are for combinations left to right from leftmost reel. Highest win only paid on each enabled payline. Wins on different paylines are added. All prizes in paytable are for currently selected bet and number of paylines. All prizes in paytable are shown in money or credits depending on the currently selected mode.\",\r\n        'slide2_P1': \"WILD<br/><br/>Substitutes for all symbols except SCATTER.\",\r\n        'slide2_P4': \"3 X SCATTER<br/><br/>12 FREE GAMES with stacked WILD symbol.<br/>All prizes X3.\",\r\n    }});\n//# sourceURL=/modules/Vikings/src/js/data/i18n.js"),eval("// cursor\r\n// controls button hover in-out cursor behavior\r\n// when the user hovers over a button, the upper-most canvas class is changed\r\n// so that the cursor is a pointer\r\ndefine('services/i18n',['pubsub', 'data/i18n-core', 'data/i18n'], function (pubsub, dataCore, dataGame) {\r\n    function updateHtmlLabels() {\r\n        $('body').find('.localizable').each(function () {\r\n            var txt = API.localize(this.getAttribute('data-id'));\r\n            this.textContent = txt;\r\n        });\r\n    }\r\n\r\n    var merged = {};\r\n    $.extend(true, merged, dataCore, dataGame);\r\n\r\n    pubsub.subscribeBatch({\r\n        'notify:languageChanged': function (id, data) {\r\n            currentLang = data.lang;\r\n            updateHtmlLabels();\r\n            pubsub.publish('request:updateLocalizedLabels');\r\n        }\r\n    });\r\n\r\n    var currentLang = '';\r\n    var defaultLang = 'ENGLISH';\r\n    var langData;\r\n\r\n    var API = {\r\n        localize: function (input) {\r\n            function parseWord(w) {\r\n                if (w[0] && w[0] === '!') {\r\n                    return w.substring(1);\r\n                } else {\r\n                    if (merged[currentLang]) {\r\n                        langData = merged[currentLang];\r\n                    } else {\r\n                        langData = merged[defaultLang];\r\n                    }\r\n                    if (langData) {\r\n                        if (w[0] && w[0] === '^') {\r\n                            return langData[w.substring(1)]\r\n                                    ? langData[w.substring(1)].toUpperCase()\r\n                                    : w.substring(1).toUpperCase();\r\n                        } else {\r\n                            return langData[w] || w;\r\n                        }\r\n                    } else {\r\n                        return w;\r\n                    }\r\n                }\r\n            }\r\n            var i;\r\n            var result = '';\r\n            if (input instanceof Array) {\r\n                for (var i = 0; i < input.length; i++) {\r\n                    result += API.localize(input[i]);\r\n                }\r\n            } else {\r\n                result += parseWord(input);\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n    return API;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/i18n.js"),eval("define('data/config-menu-core',['services/i18n'], function (i18n) {\r\n    return {\r\n        PAGES_CONTENT_OFFSET_TOP: 100,\r\n        PAGES_CONTENT_OFFSET_LEFT: 60,\r\n        TOP_DIVIDER_TOP: 97,\r\n        BOTTOM_DIVIDER_TOP: 554,\r\n        BOTTOM_PANEL_LEFT: -20,\r\n        BOTTOM_PANEL_TOP: 530,\r\n        BOTTOM_PANEL_WIDTH: 1020,\r\n        BOTTOM_PANEL_HEIGHT: 65,\r\n        MENU_LEFT_HEADER_LEFT: -20,\r\n        MENU_RIGHT_HEADER_LEFT: 857,\r\n        MENU_HEADER_TOP: -35,\r\n        MENU_HEADER_FONT_SIZE: 28,\r\n        MENU_CONTENTS_LEFT: 0,\r\n        MENU_CONTENTS_TOP: 0,\r\n        SCROLL_CONTAINER_LEFT: 41,\r\n        SCROLL_CONTAINER_TOP: 35,\r\n        SCROLL_CONTAINER_WIDTH: 772,\r\n        SCROLL_CONTAINER_HEIGHT: 402,\r\n        //\r\n        MENU_BUTTON_LEFT_LEFTHAND: 914,\r\n        MENU_BUTTON_LEFT_RIGHTHAND: 47,\r\n        MENU_BUTTON_TOP: 320,\r\n        MENU_BUTTON_WIDTH: 125,\r\n        MENU_BUTTON_HEIGHT: 121,\r\n        //\r\n        CLOSE_BUTTON_LEFT_LEFTHAND: 40,\r\n        CLOSE_BUTTON_LEFT_RIGHTHAND: 920,\r\n        CLOSE_BUTTON_TOP: 320,\r\n        CLOSE_BUTTON_WIDTH: 58,\r\n        CLOSE_BUTTON_HEIGHT: 58,\r\n        HOME_BUTTON_LEFT: 43,\r\n        HOME_BUTTON_TOP: 149,\r\n        HOME_BUTTON_WIDTH: 40,\r\n        HOME_BUTTON_HEIGHT: 40,\r\n        BACK_BUTTON_LEFT: 45,\r\n        BACK_BUTTON_TOP: 502,\r\n        BACK_BUTTON_WIDTH: 45,\r\n        BACK_BUTTON_HEIGHT: 49,\r\n        SOUND_TOGGLE_BUTTON_LEFT: 917,\r\n        SOUND_TOGGLE_BUTTON_TOP: 146.5,\r\n        SOUND_TOGGLE_BUTTON_WIDTH: 45,\r\n        SOUND_TOGGLE_BUTTON_HEIGHT: 45,\r\n        MENU_MAIN_BUTTONS_CENTER_X: 480,\r\n        MENU_MAIN_BUTTONS_CENTER_Y: 305,\r\n        MENU_MAIN_BUTTONS_WIDTH: 50,\r\n        MENU_MAIN_BUTTONS_HEIGHT: 50,\r\n        INTERFACE_BUTTON_WIDTH: 48,\r\n        INTERFACE_BUTTON_HEIGHT: 43,\r\n        SOUND_BUTTON_WIDTH: 48,\r\n        SOUND_BUTTON_HEIGHT: 50,\r\n        MENU_MAIN_BUTTONS_MARGIN_X: 160,\r\n        MENU_MAIN_BUTTONS_MARGIN_Y: 130,\r\n        MENU_MAIN_BUTTONS_FONT_SIZE: 22,\r\n        MENU_MAIN_BUTTONS_LABEL_OFFSET_Y: 50,\r\n        LEVEL_1_LEFT: 89,\r\n        LEVEL_2_LEFT: 69,\r\n        LEVEL_1_FONT_SIZE: 22,\r\n        LEVEL_2_FONT_SIZE: 26,\r\n        CYCLE_BUTTON_LEFT: 530,\r\n        CYCLE_BUTTON_WIDTH: 246.55,\r\n        CYCLE_BUTTON_HEIGHT: 60,\r\n        FLIPSWITCH_LEFT: 530,\r\n        FLIPSWITCH_WIDTH: 109,\r\n        FLIPSWITCH_HEIGHT: 62,\r\n        FLIPSWITCH_FONT_SIZE_ON: 24,\r\n        FLIPSWITCH_FONT_SIZE_OFF: 22.5,\r\n        FLIPSWITCH_FONT_COLOR_ON: 'silver',\r\n        FLIPSWITCH_BUTTON_TEXT_OFFSET_TOP_ON: 15,\r\n        FLIPSWITCH_BUTTON_TEXT_OFFSET_TOP_OFF: 16.5,\r\n        BIG_FLIPSWITCH_WIDTH: 245,\r\n        BIG_FLIPSWITCH_HEIGHT: 62,\r\n        BIG_FLIPSWITCH_FONT_SIZE: 24,\r\n        BIG_FLIPSWITCH_TEXT_OFFSET_TOP: 16,\r\n        BIG_FLIPSWITCH_BUTTON_OFFSET_TOP: 5.5,\r\n        BIG_FLIPSWITCH_BUTTON_WIDTH: 52.3,\r\n        BIG_FLIPSWITCH_BUTTON_HEIGHT: 55.3,\r\n        BIG_FLIPSWITCH_BUTTON_OFFSET_LEFT_ON: 5,\r\n        BIG_FLIPSWITCH_BUTTON_OFFSET_LEFT_OFF: 187.5,\r\n        AUTOPLAY_ROUNDS_CYCLE_BUTTON_ITEMS: ['off', 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 220, 240, 260, 280, 300, 320, 340, 360, 380, 400, 420, 440, 460, 480, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000],\r\n        AUTOPLAY_TIME_PASSED_CYCLE_BUTTON_ITEMS: ['off', 5, 10, 15, 20, 30, 60],\r\n        AUTOPLAY_WIN_EXCEEDS_CYCLE_BUTTON_ITEMS: ['off', 5, 10, 20, 50, 75, 100, 200, 500, 1000],\r\n        AUTOPLAY_BALANCE_DEC_BY_CYCLE_BUTTON_ITEMS: ['off', 10, 20, 30, 40, 50, 60, 70, 80, 90],\r\n        AUTOPLAY_BALANCE_INC_BY_CYCLE_BUTTON_ITEMS: ['off', 1.5, 2, 3, 5, 10],\r\n        GRAPHICS_QUALITY_CYCLE_BUTTON_ITEMS: ['low', 'medium', 'high'],\r\n        LANGUAGE_CYCLE_BUTTON_ITEMS: [\r\n            {label: 'ENGLISH', localizedLabel: 'ENGLISH', flag: 'menu/flag-uk'},\r\n//            {label: 'SPANISH', localizedLabel: 'ESPA  OL', flag: 'menu/flag-es'},\r\n//            {label: 'GERMAN', localizedLabel: 'DEUTSCH', flag: 'menu/flag-de'},\r\n//            {label: 'THAI', localizedLabel: 'THAI', flag: 'menu/flag-th'},\r\n//            {label: 'CHINESE', localizedLabel: '            ', flag: 'menu/flag-ch'},\r\n        ],\r\n        BOTTOM_TEXT_LEFT: 15,\r\n        BOTTOM_RIGHT_TEXT_LEFT: 945,\r\n        BOTTOM_TEXT_TOP: 536,\r\n        BOTTOM_TEXT_FONT_SIZE: 18,\r\n        BOTTOM_TEXT_BIG_FONT_TOP: 536,\r\n        BOTTOM_TEXT_BIG_FONT_SIZE: 18,\r\n        BOTTOM_TEXT_COLOR: 'white',\r\n        RULES_CONTAINER_LEFT: 41,\r\n        RULES_CONTAINER_TOP: 35,\r\n        RULES_CONTAINER_WIDTH: 772,\r\n        RULES_CONTAINER_HEIGHT: 402,\r\n        FONT_SIZE_RULES: 21,\r\n        FONT_SIZE_PAYTABLE: 24,\r\n        TOP_RIGHT_TEXT_LABEL_TOP: 57,\r\n        TOP_RIGHT_TEXT_LABEL_FONT_SIZE: 24,\r\n        TOP_RIGHT_TEXT_LABEL_BACK_TOP: 53,\r\n        TOP_RIGHT_TEXT_LABEL_BACK_HEIGHT: 31,\r\n        TOP_RIGHT_TEXT_LABEL_BACK_LEFT: 0,\r\n        TOP_RIGHT_TEXT_LABEL_BACK_WIDTH: 960,\r\n        TOP_RIGHT_TEXT_LABEL_LEFT: 945,\r\n        TOP_LEFT_TEXT_LABEL_LEFT: 15,\r\n    }\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-menu-core.js"),eval("define('data/config-menu',['jquery', 'data/config-menu-core'], function ($, coreConfig) {\r\n    return $.extend(coreConfig, {\r\n        RULES_CONTENTS: [\r\n            [\r\n                {\r\n                    type: 'img',\r\n                    src: 'symbols/Wild_00001',\r\n                    style: 'float:left; margin-left:.5%; width:23%;'\r\n                },\r\n                {\r\n                    type: 'text',\r\n                    text: 'slide2_P1',\r\n                    style: 'margin-left:3%; width:71%; float:left;',\r\n                    attr: {\r\n                        center: true,\r\n                    },\r\n                },\r\n            ],\r\n            [\r\n                {\r\n                    type: 'img',\r\n                    src: 'symbols/scatter_00001',\r\n                    style: 'margin-left:.3%; margin-top: 1%; width:23.2%; float:left;'\r\n                },\r\n                {\r\n                    type: 'text',\r\n                    text: 'slide2_P4',\r\n                    style: 'margin-left:3%; margin-top:0; width:71%; float:left; ',\r\n                    attr: {\r\n                        center: true,\r\n                    },\r\n                },\r\n            ],\r\n            [\r\n                {\r\n                    type: 'header',\r\n                    text: 'rules',\r\n                    style: '',\r\n                },\r\n                {\r\n                    type: 'text',\r\n                    text: 'rulesSlideP1',\r\n                    style: ''\r\n                },\r\n                {\r\n                    type: 'img',\r\n                    src: 'menu/lines_rules',\r\n                    style: 'display:block;width:97%;margin: 2em auto 0 auto;'\r\n                }\r\n            ],\r\n            [\r\n                {\r\n                    type: 'header',\r\n                    text: 'riskGame',\r\n                    style: '',\r\n                },\r\n                {\r\n                    type: 'text',\r\n                    text: 'riskGameSlideP1',\r\n                    style: 'clear:both;'\r\n                },\r\n                {\r\n                    type: 'container',\r\n                    style: 'text-align:center; margin: 2em auto 0 auto;',\r\n                    content: [\r\n                        {\r\n                            type: 'img',\r\n                            src: 'Cards_gamble/00001',\r\n                            style: 'display: inline-block; width: 10%;'\r\n                        },\r\n                        {\r\n                            type: 'img',\r\n                            src: 'Cards_gamble/shirt',\r\n                            style: 'display: inline-block; width: 10%; margin-left:1.4%;'\r\n                        },\r\n                        {\r\n                            type: 'img',\r\n                            src: 'Cards_gamble/shirt',\r\n                            style: 'display: inline-block; width: 10%; margin-left:.2%;'\r\n                        },\r\n                        {\r\n                            type: 'img',\r\n                            src: 'Cards_gamble/shirt',\r\n                            style: 'display: inline-block; width: 10%; margin-left:.2%;'\r\n                        },\r\n                        {\r\n                            type: 'img',\r\n                            src: 'Cards_gamble/shirt',\r\n                            style: 'display: inline-block; width: 10%; margin-left:.2%;'\r\n                        },\r\n                    ]\r\n                },\r\n            ],\r\n            [\r\n                {\r\n                    type: 'header',\r\n                    text: 'attention',\r\n                    style: '',\r\n                },\r\n                {\r\n                    type: 'text',\r\n                    text: 'attentionP',\r\n                    style: 'clear:both'\r\n                },\r\n            ]\r\n        ],\r\n        PAYTABLE_ICON_COUNT_VALUES: {\r\n            0: 5,\r\n            1: 5,\r\n            2: 5,\r\n            3: 5,\r\n            4: 5,\r\n            5: 5,\r\n            6: 5,\r\n            7: 5,\r\n            8: 5,\r\n            9: {\r\n                label: 'scatter',\r\n                count: 0,\r\n            },\r\n            10: {\r\n                label: 'wild',\r\n                count: 0,\r\n            }\r\n        }\r\n    });\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-menu.js"),
eval("// settings\r\n// hold reference to settings model\r\n// handles model persistence\r\ndefine('services/settings',['data/config', 'data/config-menu'], function (coreConfig, config) {\r\n\r\n    // default settings model\r\n    var defaultModel = {\r\n        credits: {\r\n            showInCash: false,\r\n        },\r\n        autoplay: {\r\n            rounds: {\r\n                active: false,\r\n                steps: config.AUTOPLAY_ROUNDS_CYCLE_BUTTON_ITEMS,\r\n                selectedIndex: 0,\r\n            },\r\n            timePassed: {\r\n                active: false,\r\n                steps: config.AUTOPLAY_TIME_PASSED_CYCLE_BUTTON_ITEMS,\r\n                selectedIndex: 0,\r\n            },\r\n            winExceeds: {\r\n                active: false,\r\n                steps: config.AUTOPLAY_WIN_EXCEEDS_CYCLE_BUTTON_ITEMS,\r\n                selectedIndex: 0,\r\n            },\r\n            balanceDecBy: {\r\n                active: false,\r\n                steps: config.AUTOPLAY_BALANCE_DEC_BY_CYCLE_BUTTON_ITEMS,\r\n                selectedIndex: 0,\r\n            },\r\n            balanceIncBy: {\r\n                active: false,\r\n                steps: config.AUTOPLAY_BALANCE_INC_BY_CYCLE_BUTTON_ITEMS,\r\n                selectedIndex: 0,\r\n            }\r\n        },\r\n        graphics: {\r\n            lefthand: false,\r\n        },\r\n        locale: {\r\n            language: {\r\n                steps: config.LANGUAGE_CYCLE_BUTTON_ITEMS,\r\n                selectedIndex: 0,\r\n            }\r\n        },\r\n        sound: {\r\n            quality: false,\r\n            master: {\r\n                active: false,\r\n                volume: 100\r\n            },\r\n            effects: {\r\n                active: false,\r\n                volume: 100\r\n            },\r\n            background: {\r\n                active: false,\r\n                volume: 100\r\n            }\r\n        }\r\n    };\r\n\r\n    // current model\r\n    var current = null;\r\n    var keyName = 'endorphinaSettings_' + coreConfig.GAME_NAME;\r\n\r\n    // get current model\r\n    function mGet() {\r\n        var stored;\r\n        // initialize model if not done yet\r\n        if (!current) {\r\n            // get from localStorage if present\r\n            // use default model if not\r\n            if (!localStorage.getItem(keyName)) {\r\n                current = $.extend(true, {}, defaultModel);\r\n            } else {\r\n                stored = JSON.parse(localStorage.getItem(keyName));\r\n                if (stored.version !== coreConfig.VERSION) {\r\n                    current = $.extend(true, {}, defaultModel);\r\n                } else {\r\n                    current = stored.settings;\r\n                    // reset autoplay settings\r\n                    current.autoplay = $.extend(true, {}, defaultModel.autoplay);\r\n                    current.graphics.lefthand = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n        window.settingsModel = current;\r\n        //>>includeEnd(\"debug\");\r\n\r\n        return current;\r\n    }\r\n\r\n    // save to localStorage\r\n    function mSave() {\r\n        if (current) {\r\n            try {\r\n                localStorage.setItem(keyName, JSON.stringify({\r\n                    version: coreConfig.VERSION,\r\n                    settings: current\r\n                }));\r\n            } catch (e) {\r\n                console.log('STORAGE SAVE ERROR: ', e);\r\n            }\r\n        }\r\n    }\r\n\r\n    var API = {\r\n        get: mGet,\r\n        save: mSave\r\n    };\r\n\r\n    return API;\r\n\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/settings.js"),eval("\r\ndefine('data/config-mainButtons',{\r\n    PLAY_BUTTON_OFFSET_LEFT: 0,\r\n    PLAY_BUTTON_OFFSET_TOP: 0,\r\n    LEFT_CONTROL_BUTTON_LEFT: 83,\r\n    RIGHT_CONTROL_BUTTON_LEFT: 878,\r\n    CONTROL_BUTTON_TOP: 320,\r\n    CONTROL_BUTTON_WIDTH: 152,\r\n    CONTROL_BUTTON_HEIGHT: 147,\r\n    CONTROL_BUTTON_SMALLER_FONT_SIZE: 34,\r\n    BUTTONS_FONT_SIZE: 37,\r\n    BUTTONS_LINE_HEIGHT:37,\r\n    LEFTHAND_ARROW_INFLATE_ANIMATION_LEFT: 825.5,\r\n    RIGHTHAND_ARROW_INFLATE_ANIMATION_LEFT: -14.5,\r\n    ARROW_INFLATE_ANIMATION_WIDTH: 125,\r\n    ARROW_INFLATE_ANIMATION_HEIGHT: 120,\r\n    ARROW_INFLATE_ANIMATION_TOP: 260,\r\n    ARROW_INFLATE_MOVE_LEFT_OFFSET_RIGHTHAND: 21,\r\n    ARROW_INFLATE_MOVE_TOP_OFFSET: -13.5,\r\n//    ARROW_INFLATE_MOVE_TOP_OFFSET: 0,\r\n    ARROW_INFLATE_SCALE: 1.216,\r\n    PLAY_INFLATE_ANIMATION_WIDTH: 152,\r\n    PLAY_INFLATE_ANIMATION_HEIGHT: 147,\r\n    PLAY_INFLATE_ANIMATION_TOP: 320,\r\n    PLAY_BUTTON_STATIC_DELAY_MS: 500,\r\n    E_BUTTON_STATIC_DELAY_MS: 2500,\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-mainButtons.js"),eval("// dimensions\r\n// - computes top-level elements position and dimensions\r\n// and resizes the elements\r\n// - handles full screen operations\r\n\r\ndefine('services/dimensions',['jquery', 'pubsub', 'data/config',\r\n    'services/engine',\r\n    'services/settings',\r\n    'services/platform',\r\n], function (\r\n        $, pubsub, config, engine, settings, platform) {\r\n\r\n// cache DOM references\r\n    var $html = $('html');\r\n    // canvas elements wrapper\r\n    var $canvasWrap = $('#canvas-wrap');\r\n    // dynamic HTML wrappers\r\n    var $htmlStaticWrap = $('#html-static-wrap');\r\n    var $htmlDynamicWraps = $('#html-dynamic-wrap, #html-dynamic-wrap-interactive');\r\n\r\n    // stores last computed dimensions\r\n    // returned as public object\r\n    // used when resizing various elements in game\r\n    var model = {\r\n        canvasScaleX: null,\r\n        canvasScaleY: null,\r\n        topLevelWrappersOffsetX: null,\r\n        topLevelWrappersOffsetY: null,\r\n    };\r\n    // array of all PIXI renderers\r\n    var renderers = [];\r\n    // array of all PIXI main containers\r\n    var containers = [];\r\n    // flag specifies whether the game startup is done\r\n    var gameStartupFinished = false;\r\n    // delay resize so it is not called too often\r\n    var resizeTimeout;\r\n    // left hand mode status\r\n    var leftHandModeActive = null;\r\n    // stores for window dimensions so that we can detect a silent dimension change\r\n    // on iPhone (when the proper event is not fired)\r\n    var lastWW, lastWH;\r\n    // cache iPhone flag\r\n    var is_iPhone = platform.is_iPhone();\r\n    var IPHONE_DIMS = [\r\n        [480, 320], // iPhone 4\r\n        [568, 320], // iPhone 5\r\n        [667, 375], // iPhone 6\r\n        [736, 414], // iPhone 6 plus\r\n    ];\r\n\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        'notify:gameStartupFinished': onStartupFinished,\r\n        // runs when element sizes should be updated\r\n        'request:resize': function () {\r\n            resize(true);\r\n        },\r\n        // request full screen status update\r\n        'request:updateFullScreenStatus': updateFullScreenStatus,\r\n        // request set full screen - runs on startup and every pointer down event\r\n        'request:setFullScreen': setFullScreen,\r\n        // request toggle full screen\r\n        'request:toggleFullScreen': toggleFullScreen,\r\n        'request:blurBackCanvas': blurBackCanvas,\r\n        'request:unblurCanvas': unblurCanvas,\r\n    });\r\n    // disable scrolling in page, omit iPhone because it needs scroll\r\n    // for full screen restoration swipe up workaround\r\n    if (is_iPhone) {\r\n        disableScroll_iPhone();\r\n    } else {\r\n        disableScroll();\r\n    }\r\n\r\n// bind to window resize event DOM events\r\n    $(window).on('resize', function () {\r\n        resize();\r\n    });\r\n    // bind to window focus/blur events\r\n    document.addEventListener(\"visibilitychange\", function () {\r\n        if (document.visibilityState === 'hidden') {\r\n            pubsub.publish('notify:focusOut');\r\n        }\r\n        if (document.visibilityState === 'visible') {\r\n            pubsub.publish('notify:focusIn');\r\n        }\r\n    });\r\n\r\n    // set iPhone check interval so that we can intercept silent dimensions change\r\n    // which does not fire any event\r\n    if (is_iPhone) {\r\n        (function () {\r\n            function iPhoneScrollFix() {\r\n                window.scrollTo(0, 0);\r\n            }\r\n            function isToolBarOpen(data) {\r\n                for (var i = 0; i < IPHONE_DIMS.length; i++) {\r\n                    if (data.ww === IPHONE_DIMS[i][0]\r\n                            && data.wh === IPHONE_DIMS[i][1]) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            function setScrollerHeight(data) {\r\n                for (var i = 0; i < IPHONE_DIMS.length; i++) {\r\n                    if (data.ww === IPHONE_DIMS[i][0]) {\r\n                        $scroller.height(IPHONE_DIMS[i][1] + 50);\r\n                    }\r\n                }\r\n            }\r\n            function periodicCheck() {\r\n                function close() {\r\n                    pubsub.publish('notify:overlayHidden', {\r\n                        type: 'iphone'\r\n                    });\r\n                    $html.removeClass('iphone-overlay-visible');\r\n                    iPhoneScrollFix();\r\n                    iPhoneAlertVisible = false;\r\n                    $scroller.css('visibility', 'hidden');\r\n                }\r\n                function open() {\r\n                    pubsub.publish('notify:overlayDisplayed', {\r\n                        type: 'iphone'\r\n                    });\r\n                    $html.addClass('iphone-overlay-visible');\r\n                    setScrollerHeight(data);\r\n                    iPhoneAlertVisible = true;\r\n                    $scroller.css('visibility', 'visible');\r\n                    setTimeout(iPhoneScrollFix, 0);\r\n                    setTimeout(iPhoneScrollFix, 250);\r\n                }\r\n                var data = {\r\n                    ww: window.innerWidth,\r\n                    wh: window.innerHeight,\r\n                };\r\n                if (data.ww > data.wh) {\r\n                    var toolbarsOpen = isToolBarOpen(data);\r\n                    if (toolbarsOpen && !iPhoneAlertVisible) {\r\n                        open(data);\r\n                    } else if (!toolbarsOpen && iPhoneAlertVisible) {\r\n                        close();\r\n                    }\r\n                } else if (iPhoneAlertVisible) {\r\n                    close();\r\n                }\r\n                if (touches === 0) {\r\n                    iPhoneScrollFix();\r\n                }\r\n            }\r\n            var $scroller, interval;\r\n            var iPhoneAlertVisible;\r\n            var touches = 0;\r\n            $scroller = $('#iphone-scroll-up-pane');\r\n            $scroller.on('touchstart', function () {\r\n                touches++;\r\n            });\r\n            $scroller.on('touchend', function () {\r\n                touches--;\r\n            });\r\n            interval = setInterval(periodicCheck, 500);\r\n        }());\r\n    } else {\r\n        setInterval(function () {\r\n            var ww = window.innerWidth ? window.innerWidth : $(window).width();\r\n            var wh = window.innerHeight ? window.innerHeight : $(window).height();\r\n            if (ww !== lastWW || wh !== lastWH) {\r\n                resize();\r\n            }\r\n        }, 3000);\r\n    }\r\n\r\n    return model;\r\n    // ---------------------------------------------------------------------------\r\n\r\n    // runs when game startup is done\r\n    function onStartupFinished() {\r\n        gameStartupFinished = true;\r\n        // get references to all renderers and containers\r\n        renderers = engine.getRenderers();\r\n        containers = engine.getContainers();\r\n\r\n        // run first resize\r\n        lastWH = null;\r\n        lastWW = null;\r\n        resize();\r\n    }\r\n\r\n\r\n    // --- ELEMENTS RESIZING ---\r\n\r\n    function resize(force) {\r\n        // compute position and dimensions and perform resize\r\n        function _resize() {\r\n            updateFullScreenStatus();\r\n            updateLeftHandModeStatus();\r\n\r\n            var ww = window.innerWidth ? window.innerWidth : $(window).width();\r\n            var wh = window.innerHeight ? window.innerHeight : $(window).height();\r\n\r\n            if (gameStartupFinished && is_iPhone) {\r\n                wh = iPhone_adjustWH(ww, wh);\r\n            }\r\n\r\n            var data = computeDimensions({ww: ww, wh: wh});\r\n\r\n            updateRotateOverlayStatus(data);\r\n\r\n            if (ww !== lastWW || wh !== lastWH) {\r\n                lastWW = ww;\r\n                lastWH = wh;\r\n                adjustSizes(data);\r\n                updateModel(data);\r\n                // publish event signalling we have resized top elements\r\n                // subsequently the visible nested elements will be resized\r\n                pubsub.publish('notify:dimensionsChanged');\r\n            }\r\n        }\r\n        if (gameStartupFinished && !force) {\r\n            clearTimeout(resizeTimeout);\r\n            resizeTimeout = setTimeout(_resize, 100);\r\n        } else {\r\n            _resize();\r\n        }\r\n    }\r\n\r\n    // compute the position and dimensions\r\n    // of top-level elements\r\n    // according to window size\r\n    // return computed sizes\r\n    function computeDimensions(data) {\r\n        var left, top, bottom, cutTop, cutBottom, cutSides, moveTop, canvasWidth,\r\n                canvasHeight, scaleX, scaleY;\r\n        var ratio = data.ww / data.wh;\r\n        var moveTop = 0;\r\n        if (ratio > (config.CANVAS_LIMITED_BY_HEIGHT_TRESHOLD_RATIO || 1.76)) {\r\n            // limited by height\r\n            cutTop = config.CANVAS_SIZE_TOP_MAX_CUT_PERCENT / 100;\r\n            cutBottom = config.CANVAS_SIZE_BOTTOM_MAX_CUT_PERCENT / 100;\r\n            canvasHeight = data.wh + (cutTop + cutBottom) * data.wh;\r\n            canvasWidth = config.CANVAS_SIZE_DEFAULT_RATIO * canvasHeight;\r\n            top = -cutTop * data.wh;\r\n            bottom = -cutBottom * data.wh;\r\n            left = (data.ww - canvasWidth) / 2;\r\n            moveTop = 0;\r\n        } else {\r\n            // limited by width\r\n            cutSides = config.CANVAS_SIZE_WIDTH_MAX_CUT_PERCENT / 100;\r\n            canvasWidth = data.ww + (2 * cutSides) * data.ww;\r\n            canvasHeight = 1 / config.CANVAS_SIZE_DEFAULT_RATIO * canvasWidth;\r\n            left = -cutSides * data.ww;\r\n            top = (data.wh - canvasHeight)\r\n                    * (config.CANVAS_SIZE_TOP_MAX_CUT_PERCENT /\r\n                            (config.CANVAS_SIZE_BOTTOM_MAX_CUT_PERCENT\r\n                                    + config.CANVAS_SIZE_TOP_MAX_CUT_PERCENT))\r\n            bottom = (data.wh - canvasHeight)\r\n                    * (config.CANVAS_SIZE_BOTTOM_MAX_CUT_PERCENT /\r\n                            (config.CANVAS_SIZE_BOTTOM_MAX_CUT_PERCENT\r\n                                    + config.CANVAS_SIZE_TOP_MAX_CUT_PERCENT))\r\n//            top = bottom = (data.wh - canvasHeight) / 2;\r\n//            top = bottom = (data.wh - canvasHeight) / 2;\r\n            moveTop = config.CANVAS_LIMITED_BY_WIDTH_OFFSET_TOP;\r\n        }\r\n\r\n        var transform, resizeCanvasWidth, resizeCanvasHeight,\r\n                pixiScaleX, pixiScaleY;\r\n        if (ratio > config.CANVAS_SIZE_DEFAULT_RATIO) {\r\n            resizeCanvasWidth = data.ww - left;\r\n            resizeCanvasHeight = data.wh;\r\n        } else {\r\n            resizeCanvasWidth = data.ww;\r\n            resizeCanvasHeight = data.wh - top;\r\n        }\r\n\r\n        // round the values\r\n        scaleX = Math.round((canvasWidth / config.CANVAS_BASE_WIDTH) * 1000) / 1000;\r\n        scaleY = scaleX;\r\n//        if (scaleX < .8 && scaleY < .8) {\r\n        if (true) {\r\n            // scale down by CSS transform\r\n            // this kind of scaling is used when scaling down from base size\r\n            // as opposed to PIXI scaling which is used when scaling up\r\n            transform = 'scale( ' + scaleX + ',' + scaleY + ')';\r\n            pixiScaleX = 1;\r\n            pixiScaleY = 1;\r\n            resizeCanvasWidth /= scaleX;\r\n            resizeCanvasHeight /= scaleY;\r\n        } else {\r\n            // scale up by PIXI\r\n            // this kind of scaling is used when scaling up from base size\r\n            // as opposed to CSS scaling which is used when scaling down\r\n            transform = '';\r\n            pixiScaleX = scaleX;\r\n            pixiScaleY = scaleY;\r\n        }\r\n\r\n        data = {\r\n            ww: data.ww,\r\n            wh: data.wh,\r\n            ratio: ratio,\r\n            top: top,\r\n            bottom: bottom,\r\n            left: left,\r\n            canvasWidth: canvasWidth,\r\n            canvasHeight: canvasHeight,\r\n            resizeCanvasWidth: resizeCanvasWidth,\r\n            resizeCanvasHeight: resizeCanvasHeight,\r\n            scaleX: scaleX,\r\n            scaleY: scaleY,\r\n            transform: transform,\r\n            pixiScaleX: pixiScaleX,\r\n            pixiScaleY: pixiScaleY,\r\n            moveTop: moveTop\r\n        };\r\n\r\n        return data;\r\n    }\r\n\r\n    // update top-level element position and dimensions\r\n    // according to computed values\r\n    function adjustSizes(data) {\r\n        if (gameStartupFinished) {\r\n            // HTML elements (other than canvases) wrapper\r\n            var transform = 'translate(' + data.left + 'px,' + data.top\r\n                    + 'px) scale(' + data.scaleX + ',' + data.scaleY + ')';\r\n            $htmlStaticWrap.css({\r\n                left: data.left,\r\n                top: data.top,\r\n                width: data.canvasWidth,\r\n                height: data.canvasHeight,\r\n            });\r\n            $htmlDynamicWraps.css({\r\n                width: config.CANVAS_BASE_WIDTH,\r\n                height: config.CANVAS_BASE_HEIGHT,\r\n                transform: transform,\r\n                'webkit-transform': transform,\r\n            });\r\n            // canvas elements wrappers\r\n            $canvasWrap.children().css({\r\n                // scale canvas elements by CSS transform\r\n                // this kind of scaling is used when scaling down from base size\r\n                // as opposed to PIXI scaling which is used when scaling up\r\n                transform: data.transform\r\n            });\r\n            // resize canvases by PIXI\r\n            if (renderers) {\r\n                for (var i = 0; i < renderers.length; i++) {\r\n                    if (platform.is_iOS()) {\r\n                        // fix for Safari mobile rendering\r\n                        renderers[i].resize(data.resizeCanvasWidth / 2, data.resizeCanvasHeight / 2);\r\n                    }\r\n                    renderers[i].resize(data.resizeCanvasWidth, data.resizeCanvasHeight);\r\n                }\r\n            }\r\n            // scale canvas container elements by PIXI\r\n            // this kind of scaling is used when scaling up from base size\r\n            // as opposed to CSS scaling which is used when scaling down\r\n            if (containers) {\r\n                for (var i = 0; i < containers.length; i++) {\r\n                    containers[i].scale.x = data.pixiScaleX;\r\n                    containers[i].scale.y = data.pixiScaleY;\r\n                    containers[i].needsRepaint = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        $html.css('font-size', config.DEFAULT_FONT_SIZE * data.scaleY + 'px');\r\n    }\r\n\r\n    // --- FULL SCREEN HANDLING ---\r\n\r\n    // check if we are in full screen\r\n    // and update the views accordingly\r\n    function updateFullScreenStatus() {\r\n        pubsub.publish('request:updateFS_views', {\r\n            fullScreen: getFullScreen()\r\n        });\r\n    }\r\n    // request layout update if left hand mode settings has changed\r\n    function updateLeftHandModeStatus() {\r\n        if (gameStartupFinished && settings.get().graphics.lefthand !== leftHandModeActive) {\r\n            leftHandModeActive = settings.get().graphics.lefthand;\r\n            var key = leftHandModeActive ? 'lefthand' : 'righthand';\r\n            pubsub.publish('request:updateLayout', key);\r\n        }\r\n    }\r\n    // toggle FS\r\n    function toggleFullScreen() {\r\n        setFullScreen(!getFullScreen());\r\n    }\r\n\r\n    // return whether the game is running in full screen\r\n    function getFullScreen() {\r\n        if (document.webkitCurrentFullScreenElement) {\r\n            return true;\r\n        }\r\n        return window.outerHeight === screen.height;\r\n    }\r\n\r\n    // set full screen ON/OFF\r\n    function setFullScreen(id, data) {\r\n        function setFS() {\r\n            var el = window.document.body;\r\n            var requestMethod =\r\n                    el.requestFullScreen\r\n                    || el.webkitRequestFullScreen\r\n                    || el.mozRequestFullScreen\r\n                    || el.msRequestFullscreen;\r\n            if (requestMethod) {\r\n                requestMethod.call(el);\r\n            }\r\n        }\r\n        var state = data.fullScreen;\r\n        if (state) {\r\n            setFS();\r\n        }\r\n    }\r\n\r\n\r\n    // --- HELPERS ---\r\n\r\n\r\n    // update public object\r\n    function updateModel(data) {\r\n        model.canvasScaleX = data.scaleX;\r\n        model.canvasScaleY = data.scaleY;\r\n        model.topLevelWrappersOffsetX = data.left;\r\n        model.topLevelWrappersOffsetY = data.top;\r\n        model.topLevelWrappersOffsetBottom = data.bottom;\r\n        model.moveTop = data.moveTop;\r\n        model.canvasWidth = data.canvasWidth;\r\n        model.canvasHeight = data.canvasHeight;\r\n        model.windowWidth = data.ww;\r\n        model.windowHeight = data.wh;\r\n    }\r\n\r\n    function disableScroll_iPhone() {\r\n        $(document).on('touchmove', function (e) {\r\n            if ($(e.target).closest('#iphone-scroll-up-pane').length === 0) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n    }\r\n\r\n    // disable scrolling the page\r\n    function disableScroll() {\r\n        $('#preloader').on('touchstart', function (e) {\r\n            e.preventDefault();\r\n        });\r\n        //uses document because document will be topmost level in bubbling\r\n        $(document).on('touchmove', function (e) {\r\n            e.preventDefault();\r\n        });\r\n        //uses body because jquery on events are called off of the element they are\r\n        //added to, so bubbling would not work if we used document instead.\r\n        $('body').on('touchstart', '.scrollable', function (e) {\r\n            if (e.currentTarget.scrollTop === 0) {\r\n                e.currentTarget.scrollTop = 1;\r\n            } else if (e.currentTarget.scrollHeight === e.currentTarget.scrollTop + e.currentTarget.offsetHeight) {\r\n                e.currentTarget.scrollTop -= 1;\r\n            }\r\n            e.preventDefault();\r\n        });\r\n        window.scrollTo(0, 0);\r\n        setTimeout(function () {\r\n            window.scrollTo(0, 0);\r\n        }, 0);\r\n    }\r\n\r\n    function updateRotateOverlayStatus(data) {\r\n        if (gameStartupFinished\r\n                && data.wh > data.ww && data.ww < 420) {\r\n            if (!$html.hasClass('rotate-overlay-visible')) {\r\n                $html.addClass('rotate-overlay-visible');\r\n                pubsub.publish('notify:overlayDisplayed', {\r\n                    type: 'rotate'\r\n                });\r\n            }\r\n        } else {\r\n            if ($html.hasClass('rotate-overlay-visible')) {\r\n                $html.removeClass('rotate-overlay-visible');\r\n                pubsub.publish('notify:overlayHidden', {\r\n                    type: 'rotate'\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function iPhone_adjustWH(ww, wh) {\r\n        var adjusted;\r\n        var pwh = window.innerHeight;\r\n        for (var i = 0; i < IPHONE_DIMS.length; i++) {\r\n            if (ww === IPHONE_DIMS[i][0]) {\r\n                adjusted = IPHONE_DIMS[i][1];\r\n                return adjusted - (pwh - wh);\r\n            }\r\n        }\r\n        return wh;\r\n    }\r\n\r\n\r\n    function blurBackCanvas() {\r\n        $('canvas').eq(0).addClass('blur');\r\n        $('canvas').eq(2).addClass('blur');\r\n    }\r\n    function unblurCanvas() {\r\n        $('canvas').eq(0).removeClass('blur');\r\n        $('canvas').eq(2).removeClass('blur');\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/dimensions.js"),eval("define('components/Element',[\r\n    'jquery',\r\n    'pixi',\r\n    'pubsub',\r\n    'data/config',\r\n    'services/engine',\r\n    'services/dimensions',\r\n    'services/pause',\r\n], function ($, PIXI, pubsub, config, engine, dimensions, pause) {\r\n\r\n    var lastUpdate = {};\r\n\r\n    return function create(options) {\r\n\r\n        var proto = {\r\n            // object references the groupCtrl element belongs to\r\n            groupCtrl: options.groupCtrl,\r\n            // flag defines whether elements is visible\r\n            visible: false,\r\n            // array or object contains nested PIXI elements\r\n            pixiEl: null,\r\n            // children array\r\n            children: null,\r\n            // array or object contains nested jquery elements\r\n            jQueryEl: null,\r\n            // default element initialization\r\n            init: function (options) {\r\n                var self = this;\r\n                options = options || {};\r\n                self.name = options.name || 'Element';\r\n                self.parent = options.parent;\r\n                self.mask = options.mask;\r\n                self.left = options.left;\r\n                self.top = options.top;\r\n                self.width = options.width;\r\n                self.height = options.height;\r\n                self.zIndex = options.zIndex || undefined;\r\n                self.opacity = options.opacity || 1;\r\n                self.maxOpacity = options.maxOpacity || 1;\r\n                self.originX = options.originX || 'left';\r\n                self.originY = options.originY || 'top';\r\n                self.canvasLayer = options.canvasLayer;\r\n                self.rotate = options.rotate || undefined;\r\n                self.scaleX = options.scaleX || 1;\r\n                self.scaleY = options.scaleY || 1;\r\n                self.isReelsAreaElement = options.isReelsAreaElement || undefined;\r\n                self.flipX = options.flipX;\r\n                self.flipY = options.flipY;\r\n                self.roundCoords = options.roundCoords;\r\n                self.centerVertical = options.centerVertical;\r\n                self.mode = options.mode;\r\n                self.interactive = options.interactive;\r\n                self.domElement = options.domElement;\r\n                self.css = options.css;\r\n                self.domContainerParent = options.domContainerParent;\r\n\r\n                if (options.layouts) {\r\n                    self.layouts = options.layouts;\r\n                    self.currentLayout = options.currentLayout;\r\n                    pubsub.subscribe('request:updateLayout', function (id, layout) {\r\n                        if (self.layouts[layout]) {\r\n                            self.updateLayout(layout);\r\n                        }\r\n                    });\r\n                }\r\n            },\r\n            // set requested element layout\r\n            updateLayout: function (layout) {\r\n                if (layout) {\r\n                    this.currentLayout = layout;\r\n                    var p = this.layouts[this.currentLayout];\r\n                    p.init && p.init();\r\n                    p.props && this.set(p.props);\r\n                }\r\n            },\r\n            // function handles element resizing\r\n            // according to screen size and stretch settings\r\n            resize: function (options) {\r\n                options = typeof options === 'object' || {};\r\n                if (this.visible || options.forceResize) {\r\n                    if (this.pixiEl) {\r\n                        // PIXI element resize\r\n                        if (this.pixiEl instanceof Array) {\r\n                            var length = this.pixiEl.length;\r\n                            for (var i = 0; i < length; i++) {\r\n                                this.pixiEl[i].resize();\r\n                            }\r\n                        } else {\r\n                            resizeElementPixi(this, this.pixiEl);\r\n                        }\r\n                        this.render();\r\n                    }\r\n                    if (this.jQueryEl) {\r\n                        // jQuery element resize\r\n                        if (this.jQueryEl instanceof Array) {\r\n                            var length = this.jQueryEl.length;\r\n                            for (var i = 0; i < length; i++) {\r\n                                this.jQueryEl[i].resize();\r\n                            }\r\n                        } else {\r\n                            resizeElement_jQuery(this, this.jQueryEl);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            // function displays the element on stage\r\n            show: function (options) {\r\n                options = options || {};\r\n                if (!this.visible) {\r\n                    if (this.blinkInterval) {\r\n                        pause.clearInterval(this.blinkInterval);\r\n                    }\r\n                    if (this.fadeInterval) {\r\n                        pause.clearInterval(this.fadeInterval);\r\n                    }\r\n                    this.visible = true;\r\n                    if (this.pixiEl && !window.pauseResizePixi) {\r\n                        this.resize();\r\n                    }\r\n                    if (this.jQueryEl && !window.pauseResizejQuery) {\r\n                        this.resize();\r\n                    }\r\n                    if (this.pixiEl) {\r\n                        var pixiEl = this.pixiEl;\r\n                        if (pixiEl instanceof Array) {\r\n                            for (var i = 0; i < pixiEl.length; i++) {\r\n                                pixiEl[i].show(options);\r\n                            }\r\n                        } else {\r\n                            var canvas = engine.getContainer(this.canvasLayer);\r\n                            canvas.addChild(pixiEl);\r\n                            if (pixiEl.mask) {\r\n                                canvas.addChild(pixiEl.mask);\r\n                            }\r\n                            canvas.reorder();\r\n                            canvas.needsRepaint = true;\r\n                        }\r\n                    }\r\n                    if (this.jQueryEl) {\r\n                        var jQueryEl = this.jQueryEl;\r\n                        if (jQueryEl instanceof Array) {\r\n                            for (var i = 0; i < jQueryEl.length; i++) {\r\n                                jQueryEl[i].show();\r\n                            }\r\n                        } else {\r\n                            if (jQueryEl.jQueryEl) {\r\n                                jQueryEl = jQueryEl.jQueryEl;\r\n                            }\r\n                            jQueryEl[0].style.display = 'block';\r\n                        }\r\n                    }\r\n                    this.updateLayout(this.currentLayout);\r\n                }\r\n            },\r\n            // function hides the element from stage\r\n            hide: function (options) {\r\n                options = options || {};\r\n                if (this.visible) {\r\n                    if (this.blinkInterval) {\r\n                        pause.clearInterval(this.blinkInterval);\r\n                    }\r\n                    if (this.fadeInterval) {\r\n                        pause.clearInterval(this.fadeInterval);\r\n                    }\r\n                    this.visible = false;\r\n                    if (this.pixiEl) {\r\n                        var pixiEl = this.pixiEl;\r\n                        if (pixiEl instanceof Array) {\r\n                            for (var i = 0; i < pixiEl.length; i++) {\r\n                                pixiEl[i].hide(options);\r\n                            }\r\n                        } else {\r\n                            var canvas = engine.getContainer(this.canvasLayer);\r\n                            if (canvas.children.indexOf(pixiEl) > -1) {\r\n                                canvas.removeChild(pixiEl);\r\n                                if (pixiEl.mask) {\r\n                                    canvas.removeChild(pixiEl.mask);\r\n                                }\r\n                                canvas.needsRepaint = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (this.jQueryEl) {\r\n                        var jQueryEl = this.jQueryEl;\r\n                        if (jQueryEl instanceof Array) {\r\n                            for (var i = 0; i < jQueryEl.length; i++) {\r\n                                jQueryEl[i].hide();\r\n                            }\r\n                        } else {\r\n                            if (jQueryEl.jQueryEl) {\r\n                                jQueryEl = jQueryEl.jQueryEl;\r\n                            }\r\n                            jQueryEl[0].style.display = 'none';\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            addChildren: function (arr) {\r\n                if (arr.length === undefined) {\r\n                    var a = [];\r\n                    var ks = Object.keys(arr);\r\n                    for (var i = 0; i < ks.length; i++) {\r\n                        if (arr[ks[i]] !== this) {\r\n                            a.push(arr[ks[i]]);\r\n                        }\r\n                    }\r\n                    arr = a;\r\n                }\r\n                if (!this.children) {\r\n                    this.children = arr;\r\n                } else {\r\n                    this.children = this.children.concat(arr);\r\n                }\r\n            },\r\n            // function clears the element texture from cache\r\n            destroy: function (alsoDestroyBaseTexture) {\r\n                if (this.pixiEl instanceof Array) {\r\n                    for (var i = 0; i < this.pixiEl.length; i++) {\r\n                        this.pixiEl[i].destroy();\r\n                    }\r\n                } else {\r\n                    if (this.pixiEl && this.pixiEl.texture) {\r\n                        this.pixiEl.texture.destroy(alsoDestroyBaseTexture);\r\n                    }\r\n                }\r\n            },\r\n            // issues a request to render the element on stage\r\n            render: function () {\r\n                engine.getContainer(this.canvasLayer).needsRepaint = true;\r\n            },\r\n            // function updates the element properties with the new options\r\n            set: function (options) {\r\n                if (this.pixiEl instanceof Array) {\r\n                    for (var key in options) {\r\n                        if (options.hasOwnProperty(key)) {\r\n                            this[key] = options[key];\r\n                        }\r\n                    }\r\n                    for (var i = 0; i < this.pixiEl.length; i++) {\r\n                        this.pixiEl[i].set(options);\r\n                    }\r\n                } else {\r\n                    for (var key in options) {\r\n                        if (options.hasOwnProperty(key)) {\r\n                            this[key] = options[key];\r\n                        }\r\n                    }\r\n                    this.resize();\r\n                }\r\n            },\r\n            // shows the element on stage with a fade animation\r\n            fadeIn: function (cb, time) {\r\n                var self = this;\r\n                if (self.pixiEl instanceof Array) {\r\n                    self.visible = true;\r\n                    for (var i = 0; i < self.pixiEl.length; i++) {\r\n                        self.pixiEl[i].fadeIn(cb, time);\r\n                    }\r\n                } else {\r\n                    if (!time) {\r\n                        time = 1000;\r\n                    }\r\n                    if (self.pixiEl) {\r\n                        self.opacity = 0.001;\r\n//                        console.log('opacity show = ', self.opacity);\r\n                        self.show();\r\n                        var timeStart = Date.now();\r\n                        var diff;\r\n                        pause.clearInterval(self.fadeInterval);\r\n                        self.fadeInterval = pause.setInterval(function () {\r\n                            diff = Date.now() - timeStart;\r\n                            self.opacity = diff / time;\r\n                            if (self.opacity >= 1) {\r\n                                self.opacity = 1;\r\n                                pause.clearInterval(self.fadeInterval);\r\n                                if (cb) {\r\n                                    cb();\r\n                                }\r\n                            }\r\n//                            console.log('opacity = ', self.opacity);\r\n                            self.resize();\r\n                        }, 10);\r\n                    } else if (self.jQueryEl) {\r\n                        self.jQueryEl.fadeIn();\r\n                    }\r\n                }\r\n            },\r\n            // hides the element from stage with fade animation\r\n            fadeOut: function (cb, time) {\r\n                var self = this;\r\n                if (self.pixiEl instanceof Array) {\r\n                    self.visible = false;\r\n                    for (var i = 0; i < self.pixiEl.length; i++) {\r\n                        self.pixiEl[i].fadeOut(cb, time);\r\n                    }\r\n                } else {\r\n                    if (!time) {\r\n                        time = 1000;\r\n                    }\r\n                    if (self.pixiEl) {\r\n                        self.opacity = 1;\r\n                        var timeStart = Date.now();\r\n                        var diff;\r\n                        pause.clearInterval(self.fadeInterval);\r\n                        self.fadeInterval = pause.setInterval(function () {\r\n                            diff = Date.now() - timeStart;\r\n                            self.opacity = 1 - (diff / time);\r\n                            if (self.opacity <= 0) {\r\n                                self.hide();\r\n                                self.opacity = 1;\r\n                                pause.clearInterval(self.fadeInterval);\r\n                                if (cb) {\r\n                                    cb();\r\n                                }\r\n                            } else {\r\n                                self.resize();\r\n                            }\r\n                        }, 10);\r\n                    } else if (self.jQueryEl) {\r\n                        self.jQueryEl.fadeOut();\r\n                    }\r\n                }\r\n            },\r\n            // displays / shows the element periodically\r\n            blink: function (delay) {\r\n                var self = this;\r\n                if (self.blinkInterval) {\r\n                    pause.clearInterval(self.blinkInterval);\r\n                }\r\n                if (self.pixiEl || self.jQueryEl) {\r\n                    self.blinkInterval = pause.setInterval(function () {\r\n                        self.opacity = self.opacity === 1 ? 0.001 : 1;\r\n                        self.resize();\r\n                    }, delay || 300);\r\n                }\r\n            },\r\n            appendHTML: function () {\r\n                var self = this;\r\n                if (self.domContainerParent) {\r\n                    self.domContainerParent.contentWrapper.append(self.jQueryEl);\r\n                } else if (self.interactive) {\r\n                    $('#html-dynamic-wrap-interactive').append(self.jQueryEl);\r\n                } else {\r\n                    $('#html-dynamic-wrap').append(self.jQueryEl);\r\n                }\r\n            },\r\n        };\r\n        proto.init(options);\r\n        return proto;\r\n    };\r\n\r\n    // function handles resizing of PIXI elements\r\n    // on screen size changes\r\n    function resizeElementPixi(el, pixiEl) {\r\n        function getParentOffset(el) {\r\n            var off = {\r\n                left: 0,\r\n                top: 0\r\n            };\r\n            while (el.parent) {\r\n                off.left += el.parent.left;\r\n                off.top += el.parent.top;\r\n                el = el.parent;\r\n            }\r\n            return off;\r\n        }\r\n        // update position\r\n        var parentsOffset = getParentOffset(el);\r\n        pixiEl.x = parentsOffset.left + el.left;\r\n        pixiEl.y = parentsOffset.top + el.top;\r\n\r\n        if (el.mask) {\r\n            if (!pixiEl.mask) {\r\n                pixiEl.mask = new PIXI.Graphics();\r\n                pixiEl.mask.parentLeft = 0;\r\n                pixiEl.mask.parentTop = 0;\r\n                var height = el.mask.height;\r\n                var width = el.mask.width;\r\n                if (el.isReelsAreaElement) {\r\n                    width *= config.REELS_AREA_SCALE;\r\n                    height *= config.REELS_AREA_SCALE;\r\n                }\r\n                el.mask.initLeft = el.mask.left;\r\n                el.mask.initTop = el.mask.top;\r\n                pixiEl.mask.beginFill();\r\n                pixiEl.mask.drawRect(\r\n                        el.mask.left,\r\n                        el.mask.top,\r\n                        width,\r\n                        height);\r\n                pixiEl.mask.endFill();\r\n                pixiEl.mask.wrapper = el;\r\n                engine.getContainer(el.canvasLayer).addChild(pixiEl.mask);\r\n            }\r\n            pixiEl.mask.parentLeft = parentsOffset.left;\r\n            pixiEl.mask.parentTop = parentsOffset.top;\r\n            pixiEl.mask.x = pixiEl.mask.parentLeft + (el.mask.left - el.mask.initLeft);\r\n            pixiEl.mask.y = pixiEl.mask.parentTop + (el.mask.top - el.mask.initTop);\r\n            if (el.isReelsAreaElement) {\r\n                pixiEl.mask.x -= (config.REELS_AREA_SCALE - 1)\r\n                        * ((config.CANVAS_BASE_WIDTH / 2) - (el.mask.left));\r\n                pixiEl.mask.y -= (config.REELS_AREA_SCALE - 1)\r\n                        * ((config.CANVAS_BASE_HEIGHT / 2) - (el.mask.top));\r\n                pixiEl.mask.x += config.REELS_AREA_OFFSET_LEFT;\r\n                pixiEl.mask.y += config.REELS_AREA_OFFSET_TOP;\r\n            }\r\n\r\n            pixiEl.mask.x += (dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX);\r\n            pixiEl.mask.y += (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY);\r\n        }\r\n\r\n        // update size\r\n        if (el.width !== undefined && el.height !== undefined) {\r\n            pixiEl.width = el.width;\r\n            pixiEl.height = el.height;\r\n        }\r\n\r\n        if (el.isReelsAreaElement) {\r\n            pixiEl.x -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_WIDTH / 2) - pixiEl.x);\r\n            pixiEl.y -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_HEIGHT / 2) - pixiEl.y);\r\n            pixiEl.x += config.REELS_AREA_OFFSET_LEFT;\r\n            pixiEl.y += config.REELS_AREA_OFFSET_TOP;\r\n            pixiEl.width = config.REELS_AREA_SCALE * pixiEl.width;\r\n            pixiEl.height = config.REELS_AREA_SCALE * pixiEl.height;\r\n        }\r\n\r\n        // update scale\r\n        if (el.scaleX) {\r\n            pixiEl.width = el.scaleX * pixiEl.width;\r\n        }\r\n        if (el.scaleY) {\r\n            pixiEl.height = el.scaleY * pixiEl.height;\r\n        }\r\n\r\n        if (el.centerVertical) {\r\n            if (dimensions.moveTop) {\r\n                pixiEl.y += (dimensions.moveTop / dimensions.canvasScaleY);\r\n            } else {\r\n                pixiEl.y -= (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY\r\n                        - dimensions.topLevelWrappersOffsetBottom / dimensions.canvasScaleY);\r\n            }\r\n        }\r\n\r\n        pixiEl.x += (dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX);\r\n        pixiEl.y += (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY);\r\n\r\n        // update originX\r\n        if (el.originX !== 'left') {\r\n            if (pixiEl.anchor) {\r\n                if (el.originX === 'center') {\r\n                    pixiEl.anchor = new PIXI.Point(.5, 0);\r\n                } else if (el.originX === 'right') {\r\n                    pixiEl.anchor = new PIXI.Point(1, 0);\r\n                }\r\n            } else {\r\n                if (el.originX === 'center') {\r\n                    pixiEl.pivot.x = pixiEl.width / 2;\r\n                } else if (el.originX === 'right') {\r\n                    pixiEl.pivot.x = pixiEl.width;\r\n                }\r\n            }\r\n        }\r\n        if (el.originY !== 'top') {\r\n            if (pixiEl.anchor) {\r\n                if (el.originY === 'center') {\r\n                    pixiEl.anchor = new PIXI.Point(pixiEl.anchor.x, .5);\r\n                } else if (el.originY === 'bottom') {\r\n                    pixiEl.anchor = new PIXI.Point(pixiEl.anchor.x, 1);\r\n                }\r\n            } else {\r\n                if (el.originY === 'center') {\r\n                    pixiEl.pivot.y = pixiEl.height / 2;\r\n                } else if (el.originY === 'bottom') {\r\n                    pixiEl.pivot.y = pixiEl.height;\r\n                }\r\n            }\r\n        }\r\n        // update flipX\r\n        if (el.flipX) {\r\n            pixiEl.x += pixiEl.width;\r\n            pixiEl.scale.x = -Math.abs(pixiEl.scale.x);\r\n        }\r\n        // update flipY\r\n        if (el.flipY) {\r\n            pixiEl.y += pixiEl.height;\r\n            pixiEl.scale.y = -Math.abs(pixiEl.scale.y);\r\n        }\r\n        // update rotation\r\n        if (el.rotate !== undefined) {\r\n            pixiEl.rotation = 2 * Math.PI * (el.rotate / 360);\r\n        }\r\n        // update opacity\r\n        if (el.opacity !== undefined) {\r\n            if (el.maxOpacity && el.opacity > el.maxOpacity) {\r\n                el.opacity = el.maxOpacity;\r\n            }\r\n            pixiEl.alpha = el.opacity;\r\n        }\r\n\r\n        if (el.roundCoords) {\r\n            pixiEl.x = Math.floor(pixiEl.x) + .5;\r\n            pixiEl.y = Math.floor(pixiEl.y) + .5;\r\n        }\r\n\r\n        // update children\r\n        if (el.children) {\r\n            for (var k = 0, len = el.children.length; k < len; k++) {\r\n                el.children[k].resize();\r\n            }\r\n        }\r\n    }\r\n    // function handles resizing of jQuery elements\r\n    // on screen size changes\r\n    function resizeElement_jQuery(el, jQueryEl) {\r\n        function removeUnnecessaryUpdate(update) {\r\n            var ks = Object.keys(update);\r\n            var ksLen = ks.length;\r\n            for (var i = 0; i < ks.length; i++) {\r\n                if (update.hasOwnProperty(ks[i])) {\r\n                    if (lastUpdate[ks[i]] !== undefined\r\n                            && lastUpdate[ks[i]] === update[ks[i]]) {\r\n                        delete update[ks[i]];\r\n                        ksLen -= 1;\r\n                    } else {\r\n                        lastUpdate[ks[i]] = update[ks[i]];\r\n                    }\r\n                }\r\n            }\r\n            return ksLen === 0 ? null : update;\r\n        }\r\n        function getParentOffset(el) {\r\n            var off = {\r\n                left: 0,\r\n                top: 0\r\n            };\r\n            while (el.parent) {\r\n                off.left += el.parent.left;\r\n                off.top += el.parent.top;\r\n                el = el.parent;\r\n            }\r\n            return off;\r\n        }\r\n\r\n        var update = {};\r\n\r\n        update.width = el.width * el.scaleX;\r\n        update.height = el.height * el.scaleY;\r\n\r\n\r\n        var parentsOffset = getParentOffset(el);\r\n        var left = (parentsOffset.left + el.left);\r\n        var top = (parentsOffset.top + el.top);\r\n\r\n        if (el.domElement) {\r\n            left *= dimensions.canvasScaleX;\r\n            top *= dimensions.canvasScaleY;\r\n            left += dimensions.topLevelWrappersOffsetX;\r\n            top += dimensions.topLevelWrappersOffsetY;\r\n            top += dimensions.moveTop;\r\n            update.width *= dimensions.canvasScaleX;\r\n            update.height *= dimensions.canvasScaleY;\r\n        }\r\n\r\n        el.originX === 'center' && (left -= (update.width) / 2);\r\n        el.originX === 'right' && (left -= update.width);\r\n        el.originY === 'center' && (top -= (update.height) / 2);\r\n        el.originY === 'right' && (top -= update.height);\r\n\r\n        if (el.centerVertical) {\r\n            if (dimensions.moveTop) {\r\n                top += (dimensions.moveTop / dimensions.canvasScaleY);\r\n            } else {\r\n                top -= (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY\r\n                        - dimensions.topLevelWrappersOffsetBottom / dimensions.canvasScaleY);\r\n            }\r\n        }\r\n\r\n        update.left = left;\r\n        update.top = top;\r\n\r\n        if (el.flipX) {\r\n            jQueryEl.addClass('flipX');\r\n        } else {\r\n            jQueryEl.removeClass('flipX');\r\n        }\r\n\r\n        if (el.zIndex) {\r\n            update['z-index'] = el.zIndex;\r\n        }\r\n        if (el.opacity !== undefined) {\r\n            update.opacity = el.opacity;\r\n        }\r\n\r\n//        update = removeUnnecessaryUpdate(update);\r\n        if (update) {\r\n            jQueryEl.css(update);\r\n        }\r\n\r\n        if (el.css) {\r\n            jQueryEl.css(el.css);\r\n        }\r\n\r\n        // update children\r\n        if (el.children) {\r\n            for (var k = 0, len = el.children.length; k < len; k++) {\r\n                el.children[k].resize();\r\n            }\r\n        }\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/Element.js"),
eval('/*!\r\n* SoundJS\r\n* Visit http://createjs.com/ for documentation, updates and examples.\r\n*\r\n* Copyright (c) 2010 gskinner.com, inc.\r\n*\r\n* Permission is hereby granted, free of charge, to any person\r\n* obtaining a copy of this software and associated documentation\r\n* files (the "Software"), to deal in the Software without\r\n* restriction, including without limitation the rights to use,\r\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the\r\n* Software is furnished to do so, subject to the following\r\n* conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be\r\n* included in all copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\r\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n* OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\n//##############################################################################\r\n// version.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\r\n\t/**\r\n\t * Static class holding library specific information such as the version and buildDate of the library.\r\n\t * The SoundJS class has been renamed {{#crossLink "Sound"}}{{/crossLink}}.  Please see {{#crossLink "Sound"}}{{/crossLink}}\r\n\t * for information on using sound.\r\n\t * @class SoundJS\r\n\t **/\r\n\tvar s = createjs.SoundJS = createjs.SoundJS || {};\r\n\r\n\t/**\r\n\t * The version string for this release.\r\n\t * @property version\r\n\t * @type String\r\n\t * @static\r\n\t **/\r\n\ts.version = /*=version*/"0.6.2"; // injected by build process\r\n\r\n\t/**\r\n\t * The build date for this release in UTC format.\r\n\t * @property buildDate\r\n\t * @type String\r\n\t * @static\r\n\t **/\r\n\ts.buildDate = /*=date*/"Thu, 26 Nov 2015 20:44:31 GMT"; // injected by build process\r\n\r\n})();\r\n\r\n//##############################################################################\r\n// extend.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n/**\r\n * @class Utility Methods\r\n */\r\n\r\n/**\r\n * Sets up the prototype chain and constructor property for a new class.\r\n *\r\n * This should be called right after creating the class constructor.\r\n *\r\n * \tfunction MySubClass() {}\r\n * \tcreatejs.extend(MySubClass, MySuperClass);\r\n * \tMySubClass.prototype.doSomething = function() { }\r\n *\r\n * \tvar foo = new MySubClass();\r\n * \tconsole.log(foo instanceof MySuperClass); // true\r\n * \tconsole.log(foo.prototype.constructor === MySubClass); // true\r\n *\r\n * @method extend\r\n * @param {Function} subclass The subclass.\r\n * @param {Function} superclass The superclass to extend.\r\n * @return {Function} Returns the subclass\'s new prototype.\r\n */\r\ncreatejs.extend = function(subclass, superclass) {\r\n\t"use strict";\r\n\r\n\tfunction o() { this.constructor = subclass; }\r\n\to.prototype = superclass.prototype;\r\n\treturn (subclass.prototype = new o());\r\n};\r\n\r\n//##############################################################################\r\n// promote.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n/**\r\n * @class Utility Methods\r\n */\r\n\r\n/**\r\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\r\n * It is recommended to use the super class\'s name as the prefix.\r\n * An alias to the super class\'s constructor is always added in the format `prefix_constructor`.\r\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\r\n *\r\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`\r\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\r\n * prototype of `MySubClass` as `MySuperClass_draw`.\r\n *\r\n * This should be called after the class\'s prototype is fully defined.\r\n *\r\n * \tfunction ClassA(name) {\r\n * \t\tthis.name = name;\r\n * \t}\r\n * \tClassA.prototype.greet = function() {\r\n * \t\treturn "Hello "+this.name;\r\n * \t}\r\n *\r\n * \tfunction ClassB(name, punctuation) {\r\n * \t\tthis.ClassA_constructor(name);\r\n * \t\tthis.punctuation = punctuation;\r\n * \t}\r\n * \tcreatejs.extend(ClassB, ClassA);\r\n * \tClassB.prototype.greet = function() {\r\n * \t\treturn this.ClassA_greet()+this.punctuation;\r\n * \t}\r\n * \tcreatejs.promote(ClassB, "ClassA");\r\n *\r\n * \tvar foo = new ClassB("World", "!?!");\r\n * \tconsole.log(foo.greet()); // Hello World!?!\r\n *\r\n * @method promote\r\n * @param {Function} subclass The class to promote super class methods on.\r\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\r\n * @return {Function} Returns the subclass.\r\n */\r\ncreatejs.promote = function(subclass, prefix) {\r\n\t"use strict";\r\n\r\n\tvar subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\r\n\tif (supP) {\r\n\t\tsubP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable\r\n\t\tfor (var n in supP) {\r\n\t\t\tif (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }\r\n\t\t}\r\n\t}\r\n\treturn subclass;\r\n};\r\n\r\n//##############################################################################\r\n// IndexOf.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n/**\r\n * @class Utility Methods\r\n */\r\n\r\n/**\r\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\r\n * that value.  Returns -1 if value is not found.\r\n *\r\n *      var i = createjs.indexOf(myArray, myElementToFind);\r\n *\r\n * @method indexOf\r\n * @param {Array} array Array to search for searchElement\r\n * @param searchElement Element to find in array.\r\n * @return {Number} The first index of searchElement in array.\r\n */\r\ncreatejs.indexOf = function (array, searchElement){\r\n\t"use strict";\r\n\r\n\tfor (var i = 0,l=array.length; i < l; i++) {\r\n\t\tif (searchElement === array[i]) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n};\r\n\r\n//##############################################################################\r\n// Proxy.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n/**\r\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\r\n * createjs namespace directly.\r\n *\r\n * <h4>Example</h4>\r\n *\r\n *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));\r\n *\r\n * @class Utility Methods\r\n * @main Utility Methods\r\n */\r\n\r\n(function() {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\r\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\r\n\t * method gets called in the correct scope.\r\n\t *\r\n\t * Additional arguments can be passed that will be applied to the function when it is called.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));\r\n\t *\r\n\t *      function myHandler(arg1, arg2) {\r\n\t *           // This gets called when myObject.myCallback is executed.\r\n\t *      }\r\n\t *\r\n\t * @method proxy\r\n\t * @param {Function} method The function to call\r\n\t * @param {Object} scope The scope to call the method name on\r\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\r\n\t * @public\r\n\t * @static\r\n\t */\r\n\tcreatejs.proxy = function (method, scope) {\r\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\r\n\t\treturn function () {\r\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\r\n\t\t};\r\n\t}\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// BrowserDetect.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n/**\r\n * @class Utility Methods\r\n */\r\n(function() {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * An object that determines the current browser, version, operating system, and other environment\r\n\t * variables via user agent string.\r\n\t *\r\n\t * Used for audio because feature detection is unable to detect the many limitations of mobile devices.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      if (createjs.BrowserDetect.isIOS) { // do stuff }\r\n\t *\r\n\t * @property BrowserDetect\r\n\t * @type {Object}\r\n\t * @param {Boolean} isFirefox True if our browser is Firefox.\r\n\t * @param {Boolean} isOpera True if our browser is opera.\r\n\t * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a\r\n\t * completely different browser with different abilities.\r\n\t * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).\r\n\t * @param {Boolean} isAndroid True if our browser is Android.\r\n\t * @param {Boolean} isBlackberry True if our browser is Blackberry.\r\n\t * @constructor\r\n\t * @static\r\n\t */\r\n\tfunction BrowserDetect() {\r\n\t\tthrow "BrowserDetect cannot be instantiated";\r\n\t};\r\n\r\n\tvar agent = BrowserDetect.agent = window.navigator.userAgent;\r\n\tBrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);\r\n\tBrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);\r\n\tBrowserDetect.isOpera = (window.opera != null);\r\n\tBrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities\r\n\tBrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;\r\n\tBrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;\r\n\tBrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);\r\n\r\n\tcreatejs.BrowserDetect = BrowserDetect;\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// EventDispatcher.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n(function() {\r\n\t"use strict";\r\n\r\n\r\n// constructor:\r\n\t/**\r\n\t * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\r\n\t *\r\n\t * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\r\n\t * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.\r\n\t * \r\n\t * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\r\n\t * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\r\n\t * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\r\n\t * \r\n\t * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier\r\n\t * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \r\n\t * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to\r\n\t * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.\r\n\t * \r\n\t * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}\r\n\t * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \r\n\t * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t * Add EventDispatcher capabilities to the "MyClass" class.\r\n\t *\r\n\t *      EventDispatcher.initialize(MyClass.prototype);\r\n\t *\r\n\t * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).\r\n\t *\r\n\t *      instance.addEventListener("eventName", handlerMethod);\r\n\t *      function handlerMethod(event) {\r\n\t *          console.log(event.target + " Was Clicked");\r\n\t *      }\r\n\t *\r\n\t * <b>Maintaining proper scope</b><br />\r\n\t * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}\r\n\t * method to subscribe to events simplifies this.\r\n\t *\r\n\t *      instance.addEventListener("click", function(event) {\r\n\t *          console.log(instance == this); // false, scope is ambiguous.\r\n\t *      });\r\n\t *      \r\n\t *      instance.on("click", function(event) {\r\n\t *          console.log(instance == this); // true, "on" uses dispatcher scope by default.\r\n\t *      });\r\n\t * \r\n\t * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage\r\n\t * scope.\r\n\t *\r\n\t * <b>Browser support</b>\r\n\t * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model\r\n\t * requires modern browsers (IE9+).\r\n\t *      \r\n\t *\r\n\t * @class EventDispatcher\r\n\t * @constructor\r\n\t **/\r\n\tfunction EventDispatcher() {\r\n\t\r\n\t\r\n\t// private properties:\r\n\t\t/**\r\n\t\t * @protected\r\n\t\t * @property _listeners\r\n\t\t * @type Object\r\n\t\t **/\r\n\t\tthis._listeners = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * @protected\r\n\t\t * @property _captureListeners\r\n\t\t * @type Object\r\n\t\t **/\r\n\t\tthis._captureListeners = null;\r\n\t}\r\n\tvar p = EventDispatcher.prototype;\r\n\r\n\t/**\r\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\r\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\r\n\t * for details.\r\n\t *\r\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\r\n\t *\r\n\t * @method initialize\r\n\t * @protected\r\n\t * @deprecated\r\n\t */\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\r\n\r\n\r\n// static public methods:\r\n\t/**\r\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\r\n\t * \r\n\t * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\r\n\t * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\r\n\t * \r\n\t * @method initialize\r\n\t * @static\r\n\t * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\r\n\t * prototype.\r\n\t **/\r\n\tEventDispatcher.initialize = function(target) {\r\n\t\ttarget.addEventListener = p.addEventListener;\r\n\t\ttarget.on = p.on;\r\n\t\ttarget.removeEventListener = target.off =  p.removeEventListener;\r\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\r\n\t\ttarget.hasEventListener = p.hasEventListener;\r\n\t\ttarget.dispatchEvent = p.dispatchEvent;\r\n\t\ttarget._dispatchEvent = p._dispatchEvent;\r\n\t\ttarget.willTrigger = p.willTrigger;\r\n\t};\r\n\t\r\n\r\n// public methods:\r\n\t/**\r\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\r\n\t * multiple callbacks getting fired.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      displayObject.addEventListener("click", handleClick);\r\n\t *      function handleClick(event) {\r\n\t *         // Click happened.\r\n\t *      }\r\n\t *\r\n\t * @method addEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\r\n\t * the event is dispatched.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t * @return {Function | Object} Returns the listener for chaining or assignment.\r\n\t **/\r\n\tp.addEventListener = function(type, listener, useCapture) {\r\n\t\tvar listeners;\r\n\t\tif (useCapture) {\r\n\t\t\tlisteners = this._captureListeners = this._captureListeners||{};\r\n\t\t} else {\r\n\t\t\tlisteners = this._listeners = this._listeners||{};\r\n\t\t}\r\n\t\tvar arr = listeners[type];\r\n\t\tif (arr) { this.removeEventListener(type, listener, useCapture); }\r\n\t\tarr = listeners[type]; // remove may have deleted the array\r\n\t\tif (!arr) { listeners[type] = [listener];  }\r\n\t\telse { arr.push(listener); }\r\n\t\treturn listener;\r\n\t};\r\n\t\r\n\t/**\r\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\r\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\r\n\t * \r\n\t * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\r\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\r\n\t * \r\n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\r\n\t * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\r\n\t * to `on` with the same params will create multiple listeners.\r\n\t * \r\n\t * <h4>Example</h4>\r\n\t * \r\n\t * \t\tvar listener = myBtn.on("click", handleClick, null, false, {count:3});\r\n\t * \t\tfunction handleClick(evt, data) {\r\n\t * \t\t\tdata.count -= 1;\r\n\t * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\r\n\t * \t\t\tif (data.count == 0) {\r\n\t * \t\t\t\talert("clicked 3 times!");\r\n\t * \t\t\t\tmyBtn.off("click", listener);\r\n\t * \t\t\t\t// alternately: evt.remove();\r\n\t * \t\t\t}\r\n\t * \t\t}\r\n\t * \r\n\t * @method on\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\r\n\t * the event is dispatched.\r\n\t * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\r\n\t * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\r\n\t * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\r\n\t * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\r\n\t **/\r\n\tp.on = function(type, listener, scope, once, data, useCapture) {\r\n\t\tif (listener.handleEvent) {\r\n\t\t\tscope = scope||listener;\r\n\t\t\tlistener = listener.handleEvent;\r\n\t\t}\r\n\t\tscope = scope||this;\r\n\t\treturn this.addEventListener(type, function(evt) {\r\n\t\t\t\tlistener.call(scope, evt, data);\r\n\t\t\t\tonce&&evt.remove();\r\n\t\t\t}, useCapture);\r\n\t};\r\n\r\n\t/**\r\n\t * Removes the specified event listener.\r\n\t *\r\n\t * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\r\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\r\n\t * closure will not work.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      displayObject.removeEventListener("click", handleClick);\r\n\t *\r\n\t * @method removeEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener The listener function or object.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t **/\r\n\tp.removeEventListener = function(type, listener, useCapture) {\r\n\t\tvar listeners = useCapture ? this._captureListeners : this._listeners;\r\n\t\tif (!listeners) { return; }\r\n\t\tvar arr = listeners[type];\r\n\t\tif (!arr) { return; }\r\n\t\tfor (var i=0,l=arr.length; i<l; i++) {\r\n\t\t\tif (arr[i] == listener) {\r\n\t\t\t\tif (l==1) { delete(listeners[type]); } // allows for faster checks.\r\n\t\t\t\telse { arr.splice(i,1); }\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\r\n\t * .on method.\r\n\t * \r\n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See \r\n\t * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.\r\n\t *\r\n\t * @method off\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener The listener function or object.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t **/\r\n\tp.off = p.removeEventListener;\r\n\r\n\t/**\r\n\t * Removes all listeners for the specified type, or all listeners of all types.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      // Remove all listeners\r\n\t *      displayObject.removeAllEventListeners();\r\n\t *\r\n\t *      // Remove all click listeners\r\n\t *      displayObject.removeAllEventListeners("click");\r\n\t *\r\n\t * @method removeAllEventListeners\r\n\t * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\r\n\t **/\r\n\tp.removeAllEventListeners = function(type) {\r\n\t\tif (!type) { this._listeners = this._captureListeners = null; }\r\n\t\telse {\r\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\r\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Dispatches the specified event to all listeners.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      // Use a string event\r\n\t *      this.dispatchEvent("complete");\r\n\t *\r\n\t *      // Use an Event instance\r\n\t *      var event = new createjs.Event("progress");\r\n\t *      this.dispatchEvent(event);\r\n\t *\r\n\t * @method dispatchEvent\r\n\t * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.\r\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\r\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\r\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\r\n\t * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\r\n\t * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\r\n\t * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\r\n\t **/\r\n\tp.dispatchEvent = function(eventObj, bubbles, cancelable) {\r\n\t\tif (typeof eventObj == "string") {\r\n\t\t\t// skip everything if there\'s no listeners and it doesn\'t bubble:\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\r\n\t\t\teventObj = new createjs.Event(eventObj, bubbles, cancelable);\r\n\t\t} else if (eventObj.target && eventObj.clone) {\r\n\t\t\t// redispatching an active event object, so clone it:\r\n\t\t\teventObj = eventObj.clone();\r\n\t\t}\r\n\t\t\r\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\r\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\r\n\r\n\t\tif (!eventObj.bubbles || !this.parent) {\r\n\t\t\tthis._dispatchEvent(eventObj, 2);\r\n\t\t} else {\r\n\t\t\tvar top=this, list=[top];\r\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\r\n\t\t\tvar i, l=list.length;\r\n\r\n\t\t\t// capture & atTarget\r\n\t\t\tfor (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\r\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\r\n\t\t\t}\r\n\t\t\t// bubbling\r\n\t\t\tfor (i=1; i<l && !eventObj.propagationStopped; i++) {\r\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn !eventObj.defaultPrevented;\r\n\t};\r\n\r\n\t/**\r\n\t * Indicates whether there is at least one listener for the specified event type.\r\n\t * @method hasEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @return {Boolean} Returns true if there is at least one listener for the specified event.\r\n\t **/\r\n\tp.hasEventListener = function(type) {\r\n\t\tvar listeners = this._listeners, captureListeners = this._captureListeners;\r\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\r\n\t};\r\n\t\r\n\t/**\r\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\r\n\t * ancestors (parent, parent\'s parent, etc). A return value of true indicates that if a bubbling event of the\r\n\t * specified type is dispatched from this object, it will trigger at least one listener.\r\n\t * \r\n\t * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire\r\n\t * event flow for a listener, not just this object.\r\n\t * @method willTrigger\r\n\t * @param {String} type The string type of the event.\r\n\t * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\r\n\t **/\r\n\tp.willTrigger = function(type) {\r\n\t\tvar o = this;\r\n\t\twhile (o) {\r\n\t\t\tif (o.hasEventListener(type)) { return true; }\r\n\t\t\to = o.parent;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @method toString\r\n\t * @return {String} a string representation of the instance.\r\n\t **/\r\n\tp.toString = function() {\r\n\t\treturn "[EventDispatcher]";\r\n\t};\r\n\r\n\r\n// private methods:\r\n\t/**\r\n\t * @method _dispatchEvent\r\n\t * @param {Object | String | Event} eventObj\r\n\t * @param {Object} eventPhase\r\n\t * @protected\r\n\t **/\r\n\tp._dispatchEvent = function(eventObj, eventPhase) {\r\n\t\tvar l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;\r\n\t\tif (eventObj && listeners) {\r\n\t\t\tvar arr = listeners[eventObj.type];\r\n\t\t\tif (!arr||!(l=arr.length)) { return; }\r\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\r\n\t\t\ttry { eventObj.eventPhase = eventPhase; } catch (e) {}\r\n\t\t\teventObj.removed = false;\r\n\t\t\t\r\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\r\n\t\t\tfor (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\r\n\t\t\t\tvar o = arr[i];\r\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\r\n\t\t\t\telse { o(eventObj); }\r\n\t\t\t\tif (eventObj.removed) {\r\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase==1);\r\n\t\t\t\t\teventObj.removed = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tcreatejs.EventDispatcher = EventDispatcher;\r\n}());\r\n\r\n//##############################################################################\r\n// Event.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n(function() {\r\n\t"use strict";\r\n\r\n// constructor:\r\n\t/**\r\n\t * Contains properties and methods shared by all events for use with\r\n\t * {{#crossLink "EventDispatcher"}}{{/crossLink}}.\r\n\t * \r\n\t * Note that Event objects are often reused, so you should never\r\n\t * rely on an event object\'s state outside of the call stack it was received in.\r\n\t * @class Event\r\n\t * @param {String} type The event type.\r\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\r\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\r\n\t * @constructor\r\n\t **/\r\n\tfunction Event(type, bubbles, cancelable) {\r\n\t\t\r\n\t\r\n\t// public properties:\r\n\t\t/**\r\n\t\t * The type of event.\r\n\t\t * @property type\r\n\t\t * @type String\r\n\t\t **/\r\n\t\tthis.type = type;\r\n\t\r\n\t\t/**\r\n\t\t * The object that generated an event.\r\n\t\t * @property target\r\n\t\t * @type Object\r\n\t\t * @default null\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.target = null;\r\n\t\r\n\t\t/**\r\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\r\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\r\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\r\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\r\n\t\t * @property currentTarget\r\n\t\t * @type Object\r\n\t\t * @default null\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.currentTarget = null;\r\n\t\r\n\t\t/**\r\n\t\t * For bubbling events, this indicates the current event phase:<OL>\r\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\r\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\r\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\r\n\t\t * </OL>\r\n\t\t * @property eventPhase\r\n\t\t * @type Number\r\n\t\t * @default 0\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.eventPhase = 0;\r\n\t\r\n\t\t/**\r\n\t\t * Indicates whether the event will bubble through the display list.\r\n\t\t * @property bubbles\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.bubbles = !!bubbles;\r\n\t\r\n\t\t/**\r\n\t\t * Indicates whether the default behaviour of this event can be cancelled via\r\n\t\t * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.\r\n\t\t * @property cancelable\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.cancelable = !!cancelable;\r\n\t\r\n\t\t/**\r\n\t\t * The epoch time at which this event was created.\r\n\t\t * @property timeStamp\r\n\t\t * @type Number\r\n\t\t * @default 0\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.timeStamp = (new Date()).getTime();\r\n\t\r\n\t\t/**\r\n\t\t * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called\r\n\t\t * on this event.\r\n\t\t * @property defaultPrevented\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.defaultPrevented = false;\r\n\t\r\n\t\t/**\r\n\t\t * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or\r\n\t\t * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.\r\n\t\t * @property propagationStopped\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.propagationStopped = false;\r\n\t\r\n\t\t/**\r\n\t\t * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called\r\n\t\t * on this event.\r\n\t\t * @property immediatePropagationStopped\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.immediatePropagationStopped = false;\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.\r\n\t\t * @property removed\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t * @readonly\r\n\t\t*/\r\n\t\tthis.removed = false;\r\n\t}\r\n\tvar p = Event.prototype;\r\n\r\n\t/**\r\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\r\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\r\n\t * for details.\r\n\t *\r\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\r\n\t *\r\n\t * @method initialize\r\n\t * @protected\r\n\t * @deprecated\r\n\t */\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\r\n\r\n// public methods:\r\n\t/**\r\n\t * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.\r\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\r\n\t * cancel the default behaviour associated with the event.\r\n\t * @method preventDefault\r\n\t **/\r\n\tp.preventDefault = function() {\r\n\t\tthis.defaultPrevented = this.cancelable&&true;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.\r\n\t * Mirrors the DOM event standard.\r\n\t * @method stopPropagation\r\n\t **/\r\n\tp.stopPropagation = function() {\r\n\t\tthis.propagationStopped = true;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and\r\n\t * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.\r\n\t * Mirrors the DOM event standard.\r\n\t * @method stopImmediatePropagation\r\n\t **/\r\n\tp.stopImmediatePropagation = function() {\r\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Causes the active listener to be removed via removeEventListener();\r\n\t * \r\n\t * \t\tmyBtn.addEventListener("click", function(evt) {\r\n\t * \t\t\t// do stuff...\r\n\t * \t\t\tevt.remove(); // removes this listener.\r\n\t * \t\t});\r\n\t * \r\n\t * @method remove\r\n\t **/\r\n\tp.remove = function() {\r\n\t\tthis.removed = true;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Returns a clone of the Event instance.\r\n\t * @method clone\r\n\t * @return {Event} a clone of the Event instance.\r\n\t **/\r\n\tp.clone = function() {\r\n\t\treturn new Event(this.type, this.bubbles, this.cancelable);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\r\n\t *\r\n\t * @method set\r\n\t * @param {Object} props A generic object containing properties to copy to the instance.\r\n\t * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\r\n\t * @chainable\r\n\t*/\r\n\tp.set = function(props) {\r\n\t\tfor (var n in props) { this[n] = props[n]; }\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a string representation of this object.\r\n\t * @method toString\r\n\t * @return {String} a string representation of the instance.\r\n\t **/\r\n\tp.toString = function() {\r\n\t\treturn "[Event (type="+this.type+")]";\r\n\t};\r\n\r\n\tcreatejs.Event = Event;\r\n}());\r\n\r\n//##############################################################################\r\n// ErrorEvent.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs||{};\r\n\r\n(function() {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.\r\n\t * @class ErrorEvent\r\n\t * @param {String} [title] The error title\r\n\t * @param {String} [message] The error description\r\n\t * @param {Object} [data] Additional error data\r\n\t * @constructor\r\n\t */\r\n\tfunction ErrorEvent(title, message, data) {\r\n\t\tthis.Event_constructor("error");\r\n\r\n\t\t/**\r\n\t\t * The short error title, which indicates the type of error that occurred.\r\n\t\t * @property title\r\n\t\t * @type String\r\n\t\t */\r\n\t\tthis.title = title;\r\n\r\n\t\t/**\r\n\t\t * The verbose error message, containing details about the error.\r\n\t\t * @property message\r\n\t\t * @type String\r\n\t\t */\r\n\t\tthis.message = message;\r\n\r\n\t\t/**\r\n\t\t * Additional data attached to an error.\r\n\t\t * @property data\r\n\t\t * @type {Object}\r\n\t\t */\r\n\t\tthis.data = data;\r\n\t}\r\n\r\n\tvar p = createjs.extend(ErrorEvent, createjs.Event);\r\n\r\n\tp.clone = function() {\r\n\t\treturn new createjs.ErrorEvent(this.title, this.message, this.data);\r\n\t};\r\n\r\n\tcreatejs.ErrorEvent = createjs.promote(ErrorEvent, "Event");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// ProgressEvent.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function (scope) {\r\n\t"use strict";\r\n\r\n\t// constructor\r\n\t/**\r\n\t * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.\r\n\t * @class ProgressEvent\r\n\t * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.\r\n\t * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is\r\n\t * a percentage (between 0 and 1), it can be omitted.\r\n\t * @todo Consider having this event be a "fileprogress" event as well\r\n\t * @constructor\r\n\t */\r\n\tfunction ProgressEvent(loaded, total) {\r\n\t\tthis.Event_constructor("progress");\r\n\r\n\t\t/**\r\n\t\t * The amount that has been loaded (out of a total amount)\r\n\t\t * @property loaded\r\n\t\t * @type {Number}\r\n\t\t */\r\n\t\tthis.loaded = loaded;\r\n\r\n\t\t/**\r\n\t\t * The total "size" of the load.\r\n\t\t * @property total\r\n\t\t * @type {Number}\r\n\t\t * @default 1\r\n\t\t */\r\n\t\tthis.total = (total == null) ? 1 : total;\r\n\r\n\t\t/**\r\n\t\t * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.\r\n\t\t * @property progress\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t */\r\n\t\tthis.progress = (total == 0) ? 0 : this.loaded / this.total;\r\n\t};\r\n\r\n\tvar p = createjs.extend(ProgressEvent, createjs.Event);\r\n\r\n\t/**\r\n\t * Returns a clone of the ProgressEvent instance.\r\n\t * @method clone\r\n\t * @return {ProgressEvent} a clone of the Event instance.\r\n\t **/\r\n\tp.clone = function() {\r\n\t\treturn new createjs.ProgressEvent(this.loaded, this.total);\r\n\t};\r\n\r\n\tcreatejs.ProgressEvent = createjs.promote(ProgressEvent, "Event");\r\n\r\n}(window));\r\n\r\n//##############################################################################\r\n// LoadItem.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,\r\n\t * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A\r\n\t * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the\r\n\t * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}\r\n\t * @class LoadItem\r\n\t * @constructor\r\n\t * @since 0.6.0\r\n\t */\r\n\tfunction LoadItem() {\r\n\t\t/**\r\n\t\t * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a\r\n\t\t * string (recommended), or an HTML tag.\r\n\t\t * This can also be an object, but in that case it has to include a type and be handled by a plugin.\r\n\t\t * @property src\r\n\t\t * @type {String}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.src = null;\r\n\r\n\t\t/**\r\n\t\t * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also\r\n\t\t * be set manually. This is helpful in cases where a file does not have an extension.\r\n\t\t * @property type\r\n\t\t * @type {String}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.type = null;\r\n\r\n\t\t/**\r\n\t\t * A string identifier which can be used to reference the loaded object. If none is provided, this will be\r\n\t\t * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.\r\n\t\t * @property id\r\n\t\t * @type {String}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.id = null;\r\n\r\n\t\t/**\r\n\t\t * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest\r\n\t\t * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has\r\n\t\t * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this\r\n\t\t * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in\r\n\t\t * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.\r\n\t\t * @property maintainOrder\r\n\t\t * @type {Boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.maintainOrder = false;\r\n\r\n\t\t/**\r\n\t\t * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.\r\n\t\t * @property callback\r\n\t\t * @type {String}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.callback = null;\r\n\r\n\t\t/**\r\n\t\t * An arbitrary data object, which is included with the loaded object.\r\n\t\t * @property data\r\n\t\t * @type {Object}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.data = null;\r\n\r\n\t\t/**\r\n\t\t * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or\r\n\t\t * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as\r\n\t\t * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.\r\n\t\t * @property method\r\n\t\t * @type {String}\r\n\t\t * @default get\r\n\t\t */\r\n\t\tthis.method = createjs.LoadItem.GET;\r\n\r\n\t\t/**\r\n\t\t * An object hash of name/value pairs to send to the server.\r\n\t\t * @property values\r\n\t\t * @type {Object}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.values = null;\r\n\r\n\t\t/**\r\n\t\t * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default\r\n\t\t * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the\r\n\t\t * default headers by including them in your headers object.\r\n\t\t * @property headers\r\n\t\t * @type {Object}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.headers = null;\r\n\r\n\t\t/**\r\n\t\t * Enable credentials for XHR requests.\r\n\t\t * @property withCredentials\r\n\t\t * @type {Boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.withCredentials = false;\r\n\r\n\t\t/**\r\n\t\t * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text\r\n\t\t * based files (json, xml, text, css, js).\r\n\t\t * @property mimeType\r\n\t\t * @type {String}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.mimeType = null;\r\n\r\n\t\t/**\r\n\t\t * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.\r\n\t\t * @property crossOrigin\r\n\t\t * @type {boolean}\r\n\t\t * @default Anonymous\r\n\t\t */\r\n\t\tthis.crossOrigin = null;\r\n\r\n\t\t/**\r\n\t\t * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\r\n\t\t * (level one) loading, as XHR (level 2) provides its own timeout event.\r\n\t\t * @property loadTimeout\r\n\t\t * @type {Number}\r\n\t\t * @default 8000 (8 seconds)\r\n\t\t */\r\n\t\tthis.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\r\n\t};\r\n\r\n\tvar p = LoadItem.prototype = {};\r\n\tvar s = LoadItem;\r\n\r\n\t/**\r\n\t * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\r\n\t * (level one) loading, as XHR (level 2) provides its own timeout event.\r\n\t * @property LOAD_TIMEOUT_DEFAULT\r\n\t * @type {number}\r\n\t * @static\r\n\t */\r\n\ts.LOAD_TIMEOUT_DEFAULT = 8000;\r\n\r\n\t/**\r\n\t * Create a LoadItem.\r\n\t * <ul>\r\n\t *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>\r\n\t *     <li>LoadItem instances are returned as-is</li>\r\n\t *     <li>Objects are returned with any needed properties added</li>\r\n\t * </ul>\r\n\t * @method create\r\n\t * @param {LoadItem|String|Object} value The load item value\r\n\t * @returns {LoadItem|Object}\r\n\t * @static\r\n\t */\r\n\ts.create = function (value) {\r\n\t\tif (typeof value == "string") {\r\n\t\t\tvar item = new LoadItem();\r\n\t\t\titem.src = value;\r\n\t\t\treturn item;\r\n\t\t} else if (value instanceof s) {\r\n\t\t\treturn value;\r\n\t\t} else if (value instanceof Object && value.src) {\r\n\t\t\tif (value.loadTimeout == null) {\r\n\t\t\t\tvalue.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t} else {\r\n\t\t\tthrow new Error("Type not recognized.");\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});\r\n\t *\r\n\t * @method set\r\n\t * @param {Object} props A generic object containing properties to copy to the LoadItem instance.\r\n\t * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)\r\n\t*/\r\n\tp.set = function(props) {\r\n\t\tfor (var n in props) { this[n] = props[n]; }\r\n\t\treturn this;\r\n\t};\r\n\r\n\tcreatejs.LoadItem = s;\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// RequestUtils.js\r\n//##############################################################################\r\n\r\n(function () {\r\n\r\n\t/**\r\n\t * Utilities that assist with parsing load items, and determining file types, etc.\r\n\t * @class RequestUtils\r\n\t */\r\n\tvar s = {};\r\n\r\n\t/**\r\n\t * The Regular Expression used to test file URLS for an absolute path.\r\n\t * @property ABSOLUTE_PATH\r\n\t * @type {RegExp}\r\n\t * @static\r\n\t */\r\n\ts.ABSOLUTE_PATT = /^(?:\\w+:)?\\/{2}/i;\r\n\r\n\t/**\r\n\t * The Regular Expression used to test file URLS for a relative path.\r\n\t * @property RELATIVE_PATH\r\n\t * @type {RegExp}\r\n\t * @static\r\n\t */\r\n\ts.RELATIVE_PATT = (/^[./]*?\\//i);\r\n\r\n\t/**\r\n\t * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string\r\n\t * removed.\r\n\t * @property EXTENSION_PATT\r\n\t * @type {RegExp}\r\n\t * @static\r\n\t */\r\n\ts.EXTENSION_PATT = /\\/?[^/]+\\.(\\w{1,5})$/i;\r\n\r\n\t/**\r\n\t * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:\r\n\t * <ul>\r\n\t *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or\r\n\t *     `//networkPath`)</li>\r\n\t *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>\r\n\t *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and\r\n\t *     the file path is expected to follow the format `name.ext`.</li>\r\n\t * </ul>\r\n\t * @method parseURI\r\n\t * @param {String} path\r\n\t * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional \'extension`\r\n\t * property, which is the lowercase extension.\r\n\t * @static\r\n\t */\r\n\ts.parseURI = function (path) {\r\n\t\tvar info = {absolute: false, relative: false};\r\n\t\tif (path == null) { return info; }\r\n\r\n\t\t// Drop the query string\r\n\t\tvar queryIndex = path.indexOf("?");\r\n\t\tif (queryIndex > -1) {\r\n\t\t\tpath = path.substr(0, queryIndex);\r\n\t\t}\r\n\r\n\t\t// Absolute\r\n\t\tvar match;\r\n\t\tif (s.ABSOLUTE_PATT.test(path)) {\r\n\t\t\tinfo.absolute = true;\r\n\r\n\t\t\t// Relative\r\n\t\t} else if (s.RELATIVE_PATT.test(path)) {\r\n\t\t\tinfo.relative = true;\r\n\t\t}\r\n\r\n\t\t// Extension\r\n\t\tif (match = path.match(s.EXTENSION_PATT)) {\r\n\t\t\tinfo.extension = match[1].toLowerCase();\r\n\t\t}\r\n\t\treturn info;\r\n\t};\r\n\r\n\t/**\r\n\t * Formats an object into a query string for either a POST or GET request.\r\n\t * @method formatQueryString\r\n\t * @param {Object} data The data to convert to a query string.\r\n\t * @param {Array} [query] Existing name/value pairs to append on to this query.\r\n\t * @static\r\n\t */\r\n\ts.formatQueryString = function (data, query) {\r\n\t\tif (data == null) {\r\n\t\t\tthrow new Error(\'You must specify data.\');\r\n\t\t}\r\n\t\tvar params = [];\r\n\t\tfor (var n in data) {\r\n\t\t\tparams.push(n + \'=\' + escape(data[n]));\r\n\t\t}\r\n\t\tif (query) {\r\n\t\t\tparams = params.concat(query);\r\n\t\t}\r\n\t\treturn params.join(\'&\');\r\n\t};\r\n\r\n\t/**\r\n\t * A utility method that builds a file path using a source and a data object, and formats it into a new path.\r\n\t * @method buildPath\r\n\t * @param {String} src The source path to add values to.\r\n\t * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the\r\n\t * path will be preserved.\r\n\t * @returns {string} A formatted string that contains the path and the supplied parameters.\r\n\t * @static\r\n\t */\r\n\ts.buildPath = function (src, data) {\r\n\t\tif (data == null) {\r\n\t\t\treturn src;\r\n\t\t}\r\n\r\n\t\tvar query = [];\r\n\t\tvar idx = src.indexOf(\'?\');\r\n\r\n\t\tif (idx != -1) {\r\n\t\t\tvar q = src.slice(idx + 1);\r\n\t\t\tquery = query.concat(q.split(\'&\'));\r\n\t\t}\r\n\r\n\t\tif (idx != -1) {\r\n\t\t\treturn src.slice(0, idx) + \'?\' + this.formatQueryString(data, query);\r\n\t\t} else {\r\n\t\t\treturn src + \'?\' + this.formatQueryString(data, query);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * @method isCrossDomain\r\n\t * @param {LoadItem|Object} item A load item with a `src` property.\r\n\t * @return {Boolean} If the load item is loading from a different domain than the current location.\r\n\t * @static\r\n\t */\r\n\ts.isCrossDomain = function (item) {\r\n\t\tvar target = document.createElement("a");\r\n\t\ttarget.href = item.src;\r\n\r\n\t\tvar host = document.createElement("a");\r\n\t\thost.href = location.href;\r\n\r\n\t\tvar crossdomain = (target.hostname != "") &&\r\n\t\t\t\t\t\t  (target.port != host.port ||\r\n\t\t\t\t\t\t   target.protocol != host.protocol ||\r\n\t\t\t\t\t\t   target.hostname != host.hostname);\r\n\t\treturn crossdomain;\r\n\t};\r\n\r\n\t/**\r\n\t * @method isLocal\r\n\t * @param {LoadItem|Object} item A load item with a `src` property\r\n\t * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as\r\n\t * well.\r\n\t * @static\r\n\t */\r\n\ts.isLocal = function (item) {\r\n\t\tvar target = document.createElement("a");\r\n\t\ttarget.href = item.src;\r\n\t\treturn target.hostname == "" && target.protocol == "file:";\r\n\t};\r\n\r\n\t/**\r\n\t * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked\r\n\t * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play\r\n\t * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get\r\n\t * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on\r\n\t * {{#crossLink "AbstractLoader"}}{{/crossLink}}.\r\n\t * @method isBinary\r\n\t * @param {String} type The item type.\r\n\t * @return {Boolean} If the specified type is binary.\r\n\t * @static\r\n\t */\r\n\ts.isBinary = function (type) {\r\n\t\tswitch (type) {\r\n\t\t\tcase createjs.AbstractLoader.IMAGE:\r\n\t\t\tcase createjs.AbstractLoader.BINARY:\r\n\t\t\t\treturn true;\r\n\t\t\tdefault:\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Check if item is a valid HTMLImageElement\r\n\t * @method isImageTag\r\n\t * @param {Object} item\r\n\t * @returns {Boolean}\r\n\t * @static\r\n\t */\r\n\ts.isImageTag = function(item) {\r\n\t\treturn item instanceof HTMLImageElement;\r\n\t};\r\n\r\n\t/**\r\n\t * Check if item is a valid HTMLAudioElement\r\n\t * @method isAudioTag\r\n\t * @param {Object} item\r\n\t * @returns {Boolean}\r\n\t * @static\r\n\t */\r\n\ts.isAudioTag = function(item) {\r\n\t\tif (window.HTMLAudioElement) {\r\n\t\t\treturn item instanceof HTMLAudioElement;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Check if item is a valid HTMLVideoElement\r\n\t * @method isVideoTag\r\n\t * @param {Object} item\r\n\t * @returns {Boolean}\r\n\t * @static\r\n\t */\r\n\ts.isVideoTag = function(item) {\r\n\t\tif (window.HTMLVideoElement) {\r\n\t\t\treturn item instanceof HTMLVideoElement;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.\r\n\t * @method isText\r\n\t * @param {String} type The item type.\r\n\t * @return {Boolean} If the specified type is text.\r\n\t * @static\r\n\t */\r\n\ts.isText = function (type) {\r\n\t\tswitch (type) {\r\n\t\t\tcase createjs.AbstractLoader.TEXT:\r\n\t\t\tcase createjs.AbstractLoader.JSON:\r\n\t\t\tcase createjs.AbstractLoader.MANIFEST:\r\n\t\t\tcase createjs.AbstractLoader.XML:\r\n\t\t\tcase createjs.AbstractLoader.CSS:\r\n\t\t\tcase createjs.AbstractLoader.SVG:\r\n\t\t\tcase createjs.AbstractLoader.JAVASCRIPT:\r\n\t\t\tcase createjs.AbstractLoader.SPRITESHEET:\r\n\t\t\t\treturn true;\r\n\t\t\tdefault:\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Determine the type of the object using common extensions. Note that the type can be passed in with the load item\r\n\t * if it is an unusual extension.\r\n\t * @method getTypeByExtension\r\n\t * @param {String} extension The file extension to use to determine the load type.\r\n\t * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if\r\n\t * the type can not be determined by the extension.\r\n\t * @static\r\n\t */\r\n\ts.getTypeByExtension = function (extension) {\r\n\t\tif (extension == null) {\r\n\t\t\treturn createjs.AbstractLoader.TEXT;\r\n\t\t}\r\n\r\n\t\tswitch (extension.toLowerCase()) {\r\n\t\t\tcase "jpeg":\r\n\t\t\tcase "jpg":\r\n\t\t\tcase "gif":\r\n\t\t\tcase "png":\r\n\t\t\tcase "webp":\r\n\t\t\tcase "bmp":\r\n\t\t\t\treturn createjs.AbstractLoader.IMAGE;\r\n\t\t\tcase "ogg":\r\n\t\t\tcase "mp3":\r\n\t\t\tcase "webm":\r\n\t\t\t\treturn createjs.AbstractLoader.SOUND;\r\n\t\t\tcase "mp4":\r\n\t\t\tcase "webm":\r\n\t\t\tcase "ts":\r\n\t\t\t\treturn createjs.AbstractLoader.VIDEO;\r\n\t\t\tcase "json":\r\n\t\t\t\treturn createjs.AbstractLoader.JSON;\r\n\t\t\tcase "xml":\r\n\t\t\t\treturn createjs.AbstractLoader.XML;\r\n\t\t\tcase "css":\r\n\t\t\t\treturn createjs.AbstractLoader.CSS;\r\n\t\t\tcase "js":\r\n\t\t\t\treturn createjs.AbstractLoader.JAVASCRIPT;\r\n\t\t\tcase \'svg\':\r\n\t\t\t\treturn createjs.AbstractLoader.SVG;\r\n\t\t\tdefault:\r\n\t\t\t\treturn createjs.AbstractLoader.TEXT;\r\n\t\t}\r\n\t};\r\n\r\n\tcreatejs.RequestUtils = s;\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// AbstractLoader.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n// constructor\r\n\t/**\r\n\t * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,\r\n\t * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.\r\n\t * @class AbstractLoader\r\n\t * @param {LoadItem|object|string} loadItem The item to be loaded.\r\n\t * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a\r\n\t * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the\r\n\t * other, so this is a suggested directive.\r\n\t * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,\r\n\t * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.\r\n\t * @extends EventDispatcher\r\n\t */\r\n\tfunction AbstractLoader(loadItem, preferXHR, type) {\r\n\t\tthis.EventDispatcher_constructor();\r\n\r\n\t\t// public properties\r\n\t\t/**\r\n\t\t * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches\r\n\t\t * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.\r\n\t\t * @property loaded\r\n\t\t * @type {Boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.loaded = false;\r\n\r\n\t\t/**\r\n\t\t * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property\r\n\t\t * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}\r\n\t\t * instead.\r\n\t\t * @property canceled\r\n\t\t * @type {Boolean}\r\n\t\t * @default false\r\n\t\t * @readonly\r\n\t\t */\r\n\t\tthis.canceled = false;\r\n\r\n\t\t/**\r\n\t\t * The current load progress (percentage) for this item. This will be a number between 0 and 1.\r\n\t\t *\r\n\t\t * <h4>Example</h4>\r\n\t\t *\r\n\t\t *     var queue = new createjs.LoadQueue();\r\n\t\t *     queue.loadFile("largeImage.png");\r\n\t\t *     queue.on("progress", function() {\r\n\t\t *         console.log("Progress:", queue.progress, event.progress);\r\n\t\t *     });\r\n\t\t *\r\n\t\t * @property progress\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t */\r\n\t\tthis.progress = 0;\r\n\r\n\t\t/**\r\n\t\t * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of\r\n\t\t * supported types.\r\n\t\t * @property type\r\n\t\t * @type {String}\r\n\t\t */\r\n\t\tthis.type = type;\r\n\r\n\t\t/**\r\n\t\t * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader\r\n\t\t * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property\r\n\t\t * can be overridden to provide custom formatting.\r\n\t\t *\r\n\t\t * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be\r\n\t\t * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks\r\n\t\t * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is\r\n\t\t * called in the current scope, as well as the success and error callbacks.\r\n\t\t *\r\n\t\t * <h4>Example asynchronous resultFormatter</h4>\r\n\t\t *\r\n\t\t * \tfunction _formatResult(loader) {\r\n\t\t * \t\treturn function(success, error) {\r\n\t\t * \t\t\tif (errorCondition) { error(errorDetailEvent); }\r\n\t\t * \t\t\tsuccess(result);\r\n\t\t * \t\t}\r\n\t\t * \t}\r\n\t\t * @property resultFormatter\r\n\t\t * @type {Function}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.resultFormatter = null;\r\n\r\n\t\t// protected properties\r\n\t\t/**\r\n\t\t * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},\r\n\t\t * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.\r\n\t\t * @property _item\r\n\t\t * @type {LoadItem|Object}\r\n\t\t * @private\r\n\t\t */\r\n\t\tif (loadItem) {\r\n\t\t\tthis._item = createjs.LoadItem.create(loadItem);\r\n\t\t} else {\r\n\t\t\tthis._item = null;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Whether the loader will try and load content using XHR (true) or HTML tags (false).\r\n\t\t * @property _preferXHR\r\n\t\t * @type {Boolean}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._preferXHR = preferXHR;\r\n\r\n\t\t/**\r\n\t\t * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For\r\n\t\t * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.\r\n\t\t * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.\r\n\t\t * @property _result\r\n\t\t * @type {Object|String}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._result = null;\r\n\r\n\t\t/**\r\n\t\t * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}\r\n\t\t * method, and passing `true`.\r\n\t\t * @property _rawResult\r\n\t\t * @type {Object|String}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._rawResult = null;\r\n\r\n\t\t/**\r\n\t\t * A list of items that loaders load behind the scenes. This does not include the main item the loader is\r\n\t\t * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and\r\n\t\t * {{#crossLink "ManifestLoader"}}{{/crossLink}}.\r\n\t\t * @property _loadItems\r\n\t\t * @type {null}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._loadedItems = null;\r\n\r\n\t\t/**\r\n\t\t * The attribute the items loaded using tags use for the source.\r\n\t\t * @type {string}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._tagSrcAttribute = null;\r\n\r\n\t\t/**\r\n\t\t * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.\r\n\t\t * @property _tag\r\n\t\t * @type {Object}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._tag = null;\r\n\t};\r\n\r\n\tvar p = createjs.extend(AbstractLoader, createjs.EventDispatcher);\r\n\tvar s = AbstractLoader;\r\n\r\n\t// TODO: deprecated\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\r\n\r\n\r\n\t/**\r\n\t * Defines a POST request, use for a method value when loading data.\r\n\t * @property POST\r\n\t * @type {string}\r\n\t * @default post\r\n\t * @static\r\n\t */\r\n\ts.POST = "POST";\r\n\r\n\t/**\r\n\t * Defines a GET request, use for a method value when loading data.\r\n\t * @property GET\r\n\t * @type {string}\r\n\t * @default get\r\n\t * @static\r\n\t */\r\n\ts.GET = "GET";\r\n\r\n\t/**\r\n\t * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.\r\n\t * @property BINARY\r\n\t * @type {String}\r\n\t * @default binary\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.BINARY = "binary";\r\n\r\n\t/**\r\n\t * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a\r\n\t * &lt;style&gt; tag when loaded with tags.\r\n\t * @property CSS\r\n\t * @type {String}\r\n\t * @default css\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.CSS = "css";\r\n\r\n\t/**\r\n\t * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.\r\n\t * @property IMAGE\r\n\t * @type {String}\r\n\t * @default image\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.IMAGE = "image";\r\n\r\n\t/**\r\n\t * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a\r\n\t * &lt;script&gt; tag.\r\n\t *\r\n\t * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into\r\n\t * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,\r\n\t * only tag-loaded scripts are injected.\r\n\t * @property JAVASCRIPT\r\n\t * @type {String}\r\n\t * @default javascript\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.JAVASCRIPT = "javascript";\r\n\r\n\t/**\r\n\t * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a\r\n\t * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,\r\n\t * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON\r\n\t * must contain a matching wrapper function.\r\n\t * @property JSON\r\n\t * @type {String}\r\n\t * @default json\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.JSON = "json";\r\n\r\n\t/**\r\n\t * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a\r\n\t * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.\r\n\t * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}\r\n\t * property is set to.\r\n\t * @property JSONP\r\n\t * @type {String}\r\n\t * @default jsonp\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.JSONP = "jsonp";\r\n\r\n\t/**\r\n\t * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded\r\n\t * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an\r\n\t * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}\r\n\t * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,\r\n\t * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.\r\n\t * @property MANIFEST\r\n\t * @type {String}\r\n\t * @default manifest\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.MANIFEST = "manifest";\r\n\r\n\t/**\r\n\t * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an\r\n\t * &lt;audio&gt; tag.\r\n\t * @property SOUND\r\n\t * @type {String}\r\n\t * @default sound\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.SOUND = "sound";\r\n\r\n\t/**\r\n\t * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an\r\n\t * &lt;video&gt; tag.\r\n\t * @property VIDEO\r\n\t * @type {String}\r\n\t * @default video\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.VIDEO = "video";\r\n\r\n\t/**\r\n\t * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.\r\n\t * @property SPRITESHEET\r\n\t * @type {String}\r\n\t * @default spritesheet\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.SPRITESHEET = "spritesheet";\r\n\r\n\t/**\r\n\t * The preload type for SVG files.\r\n\t * @property SVG\r\n\t * @type {String}\r\n\t * @default svg\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.SVG = "svg";\r\n\r\n\t/**\r\n\t * The preload type for text files, which is also the default file type if the type can not be determined. Text is\r\n\t * loaded as raw text.\r\n\t * @property TEXT\r\n\t * @type {String}\r\n\t * @default text\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.TEXT = "text";\r\n\r\n\t/**\r\n\t * The preload type for xml files. XML is loaded into an XML document.\r\n\t * @property XML\r\n\t * @type {String}\r\n\t * @default xml\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.XML = "xml";\r\n\r\n// Events\r\n\t/**\r\n\t * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to\r\n\t * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.\r\n\t * @event progress\r\n\t * @since 0.3.0\r\n\t */\r\n\r\n\t/**\r\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.\r\n\t * @event loadstart\r\n\t * @param {Object} target The object that dispatched the event.\r\n\t * @param {String} type The event type.\r\n\t * @since 0.3.1\r\n\t */\r\n\r\n\t/**\r\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.\r\n\t * @event complete\r\n\t * @param {Object} target The object that dispatched the event.\r\n\t * @param {String} type The event type.\r\n\t * @since 0.3.0\r\n\t */\r\n\r\n\t/**\r\n\t * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was\r\n\t * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was\r\n\t * just a regular {{#crossLink "Event"}}{{/crossLink}}.\r\n\t * @event error\r\n\t * @since 0.3.0\r\n\t */\r\n\r\n\t/**\r\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.\r\n\t * This enables loaders to maintain internal queues, and surface file load errors.\r\n\t * @event fileerror\r\n\t * @param {Object} target The object that dispatched the event.\r\n\t * @param {String} type The even type ("fileerror")\r\n\t * @param {LoadItem|object} The item that encountered the error\r\n\t * @since 0.6.0\r\n\t */\r\n\r\n\t/**\r\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables\r\n\t * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s\r\n\t * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a\r\n\t * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.\r\n\t * @event fileload\r\n\t * @param {Object} target The object that dispatched the event.\r\n\t * @param {String} type The event type ("fileload")\r\n\t * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\r\n\t * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the\r\n\t * object will contain that value as a `src` property.\r\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\r\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\r\n\t * to a usable object.\r\n\t * @since 0.6.0\r\n\t */\r\n\r\n\t/**\r\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.\r\n\t * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.\r\n\t * @event initialize\r\n\t * @param {Object} target The object that dispatched the event.\r\n\t * @param {String} type The event type ("initialize")\r\n\t * @param {AbstractLoader} loader The loader that has been initialized.\r\n\t */\r\n\r\n\r\n\t/**\r\n\t * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was\r\n\t * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or\r\n\t * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will\r\n\t * be a {{#crossLink "LoadItem"}}{{/crossLink}}.\r\n\t * @method getItem\r\n\t * @return {Object} The manifest item that this loader is responsible for loading.\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.getItem = function () {\r\n\t\treturn this._item;\r\n\t};\r\n\r\n\t/**\r\n\t * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}\r\n\t * event is dispatched.\r\n\t * @method getResult\r\n\t * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded\r\n\t * data (if it exists).\r\n\t * @return {Object}\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.getResult = function (raw) {\r\n\t\treturn raw ? this._rawResult : this._result;\r\n\t};\r\n\r\n\t/**\r\n\t * Return the `tag` this object creates or uses for loading.\r\n\t * @method getTag\r\n\t * @return {Object} The tag instance\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.getTag = function () {\r\n\t\treturn this._tag;\r\n\t};\r\n\r\n\t/**\r\n\t * Set the `tag` this item uses for loading.\r\n\t * @method setTag\r\n\t * @param {Object} tag The tag instance\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.setTag = function(tag) {\r\n\t  this._tag = tag;\r\n\t};\r\n\r\n\t/**\r\n\t * Begin loading the item. This method is required when using a loader by itself.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      var queue = new createjs.LoadQueue();\r\n\t *      queue.on("complete", handleComplete);\r\n\t *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet\r\n\t *      queue.load();\r\n\t *\r\n\t * @method load\r\n\t */\r\n\tp.load = function () {\r\n\t\tthis._createRequest();\r\n\r\n\t\tthis._request.on("complete", this, this);\r\n\t\tthis._request.on("progress", this, this);\r\n\t\tthis._request.on("loadStart", this, this);\r\n\t\tthis._request.on("abort", this, this);\r\n\t\tthis._request.on("timeout", this, this);\r\n\t\tthis._request.on("error", this, this);\r\n\r\n\t\tvar evt = new createjs.Event("initialize");\r\n\t\tevt.loader = this._request;\r\n\t\tthis.dispatchEvent(evt);\r\n\r\n\t\tthis._request.load();\r\n\t};\r\n\r\n\t/**\r\n\t * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in\r\n\t * the background), but events will not longer be dispatched.\r\n\t * @method cancel\r\n\t */\r\n\tp.cancel = function () {\r\n\t\tthis.canceled = true;\r\n\t\tthis.destroy();\r\n\t};\r\n\r\n\t/**\r\n\t * Clean up the loader.\r\n\t * @method destroy\r\n\t */\r\n\tp.destroy = function() {\r\n\t\tif (this._request) {\r\n\t\t\tthis._request.removeAllEventListeners();\r\n\t\t\tthis._request.destroy();\r\n\t\t}\r\n\r\n\t\tthis._request = null;\r\n\r\n\t\tthis._item = null;\r\n\t\tthis._rawResult = null;\r\n\t\tthis._result = null;\r\n\r\n\t\tthis._loadItems = null;\r\n\r\n\t\tthis.removeAllEventListeners();\r\n\t};\r\n\r\n\t/**\r\n\t * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}\r\n\t * to expose items it loads internally.\r\n\t * @method getLoadedItems\r\n\t * @return {Array} A list of the items loaded by the loader.\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.getLoadedItems = function () {\r\n\t\treturn this._loadedItems;\r\n\t};\r\n\r\n\r\n\t// Private methods\r\n\t/**\r\n\t * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or\r\n\t * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.\r\n\t * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},\r\n\t * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.\r\n\t * @method _createRequest\r\n\t * @protected\r\n\t */\r\n\tp._createRequest = function() {\r\n\t\tif (!this._preferXHR) {\r\n\t\t\tthis._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\r\n\t\t} else {\r\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented\r\n\t * by loaders that require tag loading.\r\n\t * @method _createTag\r\n\t * @param {String} src The tag source\r\n\t * @return {HTMLElement} The tag that was created\r\n\t * @protected\r\n\t */\r\n\tp._createTag = function(src) { return null; };\r\n\r\n\t/**\r\n\t * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}\r\n\t * event for details on the event payload.\r\n\t * @method _sendLoadStart\r\n\t * @protected\r\n\t */\r\n\tp._sendLoadStart = function () {\r\n\t\tif (this._isCanceled()) { return; }\r\n\t\tthis.dispatchEvent("loadstart");\r\n\t};\r\n\r\n\t/**\r\n\t * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.\r\n\t * @method _sendProgress\r\n\t * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>\r\n\t * and <code>total</code> properties.\r\n\t * @protected\r\n\t */\r\n\tp._sendProgress = function (value) {\r\n\t\tif (this._isCanceled()) { return; }\r\n\t\tvar event = null;\r\n\t\tif (typeof(value) == "number") {\r\n\t\t\tthis.progress = value;\r\n\t\t\tevent = new createjs.ProgressEvent(this.progress);\r\n\t\t} else {\r\n\t\t\tevent = value;\r\n\t\t\tthis.progress = value.loaded / value.total;\r\n\t\t\tevent.progress = this.progress;\r\n\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\r\n\t\t}\r\n\t\tthis.hasEventListener("progress") && this.dispatchEvent(event);\r\n\t};\r\n\r\n\t/**\r\n\t * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event\r\n\t * @method _sendComplete\r\n\t * @protected\r\n\t */\r\n\tp._sendComplete = function () {\r\n\t\tif (this._isCanceled()) { return; }\r\n\r\n\t\tthis.loaded = true;\r\n\r\n\t\tvar event = new createjs.Event("complete");\r\n\t\tevent.rawResult = this._rawResult;\r\n\r\n\t\tif (this._result != null) {\r\n\t\t\tevent.result = this._result;\r\n\t\t}\r\n\r\n\t\tthis.dispatchEvent(event);\r\n\t};\r\n\r\n\t/**\r\n\t * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}\r\n\t * event for details on the event payload.\r\n\t * @method _sendError\r\n\t * @param {ErrorEvent} event The event object containing specific error properties.\r\n\t * @protected\r\n\t */\r\n\tp._sendError = function (event) {\r\n\t\tif (this._isCanceled() || !this.hasEventListener("error")) { return; }\r\n\t\tif (event == null) {\r\n\t\t\tevent = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error\r\n\t\t}\r\n\t\tthis.dispatchEvent(event);\r\n\t};\r\n\r\n\t/**\r\n\t * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events\r\n\t * do not cause issues after the queue has been cleaned up.\r\n\t * @method _isCanceled\r\n\t * @return {Boolean} If the loader has been canceled.\r\n\t * @protected\r\n\t */\r\n\tp._isCanceled = function () {\r\n\t\tif (window.createjs == null || this.canceled) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * A custom result formatter function, which is called just before a request dispatches its complete event. Most\r\n\t * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The\r\n\t * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.\r\n\t * @property resultFormatter\r\n\t * @type Function\r\n\t * @return {Object} The formatted result\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.resultFormatter = null;\r\n\r\n\t/**\r\n\t * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but\r\n\t * this method can be overridden for custom behaviours.\r\n\t * @method handleEvent\r\n\t * @param {Event} event The event that the internal request dispatches.\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.handleEvent = function (event) {\r\n\t\tswitch (event.type) {\r\n\t\t\tcase "complete":\r\n\t\t\t\tthis._rawResult = event.target._response;\r\n\t\t\t\tvar result = this.resultFormatter && this.resultFormatter(this);\r\n\t\t\t\tif (result instanceof Function) {\r\n\t\t\t\t\tresult.call(this,\r\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatSuccess, this),\r\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatFailed, this)\r\n\t\t\t\t\t);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._result =  result || this._rawResult;\r\n\t\t\t\t\tthis._sendComplete();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase "progress":\r\n\t\t\t\tthis._sendProgress(event);\r\n\t\t\t\tbreak;\r\n\t\t\tcase "error":\r\n\t\t\t\tthis._sendError(event);\r\n\t\t\t\tbreak;\r\n\t\t\tcase "loadstart":\r\n\t\t\t\tthis._sendLoadStart();\r\n\t\t\t\tbreak;\r\n\t\t\tcase "abort":\r\n\t\t\tcase "timeout":\r\n\t\t\t\tif (!this._isCanceled()) {\r\n\t\t\t\t\tthis.dispatchEvent(new createjs.ErrorEvent("PRELOAD_" + event.type.toUpperCase() + "_ERROR"));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * The "success" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous\r\n\t * functions.\r\n\t * @method _resultFormatSuccess\r\n\t * @param {Object} result The formatted result\r\n\t * @private\r\n\t */\r\n\tp._resultFormatSuccess = function (result) {\r\n\t\tthis._result = result;\r\n\t\tthis._sendComplete();\r\n\t};\r\n\r\n\t/**\r\n\t * The "error" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous\r\n\t * functions.\r\n\t * @method _resultFormatSuccess\r\n\t * @param {Object} error The error event\r\n\t * @private\r\n\t */\r\n\tp._resultFormatFailed = function (event) {\r\n\t\tthis._sendError(event);\r\n\t};\r\n\r\n\t/**\r\n\t * @method buildPath\r\n\t * @protected\r\n\t * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}\r\n\t * instead.\r\n\t */\r\n\tp.buildPath = function (src, data) {\r\n\t\treturn createjs.RequestUtils.buildPath(src, data);\r\n\t};\r\n\r\n\t/**\r\n\t * @method toString\r\n\t * @return {String} a string representation of the instance.\r\n\t */\r\n\tp.toString = function () {\r\n\t\treturn "[PreloadJS AbstractLoader]";\r\n\t};\r\n\r\n\tcreatejs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// AbstractMediaLoader.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t// constructor\r\n\t/**\r\n\t * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that\r\n\t * handle HTML media elements, such as Video and Audio.\r\n\t * @class AbstractMediaLoader\r\n\t * @param {LoadItem|Object} loadItem\r\n\t * @param {Boolean} preferXHR\r\n\t * @param {String} type The type of media to load. Usually "video" or "audio".\r\n\t * @extends AbstractLoader\r\n\t * @constructor\r\n\t */\r\n\tfunction AbstractMediaLoader(loadItem, preferXHR, type) {\r\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, type);\r\n\r\n\t\t// public properties\r\n\t\tthis.resultFormatter = this._formatResult;\r\n\r\n\t\t// protected properties\r\n\t\tthis._tagSrcAttribute = "src";\r\n\r\n        this.on("initialize", this._updateXHR, this);\r\n\t};\r\n\r\n\tvar p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);\r\n\r\n\t// static properties\r\n\t// public methods\r\n\tp.load = function () {\r\n\t\t// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.\r\n\t\tif (!this._tag) {\r\n\t\t\tthis._tag = this._createTag(this._item.src);\r\n\t\t}\r\n\r\n\t\tthis._tag.preload = "auto";\r\n\t\tthis._tag.load();\r\n\r\n\t\tthis.AbstractLoader_load();\r\n\t};\r\n\r\n\t// protected methods\r\n\t/**\r\n\t * Creates a new tag for loading if it doesn\'t exist yet.\r\n\t * @method _createTag\r\n\t * @private\r\n\t */\r\n\tp._createTag = function () {};\r\n\r\n\r\n\tp._createRequest = function() {\r\n\t\tif (!this._preferXHR) {\r\n\t\t\tthis._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\r\n\t\t} else {\r\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\r\n\t\t}\r\n\t};\r\n\r\n    // protected methods\r\n    /**\r\n     * Before the item loads, set its mimeType and responseType.\r\n     * @property _updateXHR\r\n     * @param {Event} event\r\n     * @private\r\n     */\r\n    p._updateXHR = function (event) {\r\n        // Only exists for XHR\r\n        if (event.loader.setResponseType) {\r\n            event.loader.setResponseType("blob");\r\n        }\r\n    };\r\n\r\n\t/**\r\n\t * The result formatter for media files.\r\n\t * @method _formatResult\r\n\t * @param {AbstractLoader} loader\r\n\t * @returns {HTMLVideoElement|HTMLAudioElement}\r\n\t * @private\r\n\t */\r\n\tp._formatResult = function (loader) {\r\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);\r\n\t\tthis._tag.onstalled = null;\r\n\t\tif (this._preferXHR) {\r\n            var URL = window.URL || window.webkitURL;\r\n            var result = loader.getResult(true);\r\n\r\n\t\t\tloader.getTag().src = URL.createObjectURL(result);\r\n\t\t}\r\n\t\treturn loader.getTag();\r\n\t};\r\n\r\n\tcreatejs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// AbstractRequest.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},\r\n\t * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the\r\n\t * hood to get data.\r\n\t * @class AbstractRequest\r\n\t * @param {LoadItem} item\r\n\t * @constructor\r\n\t */\r\n\tvar AbstractRequest = function (item) {\r\n\t\tthis._item = item;\r\n\t};\r\n\r\n\tvar p = createjs.extend(AbstractRequest, createjs.EventDispatcher);\r\n\r\n\t// public methods\r\n\t/**\r\n\t * Begin a load.\r\n\t * @method load\r\n\t */\r\n\tp.load =  function() {};\r\n\r\n\t/**\r\n\t * Clean up a request.\r\n\t * @method destroy\r\n\t */\r\n\tp.destroy = function() {};\r\n\r\n\t/**\r\n\t * Cancel an in-progress request.\r\n\t * @method cancel\r\n\t */\r\n\tp.cancel = function() {};\r\n\r\n\tcreatejs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// TagRequest.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t// constructor\r\n\t/**\r\n\t * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.\r\n\t * @class TagRequest\r\n\t * @param {LoadItem} loadItem\r\n\t * @param {HTMLElement} tag\r\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.\r\n\t */\r\n\tfunction TagRequest(loadItem, tag, srcAttribute) {\r\n\t\tthis.AbstractRequest_constructor(loadItem);\r\n\r\n\t\t// protected properties\r\n\t\t/**\r\n\t\t * The HTML tag instance that is used to load.\r\n\t\t * @property _tag\r\n\t\t * @type {HTMLElement}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._tag = tag;\r\n\r\n\t\t/**\r\n\t\t * The tag attribute that specifies the source, such as "src", "href", etc.\r\n\t\t * @property _tagSrcAttribute\r\n\t\t * @type {String}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._tagSrcAttribute = srcAttribute;\r\n\r\n\t\t/**\r\n\t\t * A method closure used for handling the tag load event.\r\n\t\t * @property _loadedHandler\r\n\t\t * @type {Function}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\r\n\r\n\t\t/**\r\n\t\t * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.\r\n\t\t * @property _addedToDOM\r\n\t\t * @type {Boolean}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._addedToDOM = false;\r\n\r\n\t\t/**\r\n\t\t * Determines what the tags initial style.visibility was, so we can set it correctly after a load.\r\n\t\t *\r\n\t\t * @type {null}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._startTagVisibility = null;\r\n\t};\r\n\r\n\tvar p = createjs.extend(TagRequest, createjs.AbstractRequest);\r\n\r\n\t// public methods\r\n\tp.load = function () {\r\n\t\tthis._tag.onload = createjs.proxy(this._handleTagComplete, this);\r\n\t\tthis._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);\r\n\t\tthis._tag.onerror = createjs.proxy(this._handleError, this);\r\n\r\n\t\tvar evt = new createjs.Event("initialize");\r\n\t\tevt.loader = this._tag;\r\n\r\n\t\tthis.dispatchEvent(evt);\r\n\r\n\t\tthis._hideTag();\r\n\r\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\r\n\r\n\t\tthis._tag[this._tagSrcAttribute] = this._item.src;\r\n\r\n\t\t// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.\r\n\t\tif (this._tag.parentNode == null) {\r\n\t\t\twindow.document.body.appendChild(this._tag);\r\n\t\t\tthis._addedToDOM = true;\r\n\t\t}\r\n\t};\r\n\r\n\tp.destroy = function() {\r\n\t\tthis._clean();\r\n\t\tthis._tag = null;\r\n\r\n\t\tthis.AbstractRequest_destroy();\r\n\t};\r\n\r\n\t// private methods\r\n\t/**\r\n\t * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT\r\n\t * and LINK tags), but other cases may exist.\r\n\t * @method _handleReadyStateChange\r\n\t * @private\r\n\t */\r\n\tp._handleReadyStateChange = function () {\r\n\t\tclearTimeout(this._loadTimeout);\r\n\t\t// This is strictly for tags in browsers that do not support onload.\r\n\t\tvar tag = this._tag;\r\n\r\n\t\t// Complete is for old IE support.\r\n\t\tif (tag.readyState == "loaded" || tag.readyState == "complete") {\r\n\t\t\tthis._handleTagComplete();\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Handle any error events from the tag.\r\n\t * @method _handleError\r\n\t * @protected\r\n\t */\r\n\tp._handleError = function() {\r\n\t\tthis._clean();\r\n\t\tthis.dispatchEvent("error");\r\n\t};\r\n\r\n\t/**\r\n\t * Handle the tag\'s onload callback.\r\n\t * @method _handleTagComplete\r\n\t * @private\r\n\t */\r\n\tp._handleTagComplete = function () {\r\n\t\tthis._rawResult = this._tag;\r\n\t\tthis._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;\r\n\r\n\t\tthis._clean();\r\n\t\tthis._showTag();\r\n\r\n\t\tthis.dispatchEvent("complete");\r\n\t};\r\n\r\n\t/**\r\n\t * The tag request has not loaded within the time specified in loadTimeout.\r\n\t * @method _handleError\r\n\t * @param {Object} event The XHR error event.\r\n\t * @private\r\n\t */\r\n\tp._handleTimeout = function () {\r\n\t\tthis._clean();\r\n\t\tthis.dispatchEvent(new createjs.Event("timeout"));\r\n\t};\r\n\r\n\t/**\r\n\t * Remove event listeners, but don\'t destroy the request object\r\n\t * @method _clean\r\n\t * @private\r\n\t */\r\n\tp._clean = function() {\r\n\t\tthis._tag.onload = null;\r\n\t\tthis._tag.onreadystatechange = null;\r\n\t\tthis._tag.onerror = null;\r\n\t\tif (this._addedToDOM && this._tag.parentNode != null) {\r\n\t\t\tthis._tag.parentNode.removeChild(this._tag);\r\n\t\t}\r\n\t\tclearTimeout(this._loadTimeout);\r\n\t};\r\n\r\n\tp._hideTag = function() {\r\n\t\tthis._startTagVisibility = this._tag.style.visibility;\r\n\t\tthis._tag.style.visibility = "hidden";\r\n\t};\r\n\r\n\tp._showTag = function() {\r\n\t\tthis._tag.style.visibility = this._startTagVisibility;\r\n\t};\r\n\r\n\t/**\r\n\t * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio\r\n\t * that is already in a load, but not complete.\r\n\t * @method _handleStalled\r\n\t * @private\r\n\t */\r\n\tp._handleStalled = function () {\r\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\r\n\t};\r\n\r\n\tcreatejs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// MediaTagRequest.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t// constructor\r\n\t/**\r\n\t * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.\r\n\t * @class MediaTagRequest\r\n\t * @param {LoadItem} loadItem\r\n\t * @param {HTMLAudioElement|HTMLVideoElement} tag\r\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.\r\n\t * @constructor\r\n\t */\r\n\tfunction MediaTagRequest(loadItem, tag, srcAttribute) {\r\n\t\tthis.AbstractRequest_constructor(loadItem);\r\n\r\n\t\t// protected properties\r\n\t\tthis._tag = tag;\r\n\t\tthis._tagSrcAttribute = srcAttribute;\r\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\r\n\t};\r\n\r\n\tvar p = createjs.extend(MediaTagRequest, createjs.TagRequest);\r\n\tvar s = MediaTagRequest;\r\n\r\n\t// public methods\r\n\tp.load = function () {\r\n\t\tvar sc = createjs.proxy(this._handleStalled, this);\r\n\t\tthis._stalledCallback = sc;\r\n\r\n\t\tvar pc = createjs.proxy(this._handleProgress, this);\r\n\t\tthis._handleProgress = pc;\r\n\r\n\t\tthis._tag.addEventListener("stalled", sc);\r\n\t\tthis._tag.addEventListener("progress", pc);\r\n\r\n\t\t// This will tell us when audio is buffered enough to play through, but not when its loaded.\r\n\t\t// The tag doesn\'t keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.\r\n\t\tthis._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn\'t work in Chrome, so we use an event.\r\n\r\n\t\tthis.TagRequest_load();\r\n\t};\r\n\r\n\t// private methods\r\n\tp._handleReadyStateChange = function () {\r\n\t\tclearTimeout(this._loadTimeout);\r\n\t\t// This is strictly for tags in browsers that do not support onload.\r\n\t\tvar tag = this._tag;\r\n\r\n\t\t// Complete is for old IE support.\r\n\t\tif (tag.readyState == "loaded" || tag.readyState == "complete") {\r\n\t\t\tthis._handleTagComplete();\r\n\t\t}\r\n\t};\r\n\r\n\tp._handleStalled = function () {\r\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\r\n\t};\r\n\r\n\t/**\r\n\t * An XHR request has reported progress.\r\n\t * @method _handleProgress\r\n\t * @param {Object} event The XHR progress event.\r\n\t * @private\r\n\t */\r\n\tp._handleProgress = function (event) {\r\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\r\n\t\t\treturn; // Sometimes we get no "total", so just ignore the progress event.\r\n\t\t}\r\n\r\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\r\n\t\tthis.dispatchEvent(newEvent);\r\n\t};\r\n\r\n\t// protected methods\r\n\tp._clean = function () {\r\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);\r\n\t\tthis._tag.removeEventListener("stalled", this._stalledCallback);\r\n\t\tthis._tag.removeEventListener("progress", this._progressCallback);\r\n\r\n\t\tthis.TagRequest__clean();\r\n\t};\r\n\r\n\tcreatejs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// XHRRequest.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n// constructor\r\n\t/**\r\n\t * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used\r\n\t * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.\r\n\t * XHR requests load the content as text or binary data, provide progress and consistent completion events, and\r\n\t * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for\r\n\t * cross-domain loading.\r\n\t * @class XHRRequest\r\n\t * @constructor\r\n\t * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\r\n\t * for an overview of supported file properties.\r\n\t * @extends AbstractLoader\r\n\t */\r\n\tfunction XHRRequest (item) {\r\n\t\tthis.AbstractRequest_constructor(item);\r\n\r\n\t\t// protected properties\r\n\t\t/**\r\n\t\t * A reference to the XHR request used to load the content.\r\n\t\t * @property _request\r\n\t\t * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._request = null;\r\n\r\n\t\t/**\r\n\t\t * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,\r\n\t\t * typically IE9).\r\n\t\t * @property _loadTimeout\r\n\t\t * @type {Number}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._loadTimeout = null;\r\n\r\n\t\t/**\r\n\t\t * The browser\'s XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect\r\n\t\t * the version, so we use capabilities to make a best guess.\r\n\t\t * @property _xhrLevel\r\n\t\t * @type {Number}\r\n\t\t * @default 1\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._xhrLevel = 1;\r\n\r\n\t\t/**\r\n\t\t * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be\r\n\t\t * null until the file is loaded.\r\n\t\t * @property _response\r\n\t\t * @type {mixed}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._response = null;\r\n\r\n\t\t/**\r\n\t\t * The response of the loaded file before it is modified. In most cases, content is converted from raw text to\r\n\t\t * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still\r\n\t\t * want to access the raw content as it was loaded.\r\n\t\t * @property _rawResponse\r\n\t\t * @type {String|Object}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._rawResponse = null;\r\n\r\n\t\tthis._canceled = false;\r\n\r\n\t\t// Setup our event handlers now.\r\n\t\tthis._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);\r\n\t\tthis._handleProgressProxy = createjs.proxy(this._handleProgress, this);\r\n\t\tthis._handleAbortProxy = createjs.proxy(this._handleAbort, this);\r\n\t\tthis._handleErrorProxy = createjs.proxy(this._handleError, this);\r\n\t\tthis._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);\r\n\t\tthis._handleLoadProxy = createjs.proxy(this._handleLoad, this);\r\n\t\tthis._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);\r\n\r\n\t\tif (!this._createXHR(item)) {\r\n\t\t\t//TODO: Throw error?\r\n\t\t}\r\n\t};\r\n\r\n\tvar p = createjs.extend(XHRRequest, createjs.AbstractRequest);\r\n\r\n// static properties\r\n\t/**\r\n\t * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.\r\n\t * @property ACTIVEX_VERSIONS\r\n\t * @type {Array}\r\n\t * @since 0.4.2\r\n\t * @private\r\n\t */\r\n\tXHRRequest.ACTIVEX_VERSIONS = [\r\n\t\t"Msxml2.XMLHTTP.6.0",\r\n\t\t"Msxml2.XMLHTTP.5.0",\r\n\t\t"Msxml2.XMLHTTP.4.0",\r\n\t\t"MSXML2.XMLHTTP.3.0",\r\n\t\t"MSXML2.XMLHTTP",\r\n\t\t"Microsoft.XMLHTTP"\r\n\t];\r\n\r\n// Public methods\r\n\t/**\r\n\t * Look up the loaded result.\r\n\t * @method getResult\r\n\t * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content\r\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\r\n\t * returned instead.\r\n\t * @return {Object} A result object containing the content that was loaded, such as:\r\n\t * <ul>\r\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\r\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the\r\n\t *      HTML head.</li>\r\n\t *      <li>A style tag for CSS (&lt;style /&gt;)</li>\r\n\t *      <li>Raw text for TEXT</li>\r\n\t *      <li>A formatted JavaScript object defined by JSON</li>\r\n\t *      <li>An XML document</li>\r\n\t *      <li>An binary arraybuffer loaded by XHR</li>\r\n\t * </ul>\r\n\t * Note that if a raw result is requested, but not found, the result will be returned instead.\r\n\t */\r\n\tp.getResult = function (raw) {\r\n\t\tif (raw && this._rawResponse) {\r\n\t\t\treturn this._rawResponse;\r\n\t\t}\r\n\t\treturn this._response;\r\n\t};\r\n\r\n\t// Overrides abstract method in AbstractRequest\r\n\tp.cancel = function () {\r\n\t\tthis.canceled = true;\r\n\t\tthis._clean();\r\n\t\tthis._request.abort();\r\n\t};\r\n\r\n\t// Overrides abstract method in AbstractLoader\r\n\tp.load = function () {\r\n\t\tif (this._request == null) {\r\n\t\t\tthis._handleError();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//Events\r\n\t\tif (this._request.addEventListener != null) {\r\n\t\t\tthis._request.addEventListener("loadstart", this._handleLoadStartProxy, false);\r\n\t\t\tthis._request.addEventListener("progress", this._handleProgressProxy, false);\r\n\t\t\tthis._request.addEventListener("abort", this._handleAbortProxy, false);\r\n\t\t\tthis._request.addEventListener("error", this._handleErrorProxy, false);\r\n\t\t\tthis._request.addEventListener("timeout", this._handleTimeoutProxy, false);\r\n\r\n\t\t\t// Note: We don\'t get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\r\n\t\t\tthis._request.addEventListener("load", this._handleLoadProxy, false);\r\n\t\t\tthis._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);\r\n\t\t} else {\r\n\t\t\t// IE9 support\r\n\t\t\tthis._request.onloadstart = this._handleLoadStartProxy;\r\n\t\t\tthis._request.onprogress = this._handleProgressProxy;\r\n\t\t\tthis._request.onabort = this._handleAbortProxy;\r\n\t\t\tthis._request.onerror = this._handleErrorProxy;\r\n\t\t\tthis._request.ontimeout = this._handleTimeoutProxy;\r\n\r\n\t\t\t// Note: We don\'t get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\r\n\t\t\tthis._request.onload = this._handleLoadProxy;\r\n\t\t\tthis._request.onreadystatechange = this._handleReadyStateChangeProxy;\r\n\t\t}\r\n\r\n\t\t// Set up a timeout if we don\'t have XHR2\r\n\t\tif (this._xhrLevel == 1) {\r\n\t\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\r\n\t\t}\r\n\r\n\t\t// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome\r\n\t\ttry {\r\n\t\t\tif (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {\r\n\t\t\t\tthis._request.send();\r\n\t\t\t} else if (this._item.method == createjs.AbstractLoader.POST) {\r\n\t\t\t\tthis._request.send(createjs.RequestUtils.formatQueryString(this._item.values));\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\tthis.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));\r\n\t\t}\r\n\t};\r\n\r\n\tp.setResponseType = function (type) {\r\n\t\t// Some old browsers doesn\'t support blob, so we convert arraybuffer to blob after response is downloaded\r\n\t\tif (type === \'blob\') {\r\n\t\t\ttype = window.URL ? \'blob\' : \'arraybuffer\';\r\n\t\t\tthis._responseType = type;\r\n\t\t}\r\n\t\tthis._request.responseType = type;\r\n\t};\r\n\r\n\t/**\r\n\t * Get all the response headers from the XmlHttpRequest.\r\n\t *\r\n\t * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match\r\n\t * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,\r\n\t * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE\r\n\t * pair.\r\n\t * @method getAllResponseHeaders\r\n\t * @return {String}\r\n\t * @since 0.4.1\r\n\t */\r\n\tp.getAllResponseHeaders = function () {\r\n\t\tif (this._request.getAllResponseHeaders instanceof Function) {\r\n\t\t\treturn this._request.getAllResponseHeaders();\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Get a specific response header from the XmlHttpRequest.\r\n\t *\r\n\t * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches\r\n\t * header, unless the field name is Set-Cookie or Set-Cookie2.\r\n\t * @method getResponseHeader\r\n\t * @param {String} header The header name to retrieve.\r\n\t * @return {String}\r\n\t * @since 0.4.1\r\n\t */\r\n\tp.getResponseHeader = function (header) {\r\n\t\tif (this._request.getResponseHeader instanceof Function) {\r\n\t\t\treturn this._request.getResponseHeader(header);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\r\n// protected methods\r\n\t/**\r\n\t * The XHR request has reported progress.\r\n\t * @method _handleProgress\r\n\t * @param {Object} event The XHR progress event.\r\n\t * @private\r\n\t */\r\n\tp._handleProgress = function (event) {\r\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\r\n\t\t\treturn; // Sometimes we get no "total", so just ignore the progress event.\r\n\t\t}\r\n\r\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\r\n\t\tthis.dispatchEvent(newEvent);\r\n\t};\r\n\r\n\t/**\r\n\t * The XHR request has reported a load start.\r\n\t * @method _handleLoadStart\r\n\t * @param {Object} event The XHR loadStart event.\r\n\t * @private\r\n\t */\r\n\tp._handleLoadStart = function (event) {\r\n\t\tclearTimeout(this._loadTimeout);\r\n\t\tthis.dispatchEvent("loadstart");\r\n\t};\r\n\r\n\t/**\r\n\t * The XHR request has reported an abort event.\r\n\t * @method handleAbort\r\n\t * @param {Object} event The XHR abort event.\r\n\t * @private\r\n\t */\r\n\tp._handleAbort = function (event) {\r\n\t\tthis._clean();\r\n\t\tthis.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));\r\n\t};\r\n\r\n\t/**\r\n\t * The XHR request has reported an error event.\r\n\t * @method _handleError\r\n\t * @param {Object} event The XHR error event.\r\n\t * @private\r\n\t */\r\n\tp._handleError = function (event) {\r\n\t\tthis._clean();\r\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(event.message));\r\n\t};\r\n\r\n\t/**\r\n\t * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload\r\n\t * event, so we must monitor the readyStateChange to determine if the file is loaded.\r\n\t * @method _handleReadyStateChange\r\n\t * @param {Object} event The XHR readyStateChange event.\r\n\t * @private\r\n\t */\r\n\tp._handleReadyStateChange = function (event) {\r\n\t\tif (this._request.readyState == 4) {\r\n\t\t\tthis._handleLoad();\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has\r\n\t * <code>request.readyState == 4</code>. Only the first call to this method will be processed.\r\n\t * @method _handleLoad\r\n\t * @param {Object} event The XHR load event.\r\n\t * @private\r\n\t */\r\n\tp._handleLoad = function (event) {\r\n\t\tif (this.loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.loaded = true;\r\n\r\n\t\tvar error = this._checkError();\r\n\t\tif (error) {\r\n\t\t\tthis._handleError(error);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._response = this._getResponse();\r\n\t\t// Convert arraybuffer back to blob\r\n\t\tif (this._responseType === \'arraybuffer\') {\r\n\t\t\ttry {\r\n\t\t\t\tthis._response = new Blob([this._response]);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// Fallback to use BlobBuilder if Blob constructor is not supported\r\n\t\t\t\t// Tested on Android 2.3 ~ 4.2 and iOS5 safari\r\n\t\t\t\twindow.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\r\n\t\t\t\tif (e.name === \'TypeError\' && window.BlobBuilder) {\r\n\t\t\t\t\tvar builder = new BlobBuilder();\r\n\t\t\t\t\tbuilder.append(this._response);\r\n\t\t\t\t\tthis._response = builder.getBlob();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._clean();\r\n\r\n\t\tthis.dispatchEvent(new createjs.Event("complete"));\r\n\t};\r\n\r\n\t/**\r\n\t * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>\r\n\t * callback.\r\n\t * @method _handleTimeout\r\n\t * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.\r\n\t * @private\r\n\t */\r\n\tp._handleTimeout = function (event) {\r\n\t\tthis._clean();\r\n\r\n\t\tthis.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));\r\n\t};\r\n\r\n// Protected\r\n\t/**\r\n\t * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note\r\n\t * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.\r\n\t * @method _checkError\r\n\t * @return {int} If the request status returns an error code.\r\n\t * @private\r\n\t */\r\n\tp._checkError = function () {\r\n\t\t//LM: Probably need additional handlers here, maybe 501\r\n\t\tvar status = parseInt(this._request.status);\r\n\r\n\t\tswitch (status) {\r\n\t\t\tcase 404:   // Not Found\r\n\t\t\tcase 0:     // Not Loaded\r\n\t\t\t\treturn new Error(status);\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\r\n\t/**\r\n\t * Validate the response. Different browsers have different approaches, some of which throw errors when accessed\r\n\t * in other browsers. If there is no response, the <code>_response</code> property will remain null.\r\n\t * @method _getResponse\r\n\t * @private\r\n\t */\r\n\tp._getResponse = function () {\r\n\t\tif (this._response != null) {\r\n\t\t\treturn this._response;\r\n\t\t}\r\n\r\n\t\tif (this._request.response != null) {\r\n\t\t\treturn this._request.response;\r\n\t\t}\r\n\r\n\t\t// Android 2.2 uses .responseText\r\n\t\ttry {\r\n\t\t\tif (this._request.responseText != null) {\r\n\t\t\t\treturn this._request.responseText;\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t}\r\n\r\n\t\t// When loading XML, IE9 does not return .response, instead it returns responseXML.xml\r\n\t\ttry {\r\n\t\t\tif (this._request.responseXML != null) {\r\n\t\t\t\treturn this._request.responseXML;\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n\t/**\r\n\t * Create an XHR request. Depending on a number of factors, we get totally different results.\r\n\t * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>\r\n\t *      <li>XMLHttpRequest are created when available.</li>\r\n\t *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>\r\n\t *      <li>Text requests override the mime type if possible</li>\r\n\t *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>\r\n\t *      <li>Binary loads set the response type to "arraybuffer"</li></ol>\r\n\t * @method _createXHR\r\n\t * @param {Object} item The requested item that is being loaded.\r\n\t * @return {Boolean} If an XHR request or equivalent was successfully created.\r\n\t * @private\r\n\t */\r\n\tp._createXHR = function (item) {\r\n\t\t// Check for cross-domain loads. We can\'t fully support them, but we can try.\r\n\t\tvar crossdomain = createjs.RequestUtils.isCrossDomain(item);\r\n\t\tvar headers = {};\r\n\r\n\t\t// Create the request. Fallback to whatever support we have.\r\n\t\tvar req = null;\r\n\t\tif (window.XMLHttpRequest) {\r\n\t\t\treq = new XMLHttpRequest();\r\n\t\t\t// This is 8 or 9, so use XDomainRequest instead.\r\n\t\t\tif (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {\r\n\t\t\t\treq = new XDomainRequest();\r\n\t\t\t}\r\n\t\t} else { // Old IE versions use a different approach\r\n\t\t\tfor (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {\r\n\t\t\t\tvar axVersion = s.ACTIVEX_VERSIONS[i];\r\n\t\t\t\ttry {\r\n\t\t\t\t\treq = new ActiveXObject(axVersion);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (req == null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Default to utf-8 for Text requests.\r\n\t\tif (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {\r\n\t\t\titem.mimeType = "text/plain; charset=utf-8";\r\n\t\t}\r\n\r\n\t\t// IE9 doesn\'t support overrideMimeType(), so we need to check for it.\r\n\t\tif (item.mimeType && req.overrideMimeType) {\r\n\t\t\treq.overrideMimeType(item.mimeType);\r\n\t\t}\r\n\r\n\t\t// Determine the XHR level\r\n\t\tthis._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;\r\n\r\n\t\tvar src = null;\r\n\t\tif (item.method == createjs.AbstractLoader.GET) {\r\n\t\t\tsrc = createjs.RequestUtils.buildPath(item.src, item.values);\r\n\t\t} else {\r\n\t\t\tsrc = item.src;\r\n\t\t}\r\n\r\n\t\t// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)\r\n\t\treq.open(item.method || createjs.AbstractLoader.GET, src, true);\r\n\r\n\t\tif (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {\r\n\t\t\theaders["Origin"] = location.origin;\r\n\t\t}\r\n\r\n\t\t// To send data we need to set the Content-type header)\r\n\t\tif (item.values && item.method == createjs.AbstractLoader.POST) {\r\n\t\t\theaders["Content-Type"] = "application/x-www-form-urlencoded";\r\n\t\t}\r\n\r\n\t\tif (!crossdomain && !headers["X-Requested-With"]) {\r\n\t\t\theaders["X-Requested-With"] = "XMLHttpRequest";\r\n\t\t}\r\n\r\n\t\tif (item.headers) {\r\n\t\t\tfor (var n in item.headers) {\r\n\t\t\t\theaders[n] = item.headers[n];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (n in headers) {\r\n\t\t\treq.setRequestHeader(n, headers[n])\r\n\t\t}\r\n\r\n\t\tif (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {\r\n\t\t\treq.withCredentials = item.withCredentials;\r\n\t\t}\r\n\r\n\t\tthis._request = req;\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * A request has completed (or failed or canceled), and needs to be disposed.\r\n\t * @method _clean\r\n\t * @private\r\n\t */\r\n\tp._clean = function () {\r\n\t\tclearTimeout(this._loadTimeout);\r\n\r\n\t\tif (this._request.removeEventListener != null) {\r\n\t\t\tthis._request.removeEventListener("loadstart", this._handleLoadStartProxy);\r\n\t\t\tthis._request.removeEventListener("progress", this._handleProgressProxy);\r\n\t\t\tthis._request.removeEventListener("abort", this._handleAbortProxy);\r\n\t\t\tthis._request.removeEventListener("error", this._handleErrorProxy);\r\n\t\t\tthis._request.removeEventListener("timeout", this._handleTimeoutProxy);\r\n\t\t\tthis._request.removeEventListener("load", this._handleLoadProxy);\r\n\t\t\tthis._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);\r\n\t\t} else {\r\n\t\t\tthis._request.onloadstart = null;\r\n\t\t\tthis._request.onprogress = null;\r\n\t\t\tthis._request.onabort = null;\r\n\t\t\tthis._request.onerror = null;\r\n\t\t\tthis._request.ontimeout = null;\r\n\t\t\tthis._request.onload = null;\r\n\t\t\tthis._request.onreadystatechange = null;\r\n\t\t}\r\n\t};\r\n\r\n\tp.toString = function () {\r\n\t\treturn "[PreloadJS XHRRequest]";\r\n\t};\r\n\r\n\tcreatejs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// SoundLoader.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t// constructor\r\n\t/**\r\n\t * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which\r\n\t * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an\r\n\t * external framework that handles audio playback. To load content that can be played by WebAudio, use the\r\n\t * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.\r\n\t * @class SoundLoader\r\n\t * @param {LoadItem|Object} loadItem\r\n\t * @param {Boolean} preferXHR\r\n\t * @extends AbstractMediaLoader\r\n\t * @constructor\r\n\t */\r\n\tfunction SoundLoader(loadItem, preferXHR) {\r\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);\r\n\r\n\t\t// protected properties\r\n\t\tif (createjs.RequestUtils.isAudioTag(loadItem)) {\r\n\t\t\tthis._tag = loadItem;\r\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {\r\n\t\t\tthis._tag = loadItem;\r\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {\r\n\t\t\tthis._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;\r\n\t\t}\r\n\r\n\t\tif (this._tag != null) {\r\n\t\t\tthis._preferXHR = false;\r\n\t\t}\r\n\t};\r\n\r\n\tvar p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);\r\n\tvar s = SoundLoader;\r\n\r\n\t// static methods\r\n\t/**\r\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\r\n\t * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.\r\n\t * @method canLoadItem\r\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\r\n\t * @returns {Boolean} Whether the loader can load the item.\r\n\t * @static\r\n\t */\r\n\ts.canLoadItem = function (item) {\r\n\t\treturn item.type == createjs.AbstractLoader.SOUND;\r\n\t};\r\n\r\n\t// protected methods\r\n\tp._createTag = function (src) {\r\n\t\tvar tag = document.createElement("audio");\r\n\t\ttag.autoplay = false;\r\n\t\ttag.preload = "none";\r\n\r\n\t\t//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.\r\n\t\ttag.src = src;\r\n\t\treturn tag;\r\n\t};\r\n\r\n\tcreatejs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// AudioSprite.js\r\n//##############################################################################\r\n\r\n//  NOTE this is "Class" is purely to document audioSprite Setup and usage.\r\n\r\n\r\n/**\r\n * <strong>Note: AudioSprite is not a class, but its usage is easily lost in the documentation, so it has been called\r\n * out here for quick reference.</strong>\r\n *\r\n * Audio sprites are much like CSS sprites or image sprite sheets: multiple audio assets grouped into a single file.\r\n * Audio sprites work around limitations in certain browsers, where only a single sound can be loaded and played at a\r\n * time. We recommend at least 300ms of silence between audio clips to deal with HTML audio tag inaccuracy, and to prevent\r\n * accidentally playing bits of the neighbouring clips.\r\n *\r\n * <strong>Benefits of Audio Sprites:</strong>\r\n * <ul>\r\n *     <li>More robust support for older browsers and devices that only allow a single audio instance, such as iOS 5.</li>\r\n *     <li>They provide a work around for the Internet Explorer 9 audio tag limit, which restricts how many different\r\n *     sounds that could be loaded at once.</li>\r\n *     <li>Faster loading by only requiring a single network request for several sounds, especially on mobile devices\r\n * where the network round trip for each file can add significant latency.</li>\r\n * </ul>\r\n *\r\n * <strong>Drawbacks of Audio Sprites</strong>\r\n * <ul>\r\n *     <li>No guarantee of smooth looping when using HTML or Flash audio. If you have a track that needs to loop\r\n * \t\tsmoothly and you are supporting non-web audio browsers, do not use audio sprites for that sound if you can avoid\r\n * \t\tit.</li>\r\n *     <li>No guarantee that HTML audio will play back immediately, especially the first time. In some browsers\r\n *     (Chrome!), HTML audio will only load enough to play through at the current download speed     so we rely on the\r\n *     `canplaythrough` event to determine if the audio is loaded. Since audio sprites must jump ahead to play specific\r\n *     sounds, the audio may not yet have downloaded fully.</li>\r\n *     <li>Audio sprites share the same core source, so if you have a sprite with 5 sounds and are limited to 2\r\n * \t\tconcurrently playing instances, you can only play 2 of the sounds at the same time.</li>\r\n * </ul>\r\n *\r\n * <h4>Example</h4>\r\n *\r\n *\t\tcreatejs.Sound.initializeDefaultPlugins();\r\n *\t\tvar assetsPath = "./assets/";\r\n *\t\tvar sounds = [{\r\n *\t\t\tsrc:"MyAudioSprite.ogg", data: {\r\n *\t\t\t\taudioSprite: [\r\n *\t\t\t\t\t{id:"sound1", startTime:0, duration:500},\r\n *\t\t\t\t\t{id:"sound2", startTime:1000, duration:400},\r\n *\t\t\t\t\t{id:"sound3", startTime:1700, duration: 1000}\r\n *\t\t\t\t]}\r\n *\t\t\t}\r\n *\t\t];\r\n *\t\tcreatejs.Sound.alternateExtensions = ["mp3"];\r\n *\t\tcreatejs.Sound.on("fileload", loadSound);\r\n *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\r\n *\t\t// after load is complete\r\n *\t\tcreatejs.Sound.play("sound2");\r\n *\r\n * You can also create audio sprites on the fly by setting the startTime and duration when creating an new AbstractSoundInstance.\r\n *\r\n * \t\tcreatejs.Sound.play("MyAudioSprite", {startTime: 1000, duration: 400});\r\n *\r\n * The excellent CreateJS community has created a tool to create audio sprites, available at\r\n * <a href="https://github.com/tonistiigi/audiosprite" target="_blank">https://github.com/tonistiigi/audiosprite</a>,\r\n * as well as a <a href="http://jsfiddle.net/bharat_battu/g8fFP/12/" target="_blank">jsfiddle</a> to convert the output\r\n * to SoundJS format.\r\n *\r\n * @class AudioSprite\r\n * @since 0.6.0\r\n */\r\n\r\n//##############################################################################\r\n// PlayPropsConfig.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\t/**\r\n\t * A class to store the optional play properties passed in {{#crossLink "Sound/play"}}{{/crossLink}} and\r\n\t * {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}} calls.\r\n\t *\r\n\t * Optional Play Properties Include:\r\n\t * <ul>\r\n\t * <li>interrupt - How to interrupt any currently playing instances of audio with the same source,\r\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\r\n\t * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.</li>\r\n\t * <li>delay - The amount of time to delay the start of audio playback, in milliseconds.</li>\r\n\t * <li>offset - The offset from the start of the audio to begin playback, in milliseconds.</li>\r\n\t * <li>loop - How many times the audio loops when it reaches the end of playback. The default is 0 (no\r\n\t * loops), and -1 can be used for infinite playback.</li>\r\n\t * <li>volume - The volume of the sound, between 0 and 1. Note that the master volume is applied\r\n\t * against the individual volume.</li>\r\n\t * <li>pan - The left-right pan of the sound (if supported), between -1 (left) and 1 (right).</li>\r\n\t * <li>startTime - To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.</li>\r\n\t * <li>duration - To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.</li>\r\n\t * </ul>\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t * \tvar ppc = new createjs.PlayPropsConfig().set({interrupt: createjs.Sound.INTERRUPT_ANY, loop: -1, volume: 0.5})\r\n\t * \tcreatejs.Sound.play("mySound", ppc);\r\n\t * \tmySoundInstance.play(ppc);\r\n\t *\r\n\t * @class PlayPropsConfig\r\n\t * @constructor\r\n\t * @since 0.6.1\r\n\t */\r\n\t// TODO think of a better name for this class\r\n\tvar PlayPropsConfig = function () {\r\n// Public Properties\r\n\t\t/**\r\n\t\t * How to interrupt any currently playing instances of audio with the same source,\r\n\t\t * if the maximum number of instances of the sound are already playing. Values are defined as\r\n\t\t * <code>INTERRUPT_TYPE</code> constants on the Sound class, with the default defined by\r\n\t\t * {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\r\n\t\t * @property interrupt\r\n\t\t * @type {string}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.interrupt = null;\r\n\r\n\t\t/**\r\n\t\t * The amount of time to delay the start of audio playback, in milliseconds.\r\n\t\t * @property delay\r\n\t\t * @type {Number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.delay = null;\r\n\r\n\t\t/**\r\n\t\t * The offset from the start of the audio to begin playback, in milliseconds.\r\n\t\t * @property offset\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.offset = null;\r\n\r\n\t\t/**\r\n\t\t * How many times the audio loops when it reaches the end of playback. The default is 0 (no\r\n\t\t * loops), and -1 can be used for infinite playback.\r\n\t\t * @property loop\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.loop = null;\r\n\r\n\t\t/**\r\n\t\t * The volume of the sound, between 0 and 1. Note that the master volume is applied\r\n\t\t * against the individual volume.\r\n\t\t * @property volume\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.volume = null;\r\n\r\n\t\t/**\r\n\t\t * The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\r\n\t\t * @property pan\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.pan = null;\r\n\r\n\t\t/**\r\n\t\t * Used to create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\r\n\t\t * @property startTime\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.startTime = null;\r\n\r\n\t\t/**\r\n\t\t * Used to create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\r\n\t\t * @property duration\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.duration = null;\r\n\t};\r\n\tvar p = PlayPropsConfig.prototype = {};\r\n\tvar s = PlayPropsConfig;\r\n\r\n\r\n// Static Methods\r\n\t/**\r\n\t * Creates a PlayPropsConfig from another PlayPropsConfig or an Object.\r\n\t *\r\n\t * @method create\r\n\t * @param {PlayPropsConfig|Object} value The play properties\r\n\t * @returns {PlayPropsConfig}\r\n\t * @static\r\n\t */\r\n\ts.create = function (value) {\r\n\t\tif (value instanceof s || value instanceof Object) {\r\n\t\t\tvar ppc = new createjs.PlayPropsConfig();\r\n\t\t\tppc.set(value);\r\n\t\t\treturn ppc;\r\n\t\t} else {\r\n\t\t\tthrow new Error("Type not recognized.");\r\n\t\t}\r\n\t};\r\n\r\n// Public Methods\r\n\t/**\r\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      var PlayPropsConfig = new createjs.PlayPropsConfig().set({loop:-1, volume:0.7});\r\n\t *\r\n\t * @method set\r\n\t * @param {Object} props A generic object containing properties to copy to the PlayPropsConfig instance.\r\n\t * @return {PlayPropsConfig} Returns the instance the method is called on (useful for chaining calls.)\r\n\t*/\r\n\tp.set = function(props) {\r\n\t\tfor (var n in props) { this[n] = props[n]; }\r\n\t\treturn this;\r\n\t};\r\n\r\n\tp.toString = function() {\r\n\t\treturn "[PlayPropsConfig]";\r\n\t};\r\n\r\n\tcreatejs.PlayPropsConfig = s;\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// Sound.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * The Sound class is the public API for creating sounds, controlling the overall sound levels, and managing plugins.\r\n\t * All Sound APIs on this class are static.\r\n\t *\r\n\t * <b>Registering and Preloading</b><br />\r\n\t * Before you can play a sound, it <b>must</b> be registered. You can do this with {{#crossLink "Sound/registerSound"}}{{/crossLink}},\r\n\t * or register multiple sounds using {{#crossLink "Sound/registerSounds"}}{{/crossLink}}. If you don\'t register a\r\n\t * sound prior to attempting to play it using {{#crossLink "Sound/play"}}{{/crossLink}} or create it using {{#crossLink "Sound/createInstance"}}{{/crossLink}},\r\n\t * the sound source will be automatically registered but playback will fail as the source will not be ready. If you use\r\n\t * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>, registration is handled for you when the sound is\r\n\t * preloaded. It is recommended to preload sounds either internally using the register functions or externally using\r\n\t * PreloadJS so they are ready when you want to use them.\r\n\t *\r\n\t * <b>Playback</b><br />\r\n\t * To play a sound once it\'s been registered and preloaded, use the {{#crossLink "Sound/play"}}{{/crossLink}} method.\r\n\t * This method returns a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} which can be paused, resumed, muted, etc.\r\n\t * Please see the {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} documentation for more on the instance control APIs.\r\n\t *\r\n\t * <b>Plugins</b><br />\r\n\t * By default, the {{#crossLink "WebAudioPlugin"}}{{/crossLink}} or the {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}\r\n\t * are used (when available), although developers can change plugin priority or add new plugins (such as the\r\n\t * provided {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}). Please see the {{#crossLink "Sound"}}{{/crossLink}} API\r\n\t * methods for more on the playback and plugin APIs. To install plugins, or specify a different plugin order, see\r\n\t * {{#crossLink "Sound/installPlugins"}}{{/crossLink}}.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio";\r\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.FlashAudioPlugin]);\r\n\t *      createjs.Sound.alternateExtensions = ["mp3"];\r\n\t *      createjs.Sound.on("fileload", this.loadHandler, this);\r\n\t *      createjs.Sound.registerSound("path/to/mySound.ogg", "sound");\r\n\t *      function loadHandler(event) {\r\n     *          // This is fired for each sound that is registered.\r\n     *          var instance = createjs.Sound.play("sound");  // play using id.  Could also use full source path or event.src.\r\n     *          instance.on("complete", this.handleComplete, this);\r\n     *          instance.volume = 0.5;\r\n\t *      }\r\n\t *\r\n\t * The maximum number of concurrently playing instances of the same sound can be specified in the "data" argument\r\n\t * of {{#crossLink "Sound/registerSound"}}{{/crossLink}}.  Note that if not specified, the active plugin will apply\r\n\t * a default limit.  Currently HTMLAudioPlugin sets a default limit of 2, while WebAudioPlugin and FlashAudioPlugin set a\r\n\t * default limit of 100.\r\n\t *\r\n\t *      createjs.Sound.registerSound("sound.mp3", "soundId", 4);\r\n\t *\r\n\t * Sound can be used as a plugin with PreloadJS to help preload audio properly. Audio preloaded with PreloadJS is\r\n\t * automatically registered with the Sound class. When audio is not preloaded, Sound will do an automatic internal\r\n\t * load. As a result, it may fail to play the first time play is called if the audio is not finished loading. Use\r\n\t * the {{#crossLink "Sound/fileload:event"}}{{/crossLink}} event to determine when a sound has finished internally\r\n\t * preloading. It is recommended that all audio is preloaded before it is played.\r\n\t *\r\n\t *      var queue = new createjs.LoadQueue();\r\n\t *\t\tqueue.installPlugin(createjs.Sound);\r\n\t *\r\n\t * <b>Audio Sprites</b><br />\r\n\t * SoundJS has added support for {{#crossLink "AudioSprite"}}{{/crossLink}}, available as of version 0.6.0.\r\n\t * For those unfamiliar with audio sprites, they are much like CSS sprites or sprite sheets: multiple audio assets\r\n\t * grouped into a single file.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *\t\tvar assetsPath = "./assets/";\r\n\t *\t\tvar sounds = [{\r\n\t *\t\t\tsrc:"MyAudioSprite.ogg", data: {\r\n\t *\t\t\t\taudioSprite: [\r\n\t *\t\t\t\t\t{id:"sound1", startTime:0, duration:500},\r\n\t *\t\t\t\t\t{id:"sound2", startTime:1000, duration:400},\r\n\t *\t\t\t\t\t{id:"sound3", startTime:1700, duration: 1000}\r\n\t *\t\t\t\t]}\r\n \t *\t\t\t}\r\n\t *\t\t];\r\n\t *\t\tcreatejs.Sound.alternateExtensions = ["mp3"];\r\n\t *\t\tcreatejs.Sound.on("fileload", loadSound);\r\n\t *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\r\n\t *\t\t// after load is complete\r\n\t *\t\tcreatejs.Sound.play("sound2");\r\n\t *\r\n\t * <b>Mobile Playback</b><br />\r\n\t * Devices running iOS require the WebAudio context to be "unlocked" by playing at least one sound inside of a user-\r\n\t * initiated event (such as touch/click). Earlier versions of SoundJS included a "MobileSafe" sample, but this is no\r\n\t * longer necessary as of SoundJS 0.6.2.\r\n\t * <ul>\r\n\t *     <li>\r\n\t *         In SoundJS 0.4.1 and above, you can either initialize plugins or use the {{#crossLink "WebAudioPlugin/playEmptySound"}}{{/crossLink}}\r\n\t *         method in the call stack of a user input event to manually unlock the audio context.\r\n\t *     </li>\r\n\t *     <li>\r\n\t *         In SoundJS 0.6.2 and above, SoundJS will automatically listen for the first document-level "mousedown"\r\n\t *         and "touchend" event, and unlock WebAudio. This will continue to check these events until the WebAudio\r\n\t *         context becomes "unlocked" (changes from "suspended" to "running")\r\n\t *     </li>\r\n\t *     <li>\r\n\t *         Both the "mousedown" and "touchend" events can be used to unlock audio in iOS9+, the "touchstart" event\r\n\t *         will work in iOS8 and below. The "touchend" event will only work in iOS9 when the gesture is interpreted\r\n\t *         as a "click", so if the user long-presses the button, it will no longer work.\r\n\t *     </li>\r\n\t *     <li>\r\n\t *         When using the <a href="http://www.createjs.com/docs/easeljs/classes/Touch.html">EaselJS Touch class</a>,\r\n\t *         the "mousedown" event will not fire when a canvas is clicked, since MouseEvents are prevented, to ensure\r\n\t *         only touch events fire. To get around this, you can either rely on "touchend", or:\r\n\t *         <ol>\r\n\t *             <li>Set the `allowDefault` property on the Touch class constructor to `true` (defaults to `false`).</li>\r\n\t *             <li>Set the `preventSelection` property on the EaselJS `Stage` to `false`.</li>\r\n\t *         </ol>\r\n\t *         These settings may change how your application behaves, and are not recommended.\r\n\t *     </li>\r\n\t * </ul>\r\n\t *\r\n\t * <b>Loading Alternate Paths and Extension-less Files</b><br />\r\n\t * SoundJS supports loading alternate paths and extension-less files by passing an object instead of a string for\r\n\t * the `src` property, which is a hash using the format `{extension:"path", extension2:"path2"}`. These labels are\r\n\t * how SoundJS determines if the browser will support the sound. This also enables multiple formats to live in\r\n\t * different folders, or on CDNs, which often has completely different filenames for each file.\r\n\t *\r\n\t * Priority is determined by the property order (first property is tried first).  This is supported by both internal loading\r\n\t * and loading with PreloadJS.\r\n\t *\r\n\t * <em>Note: an id is required for playback.</em>\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *\t\tvar sounds = {path:"./audioPath/",\r\n\t * \t\t\t\tmanifest: [\r\n\t *\t\t\t\t{id: "cool", src: {mp3:"mp3/awesome.mp3", ogg:"noExtensionOggFile"}}\r\n\t *\t\t]};\r\n\t *\r\n\t *\t\tcreatejs.Sound.alternateExtensions = ["mp3"];\r\n\t *\t\tcreatejs.Sound.addEventListener("fileload", handleLoad);\r\n\t *\t\tcreatejs.Sound.registerSounds(sounds);\r\n\t *\r\n\t * <h3>Known Browser and OS issues</h3>\r\n\t * <b>IE 9 HTML Audio limitations</b><br />\r\n\t * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\r\n\t * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\r\n\t * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\r\n     * <li>MP3 encoding will not always work for audio tags, particularly in Internet Explorer. We\'ve found default\r\n\t * encoding with 64kbps works.</li>\r\n\t * <li>Occasionally very short samples will get cut off.</li>\r\n\t * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by\r\n\t * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe\r\n\t * estimate.</li></ul>\r\n\t *\r\n\t * <b>Firefox 25 Web Audio limitations</b>\r\n\t * <ul><li>mp3 audio files do not load properly on all windows machines, reported\r\n\t * <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>. </br>\r\n\t * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if\r\n\t * possible.</li></ul>\r\n\r\n\t * <b>Safari limitations</b><br />\r\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\r\n\t *\r\n\t * <b>iOS 6 Web Audio limitations</b><br />\r\n\t * <ul><li>Sound is initially locked, and must be unlocked via a user-initiated event. Please see the section on\r\n\t * Mobile Playback above.</li>\r\n\t * <li>A bug exists that will distort un-cached web audio when a video element is present in the DOM that has audio\r\n\t * at a different sampleRate.</li>\r\n\t * </ul>\r\n\t *\r\n\t * <b>Android HTML Audio limitations</b><br />\r\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\r\n\t * <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use\r\n\t * a delay.</li></ul>\r\n\t *\r\n\t * <b>Web Audio and PreloadJS</b><br />\r\n\t * <ul><li>Web Audio must be loaded through XHR, therefore when used with PreloadJS, tag loading is not possible.\r\n\t * This means that tag loading can not be used to avoid cross domain issues.</li><ul>\r\n\t *\r\n\t * @class Sound\r\n\t * @static\r\n\t * @uses EventDispatcher\r\n\t */\r\n\tfunction Sound() {\r\n\t\tthrow "Sound cannot be instantiated";\r\n\t}\r\n\r\n\tvar s = Sound;\r\n\r\n\r\n// Static Properties\r\n\t/**\r\n\t * The interrupt value to interrupt any currently playing instance with the same source, if the maximum number of\r\n\t * instances of the sound are already playing.\r\n\t * @property INTERRUPT_ANY\r\n\t * @type {String}\r\n\t * @default any\r\n\t * @static\r\n\t */\r\n\ts.INTERRUPT_ANY = "any";\r\n\r\n\t/**\r\n\t * The interrupt value to interrupt the earliest currently playing instance with the same source that progressed the\r\n\t * least distance in the audio track, if the maximum number of instances of the sound are already playing.\r\n\t * @property INTERRUPT_EARLY\r\n\t * @type {String}\r\n\t * @default early\r\n\t * @static\r\n\t */\r\n\ts.INTERRUPT_EARLY = "early";\r\n\r\n\t/**\r\n\t * The interrupt value to interrupt the currently playing instance with the same source that progressed the most\r\n\t * distance in the audio track, if the maximum number of instances of the sound are already playing.\r\n\t * @property INTERRUPT_LATE\r\n\t * @type {String}\r\n\t * @default late\r\n\t * @static\r\n\t */\r\n\ts.INTERRUPT_LATE = "late";\r\n\r\n\t/**\r\n\t * The interrupt value to not interrupt any currently playing instances with the same source, if the maximum number of\r\n\t * instances of the sound are already playing.\r\n\t * @property INTERRUPT_NONE\r\n\t * @type {String}\r\n\t * @default none\r\n\t * @static\r\n\t */\r\n\ts.INTERRUPT_NONE = "none";\r\n\r\n\t/**\r\n\t * Defines the playState of an instance that is still initializing.\r\n\t * @property PLAY_INITED\r\n\t * @type {String}\r\n\t * @default playInited\r\n\t * @static\r\n\t */\r\n\ts.PLAY_INITED = "playInited";\r\n\r\n\t/**\r\n\t * Defines the playState of an instance that is currently playing or paused.\r\n\t * @property PLAY_SUCCEEDED\r\n\t * @type {String}\r\n\t * @default playSucceeded\r\n\t * @static\r\n\t */\r\n\ts.PLAY_SUCCEEDED = "playSucceeded";\r\n\r\n\t/**\r\n\t * Defines the playState of an instance that was interrupted by another instance.\r\n\t * @property PLAY_INTERRUPTED\r\n\t * @type {String}\r\n\t * @default playInterrupted\r\n\t * @static\r\n\t */\r\n\ts.PLAY_INTERRUPTED = "playInterrupted";\r\n\r\n\t/**\r\n\t * Defines the playState of an instance that completed playback.\r\n\t * @property PLAY_FINISHED\r\n\t * @type {String}\r\n\t * @default playFinished\r\n\t * @static\r\n\t */\r\n\ts.PLAY_FINISHED = "playFinished";\r\n\r\n\t/**\r\n\t * Defines the playState of an instance that failed to play. This is usually caused by a lack of available channels\r\n\t * when the interrupt mode was "INTERRUPT_NONE", the playback stalled, or the sound could not be found.\r\n\t * @property PLAY_FAILED\r\n\t * @type {String}\r\n\t * @default playFailed\r\n\t * @static\r\n\t */\r\n\ts.PLAY_FAILED = "playFailed";\r\n\r\n\t/**\r\n\t * A list of the default supported extensions that Sound will <i>try</i> to play. Plugins will check if the browser\r\n\t * can play these types, so modifying this list before a plugin is initialized will allow the plugins to try to\r\n\t * support additional media types.\r\n\t *\r\n\t * NOTE this does not currently work for {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.\r\n\t *\r\n\t * More details on file formats can be found at <a href="http://en.wikipedia.org/wiki/Audio_file_format" target="_blank">http://en.wikipedia.org/wiki/Audio_file_format</a>.<br />\r\n\t * A very detailed list of file formats can be found at <a href="http://www.fileinfo.com/filetypes/audio" target="_blank">http://www.fileinfo.com/filetypes/audio</a>.\r\n\t * @property SUPPORTED_EXTENSIONS\r\n\t * @type {Array[String]}\r\n\t * @default ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"]\r\n\t * @since 0.4.0\r\n\t * @static\r\n\t */\r\n\ts.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"];\r\n\r\n\t/**\r\n\t * Some extensions use another type of extension support to play (one of them is a codex).  This allows you to map\r\n\t * that support so plugins can accurately determine if an extension is supported.  Adding to this list can help\r\n\t * plugins determine more accurately if an extension is supported.\r\n\t *\r\n \t * A useful list of extensions for each format can be found at <a href="http://html5doctor.com/html5-audio-the-state-of-play/" target="_blank">http://html5doctor.com/html5-audio-the-state-of-play/</a>.\r\n\t * @property EXTENSION_MAP\r\n\t * @type {Object}\r\n\t * @since 0.4.0\r\n\t * @default {m4a:"mp4"}\r\n\t * @static\r\n\t */\r\n\ts.EXTENSION_MAP = {\r\n\t\tm4a:"mp4"\r\n\t};\r\n\r\n\t/**\r\n\t * The RegExp pattern used to parse file URIs. This supports simple file names, as well as full domain URIs with\r\n\t * query strings. The resulting match is: protocol:$1 domain:$2 path:$3 file:$4 extension:$5 query:$6.\r\n\t * @property FILE_PATTERN\r\n\t * @type {RegExp}\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts.FILE_PATTERN = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([/.]*?(?:[^?]+)?\\/)?((?:[^/?]+)\\.(\\w+))(?:\\?(\\S+)?)?$/;\r\n\r\n\r\n// Class Public properties\r\n\t/**\r\n\t * Determines the default behavior for interrupting other currently playing instances with the same source, if the\r\n\t * maximum number of instances of the sound are already playing.  Currently the default is {{#crossLink "Sound/INTERRUPT_NONE:property"}}{{/crossLink}}\r\n\t * but this can be set and will change playback behavior accordingly.  This is only used when {{#crossLink "Sound/play"}}{{/crossLink}}\r\n\t * is called without passing a value for interrupt.\r\n\t * @property defaultInterruptBehavior\r\n\t * @type {String}\r\n\t * @default Sound.INTERRUPT_NONE, or "none"\r\n\t * @static\r\n\t * @since 0.4.0\r\n\t */\r\n\ts.defaultInterruptBehavior = s.INTERRUPT_NONE;  // OJR does s.INTERRUPT_ANY make more sense as default?  Needs game dev testing to see which case makes more sense.\r\n\r\n\t/**\r\n\t * An array of extensions to attempt to use when loading sound, if the default is unsupported by the active plugin.\r\n\t * These are applied in order, so if you try to Load Thunder.ogg in a browser that does not support ogg, and your\r\n\t * extensions array is ["mp3", "m4a", "wav"] it will check mp3 support, then m4a, then wav. The audio files need\r\n\t * to exist in the same location, as only the extension is altered.\r\n\t *\r\n\t * Note that regardless of which file is loaded, you can call {{#crossLink "Sound/createInstance"}}{{/crossLink}}\r\n\t * and {{#crossLink "Sound/play"}}{{/crossLink}} using the same id or full source path passed for loading.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *\tvar sounds = [\r\n\t *\t\t{src:"myPath/mySound.ogg", id:"example"},\r\n\t *\t];\r\n\t *\tcreatejs.Sound.alternateExtensions = ["mp3"]; // now if ogg is not supported, SoundJS will try asset0.mp3\r\n\t *\tcreatejs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads\r\n\t *\tcreatejs.Sound.registerSounds(sounds, assetPath);\r\n\t *\t// ...\r\n\t *\tcreatejs.Sound.play("myPath/mySound.ogg"); // works regardless of what extension is supported.  Note calling with ID is a better approach\r\n\t *\r\n\t * @property alternateExtensions\r\n\t * @type {Array}\r\n\t * @since 0.5.2\r\n\t * @static\r\n\t */\r\n\ts.alternateExtensions = [];\r\n\r\n\t/**\r\n\t * The currently active plugin. If this is null, then no plugin could be initialized. If no plugin was specified,\r\n\t * Sound attempts to apply the default plugins: {{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by\r\n\t * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\r\n\t * @property activePlugin\r\n\t * @type {Object}\r\n\t * @static\r\n\t */\r\n    s.activePlugin = null;\r\n\r\n\r\n// class getter / setter properties\r\n\t/**\r\n\t * Set the master volume of Sound. The master volume is multiplied against each sound\'s individual volume.  For\r\n\t * example, if master volume is 0.5 and a sound\'s volume is 0.5, the resulting volume is 0.25. To set individual\r\n\t * sound volume, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *     createjs.Sound.volume = 0.5;\r\n\t *\r\n\t *\r\n\t * @property volume\r\n\t * @type {Number}\r\n\t * @default 1\r\n\t * @since 0.6.1\r\n\t */\r\n\ts._masterVolume = 1;\r\n\tObject.defineProperty(s, "volume", {\r\n\t\tget: function () {return this._masterVolume;},\r\n\t\tset: function (value) {\r\n\t\t\t\tif (Number(value) == null) {return false;}\r\n\t\t\t\tvalue = Math.max(0, Math.min(1, value));\r\n\t\t\t\ts._masterVolume = value;\r\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\r\n\t\t\t\t\tvar instances = this._instances;\r\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\r\n\t\t\t\t\t\tinstances[i].setMasterVolume(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t});\r\n\r\n\t/**\r\n\t * Mute/Unmute all audio. Note that muted audio still plays at 0 volume. This global mute value is maintained\r\n\t * separately and when set will override, but not change the mute property of individual instances. To mute an individual\r\n\t * instance, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *     createjs.Sound.muted = true;\r\n\t *\r\n\t *\r\n\t * @property muted\r\n\t * @type {Boolean}\r\n\t * @default false\r\n\t * @since 0.6.1\r\n\t */\r\n\ts._masterMute = false;\r\n\t// OJR references to the methods were not working, so the code had to be duplicated here\r\n\tObject.defineProperty(s, "muted", {\r\n\t\tget: function () {return this._masterMute;},\r\n\t\tset: function (value) {\r\n\t\t\t\tif (value == null) {return false;}\r\n\r\n\t\t\t\tthis._masterMute = value;\r\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\r\n\t\t\t\t\tvar instances = this._instances;\r\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\r\n\t\t\t\t\t\tinstances[i].setMasterMute(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t});\r\n\r\n\t/**\r\n\t * Get the active plugins capabilities, which help determine if a plugin can be used in the current environment,\r\n\t * or if the plugin supports a specific feature. Capabilities include:\r\n\t * <ul>\r\n\t *     <li><b>panning:</b> If the plugin can pan audio from left to right</li>\r\n\t *     <li><b>volume;</b> If the plugin can control audio volume.</li>\r\n\t *     <li><b>tracks:</b> The maximum number of audio tracks that can be played back at a time. This will be -1\r\n\t *     if there is no known limit.</li>\r\n\t * <br />An entry for each file type in {{#crossLink "Sound/SUPPORTED_EXTENSIONS:property"}}{{/crossLink}}:\r\n\t *     <li><b>mp3:</b> If MP3 audio is supported.</li>\r\n\t *     <li><b>ogg:</b> If OGG audio is supported.</li>\r\n\t *     <li><b>wav:</b> If WAV audio is supported.</li>\r\n\t *     <li><b>mpeg:</b> If MPEG audio is supported.</li>\r\n\t *     <li><b>m4a:</b> If M4A audio is supported.</li>\r\n\t *     <li><b>mp4:</b> If MP4 audio is supported.</li>\r\n\t *     <li><b>aiff:</b> If aiff audio is supported.</li>\r\n\t *     <li><b>wma:</b> If wma audio is supported.</li>\r\n\t *     <li><b>mid:</b> If mid audio is supported.</li>\r\n\t * </ul>\r\n\t *\r\n\t * You can get a specific capability of the active plugin using standard object notation\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      var mp3 = createjs.Sound.capabilities.mp3;\r\n\t *\r\n\t * Note this property is read only.\r\n\t *\r\n\t * @property capabilities\r\n\t * @type {Object}\r\n\t * @static\r\n\t * @readOnly\r\n\t * @since 0.6.1\r\n\t */\r\n\tObject.defineProperty(s, "capabilities", {\r\n\t\tget: function () {\r\n\t\t\t\t\tif (s.activePlugin == null) {return null;}\r\n\t\t\t\t\treturn s.activePlugin._capabilities;\r\n\t\t\t\t},\r\n\t\tset: function (value) { return false;}\r\n\t});\r\n\r\n\r\n// Class Private properties\r\n\t/**\r\n\t * Determines if the plugins have been registered. If false, the first call to play() will instantiate the default\r\n\t * plugins ({{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}).\r\n\t * If plugins have been registered, but none are applicable, then sound playback will fail.\r\n\t * @property _pluginsRegistered\r\n\t * @type {Boolean}\r\n\t * @default false\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._pluginsRegistered = false;\r\n\r\n\t/**\r\n\t * Used internally to assign unique IDs to each AbstractSoundInstance.\r\n\t * @property _lastID\r\n\t * @type {Number}\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._lastID = 0;\r\n\r\n\t/**\r\n\t * An array containing all currently playing instances. This allows Sound to control the volume, mute, and playback of\r\n\t * all instances when using static APIs like {{#crossLink "Sound/stop"}}{{/crossLink}} and {{#crossLink "Sound/setVolume"}}{{/crossLink}}.\r\n\t * When an instance has finished playback, it gets removed via the {{#crossLink "Sound/finishedPlaying"}}{{/crossLink}}\r\n\t * method. If the user replays an instance, it gets added back in via the {{#crossLink "Sound/_beginPlaying"}}{{/crossLink}}\r\n\t * method.\r\n\t * @property _instances\r\n\t * @type {Array}\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._instances = [];\r\n\r\n\t/**\r\n\t * An object hash storing objects with sound sources, startTime, and duration via there corresponding ID.\r\n\t * @property _idHash\r\n\t * @type {Object}\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._idHash = {};\r\n\r\n\t/**\r\n\t * An object hash that stores preloading sound sources via the parsed source that is passed to the plugin.  Contains the\r\n\t * source, id, and data that was passed in by the user.  Parsed sources can contain multiple instances of source, id,\r\n\t * and data.\r\n\t * @property _preloadHash\r\n\t * @type {Object}\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._preloadHash = {};\r\n\r\n\t/**\r\n\t * An object hash storing {{#crossLink "PlayPropsConfig"}}{{/crossLink}} via the parsed source that is passed as defaultPlayProps in\r\n\t * {{#crossLink "Sound/registerSound"}}{{/crossLink}} and {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\r\n\t * @property _defaultPlayPropsHash\r\n\t * @type {Object}\r\n\t * @protected\r\n\t * @static\r\n\t * @since 0.6.1\r\n\t */\r\n\ts._defaultPlayPropsHash = {};\r\n\r\n\r\n// EventDispatcher methods:\r\n\ts.addEventListener = null;\r\n\ts.removeEventListener = null;\r\n\ts.removeAllEventListeners = null;\r\n\ts.dispatchEvent = null;\r\n\ts.hasEventListener = null;\r\n\ts._listeners = null;\r\n\r\n\tcreatejs.EventDispatcher.initialize(s); // inject EventDispatcher methods.\r\n\r\n\r\n// Events\r\n\t/**\r\n\t * This event is fired when a file finishes loading internally. This event is fired for each loaded sound,\r\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\r\n\t * @event fileload\r\n\t * @param {Object} target The object that dispatched the event.\r\n\t * @param {String} type The event type.\r\n\t * @param {String} src The source of the sound that was loaded.\r\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\r\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\r\n\t * @since 0.4.1\r\n\t */\r\n\r\n\t/**\r\n\t * This event is fired when a file fails loading internally. This event is fired for each loaded sound,\r\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\r\n\t * @event fileerror\r\n\t * @param {Object} target The object that dispatched the event.\r\n\t * @param {String} type The event type.\r\n\t * @param {String} src The source of the sound that was loaded.\r\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\r\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\r\n\t * @since 0.6.0\r\n\t */\r\n\r\n\r\n// Class Public Methods\r\n\t/**\r\n\t * Get the preload rules to allow Sound to be used as a plugin by <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\r\n\t * Any load calls that have the matching type or extension will fire the callback method, and use the resulting\r\n\t * object, which is potentially modified by Sound. This helps when determining the correct path, as well as\r\n\t * registering the audio instance(s) with Sound. This method should not be called, except by PreloadJS.\r\n\t * @method getPreloadHandlers\r\n\t * @return {Object} An object containing:\r\n\t * <ul><li>callback: A preload callback that is fired when a file is added to PreloadJS, which provides\r\n\t *      Sound a mechanism to modify the load parameters, select the correct file format, register the sound, etc.</li>\r\n\t *      <li>types: A list of file types that are supported by Sound (currently supports "sound").</li>\r\n\t *      <li>extensions: A list of file extensions that are supported by Sound (see {{#crossLink "Sound/SUPPORTED_EXTENSIONS:property"}}{{/crossLink}}).</li></ul>\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts.getPreloadHandlers = function () {\r\n\t\treturn {\r\n\t\t\tcallback:createjs.proxy(s.initLoad, s),\r\n\t\t\ttypes:["sound"],\r\n\t\t\textensions:s.SUPPORTED_EXTENSIONS\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * Used to dispatch fileload events from internal loading.\r\n\t * @method _handleLoadComplete\r\n\t * @param event A loader event.\r\n\t * @protected\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts._handleLoadComplete = function(event) {\r\n\t\tvar src = event.target.getItem().src;\r\n\t\tif (!s._preloadHash[src]) {return;}\r\n\r\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\r\n\t\t\tvar item = s._preloadHash[src][i];\r\n\t\t\ts._preloadHash[src][i] = true;\r\n\r\n\t\t\tif (!s.hasEventListener("fileload")) { continue; }\r\n\r\n\t\t\tvar event = new createjs.Event("fileload");\r\n\t\t\tevent.src = item.src;\r\n\t\t\tevent.id = item.id;\r\n\t\t\tevent.data = item.data;\r\n\t\t\tevent.sprite = item.sprite;\r\n\r\n\t\t\ts.dispatchEvent(event);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Used to dispatch error events from internal preloading.\r\n\t * @param event\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t * @static\r\n\t */\r\n\ts._handleLoadError = function(event) {\r\n\t\tvar src = event.target.getItem().src;\r\n\t\tif (!s._preloadHash[src]) {return;}\r\n\r\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\r\n\t\t\tvar item = s._preloadHash[src][i];\r\n\t\t\ts._preloadHash[src][i] = false;\r\n\r\n\t\t\tif (!s.hasEventListener("fileerror")) { continue; }\r\n\r\n\t\t\tvar event = new createjs.Event("fileerror");\r\n\t\t\tevent.src = item.src;\r\n\t\t\tevent.id = item.id;\r\n\t\t\tevent.data = item.data;\r\n\t\t\tevent.sprite = item.sprite;\r\n\r\n\t\t\ts.dispatchEvent(event);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Used by {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} to register a Sound plugin.\r\n\t *\r\n\t * @method _registerPlugin\r\n\t * @param {Object} plugin The plugin class to install.\r\n\t * @return {Boolean} Whether the plugin was successfully initialized.\r\n\t * @static\r\n\t * @private\r\n\t */\r\n\ts._registerPlugin = function (plugin) {\r\n\t\t// Note: Each plugin is passed in as a class reference, but we store the activePlugin as an instance\r\n\t\tif (plugin.isSupported()) {\r\n\t\t\ts.activePlugin = new plugin();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * Register a list of Sound plugins, in order of precedence. To register a single plugin, pass a single element in the array.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";\r\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\r\n\t *\r\n\t * @method registerPlugins\r\n\t * @param {Array} plugins An array of plugins classes to install.\r\n\t * @return {Boolean} Whether a plugin was successfully initialized.\r\n\t * @static\r\n\t */\r\n\ts.registerPlugins = function (plugins) {\r\n\t\ts._pluginsRegistered = true;\r\n\t\tfor (var i = 0, l = plugins.length; i < l; i++) {\r\n\t\t\tif (s._registerPlugin(plugins[i])) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * Initialize the default plugins. This method is automatically called when any audio is played or registered before\r\n\t * the user has manually registered plugins, and enables Sound to work without manual plugin setup. Currently, the\r\n\t * default plugins are {{#crossLink "WebAudioPlugin"}}{{/crossLink}} followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t * \tif (!createjs.initializeDefaultPlugins()) { return; }\r\n\t *\r\n\t * @method initializeDefaultPlugins\r\n\t * @returns {Boolean} True if a plugin was initialized, false otherwise.\r\n\t * @since 0.4.0\r\n\t * @static\r\n\t */\r\n\ts.initializeDefaultPlugins = function () {\r\n\t\tif (s.activePlugin != null) {return true;}\r\n\t\tif (s._pluginsRegistered) {return false;}\r\n\t\tif (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) {return true;}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * Determines if Sound has been initialized, and a plugin has been activated.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t * This example sets up a Flash fallback, but only if there is no plugin specified yet.\r\n\t *\r\n\t * \tif (!createjs.Sound.isReady()) {\r\n\t *\t\tcreatejs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";\r\n\t * \t\tcreatejs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\r\n\t *\t}\r\n\t *\r\n\t * @method isReady\r\n\t * @return {Boolean} If Sound has initialized a plugin.\r\n\t * @static\r\n\t */\r\n\ts.isReady = function () {\r\n\t\treturn (s.activePlugin != null);\r\n\t};\r\n\r\n\t/**\r\n\t * Deprecated, please use {{#crossLink "Sound/capabilities:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * @method getCapabilities\r\n\t * @return {Object} An object containing the capabilities of the active plugin.\r\n\t * @static\r\n\t * @deprecated\r\n\t */\r\n\ts.getCapabilities = function () {\r\n\t\tif (s.activePlugin == null) {return null;}\r\n\t\treturn s.activePlugin._capabilities;\r\n\t};\r\n\r\n\t/**\r\n\t * Deprecated, please use {{#crossLink "Sound/capabilities:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * @method getCapability\r\n\t * @param {String} key The capability to retrieve\r\n\t * @return {Number|Boolean} The value of the capability.\r\n\t * @static\r\n\t * @see getCapabilities\r\n\t * @deprecated\r\n\t */\r\n\ts.getCapability = function (key) {\r\n\t\tif (s.activePlugin == null) {return null;}\r\n\t\treturn s.activePlugin._capabilities[key];\r\n\t};\r\n\r\n\t/**\r\n\t * Process manifest items from <a href="http://preloadjs.com" target="_blank">PreloadJS</a>. This method is intended\r\n\t * for usage by a plugin, and not for direct interaction.\r\n\t * @method initLoad\r\n\t * @param {Object} src The object to load.\r\n\t * @return {Object|AbstractLoader} An instance of AbstractLoader.\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts.initLoad = function (loadItem) {\r\n\t\treturn s._registerSound(loadItem);\r\n\t};\r\n\r\n\t/**\r\n\t * Internal method for loading sounds.  This should not be called directly.\r\n\t *\r\n\t * @method _registerSound\r\n\t * @param {Object} src The object to load, containing src property and optionally containing id and data.\r\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\r\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\r\n\t * Returns true if the source is already loaded.\r\n\t * @static\r\n\t * @private\r\n\t * @since 0.6.0\r\n\t */\r\n\r\n\ts._registerSound = function (loadItem) {\r\n\t\tif (!s.initializeDefaultPlugins()) {return false;}\r\n\r\n\t\tvar details;\r\n\t\tif (loadItem.src instanceof Object) {\r\n\t\t\tdetails = s._parseSrc(loadItem.src);\r\n\t\t\tdetails.src = loadItem.path + details.src;\r\n\t\t} else {\r\n\t\t\tdetails = s._parsePath(loadItem.src);\r\n\t\t}\r\n\t\tif (details == null) {return false;}\r\n\t\tloadItem.src = details.src;\r\n\t\tloadItem.type = "sound";\r\n\r\n\t\tvar data = loadItem.data;\r\n\t\tvar numChannels = null;\r\n\t\tif (data != null) {\r\n\t\t\tif (!isNaN(data.channels)) {\r\n\t\t\t\tnumChannels = parseInt(data.channels);\r\n\t\t\t} else if (!isNaN(data)) {\r\n\t\t\t\tnumChannels = parseInt(data);\r\n\t\t\t}\r\n\r\n\t\t\tif(data.audioSprite) {\r\n\t\t\t\tvar sp;\r\n\t\t\t\tfor(var i = data.audioSprite.length; i--; ) {\r\n\t\t\t\t\tsp = data.audioSprite[i];\r\n\t\t\t\t\ts._idHash[sp.id] = {src: loadItem.src, startTime: parseInt(sp.startTime), duration: parseInt(sp.duration)};\r\n\r\n\t\t\t\t\tif (sp.defaultPlayProps) {\r\n\t\t\t\t\t\ts._defaultPlayPropsHash[sp.id] = createjs.PlayPropsConfig.create(sp.defaultPlayProps);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (loadItem.id != null) {s._idHash[loadItem.id] = {src: loadItem.src}};\r\n\t\tvar loader = s.activePlugin.register(loadItem);\r\n\r\n\t\tSoundChannel.create(loadItem.src, numChannels);\r\n\r\n\t\t// return the number of instances to the user.  This will also be returned in the load event.\r\n\t\tif (data == null || !isNaN(data)) {\r\n\t\t\tloadItem.data = numChannels || SoundChannel.maxPerChannel();\r\n\t\t} else {\r\n\t\t\tloadItem.data.channels = numChannels || SoundChannel.maxPerChannel();\r\n\t\t}\r\n\r\n\t\tif (loader.type) {loadItem.type = loader.type;}\r\n\r\n\t\tif (loadItem.defaultPlayProps) {\r\n\t\t\ts._defaultPlayPropsHash[loadItem.src] = createjs.PlayPropsConfig.create(loadItem.defaultPlayProps);\r\n\t\t}\r\n\t\treturn loader;\r\n\t};\r\n\r\n\t/**\r\n\t * Register an audio file for loading and future playback in Sound. This is automatically called when using\r\n\t * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.  It is recommended to register all sounds that\r\n\t * need to be played back in order to properly prepare and preload them. Sound does internal preloading when required.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      createjs.Sound.alternateExtensions = ["mp3"];\r\n\t *      createjs.Sound.on("fileload", handleLoad); // add an event listener for when load is completed\r\n\t *      createjs.Sound.registerSound("myAudioPath/mySound.ogg", "myID", 3);\r\n\t *      createjs.Sound.registerSound({ogg:"path1/mySound.ogg", mp3:"path2/mySoundNoExtension"}, "myID", 3);\r\n\t *\r\n\t *\r\n\t * @method registerSound\r\n\t * @param {String | Object} src The source or an Object with a "src" property or an Object with multiple extension labeled src properties.\r\n\t * @param {String} [id] An id specified by the user to play the sound later.  Note id is required for when src is multiple extension labeled src properties.\r\n\t * @param {Number | Object} [data] Data associated with the item. Sound uses the data parameter as the number of\r\n\t * channels for an audio instance, however a "channels" property can be appended to the data object if it is used\r\n\t * for other information. The audio channels will set a default based on plugin if no value is found.\r\n\t * Sound also uses the data property to hold an {{#crossLink "AudioSprite"}}{{/crossLink}} array of objects in the following format {id, startTime, duration}.<br/>\r\n\t *   id used to play the sound later, in the same manner as a sound src with an id.<br/>\r\n\t *   startTime is the initial offset to start playback and loop from, in milliseconds.<br/>\r\n\t *   duration is the amount of time to play the clip for, in milliseconds.<br/>\r\n\t * This allows Sound to support audio sprites that are played back by id.\r\n\t * @param {string} basePath Set a path that will be prepended to src for loading.\r\n\t * @param {Object | PlayPropsConfig} defaultPlayProps Optional Playback properties that will be set as the defaults on any new AbstractSoundInstance.\r\n\t * See {{#crossLink "PlayPropsConfig"}}{{/crossLink}} for options.\r\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\r\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\r\n\t * Returns true if the source is already loaded.\r\n\t * @static\r\n\t * @since 0.4.0\r\n\t */\r\n\ts.registerSound = function (src, id, data, basePath, defaultPlayProps) {\r\n\t\tvar loadItem = {src: src, id: id, data:data, defaultPlayProps:defaultPlayProps};\r\n\t\tif (src instanceof Object && src.src) {\r\n\t\t\tbasePath = id;\r\n\t\t\tloadItem = src;\r\n\t\t}\r\n\t\tloadItem = createjs.LoadItem.create(loadItem);\r\n\t\tloadItem.path = basePath;\r\n\r\n\t\tif (basePath != null && !(loadItem.src instanceof Object)) {loadItem.src = basePath + src;}\r\n\r\n\t\tvar loader = s._registerSound(loadItem);\r\n\t\tif(!loader) {return false;}\r\n\r\n\t\tif (!s._preloadHash[loadItem.src]) { s._preloadHash[loadItem.src] = [];}\r\n\t\ts._preloadHash[loadItem.src].push(loadItem);\r\n\t\tif (s._preloadHash[loadItem.src].length == 1) {\r\n\t\t\t// OJR note this will disallow reloading a sound if loading fails or the source changes\r\n\t\t\tloader.on("complete", createjs.proxy(this._handleLoadComplete, this));\r\n\t\t\tloader.on("error", createjs.proxy(this._handleLoadError, this));\r\n\t\t\ts.activePlugin.preload(loader);\r\n\t\t} else {\r\n\t\t\tif (s._preloadHash[loadItem.src][0] == true) {return true;}\r\n\t\t}\r\n\r\n\t\treturn loadItem;\r\n\t};\r\n\r\n\t/**\r\n\t * Register an array of audio files for loading and future playback in Sound. It is recommended to register all\r\n\t * sounds that need to be played back in order to properly prepare and preload them. Sound does internal preloading\r\n\t * when required.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t * \t\tvar assetPath = "./myAudioPath/";\r\n\t *      var sounds = [\r\n\t *          {src:"asset0.ogg", id:"example"},\r\n\t *          {src:"asset1.ogg", id:"1", data:6},\r\n\t *          {src:"asset2.mp3", id:"works"}\r\n\t *          {src:{mp3:"path1/asset3.mp3", ogg:"path2/asset3NoExtension}, id:"better"}\r\n\t *      ];\r\n\t *      createjs.Sound.alternateExtensions = ["mp3"];\t// if the passed extension is not supported, try this extension\r\n\t *      createjs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads\r\n\t *      createjs.Sound.registerSounds(sounds, assetPath);\r\n\t *\r\n\t * @method registerSounds\r\n\t * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for\r\n\t * {{#crossLink "Sound/registerSound"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>\r\n\t * with "id" and "data" being optional.\r\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to load.\r\n\t * Note id is required if src is an object with extension labeled src properties.\r\n\t * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing\r\n\t * audio that was loaded with a basePath by src, the basePath must be included.\r\n\t * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.\r\n\t * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.\r\n\t * Also, it will return true for any values when the source is already loaded.\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.registerSounds = function (sounds, basePath) {\r\n\t\tvar returnValues = [];\r\n\t\tif (sounds.path) {\r\n\t\t\tif (!basePath) {\r\n\t\t\t\tbasePath = sounds.path;\r\n\t\t\t} else {\r\n\t\t\t\tbasePath = basePath + sounds.path;\r\n\t\t\t}\r\n\t\t\tsounds = sounds.manifest;\r\n\t\t\t// TODO document this feature\r\n\t\t}\r\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\r\n\t\t\treturnValues[i] = createjs.Sound.registerSound(sounds[i].src, sounds[i].id, sounds[i].data, basePath, sounds[i].defaultPlayProps);\r\n\t\t}\r\n\t\treturn returnValues;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove a sound that has been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\r\n\t * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\r\n\t * <br />Note this will stop playback on active instances playing this sound before deleting them.\r\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      createjs.Sound.removeSound("myID");\r\n\t *      createjs.Sound.removeSound("myAudioBasePath/mySound.ogg");\r\n\t *      createjs.Sound.removeSound("myPath/myOtherSound.mp3", "myBasePath/");\r\n\t *      createjs.Sound.removeSound({mp3:"musicNoExtension", ogg:"music.ogg"}, "myBasePath/");\r\n\t *\r\n\t * @method removeSound\r\n\t * @param {String | Object} src The src or ID of the audio, or an Object with a "src" property, or an Object with multiple extension labeled src properties.\r\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\r\n\t * @return {Boolean} True if sound is successfully removed.\r\n\t * @static\r\n\t * @since 0.4.1\r\n\t */\r\n\ts.removeSound = function(src, basePath) {\r\n\t\tif (s.activePlugin == null) {return false;}\r\n\r\n\t\tif (src instanceof Object && src.src) {src = src.src;}\r\n\r\n\t\tvar details;\r\n\t\tif (src instanceof Object) {\r\n\t\t\tdetails = s._parseSrc(src);\r\n\t\t} else {\r\n\t\t\tsrc = s._getSrcById(src).src;\r\n\t\t\tdetails = s._parsePath(src);\r\n\t\t}\r\n\t\tif (details == null) {return false;}\r\n\t\tsrc = details.src;\r\n\t\tif (basePath != null) {src = basePath + src;}\r\n\r\n\t\tfor(var prop in s._idHash){\r\n\t\t\tif(s._idHash[prop].src == src) {\r\n\t\t\t\tdelete(s._idHash[prop]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// clear from SoundChannel, which also stops and deletes all instances\r\n\t\tSoundChannel.removeSrc(src);\r\n\r\n\t\tdelete(s._preloadHash[src]);\r\n\r\n\t\ts.activePlugin.removeSound(src);\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove an array of audio files that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\r\n\t * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\r\n\t * <br />Note this will stop playback on active instances playing this audio before deleting them.\r\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t * \t\tassetPath = "./myPath/";\r\n\t *      var sounds = [\r\n\t *          {src:"asset0.ogg", id:"example"},\r\n\t *          {src:"asset1.ogg", id:"1", data:6},\r\n\t *          {src:"asset2.mp3", id:"works"}\r\n\t *      ];\r\n\t *      createjs.Sound.removeSounds(sounds, assetPath);\r\n\t *\r\n\t * @method removeSounds\r\n\t * @param {Array} sounds An array of objects to remove. Objects are expected to be in the format needed for\r\n\t * {{#crossLink "Sound/removeSound"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>.\r\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to remove.\r\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\r\n\t * @return {Object} An array of Boolean values representing if the sounds with the same array index were\r\n\t * successfully removed.\r\n\t * @static\r\n\t * @since 0.4.1\r\n\t */\r\n\ts.removeSounds = function (sounds, basePath) {\r\n\t\tvar returnValues = [];\r\n\t\tif (sounds.path) {\r\n\t\t\tif (!basePath) {\r\n\t\t\t\tbasePath = sounds.path;\r\n\t\t\t} else {\r\n\t\t\t\tbasePath = basePath + sounds.path;\r\n\t\t\t}\r\n\t\t\tsounds = sounds.manifest;\r\n\t\t}\r\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\r\n\t\t\treturnValues[i] = createjs.Sound.removeSound(sounds[i].src, basePath);\r\n\t\t}\r\n\t\treturn returnValues;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove all sounds that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\r\n\t * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\r\n\t * <br />Note this will stop playback on all active sound instances before deleting them.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *     createjs.Sound.removeAllSounds();\r\n\t *\r\n\t * @method removeAllSounds\r\n\t * @static\r\n\t * @since 0.4.1\r\n\t */\r\n\ts.removeAllSounds = function() {\r\n\t\ts._idHash = {};\r\n\t\ts._preloadHash = {};\r\n\t\tSoundChannel.removeAll();\r\n\t\tif (s.activePlugin) {s.activePlugin.removeAllSounds();}\r\n\t};\r\n\r\n\t/**\r\n\t * Check if a source has been loaded by internal preloaders. This is necessary to ensure that sounds that are\r\n\t * not completed preloading will not kick off a new internal preload if they are played.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *     var mySound = "assetPath/asset0.ogg";\r\n\t *     if(createjs.Sound.loadComplete(mySound) {\r\n\t *         createjs.Sound.play(mySound);\r\n\t *     }\r\n\t *\r\n\t * @method loadComplete\r\n\t * @param {String} src The src or id that is being loaded.\r\n\t * @return {Boolean} If the src is already loaded.\r\n\t * @since 0.4.0\r\n\t * @static\r\n\t */\r\n\ts.loadComplete = function (src) {\r\n\t\tif (!s.isReady()) { return false; }\r\n\t\tvar details = s._parsePath(src);\r\n\t\tif (details) {\r\n\t\t\tsrc = s._getSrcById(details.src).src;\r\n\t\t} else {\r\n\t\t\tsrc = s._getSrcById(src).src;\r\n\t\t}\r\n\t\tif(s._preloadHash[src] == undefined) {return false;}\r\n\t\treturn (s._preloadHash[src][0] == true);  // src only loads once, so if it\'s true for the first it\'s true for all\r\n\t};\r\n\r\n\t/**\r\n\t * Parse the path of a sound. Alternate extensions will be attempted in order if the\r\n\t * current extension is not supported\r\n\t * @method _parsePath\r\n\t * @param {String} value The path to an audio source.\r\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink "Sound/activePlugin:property"}}{{/crossLink}}\r\n\t * and returned to a preloader like <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._parsePath = function (value) {\r\n\t\tif (typeof(value) != "string") {value = value.toString();}\r\n\r\n\t\tvar match = value.match(s.FILE_PATTERN);\r\n\t\tif (match == null) {return false;}\r\n\r\n\t\tvar name = match[4];\r\n\t\tvar ext = match[5];\r\n\t\tvar c = s.capabilities;\r\n\t\tvar i = 0;\r\n\t\twhile (!c[ext]) {\r\n\t\t\text = s.alternateExtensions[i++];\r\n\t\t\tif (i > s.alternateExtensions.length) { return null;}\t// no extensions are supported\r\n\t\t}\r\n\t\tvalue = value.replace("."+match[5], "."+ext);\r\n\r\n\t\tvar ret = {name:name, src:value, extension:ext};\r\n\t\treturn ret;\r\n\t};\r\n\r\n\t/**\r\n\t * Parse the path of a sound based on properties of src matching with supported extensions.\r\n\t * Returns false if none of the properties are supported\r\n\t * @method _parseSrc\r\n\t * @param {Object} value The paths to an audio source, indexed by extension type.\r\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink "Sound/activePlugin:property"}}{{/crossLink}}\r\n\t * and returned to a preloader like <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._parseSrc = function (value) {\r\n\t\tvar ret = {name:undefined, src:undefined, extension:undefined};\r\n\t\tvar c = s.capabilities;\r\n\r\n\t\tfor (var prop in value) {\r\n\t\t  if(value.hasOwnProperty(prop) && c[prop]) {\r\n\t\t\t\tret.src = value[prop];\r\n\t\t\t\tret.extension = prop;\r\n\t\t\t\tbreak;\r\n\t\t  }\r\n\t\t}\r\n\t\tif (!ret.src) {return false;}\t// no matches\r\n\r\n\t\tvar i = ret.src.lastIndexOf("/");\r\n\t\tif (i != -1) {\r\n\t\t\tret.name = ret.src.slice(i+1);\r\n\t\t} else {\r\n\t\t\tret.name = ret.src;\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t};\r\n\r\n\t/* ---------------\r\n\t Static API.\r\n\t --------------- */\r\n\t/**\r\n\t * Play a sound and get a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to control. If the sound fails to play, a\r\n\t * AbstractSoundInstance will still be returned, and have a playState of {{#crossLink "Sound/PLAY_FAILED:property"}}{{/crossLink}}.\r\n\t * Note that even on sounds with failed playback, you may still be able to call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}},\r\n\t * since the failure could be due to lack of available channels. If the src does not have a supported extension or\r\n\t * if there is no available plugin, a default AbstractSoundInstance will be returned which will not play any audio, but will not generate errors.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      createjs.Sound.on("fileload", handleLoad);\r\n\t *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);\r\n\t *      function handleLoad(event) {\r\n\t *      \tcreatejs.Sound.play("myID");\r\n\t *      \t// store off AbstractSoundInstance for controlling\r\n\t *      \tvar myInstance = createjs.Sound.play("myID", {interrupt: createjs.Sound.INTERRUPT_ANY, loop:-1});\r\n\t *      }\r\n\t *\r\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\r\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\r\n\t *\r\n\t * <b>Parameters Deprecated</b><br />\r\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink "PlayPropsConfig"}}{{/crossLink}}.\r\n\t *\r\n\t * @method play\r\n\t * @param {String} src The src or ID of the audio.\r\n\t * @param {String | Object} [interrupt="none"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\r\n\t * This parameter can be an instance of {{#crossLink "PlayPropsConfig"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\r\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\r\n\t * <br /><strong>OR</strong><br />\r\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\r\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\r\n\t * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\r\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\r\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\r\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\r\n\t * loops), and -1 can be used for infinite playback.\r\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\r\n\t * against the individual volume.\r\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\r\n\t * @param {Number} [startTime=null] <b>Deprecated</b> To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\r\n\t * @param {Number} [duration=null] <b>Deprecated</b> To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\r\n\t * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.\r\n\t * @static\r\n\t */\r\n\ts.play = function (src, interrupt, delay, offset, loop, volume, pan, startTime, duration) {\r\n\t\tvar playProps;\r\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\r\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\r\n\t\t} else {\r\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan, startTime:startTime, duration:duration});\r\n\t\t}\r\n\t\tvar instance = s.createInstance(src, playProps.startTime, playProps.duration);\r\n\t\tvar ok = s._playInstance(instance, playProps);\r\n\t\tif (!ok) {instance._playFailed();}\r\n\t\treturn instance;\r\n\t};\r\n\r\n\t/**\r\n\t * Creates a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} using the passed in src. If the src does not have a\r\n\t * supported extension or if there is no available plugin, a default AbstractSoundInstance will be returned that can be\r\n\t * called safely but does nothing.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      var myInstance = null;\r\n\t *      createjs.Sound.on("fileload", handleLoad);\r\n\t *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);\r\n\t *      function handleLoad(event) {\r\n\t *      \tmyInstance = createjs.Sound.createInstance("myID");\r\n\t *      \t// alternately we could call the following\r\n\t *      \tmyInstance = createjs.Sound.createInstance("myAudioPath/mySound.mp3");\r\n\t *      }\r\n\t *\r\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\r\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\r\n\t *\r\n\t * @method createInstance\r\n\t * @param {String} src The src or ID of the audio.\r\n\t * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\r\n\t * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\r\n\t * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.\r\n\t * Unsupported extensions will return the default AbstractSoundInstance.\r\n\t * @since 0.4.0\r\n\t * @static\r\n\t */\r\n\ts.createInstance = function (src, startTime, duration) {\r\n\t\tif (!s.initializeDefaultPlugins()) {return new createjs.DefaultSoundInstance(src, startTime, duration);}\r\n\r\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[src];\t// for audio sprites, which create and store defaults by id\r\n\t\tsrc = s._getSrcById(src);\r\n\r\n\t\tvar details = s._parsePath(src.src);\r\n\r\n\t\tvar instance = null;\r\n\t\tif (details != null && details.src != null) {\r\n\t\t\tSoundChannel.create(details.src);\r\n\t\t\tif (startTime == null) {startTime = src.startTime;}\r\n\t\t\tinstance = s.activePlugin.create(details.src, startTime, duration || src.duration);\r\n\r\n\t\t\tdefaultPlayProps = defaultPlayProps || s._defaultPlayPropsHash[details.src];\r\n\t\t\tif(defaultPlayProps) {\r\n\t\t\t\tinstance.applyPlayProps(defaultPlayProps);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tinstance = new createjs.DefaultSoundInstance(src, startTime, duration);\r\n\t\t}\r\n\r\n\t\tinstance.uniqueId = s._lastID++;\r\n\r\n\t\treturn instance;\r\n\t};\r\n\r\n\t/**\r\n\t * Stop all audio (global stop). Stopped audio is reset, and not paused. To play audio that has been stopped,\r\n\t * call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *     createjs.Sound.stop();\r\n\t *\r\n\t * @method stop\r\n\t * @static\r\n\t */\r\n\ts.stop = function () {\r\n\t\tvar instances = this._instances;\r\n\t\tfor (var i = instances.length; i--; ) {\r\n\t\t\tinstances[i].stop();  // NOTE stop removes instance from this._instances\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Deprecated, please use {{#crossLink "Sound/volume:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * @method setVolume\r\n\t * @param {Number} value The master volume value. The acceptable range is 0-1.\r\n\t * @static\r\n\t * @deprecated\r\n\t */\r\n\ts.setVolume = function (value) {\r\n\t\tif (Number(value) == null) {return false;}\r\n\t\tvalue = Math.max(0, Math.min(1, value));\r\n\t\ts._masterVolume = value;\r\n\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\r\n\t\t\tvar instances = this._instances;\r\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\r\n\t\t\t\tinstances[i].setMasterVolume(value);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Deprecated, please use {{#crossLink "Sound/volume:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * @method getVolume\r\n\t * @return {Number} The master volume, in a range of 0-1.\r\n\t * @static\r\n\t * @deprecated\r\n\t */\r\n\ts.getVolume = function () {\r\n\t\treturn this._masterVolume;\r\n\t};\r\n\r\n\t/**\r\n\t * Deprecated, please use {{#crossLink "Sound/muted:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * @method setMute\r\n\t * @param {Boolean} value Whether the audio should be muted or not.\r\n\t * @return {Boolean} If the mute was set.\r\n\t * @static\r\n\t * @since 0.4.0\r\n\t * @deprecated\r\n\t */\r\n\ts.setMute = function (value) {\r\n\t\tif (value == null) {return false;}\r\n\r\n\t\tthis._masterMute = value;\r\n\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\r\n\t\t\tvar instances = this._instances;\r\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\r\n\t\t\t\tinstances[i].setMasterMute(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Deprecated, please use {{#crossLink "Sound/muted:property"}}{{/crossLink}} instead.\r\n\t *\r\n\t * @method getMute\r\n\t * @return {Boolean} The mute value of Sound.\r\n\t * @static\r\n\t * @since 0.4.0\r\n\t * @deprecated\r\n\t */\r\n\ts.getMute = function () {\r\n\t\treturn this._masterMute;\r\n\t};\r\n\r\n\t/**\r\n\t * Set the default playback properties for all new SoundInstances of the passed in src or ID.\r\n\t * See {{#crossLink "PlayPropsConfig"}}{{/crossLink}} for available properties.\r\n\t *\r\n\t * @method setDefaultPlayProps\r\n\t * @param {String} src The src or ID used to register the audio.\r\n\t * @param {Object | PlayPropsConfig} playProps The playback properties you would like to set.\r\n\t * @since 0.6.1\r\n\t */\r\n\ts.setDefaultPlayProps = function(src, playProps) {\r\n\t\tsrc = s._getSrcById(src);\r\n\t\ts._defaultPlayPropsHash[s._parsePath(src.src).src] = createjs.PlayPropsConfig.create(playProps);\r\n\t};\r\n\r\n\t/**\r\n\t * Get the default playback properties for the passed in src or ID.  These properties are applied to all\r\n\t * new SoundInstances.  Returns null if default does not exist.\r\n\t *\r\n\t * @method getDefaultPlayProps\r\n\t * @param {String} src The src or ID used to register the audio.\r\n\t * @returns {PlayPropsConfig} returns an existing PlayPropsConfig or null if one does not exist\r\n\t * @since 0.6.1\r\n\t */\r\n\ts.getDefaultPlayProps = function(src) {\r\n\t\tsrc = s._getSrcById(src);\r\n\t\treturn s._defaultPlayPropsHash[s._parsePath(src.src).src];\r\n\t};\r\n\r\n\r\n\t/* ---------------\r\n\t Internal methods\r\n\t --------------- */\r\n\t/**\r\n\t * Play an instance. This is called by the static API, as well as from plugins. This allows the core class to\r\n\t * control delays.\r\n\t * @method _playInstance\r\n\t * @param {AbstractSoundInstance} instance The {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to start playing.\r\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\r\n\t * @return {Boolean} If the sound can start playing. Sounds that fail immediately will return false. Sounds that\r\n\t * have a delay will return true, but may still fail to play.\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._playInstance = function (instance, playProps) {\r\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[instance.src] || {};\r\n\t\tif (playProps.interrupt == null) {playProps.interrupt = defaultPlayProps.interrupt || s.defaultInterruptBehavior};\r\n\t\tif (playProps.delay == null) {playProps.delay = defaultPlayProps.delay || 0;}\r\n\t\tif (playProps.offset == null) {playProps.offset = instance.getPosition();}\r\n\t\tif (playProps.loop == null) {playProps.loop = instance.loop;}\r\n\t\tif (playProps.volume == null) {playProps.volume = instance.volume;}\r\n\t\tif (playProps.pan == null) {playProps.pan = instance.pan;}\r\n\r\n\t\tif (playProps.delay == 0) {\r\n\t\t\tvar ok = s._beginPlaying(instance, playProps);\r\n\t\t\tif (!ok) {return false;}\r\n\t\t} else {\r\n\t\t\t//Note that we can\'t pass arguments to proxy OR setTimeout (IE only), so just wrap the function call.\r\n\t\t\t// OJR WebAudio may want to handle this differently, so it might make sense to move this functionality into the plugins in the future\r\n\t\t\tvar delayTimeoutId = setTimeout(function () {\r\n\t\t\t\ts._beginPlaying(instance, playProps);\r\n\t\t\t}, playProps.delay);\r\n\t\t\tinstance.delayTimeoutId = delayTimeoutId;\r\n\t\t}\r\n\r\n\t\tthis._instances.push(instance);\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Begin playback. This is called immediately or after delay by {{#crossLink "Sound/playInstance"}}{{/crossLink}}.\r\n\t * @method _beginPlaying\r\n\t * @param {AbstractSoundInstance} instance A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to begin playback.\r\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\r\n\t * @return {Boolean} If the sound can start playing. If there are no available channels, or the instance fails to\r\n\t * start, this will return false.\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._beginPlaying = function (instance, playProps) {\r\n\t\tif (!SoundChannel.add(instance, playProps.interrupt)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar result = instance._beginPlaying(playProps);\r\n\t\tif (!result) {\r\n\t\t\tvar index = createjs.indexOf(this._instances, instance);\r\n\t\t\tif (index > -1) {this._instances.splice(index, 1);}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Get the source of a sound via the ID passed in with a register call. If no ID is found the value is returned\r\n\t * instead.\r\n\t * @method _getSrcById\r\n\t * @param {String} value The ID the sound was registered with.\r\n\t * @return {String} The source of the sound if it has been registered with this ID or the value that was passed in.\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._getSrcById = function (value) {\r\n\t\treturn s._idHash[value] || {src: value};\r\n\t};\r\n\r\n\t/**\r\n\t * A sound has completed playback, been interrupted, failed, or been stopped. This method removes the instance from\r\n\t * Sound management. It will be added again, if the sound re-plays. Note that this method is called from the\r\n\t * instances themselves.\r\n\t * @method _playFinished\r\n\t * @param {AbstractSoundInstance} instance The instance that finished playback.\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._playFinished = function (instance) {\r\n\t\tSoundChannel.remove(instance);\r\n\t\tvar index = createjs.indexOf(this._instances, instance);\r\n\t\tif (index > -1) {this._instances.splice(index, 1);}\t// OJR this will always be > -1, there is no way for an instance to exist without being added to this._instances\r\n\t};\r\n\r\n\tcreatejs.Sound = Sound;\r\n\r\n\t/**\r\n\t * An internal class that manages the number of active {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} instances for\r\n\t * each sound type. This method is only used internally by the {{#crossLink "Sound"}}{{/crossLink}} class.\r\n\t *\r\n\t * The number of sounds is artificially limited by Sound in order to prevent over-saturation of a\r\n\t * single sound, as well as to stay within hardware limitations, although the latter may disappear with better\r\n\t * browser support.\r\n\t *\r\n\t * When a sound is played, this class ensures that there is an available instance, or interrupts an appropriate\r\n\t * sound that is already playing.\r\n\t * #class SoundChannel\r\n\t * @param {String} src The source of the instances\r\n\t * @param {Number} [max=1] The number of instances allowed\r\n\t * @constructor\r\n\t * @protected\r\n\t */\r\n\tfunction SoundChannel(src, max) {\r\n\t\tthis.init(src, max);\r\n\t}\r\n\r\n\t/* ------------\r\n\t Static API\r\n\t ------------ */\r\n\t/**\r\n\t * A hash of channel instances indexed by source.\r\n\t * #property channels\r\n\t * @type {Object}\r\n\t * @static\r\n\t */\r\n\tSoundChannel.channels = {};\r\n\r\n\t/**\r\n\t * Create a sound channel. Note that if the sound channel already exists, this will fail.\r\n\t * #method create\r\n\t * @param {String} src The source for the channel\r\n\t * @param {Number} max The maximum amount this channel holds. The default is {{#crossLink "SoundChannel.maxDefault"}}{{/crossLink}}.\r\n\t * @return {Boolean} If the channels were created.\r\n\t * @static\r\n\t */\r\n\tSoundChannel.create = function (src, max) {\r\n\t\tvar channel = SoundChannel.get(src);\r\n\t\tif (channel == null) {\r\n\t\t\tSoundChannel.channels[src] = new SoundChannel(src, max);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\t/**\r\n\t * Delete a sound channel, stop and delete all related instances. Note that if the sound channel does not exist, this will fail.\r\n\t * #method remove\r\n\t * @param {String} src The source for the channel\r\n\t * @return {Boolean} If the channels were deleted.\r\n\t * @static\r\n\t */\r\n\tSoundChannel.removeSrc = function (src) {\r\n\t\tvar channel = SoundChannel.get(src);\r\n\t\tif (channel == null) {return false;}\r\n\t\tchannel._removeAll();\t// this stops and removes all active instances\r\n\t\tdelete(SoundChannel.channels[src]);\r\n\t\treturn true;\r\n\t};\r\n\t/**\r\n\t * Delete all sound channels, stop and delete all related instances.\r\n\t * #method removeAll\r\n\t * @static\r\n\t */\r\n\tSoundChannel.removeAll = function () {\r\n\t\tfor(var channel in SoundChannel.channels) {\r\n\t\t\tSoundChannel.channels[channel]._removeAll();\t// this stops and removes all active instances\r\n\t\t}\r\n\t\tSoundChannel.channels = {};\r\n\t};\r\n\t/**\r\n\t * Add an instance to a sound channel.\r\n\t * #method add\r\n\t * @param {AbstractSoundInstance} instance The instance to add to the channel\r\n\t * @param {String} interrupt The interrupt value to use. Please see the {{#crossLink "Sound/play"}}{{/crossLink}}\r\n\t * for details on interrupt modes.\r\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\r\n\t * @static\r\n\t */\r\n\tSoundChannel.add = function (instance, interrupt) {\r\n\t\tvar channel = SoundChannel.get(instance.src);\r\n\t\tif (channel == null) {return false;}\r\n\t\treturn channel._add(instance, interrupt);\r\n\t};\r\n\t/**\r\n\t * Remove an instance from the channel.\r\n\t * #method remove\r\n\t * @param {AbstractSoundInstance} instance The instance to remove from the channel\r\n\t * @return The success of the method call. If there is no channel, it will return false.\r\n\t * @static\r\n\t */\r\n\tSoundChannel.remove = function (instance) {\r\n\t\tvar channel = SoundChannel.get(instance.src);\r\n\t\tif (channel == null) {return false;}\r\n\t\tchannel._remove(instance);\r\n\t\treturn true;\r\n\t};\r\n\t/**\r\n\t * Get the maximum number of sounds you can have in a channel.\r\n\t * #method maxPerChannel\r\n\t * @return {Number} The maximum number of sounds you can have in a channel.\r\n\t */\r\n\tSoundChannel.maxPerChannel = function () {\r\n\t\treturn p.maxDefault;\r\n\t};\r\n\t/**\r\n\t * Get a channel instance by its src.\r\n\t * #method get\r\n\t * @param {String} src The src to use to look up the channel\r\n\t * @static\r\n\t */\r\n\tSoundChannel.get = function (src) {\r\n\t\treturn SoundChannel.channels[src];\r\n\t};\r\n\r\n\tvar p = SoundChannel.prototype;\r\n\tp.constructor = SoundChannel;\r\n\r\n\t/**\r\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\r\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\r\n\t * for details.\r\n\t *\r\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\r\n\t *\r\n\t * @method initialize\r\n\t * @protected\r\n\t * @deprecated\r\n\t */\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\r\n\r\n\r\n\t/**\r\n\t * The source of the channel.\r\n\t * #property src\r\n\t * @type {String}\r\n\t */\r\n\tp.src = null;\r\n\r\n\t/**\r\n\t * The maximum number of instances in this channel.  -1 indicates no limit\r\n\t * #property max\r\n\t * @type {Number}\r\n\t */\r\n\tp.max = null;\r\n\r\n\t/**\r\n\t * The default value to set for max, if it isn\'t passed in.  Also used if -1 is passed.\r\n\t * #property maxDefault\r\n\t * @type {Number}\r\n\t * @default 100\r\n\t * @since 0.4.0\r\n\t */\r\n\tp.maxDefault = 100;\r\n\r\n\t/**\r\n\t * The current number of active instances.\r\n\t * #property length\r\n\t * @type {Number}\r\n\t */\r\n\tp.length = 0;\r\n\r\n\t/**\r\n\t * Initialize the channel.\r\n\t * #method init\r\n\t * @param {String} src The source of the channel\r\n\t * @param {Number} max The maximum number of instances in the channel\r\n\t * @protected\r\n\t */\r\n\tp.init = function (src, max) {\r\n\t\tthis.src = src;\r\n\t\tthis.max = max || this.maxDefault;\r\n\t\tif (this.max == -1) {this.max = this.maxDefault;}\r\n\t\tthis._instances = [];\r\n\t};\r\n\r\n\t/**\r\n\t * Get an instance by index.\r\n\t * #method get\r\n\t * @param {Number} index The index to return.\r\n\t * @return {AbstractSoundInstance} The AbstractSoundInstance at a specific instance.\r\n\t */\r\n\tp._get = function (index) {\r\n\t\treturn this._instances[index];\r\n\t};\r\n\r\n\t/**\r\n\t * Add a new instance to the channel.\r\n\t * #method add\r\n\t * @param {AbstractSoundInstance} instance The instance to add.\r\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\r\n\t */\r\n\tp._add = function (instance, interrupt) {\r\n\t\tif (!this._getSlot(interrupt, instance)) {return false;}\r\n\t\tthis._instances.push(instance);\r\n\t\tthis.length++;\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove an instance from the channel, either when it has finished playing, or it has been interrupted.\r\n\t * #method remove\r\n\t * @param {AbstractSoundInstance} instance The instance to remove\r\n\t * @return {Boolean} The success of the remove call. If the instance is not found in this channel, it will\r\n\t * return false.\r\n\t */\r\n\tp._remove = function (instance) {\r\n\t\tvar index = createjs.indexOf(this._instances, instance);\r\n\t\tif (index == -1) {return false;}\r\n\t\tthis._instances.splice(index, 1);\r\n\t\tthis.length--;\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Stop playback and remove all instances from the channel.  Usually in response to a delete call.\r\n\t * #method removeAll\r\n\t */\r\n\tp._removeAll = function () {\r\n\t\t// Note that stop() removes the item from the list\r\n\t\tfor (var i=this.length-1; i>=0; i--) {\r\n\t\t\tthis._instances[i].stop();\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Get an available slot depending on interrupt value and if slots are available.\r\n\t * #method getSlot\r\n\t * @param {String} interrupt The interrupt value to use.\r\n\t * @param {AbstractSoundInstance} instance The sound instance that will go in the channel if successful.\r\n\t * @return {Boolean} Determines if there is an available slot. Depending on the interrupt mode, if there are no slots,\r\n\t * an existing AbstractSoundInstance may be interrupted. If there are no slots, this method returns false.\r\n\t */\r\n\tp._getSlot = function (interrupt, instance) {\r\n\t\tvar target, replacement;\r\n\r\n\t\tif (interrupt != Sound.INTERRUPT_NONE) {\r\n\t\t\t// First replacement candidate\r\n\t\t\treplacement = this._get(0);\r\n\t\t\tif (replacement == null) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, l = this.max; i < l; i++) {\r\n\t\t\ttarget = this._get(i);\r\n\r\n\t\t\t// Available Space\r\n\t\t\tif (target == null) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Audio is complete or not playing\r\n\t\t\tif (target.playState == Sound.PLAY_FINISHED ||\r\n\t\t\t\ttarget.playState == Sound.PLAY_INTERRUPTED ||\r\n\t\t\t\ttarget.playState == Sound.PLAY_FAILED) {\r\n\t\t\t\treplacement = target;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (interrupt == Sound.INTERRUPT_NONE) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Audio is a better candidate than the current target, according to playhead\r\n\t\t\tif ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) ||\r\n\t\t\t\t(interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) {\r\n\t\t\t\t\treplacement = target;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (replacement != null) {\r\n\t\t\treplacement._interrupt();\r\n\t\t\tthis._remove(replacement);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\tp.toString = function () {\r\n\t\treturn "[Sound SoundChannel]";\r\n\t};\r\n\t// do not add SoundChannel to namespace\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// AbstractSoundInstance.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n/**\r\n * A AbstractSoundInstance is created when any calls to the Sound API method {{#crossLink "Sound/play"}}{{/crossLink}} or\r\n * {{#crossLink "Sound/createInstance"}}{{/crossLink}} are made. The AbstractSoundInstance is returned by the active plugin\r\n * for control by the user.\r\n *\r\n * <h4>Example</h4>\r\n *\r\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");\r\n *\r\n * A number of additional parameters provide a quick way to determine how a sound is played. Please see the Sound\r\n * API method {{#crossLink "Sound/play"}}{{/crossLink}} for a list of arguments.\r\n *\r\n * Once a AbstractSoundInstance is created, a reference can be stored that can be used to control the audio directly through\r\n * the AbstractSoundInstance. If the reference is not stored, the AbstractSoundInstance will play out its audio (and any loops), and\r\n * is then de-referenced from the {{#crossLink "Sound"}}{{/crossLink}} class so that it can be cleaned up. If audio\r\n * playback has completed, a simple call to the {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}} instance method\r\n * will rebuild the references the Sound class need to control it.\r\n *\r\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3", {loop:2});\r\n *      myInstance.on("loop", handleLoop);\r\n *      function handleLoop(event) {\r\n *          myInstance.volume = myInstance.volume * 0.5;\r\n *      }\r\n *\r\n * Events are dispatched from the instance to notify when the sound has completed, looped, or when playback fails\r\n *\r\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");\r\n *      myInstance.on("complete", handleComplete);\r\n *      myInstance.on("loop", handleLoop);\r\n *      myInstance.on("failed", handleFailed);\r\n *\r\n *\r\n * @class AbstractSoundInstance\r\n * @param {String} src The path to and file name of the sound.\r\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\r\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\r\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\r\n * @extends EventDispatcher\r\n * @constructor\r\n */\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\r\n// Constructor:\r\n\tvar AbstractSoundInstance = function (src, startTime, duration, playbackResource) {\r\n\t\tthis.EventDispatcher_constructor();\r\n\r\n\r\n\t// public properties:\r\n\t\t/**\r\n\t\t * The source of the sound.\r\n\t\t * @property src\r\n\t\t * @type {String}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.src = src;\r\n\r\n\t\t/**\r\n\t\t * The unique ID of the instance. This is set by {{#crossLink "Sound"}}{{/crossLink}}.\r\n\t\t * @property uniqueId\r\n\t\t * @type {String} | Number\r\n\t\t * @default -1\r\n\t\t */\r\n\t\tthis.uniqueId = -1;\r\n\r\n\t\t/**\r\n\t\t * The play state of the sound. Play states are defined as constants on {{#crossLink "Sound"}}{{/crossLink}}.\r\n\t\t * @property playState\r\n\t\t * @type {String}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.playState = null;\r\n\r\n\t\t/**\r\n\t\t * A Timeout created by {{#crossLink "Sound"}}{{/crossLink}} when this AbstractSoundInstance is played with a delay.\r\n\t\t * This allows AbstractSoundInstance to remove the delay if stop, pause, or cleanup are called before playback begins.\r\n\t\t * @property delayTimeoutId\r\n\t\t * @type {timeoutVariable}\r\n\t\t * @default null\r\n\t\t * @protected\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\t\tthis.delayTimeoutId = null;\r\n\t\t// TODO consider moving delay into AbstractSoundInstance so it can be handled by plugins\r\n\r\n\r\n\t// private properties\r\n\t// Getter / Setter Properties\r\n\t\t// OJR TODO find original reason that we didn\'t use defined functions.  I think it was performance related\r\n\t\t/**\r\n\t\t * The volume of the sound, between 0 and 1.\r\n\t\t *\r\n\t\t * The actual output volume of a sound can be calculated using:\r\n\t\t * <code>myInstance.volume * createjs.Sound.getVolume();</code>\r\n\t\t *\r\n\t\t * @property volume\r\n\t\t * @type {Number}\r\n\t\t * @default 1\r\n\t\t */\r\n\t\tthis._volume =  1;\r\n\t\tObject.defineProperty(this, "volume", {\r\n\t\t\tget: this.getVolume,\r\n\t\t\tset: this.setVolume\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * The pan of the sound, between -1 (left) and 1 (right). Note that pan is not supported by HTML Audio.\r\n\t\t *\r\n\t\t * <br />Note in WebAudioPlugin this only gives us the "x" value of what is actually 3D audio.\r\n\t\t *\r\n\t\t * @property pan\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t */\r\n\t\tthis._pan =  0;\r\n\t\tObject.defineProperty(this, "pan", {\r\n\t\t\tget: this.getPan,\r\n\t\t\tset: this.setPan\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Audio sprite property used to determine the starting offset.\r\n\t\t * @property startTime\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t * @since 0.6.1\r\n\t\t */\r\n\t\tthis._startTime = Math.max(0, startTime || 0);\r\n\t\tObject.defineProperty(this, "startTime", {\r\n\t\t\tget: this.getStartTime,\r\n\t\t\tset: this.setStartTime\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Sets or gets the length of the audio clip, value is in milliseconds.\r\n\t\t *\r\n\t\t * @property duration\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t * @since 0.6.0\r\n\t\t */\r\n\t\tthis._duration = Math.max(0, duration || 0);\r\n\t\tObject.defineProperty(this, "duration", {\r\n\t\t\tget: this.getDuration,\r\n\t\t\tset: this.setDuration\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Object that holds plugin specific resource need for audio playback.\r\n\t\t * This is set internally by the plugin.  For example, WebAudioPlugin will set an array buffer,\r\n\t\t * HTMLAudioPlugin will set a tag, FlashAudioPlugin will set a flash reference.\r\n\t\t *\r\n\t\t * @property playbackResource\r\n\t\t * @type {Object}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis._playbackResource = null;\r\n\t\tObject.defineProperty(this, "playbackResource", {\r\n\t\t\tget: this.getPlaybackResource,\r\n\t\t\tset: this.setPlaybackResource\r\n\t\t});\r\n\t\tif(playbackResource !== false && playbackResource !== true) { this.setPlaybackResource(playbackResource); }\r\n\r\n\t\t/**\r\n\t\t * The position of the playhead in milliseconds. This can be set while a sound is playing, paused, or stopped.\r\n\t\t *\r\n\t\t * @property position\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t * @since 0.6.0\r\n\t\t */\r\n\t\tthis._position = 0;\r\n\t\tObject.defineProperty(this, "position", {\r\n\t\t\tget: this.getPosition,\r\n\t\t\tset: this.setPosition\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * The number of play loops remaining. Negative values will loop infinitely.\r\n\t\t *\r\n\t\t * @property loop\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t * @public\r\n\t\t * @since 0.6.0\r\n\t\t */\r\n\t\tthis._loop = 0;\r\n\t\tObject.defineProperty(this, "loop", {\r\n\t\t\tget: this.getLoop,\r\n\t\t\tset: this.setLoop\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Mutes or unmutes the current audio instance.\r\n\t\t *\r\n\t\t * @property muted\r\n\t\t * @type {Boolean}\r\n\t\t * @default false\r\n\t\t * @since 0.6.0\r\n\t\t */\r\n\t\tthis._muted = false;\r\n\t\tObject.defineProperty(this, "muted", {\r\n\t\t\tget: this.getMuted,\r\n\t\t\tset: this.setMuted\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Pauses or resumes the current audio instance.\r\n\t\t *\r\n\t\t * @property paused\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\t\tthis._paused = false;\r\n\t\tObject.defineProperty(this, "paused", {\r\n\t\t\tget: this.getPaused,\r\n\t\t\tset: this.setPaused\r\n\t\t});\r\n\r\n\r\n\t// Events\r\n\t\t/**\r\n\t\t * The event that is fired when playback has started successfully.\r\n\t\t * @event succeeded\r\n\t\t * @param {Object} target The object that dispatched the event.\r\n\t\t * @param {String} type The event type.\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * The event that is fired when playback is interrupted. This happens when another sound with the same\r\n\t\t * src property is played using an interrupt value that causes this instance to stop playing.\r\n\t\t * @event interrupted\r\n\t\t * @param {Object} target The object that dispatched the event.\r\n\t\t * @param {String} type The event type.\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * The event that is fired when playback has failed. This happens when there are too many channels with the same\r\n\t\t * src property already playing (and the interrupt value doesn\'t cause an interrupt of another instance), or\r\n\t\t * the sound could not be played, perhaps due to a 404 error.\r\n\t\t * @event failed\r\n\t\t * @param {Object} target The object that dispatched the event.\r\n\t\t * @param {String} type The event type.\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * The event that is fired when a sound has completed playing but has loops remaining.\r\n\t\t * @event loop\r\n\t\t * @param {Object} target The object that dispatched the event.\r\n\t\t * @param {String} type The event type.\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * The event that is fired when playback completes. This means that the sound has finished playing in its\r\n\t\t * entirety, including its loop iterations.\r\n\t\t * @event complete\r\n\t\t * @param {Object} target The object that dispatched the event.\r\n\t\t * @param {String} type The event type.\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\t};\r\n\r\n\tvar p = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);\r\n\r\n\t// TODO: deprecated\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\r\n\r\n\r\n// Public Methods:\r\n\t/**\r\n\t * Play an instance. This method is intended to be called on SoundInstances that already exist (created\r\n\t * with the Sound API {{#crossLink "Sound/createInstance"}}{{/crossLink}} or {{#crossLink "Sound/play"}}{{/crossLink}}).\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      var myInstance = createjs.Sound.createInstance(mySrc);\r\n\t *      myInstance.play({interrupt:createjs.Sound.INTERRUPT_ANY, loop:2, pan:0.5});\r\n\t *\r\n\t * Note that if this sound is already playing, this call will still set the passed in parameters.\r\n\r\n\t * <b>Parameters Deprecated</b><br />\r\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink "PlayPropsConfig"}}{{/crossLink}}.\r\n\t *\r\n\t * @method play\r\n\t * @param {String | Object} [interrupt="none"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\r\n\t * This parameter can be an instance of {{#crossLink "PlayPropsConfig"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\r\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\r\n\t * <br /><strong>OR</strong><br />\r\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\r\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\r\n\t * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\r\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\r\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\r\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\r\n\t * loops), and -1 can be used for infinite playback.\r\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\r\n\t * against the individual volume.\r\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\r\n\t * Note that pan is not supported for HTML Audio.\r\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\r\n\t */\r\n\tp.play = function (interrupt, delay, offset, loop, volume, pan) {\r\n\t\tvar playProps;\r\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\r\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\r\n\t\t} else {\r\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan});\r\n\t\t}\r\n\r\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\r\n\t\t\tthis.applyPlayProps(playProps);\r\n\t\t\tif (this._paused) {\tthis.setPaused(false); }\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._cleanUp();\r\n\t\tcreatejs.Sound._playInstance(this, playProps);\t// make this an event dispatch??\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Stop playback of the instance. Stopped sounds will reset their position to 0, and calls to {{#crossLink "AbstractSoundInstance/resume"}}{{/crossLink}}\r\n\t * will fail. To start playback again, call {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.\r\n     *\r\n     * If you don\'t want to lose your position use yourSoundInstance.paused = true instead. {{#crossLink "AbstractSoundInstance/paused"}}{{/crossLink}}.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *     myInstance.stop();\r\n\t *\r\n\t * @method stop\r\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\r\n\t */\r\n\tp.stop = function () {\r\n\t\tthis._position = 0;\r\n\t\tthis._paused = false;\r\n\t\tthis._handleStop();\r\n\t\tthis._cleanUp();\r\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove all external references and resources from AbstractSoundInstance.  Note this is irreversible and AbstractSoundInstance will no longer work\r\n\t * @method destroy\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.destroy = function() {\r\n\t\tthis._cleanUp();\r\n\t\tthis.src = null;\r\n\t\tthis.playbackResource = null;\r\n\r\n\t\tthis.removeAllEventListeners();\r\n\t};\r\n\r\n\t/**\r\n\t * Takes an PlayPropsConfig or Object with the same properties and sets them on this instance.\r\n\t * @method applyPlayProps\r\n\t * @param {PlayPropsConfig | Object} playProps A PlayPropsConfig or object containing the same properties.\r\n\t * @since 0.6.1\r\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\r\n\t */\r\n\tp.applyPlayProps = function(playProps) {\r\n\t\tif (playProps.offset != null) { this.setPosition(playProps.offset) }\r\n\t\tif (playProps.loop != null) { this.setLoop(playProps.loop); }\r\n\t\tif (playProps.volume != null) { this.setVolume(playProps.volume); }\r\n\t\tif (playProps.pan != null) { this.setPan(playProps.pan); }\r\n\t\tif (playProps.startTime != null) {\r\n\t\t\tthis.setStartTime(playProps.startTime);\r\n\t\t\tthis.setDuration(playProps.duration);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\tp.toString = function () {\r\n\t\treturn "[AbstractSoundInstance]";\r\n\t};\r\n\r\n// get/set methods that allow support for IE8\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} directly as a property,\r\n\t *\r\n\t * @deprecated\r\n\t * @method getPaused\r\n\t * @returns {boolean} If the instance is currently paused\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.getPaused = function() {\r\n\t\treturn this._paused;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setPaused\r\n\t * @param {boolean} value\r\n\t * @since 0.6.0\r\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\r\n\t */\r\n\tp.setPaused = function (value) {\r\n\t\tif ((value !== true && value !== false) || this._paused == value) {return;}\r\n\t\tif (value == true && this.playState != createjs.Sound.PLAY_SUCCEEDED) {return;}\r\n\t\tthis._paused = value;\r\n\t\tif(value) {\r\n\t\t\tthis._pause();\r\n\t\t} else {\r\n\t\t\tthis._resume();\r\n\t\t}\r\n\t\tclearTimeout(this.delayTimeoutId);\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setVolume\r\n\t * @param {Number} value The volume to set, between 0 and 1.\r\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\r\n\t */\r\n\tp.setVolume = function (value) {\r\n\t\tif (value == this._volume) { return this; }\r\n\t\tthis._volume = Math.max(0, Math.min(1, value));\r\n\t\tif (!this._muted) {\r\n\t\t\tthis._updateVolume();\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method getVolume\r\n\t * @return {Number} The current volume of the sound instance.\r\n\t */\r\n\tp.getVolume = function () {\r\n\t\treturn this._volume;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setMuted\r\n\t * @param {Boolean} value If the sound should be muted.\r\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.setMuted = function (value) {\r\n\t\tif (value !== true && value !== false) {return;}\r\n\t\tthis._muted = value;\r\n\t\tthis._updateVolume();\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method getMuted\r\n\t * @return {Boolean} If the sound is muted.\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.getMuted = function () {\r\n\t\treturn this._muted;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setPan\r\n\t * @param {Number} value The pan value, between -1 (left) and 1 (right).\r\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\r\n\t */\r\n\tp.setPan = function (value) {\r\n\t\tif(value == this._pan) { return this; }\r\n\t\tthis._pan = Math.max(-1, Math.min(1, value));\r\n\t\tthis._updatePan();\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method getPan\r\n\t * @return {Number} The value of the pan, between -1 (left) and 1 (right).\r\n\t */\r\n\tp.getPan = function () {\r\n\t\treturn this._pan;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method getPosition\r\n\t * @return {Number} The position of the playhead in the sound, in milliseconds.\r\n\t */\r\n\tp.getPosition = function () {\r\n\t\tif (!this._paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\r\n\t\t\tthis._position = this._calculateCurrentPosition();\r\n\t\t}\r\n\t\treturn this._position;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setPosition\r\n\t * @param {Number} value The position to place the playhead, in milliseconds.\r\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\r\n\t */\r\n\tp.setPosition = function (value) {\r\n\t\tthis._position = Math.max(0, value);\r\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\r\n\t\t\tthis._updatePosition();\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/startTime:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method getStartTime\r\n\t * @return {Number} The startTime of the sound instance in milliseconds.\r\n\t */\r\n\tp.getStartTime = function () {\r\n\t\treturn this._startTime;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/startTime:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setStartTime\r\n\t * @param {number} value The new startTime time in milli seconds.\r\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\r\n\t */\r\n\tp.setStartTime = function (value) {\r\n\t\tif (value == this._startTime) { return this; }\r\n\t\tthis._startTime = Math.max(0, value || 0);\r\n\t\tthis._updateStartTime();\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method getDuration\r\n\t * @return {Number} The duration of the sound instance in milliseconds.\r\n\t */\r\n\tp.getDuration = function () {\r\n\t\treturn this._duration;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setDuration\r\n\t * @param {number} value The new duration time in milli seconds.\r\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.setDuration = function (value) {\r\n\t\tif (value == this._duration) { return this; }\r\n\t\tthis._duration = Math.max(0, value || 0);\r\n\t\tthis._updateDuration();\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setPlayback\r\n\t * @param {Object} value The new playback resource.\r\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\r\n\t * @since 0.6.0\r\n\t **/\r\n\tp.setPlaybackResource = function (value) {\r\n\t\tthis._playbackResource = value;\r\n\t\tif (this._duration == 0) { this._setDurationFromSource(); }\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method setPlayback\r\n\t * @param {Object} value The new playback resource.\r\n\t * @return {Object} playback resource used for playing audio\r\n\t * @since 0.6.0\r\n\t **/\r\n\tp.getPlaybackResource = function () {\r\n\t\treturn this._playbackResource;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} directly as a property\r\n\t *\r\n\t * @deprecated\r\n\t * @method getLoop\r\n\t * @return {number}\r\n\t * @since 0.6.0\r\n\t **/\r\n\tp.getLoop = function () {\r\n\t\treturn this._loop;\r\n\t};\r\n\r\n\t/**\r\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} directly as a property,\r\n\t *\r\n\t * @deprecated\r\n\t * @method setLoop\r\n\t * @param {number} value The number of times to loop after play.\r\n\t * @since 0.6.0\r\n\t */\r\n\tp.setLoop = function (value) {\r\n\t\tif(this._playbackResource != null) {\r\n\t\t\t// remove looping\r\n\t\t\tif (this._loop != 0 && value == 0) {\r\n\t\t\t\tthis._removeLooping(value);\r\n\t\t\t}\r\n\t\t\t// add looping\r\n\t\t\telse if (this._loop == 0 && value != 0) {\r\n\t\t\t\tthis._addLooping(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._loop = value;\r\n\t};\r\n\r\n\r\n// Private Methods:\r\n\t/**\r\n\t * A helper method that dispatches all events for AbstractSoundInstance.\r\n\t * @method _sendEvent\r\n\t * @param {String} type The event type\r\n\t * @protected\r\n\t */\r\n\tp._sendEvent = function (type) {\r\n\t\tvar event = new createjs.Event(type);\r\n\t\tthis.dispatchEvent(event);\r\n\t};\r\n\r\n\t/**\r\n\t * Clean up the instance. Remove references and clean up any additional properties such as timers.\r\n\t * @method _cleanUp\r\n\t * @protected\r\n\t */\r\n\tp._cleanUp = function () {\r\n\t\tclearTimeout(this.delayTimeoutId); // clear timeout that plays delayed sound\r\n\t\tthis._handleCleanUp();\r\n\t\tthis._paused = false;\r\n\r\n\t\tcreatejs.Sound._playFinished(this);\t// TODO change to an event\r\n\t};\r\n\r\n\t/**\r\n\t * The sound has been interrupted.\r\n\t * @method _interrupt\r\n\t * @protected\r\n\t */\r\n\tp._interrupt = function () {\r\n\t\tthis._cleanUp();\r\n\t\tthis.playState = createjs.Sound.PLAY_INTERRUPTED;\r\n\t\tthis._sendEvent("interrupted");\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the Sound class when the audio is ready to play (delay has completed). Starts sound playing if the\r\n\t * src is loaded, otherwise playback will fail.\r\n\t * @method _beginPlaying\r\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\r\n\t * @return {Boolean} If playback succeeded.\r\n\t * @protected\r\n\t */\r\n\t// OJR FlashAudioSoundInstance overwrites\r\n\tp._beginPlaying = function (playProps) {\r\n\t\tthis.setPosition(playProps.offset);\r\n\t\tthis.setLoop(playProps.loop);\r\n\t\tthis.setVolume(playProps.volume);\r\n\t\tthis.setPan(playProps.pan);\r\n\t\tif (playProps.startTime != null) {\r\n\t\t\tthis.setStartTime(playProps.startTime);\r\n\t\t\tthis.setDuration(playProps.duration);\r\n\t\t}\r\n\r\n\t\tif (this._playbackResource != null && this._position < this._duration) {\r\n\t\t\tthis._paused = false;\r\n\t\t\tthis._handleSoundReady();\r\n\t\t\tthis.playState = createjs.Sound.PLAY_SUCCEEDED;\r\n\t\t\tthis._sendEvent("succeeded");\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tthis._playFailed();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Play has failed, which can happen for a variety of reasons.\r\n\t * Cleans up instance and dispatches failed event\r\n\t * @method _playFailed\r\n\t * @private\r\n\t */\r\n\tp._playFailed = function () {\r\n\t\tthis._cleanUp();\r\n\t\tthis.playState = createjs.Sound.PLAY_FAILED;\r\n\t\tthis._sendEvent("failed");\r\n\t};\r\n\r\n\t/**\r\n\t * Audio has finished playing. Manually loop it if required.\r\n\t * @method _handleSoundComplete\r\n\t * @param event\r\n\t * @protected\r\n\t */\r\n\tp._handleSoundComplete = function (event) {\r\n\t\tthis._position = 0;  // have to set this as it can be set by pause during playback\r\n\r\n\t\tif (this._loop != 0) {\r\n\t\t\tthis._loop--;  // NOTE this introduces a theoretical limit on loops = float max size x 2 - 1\r\n\t\t\tthis._handleLoop();\r\n\t\t\tthis._sendEvent("loop");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._cleanUp();\r\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\r\n\t\tthis._sendEvent("complete");\r\n\t};\r\n\r\n// Plugin specific code\r\n\t/**\r\n\t * Handles starting playback when the sound is ready for playing.\r\n\t * @method _handleSoundReady\r\n\t * @protected\r\n \t */\r\n\tp._handleSoundReady = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function used to update the volume based on the instance volume, master volume, instance mute value,\r\n\t * and master mute value.\r\n\t * @method _updateVolume\r\n\t * @protected\r\n\t */\r\n\tp._updateVolume = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function used to update the pan\r\n\t * @method _updatePan\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._updatePan = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function used to update the startTime of the audio.\r\n\t * @method _updateStartTime\r\n\t * @protected\r\n\t * @since 0.6.1\r\n\t */\r\n\tp._updateStartTime = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function used to update the duration of the audio.\r\n\t * @method _updateDuration\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._updateDuration = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function used to get the duration of the audio from the source we\'ll be playing.\r\n\t * @method _updateDuration\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._setDurationFromSource = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function that calculates the current position of the playhead and sets this._position to that value\r\n\t * @method _calculateCurrentPosition\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._calculateCurrentPosition = function () {\r\n\t\t// plugin specific code that sets this.position\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function used to update the position of the playhead.\r\n\t * @method _updatePosition\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._updatePosition = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function called when looping is removed during playback.\r\n\t * @method _removeLooping\r\n\t * @param {number} value The number of times to loop after play.\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._removeLooping = function (value) {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function called when looping is added during playback.\r\n\t * @method _addLooping\r\n\t * @param {number} value The number of times to loop after play.\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._addLooping = function (value) {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function called when pausing playback\r\n\t * @method _pause\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._pause = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function called when resuming playback\r\n\t * @method _resume\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._resume = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function called when stopping playback\r\n\t * @method _handleStop\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._handleStop = function() {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function called when AbstractSoundInstance is being cleaned up\r\n\t * @method _handleCleanUp\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._handleCleanUp = function() {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\t/**\r\n\t * Internal function called when AbstractSoundInstance has played to end and is looping\r\n\t * @method _handleLoop\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._handleLoop = function () {\r\n\t\t// plugin specific code\r\n\t};\r\n\r\n\tcreatejs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, "EventDispatcher");\r\n\tcreatejs.DefaultSoundInstance = createjs.AbstractSoundInstance;\t// used when no plugin is supported\r\n}());\r\n\r\n//##############################################################################\r\n// AbstractPlugin.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\r\n// constructor:\r\n \t/**\r\n\t * A default plugin class used as a base for all other plugins.\r\n\t * @class AbstractPlugin\r\n\t * @constructor\r\n\t * @since 0.6.0\r\n\t */\r\n\r\n\tvar AbstractPlugin = function () {\r\n\t// private properties:\r\n\t\t/**\r\n\t\t * The capabilities of the plugin.\r\n\t\t * method and is used internally.\r\n\t\t * @property _capabilities\r\n\t\t * @type {Object}\r\n\t\t * @default null\r\n\t\t * @protected\r\n\t\t * @static\r\n\t\t */\r\n\t\tthis._capabilities = null;\r\n\r\n\t\t/**\r\n\t\t * Object hash indexed by the source URI of all created loaders, used to properly destroy them if sources are removed.\r\n\t\t * @type {Object}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._loaders = {};\r\n\r\n\t\t/**\r\n\t\t * Object hash indexed by the source URI of each file to indicate if an audio source has begun loading,\r\n\t\t * is currently loading, or has completed loading.  Can be used to store non boolean data after loading\r\n\t\t * is complete (for example arrayBuffers for web audio).\r\n\t\t * @property _audioSources\r\n\t\t * @type {Object}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._audioSources = {};\r\n\r\n\t\t/**\r\n\t\t * Object hash indexed by the source URI of all created SoundInstances, updates the playbackResource if it loads after they are created,\r\n\t\t * and properly destroy them if sources are removed\r\n\t\t * @type {Object}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._soundInstances = {};\r\n\r\n\t\t/**\r\n\t\t * The internal master volume value of the plugin.\r\n\t\t * @property _volume\r\n\t\t * @type {Number}\r\n\t\t * @default 1\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._volume = 1;\r\n\r\n\t\t/**\r\n\t\t * A reference to a loader class used by a plugin that must be set.\r\n\t\t * @type {Object}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._loaderClass;\r\n\r\n\t\t/**\r\n\t\t * A reference to an AbstractSoundInstance class used by a plugin that must be set.\r\n\t\t * @type {Object}\r\n\t\t * @protected;\r\n\t\t */\r\n\t\tthis._soundInstanceClass;\r\n\t};\r\n\tvar p = AbstractPlugin.prototype;\r\n\r\n\t/**\r\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\r\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\r\n\t * for details.\r\n\t *\r\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\r\n\t *\r\n\t * @method initialize\r\n\t * @protected\r\n\t * @deprecated\r\n\t */\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\r\n\r\n\r\n// Static Properties:\r\n// NOTE THESE PROPERTIES NEED TO BE ADDED TO EACH PLUGIN\r\n\t/**\r\n\t * The capabilities of the plugin. This is generated via the _generateCapabilities method and is used internally.\r\n\t * @property _capabilities\r\n\t * @type {Object}\r\n\t * @default null\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\tAbstractPlugin._capabilities = null;\r\n\r\n\t/**\r\n\t * Determine if the plugin can be used in the current browser/OS.\r\n\t * @method isSupported\r\n\t * @return {Boolean} If the plugin can be initialized.\r\n\t * @static\r\n\t */\r\n\tAbstractPlugin.isSupported = function () {\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n// public methods:\r\n\t/**\r\n\t * Pre-register a sound for preloading and setup. This is called by {{#crossLink "Sound"}}{{/crossLink}}.\r\n\t * Note all plugins provide a <code>Loader</code> instance, which <a href="http://preloadjs.com" target="_blank">PreloadJS</a>\r\n\t * can use to assist with preloading.\r\n\t * @method register\r\n\t * @param {String} loadItem An Object containing the source of the audio\r\n\t * Note that not every plugin will manage this value.\r\n\t * @return {Object} A result object, containing a "tag" for preloading purposes.\r\n\t */\r\n\tp.register = function (loadItem) {\r\n\t\tvar loader = this._loaders[loadItem.src];\r\n\t\tif(loader && !loader.canceled) {return this._loaders[loadItem.src];}\t// already loading/loaded this, so don\'t load twice\r\n\t\t// OJR potential issue that we won\'t be firing loaded event, might need to trigger if this is already loaded?\r\n\t\tthis._audioSources[loadItem.src] = true;\r\n\t\tthis._soundInstances[loadItem.src] = [];\r\n\t\tloader = new this._loaderClass(loadItem);\r\n\t\tloader.on("complete", this._handlePreloadComplete, this);\r\n\t\tthis._loaders[loadItem.src] = loader;\r\n\t\treturn loader;\r\n\t};\r\n\r\n\t// note sound calls register before calling preload\r\n\t/**\r\n\t * Internally preload a sound.\r\n\t * @method preload\r\n\t * @param {Loader} loader The sound URI to load.\r\n\t */\r\n\tp.preload = function (loader) {\r\n\t\tloader.on("error", this._handlePreloadError, this);\r\n\t\tloader.load();\r\n\t};\r\n\r\n\t/**\r\n\t * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,\r\n\t * or has already finished loading.\r\n\t * @method isPreloadStarted\r\n\t * @param {String} src The sound URI to check.\r\n\t * @return {Boolean}\r\n\t */\r\n\tp.isPreloadStarted = function (src) {\r\n\t\treturn (this._audioSources[src] != null);\r\n\t};\r\n\r\n\t/**\r\n\t * Checks if preloading has finished for a specific source.\r\n\t * @method isPreloadComplete\r\n\t * @param {String} src The sound URI to load.\r\n\t * @return {Boolean}\r\n\t */\r\n\tp.isPreloadComplete = function (src) {\r\n\t\treturn (!(this._audioSources[src] == null || this._audioSources[src] == true));\r\n\t};\r\n\r\n\t/**\r\n\t * Remove a sound added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.\r\n\t * @method removeSound\r\n\t * @param {String} src The sound URI to unload.\r\n\t */\r\n\tp.removeSound = function (src) {\r\n\t\tif (!this._soundInstances[src]) { return; }\r\n\t\tfor (var i = this._soundInstances[src].length; i--; ) {\r\n\t\t\tvar item = this._soundInstances[src][i];\r\n\t\t\titem.destroy();\r\n\t\t}\r\n\t\tdelete(this._soundInstances[src]);\r\n\t\tdelete(this._audioSources[src]);\r\n\t\tif(this._loaders[src]) { this._loaders[src].destroy(); }\r\n\t\tdelete(this._loaders[src]);\r\n\t};\r\n\r\n\t/**\r\n\t * Remove all sounds added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.\r\n\t * @method removeAllSounds\r\n\t * @param {String} src The sound URI to unload.\r\n\t */\r\n\tp.removeAllSounds = function () {\r\n\t\tfor(var key in this._audioSources) {\r\n\t\t\tthis.removeSound(key);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.\r\n\t * @method create\r\n\t * @param {String} src The sound source to use.\r\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\r\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\r\n\t * @return {AbstractSoundInstance} A sound instance for playback and control.\r\n\t */\r\n\tp.create = function (src, startTime, duration) {\r\n\t\tif (!this.isPreloadStarted(src)) {\r\n\t\t\tthis.preload(this.register(src));\r\n\t\t}\r\n\t\tvar si = new this._soundInstanceClass(src, startTime, duration, this._audioSources[src]);\r\n\t\tthis._soundInstances[src].push(si);\r\n\t\treturn si;\r\n\t};\r\n\r\n\t// if a plugin does not support volume and mute, it should set these to null\r\n\t/**\r\n\t * Set the master volume of the plugin, which affects all SoundInstances.\r\n\t * @method setVolume\r\n\t * @param {Number} value The volume to set, between 0 and 1.\r\n\t * @return {Boolean} If the plugin processes the setVolume call (true). The Sound class will affect all the\r\n\t * instances manually otherwise.\r\n\t */\r\n\tp.setVolume = function (value) {\r\n\t\tthis._volume = value;\r\n\t\tthis._updateVolume();\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Get the master volume of the plugin, which affects all SoundInstances.\r\n\t * @method getVolume\r\n\t * @return {Number} The volume level, between 0 and 1.\r\n\t */\r\n\tp.getVolume = function () {\r\n\t\treturn this._volume;\r\n\t};\r\n\r\n\t/**\r\n\t * Mute all sounds via the plugin.\r\n\t * @method setMute\r\n\t * @param {Boolean} value If all sound should be muted or not. Note that plugin-level muting just looks up\r\n\t * the mute value of Sound {{#crossLink "Sound/getMute"}}{{/crossLink}}, so this property is not used here.\r\n\t * @return {Boolean} If the mute call succeeds.\r\n\t */\r\n\tp.setMute = function (value) {\r\n\t\tthis._updateVolume();\r\n\t\treturn true;\r\n\t};\r\n\r\n\t// plugins should overwrite this method\r\n\tp.toString = function () {\r\n\t\treturn "[AbstractPlugin]";\r\n\t};\r\n\r\n\r\n// private methods:\r\n\t/**\r\n\t * Handles internal preload completion.\r\n\t * @method _handlePreloadComplete\r\n\t * @protected\r\n\t */\r\n\tp._handlePreloadComplete = function (event) {\r\n\t\tvar src = event.target.getItem().src;\r\n\t\tthis._audioSources[src] = event.result;\r\n\t\tfor (var i = 0, l = this._soundInstances[src].length; i < l; i++) {\r\n\t\t\tvar item = this._soundInstances[src][i];\r\n\t\t\titem.setPlaybackResource(this._audioSources[src]);\r\n\t\t\t// ToDo consider adding play call here if playstate == playfailed\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Handles internal preload erros\r\n\t * @method _handlePreloadError\r\n\t * @param event\r\n\t * @protected\r\n\t */\r\n\tp._handlePreloadError = function(event) {\r\n\t\t//delete(this._audioSources[src]);\r\n\t};\r\n\r\n\t/**\r\n\t * Set the gain value for master audio. Should not be called externally.\r\n\t * @method _updateVolume\r\n\t * @protected\r\n\t */\r\n\tp._updateVolume = function () {\r\n\t\t// Plugin Specific code\r\n\t};\r\n\r\n\tcreatejs.AbstractPlugin = AbstractPlugin;\r\n}());\r\n\r\n//##############################################################################\r\n// WebAudioLoader.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * Loader provides a mechanism to preload Web Audio content via PreloadJS or internally. Instances are returned to\r\n\t * the preloader, and the load method is called when the asset needs to be requested.\r\n\t *\r\n\t * @class WebAudioLoader\r\n\t * @param {String} loadItem The item to be loaded\r\n\t * @extends XHRRequest\r\n\t * @protected\r\n\t */\r\n\tfunction Loader(loadItem) {\r\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.SOUND);\r\n\r\n\t};\r\n\tvar p = createjs.extend(Loader, createjs.AbstractLoader);\r\n\r\n\t// TODO: deprecated\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\r\n\r\n\r\n\t/**\r\n\t * web audio context required for decoding audio\r\n\t * @property context\r\n\t * @type {AudioContext}\r\n\t * @static\r\n\t */\r\n\tLoader.context = null;\r\n\r\n\r\n// public methods\r\n\tp.toString = function () {\r\n\t\treturn "[WebAudioLoader]";\r\n\t};\r\n\r\n\r\n// private methods\r\n\tp._createRequest = function() {\r\n\t\tthis._request = new createjs.XHRRequest(this._item, false);\r\n\t\tthis._request.setResponseType("arraybuffer");\r\n\t};\r\n\r\n\tp._sendComplete = function (event) {\r\n\t\t// OJR we leave this wrapped in Loader because we need to reference src and the handler only receives a single argument, the decodedAudio\r\n\t\tLoader.context.decodeAudioData(this._rawResult,\r\n\t         createjs.proxy(this._handleAudioDecoded, this),\r\n\t         createjs.proxy(this._sendError, this));\r\n\t};\r\n\r\n\r\n\t/**\r\n\t* The audio has been decoded.\r\n\t* @method handleAudioDecoded\r\n\t* @param decoded\r\n\t* @protected\r\n\t*/\r\n\tp._handleAudioDecoded = function (decodedAudio) {\r\n\t\tthis._result = decodedAudio;\r\n\t\tthis.AbstractLoader__sendComplete();\r\n\t};\r\n\r\n\tcreatejs.WebAudioLoader = createjs.promote(Loader, "AbstractLoader");\r\n}());\r\n\r\n//##############################################################################\r\n// WebAudioSoundInstance.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n/**\r\n * WebAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by\r\n * {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\r\n *\r\n * WebAudioSoundInstance exposes audioNodes for advanced users.\r\n *\r\n * @param {String} src The path to and file name of the sound.\r\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\r\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\r\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\r\n * @class WebAudioSoundInstance\r\n * @extends AbstractSoundInstance\r\n * @constructor\r\n */\r\n(function () {\r\n\t"use strict";\r\n\r\n\tfunction WebAudioSoundInstance(src, startTime, duration, playbackResource) {\r\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\r\n\r\n\r\n// public properties\r\n\t\t/**\r\n\t\t * NOTE this is only intended for use by advanced users.\r\n\t\t * <br />GainNode for controlling <code>WebAudioSoundInstance</code> volume. Connected to the {{#crossLink "WebAudioSoundInstance/destinationNode:property"}}{{/crossLink}}.\r\n\t\t * @property gainNode\r\n\t\t * @type {AudioGainNode}\r\n\t\t * @since 0.4.0\r\n\t\t *\r\n\t\t */\r\n\t\tthis.gainNode = s.context.createGain();\r\n\r\n\t\t/**\r\n\t\t * NOTE this is only intended for use by advanced users.\r\n\t\t * <br />A panNode allowing left and right audio channel panning only. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.\r\n\t\t * @property panNode\r\n\t\t * @type {AudioPannerNode}\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\t\tthis.panNode = s.context.createPanner();\r\n\t\tthis.panNode.panningModel = s._panningModel;\r\n\t\tthis.panNode.connect(this.gainNode);\r\n\t\tthis._updatePan();\r\n\r\n\t\t/**\r\n\t\t * NOTE this is only intended for use by advanced users.\r\n\t\t * <br />sourceNode is the audio source. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/panNode:property"}}{{/crossLink}}.\r\n\t\t * @property sourceNode\r\n\t\t * @type {AudioNode}\r\n\t\t * @since 0.4.0\r\n\t\t *\r\n\t\t */\r\n\t\tthis.sourceNode = null;\r\n\r\n\r\n// private properties\r\n\t\t/**\r\n\t\t * Timeout that is created internally to handle sound playing to completion.\r\n\t\t * Stored so we can remove it when stop, pause, or cleanup are called\r\n\t\t * @property _soundCompleteTimeout\r\n\t\t * @type {timeoutVariable}\r\n\t\t * @default null\r\n\t\t * @protected\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\t\tthis._soundCompleteTimeout = null;\r\n\r\n\t\t/**\r\n\t\t * NOTE this is only intended for use by very advanced users.\r\n\t\t * _sourceNodeNext is the audio source for the next loop, inserted in a look ahead approach to allow for smooth\r\n\t\t * looping. Connected to {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.\r\n\t\t * @property _sourceNodeNext\r\n\t\t * @type {AudioNode}\r\n\t\t * @default null\r\n\t\t * @protected\r\n\t\t * @since 0.4.1\r\n\t\t *\r\n\t\t */\r\n\t\tthis._sourceNodeNext = null;\r\n\r\n\t\t/**\r\n\t\t * Time audio started playback, in seconds. Used to handle set position, get position, and resuming from paused.\r\n\t\t * @property _playbackStartTime\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t * @protected\r\n\t\t * @since 0.4.0\r\n\t\t */\r\n\t\tthis._playbackStartTime = 0;\r\n\r\n\t\t// Proxies, make removing listeners easier.\r\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\r\n\t};\r\n\tvar p = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance);\r\n\tvar s = WebAudioSoundInstance;\r\n\r\n\t// TODO: deprecated\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\r\n\r\n\r\n\t/**\r\n\t * Note this is only intended for use by advanced users.\r\n\t * <br />Audio context used to create nodes.  This is and needs to be the same context used by {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\r\n  \t * @property context\r\n\t * @type {AudioContext}\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.context = null;\r\n\r\n\t/**\r\n\t * Note this is only intended for use by advanced users.\r\n\t * <br />The scratch buffer that will be assigned to the buffer property of a source node on close.  \r\n\t * This is and should be the same scratch buffer referenced by {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\r\n  \t * @property _scratchBuffer\r\n\t * @type {AudioBufferSourceNode}\r\n\t * @static\r\n\t */\r\n\ts._scratchBuffer = null;\r\n\r\n\t/**\r\n\t * Note this is only intended for use by advanced users.\r\n\t * <br /> Audio node from WebAudioPlugin that sequences to <code>context.destination</code>\r\n\t * @property destinationNode\r\n\t * @type {AudioNode}\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts.destinationNode = null;\r\n\r\n\t/**\r\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\r\n\t * @property _panningModel\r\n\t * @type {Number / String}\r\n\t * @protected\r\n\t * @static\r\n\t * @since 0.6.0\r\n\t */\r\n\ts._panningModel = "equalpower";\r\n\r\n\r\n// Public methods\r\n\tp.destroy = function() {\r\n\t\tthis.AbstractSoundInstance_destroy();\r\n\r\n\t\tthis.panNode.disconnect(0);\r\n\t\tthis.panNode = null;\r\n\t\tthis.gainNode.disconnect(0);\r\n\t\tthis.gainNode = null;\r\n\t};\r\n\r\n\tp.toString = function () {\r\n\t\treturn "[WebAudioSoundInstance]";\r\n\t};\r\n\r\n\r\n// Private Methods\r\n\tp._updatePan = function() {\r\n\t\tthis.panNode.setPosition(this._pan, 0, -0.5);\r\n\t\t// z need to be -0.5 otherwise the sound only plays in left, right, or center\r\n\t};\r\n\r\n\tp._removeLooping = function(value) {\r\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\r\n\t};\r\n\r\n\tp._addLooping = function(value) {\r\n\t\tif (this.playState != createjs.Sound.PLAY_SUCCEEDED) { return; }\r\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\r\n\t};\r\n\r\n\tp._setDurationFromSource = function () {\r\n\t\tthis._duration = this.playbackResource.duration * 1000;\r\n\t};\r\n\r\n\tp._handleCleanUp = function () {\r\n\t\tif (this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\r\n\t\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\r\n\t\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\r\n\t\t}\r\n\r\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\r\n\t\t// OJR there appears to be a bug that this doesn\'t always work in webkit (Chrome and Safari). According to the documentation, this should work.\r\n\r\n\t\tclearTimeout(this._soundCompleteTimeout);\r\n\r\n\t\tthis._playbackStartTime = 0;\t// This is used by getPosition\r\n\t};\r\n\r\n\t/**\r\n\t * Turn off and disconnect an audioNode, then set reference to null to release it for garbage collection\r\n\t * @method _cleanUpAudioNode\r\n\t * @param audioNode\r\n\t * @return {audioNode}\r\n\t * @protected\r\n\t * @since 0.4.1\r\n\t */\r\n\tp._cleanUpAudioNode = function(audioNode) {\r\n\t\tif(audioNode) {\r\n\t\t\taudioNode.stop(0);\r\n\t\t\taudioNode.disconnect(0);\r\n\t\t\t// necessary to prevent leak on iOS Safari 7-9. will throw in almost all other\r\n\t\t\t// browser implementations.\r\n\t\t\ttry { audioNode.buffer = s._scratchBuffer; } catch(e) {}\r\n\t\t\taudioNode = null;\r\n\t\t}\r\n\t\treturn audioNode;\r\n\t};\r\n\r\n\tp._handleSoundReady = function (event) {\r\n\t\tthis.gainNode.connect(s.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.\r\n\r\n\t\tvar dur = this._duration * 0.001;\r\n\t\tvar pos = this._position * 0.001;\r\n\t\tif (pos > dur) {pos = dur;}\r\n\t\tthis.sourceNode = this._createAndPlayAudioNode((s.context.currentTime - dur), pos);\r\n\t\tthis._playbackStartTime = this.sourceNode.startTime - pos;\r\n\r\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);\r\n\r\n\t\tif(this._loop != 0) {\r\n\t\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Creates an audio node using the current src and context, connects it to the gain node, and starts playback.\r\n\t * @method _createAndPlayAudioNode\r\n\t * @param {Number} startTime The time to add this to the web audio context, in seconds.\r\n\t * @param {Number} offset The amount of time into the src audio to start playback, in seconds.\r\n\t * @return {audioNode}\r\n\t * @protected\r\n\t * @since 0.4.1\r\n\t */\r\n\tp._createAndPlayAudioNode = function(startTime, offset) {\r\n\t\tvar audioNode = s.context.createBufferSource();\r\n\t\taudioNode.buffer = this.playbackResource;\r\n\t\taudioNode.connect(this.panNode);\r\n\t\tvar dur = this._duration * 0.001;\r\n\t\taudioNode.startTime = startTime + dur;\r\n\t\taudioNode.start(audioNode.startTime, offset+(this._startTime*0.001), dur - offset);\r\n\t\treturn audioNode;\r\n\t};\r\n\r\n\tp._pause = function () {\r\n\t\tthis._position = (s.context.currentTime - this._playbackStartTime) * 1000;  // * 1000 to give milliseconds, lets us restart at same point\r\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\r\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\r\n\r\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\r\n\r\n\t\tclearTimeout(this._soundCompleteTimeout);\r\n\t};\r\n\r\n\tp._resume = function () {\r\n\t\tthis._handleSoundReady();\r\n\t};\r\n\r\n\t/*\r\n\tp._handleStop = function () {\r\n\t\t// web audio does not need to do anything extra\r\n\t};\r\n\t*/\r\n\r\n\tp._updateVolume = function () {\r\n\t\tvar newVolume = this._muted ? 0 : this._volume;\r\n\t  \tif (newVolume != this.gainNode.gain.value) {\r\n\t\t  this.gainNode.gain.value = newVolume;\r\n  \t\t}\r\n\t};\r\n\r\n\tp._calculateCurrentPosition = function () {\r\n\t\treturn ((s.context.currentTime - this._playbackStartTime) * 1000); // pos in seconds * 1000 to give milliseconds\r\n\t};\r\n\r\n\tp._updatePosition = function () {\r\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\r\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\r\n\t\tclearTimeout(this._soundCompleteTimeout);\r\n\r\n\t\tif (!this._paused) {this._handleSoundReady();}\r\n\t};\r\n\r\n\t// OJR we are using a look ahead approach to ensure smooth looping.\r\n\t// We add _sourceNodeNext to the audio context so that it starts playing even if this callback is delayed.\r\n\t// This technique is described here:  http://www.html5rocks.com/en/tutorials/audio/scheduling/\r\n\t// NOTE the cost of this is that our audio loop may not always match the loop event timing precisely.\r\n\tp._handleLoop = function () {\r\n\t\tthis._cleanUpAudioNode(this.sourceNode);\r\n\t\tthis.sourceNode = this._sourceNodeNext;\r\n\t\tthis._playbackStartTime = this.sourceNode.startTime;\r\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\r\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration);\r\n\t};\r\n\r\n\tp._updateDuration = function () {\r\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\r\n\t\t\tthis._pause();\r\n\t\t\tthis._resume();\r\n\t\t}\r\n\t};\r\n\r\n\tcreatejs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, "AbstractSoundInstance");\r\n}());\r\n\r\n//##############################################################################\r\n// WebAudioPlugin.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * Play sounds using Web Audio in the browser. The WebAudioPlugin is currently the default plugin, and will be used\r\n\t * anywhere that it is supported. To change plugin priority, check out the Sound API\r\n\t * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} method.\r\n\r\n\t * <h4>Known Browser and OS issues for Web Audio</h4>\r\n\t * <b>Firefox 25</b>\r\n\t * <li>\r\n\t *     mp3 audio files do not load properly on all windows machines, reported <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>.\r\n\t *     <br />For this reason it is recommended to pass another FireFox-supported type (i.e. ogg) as the default\r\n\t *     extension, until this bug is resolved\r\n\t * </li>\r\n\t *\r\n\t * <b>Webkit (Chrome and Safari)</b>\r\n\t * <li>\r\n\t *     AudioNode.disconnect does not always seem to work.  This can cause the file size to grow over time if you\r\n\t * \t   are playing a lot of audio files.\r\n\t * </li>\r\n\t *\r\n\t * <b>iOS 6 limitations</b>\r\n\t * <ul>\r\n\t *     <li>\r\n\t *         Sound is initially muted and will only unmute through play being called inside a user initiated event\r\n\t *         (touch/click). Please read the mobile playback notes in the the {{#crossLink "Sound"}}{{/crossLink}}\r\n\t *         class for a full overview of the limitations, and how to get around them.\r\n\t *     </li>\r\n\t *\t   <li>\r\n\t *\t       A bug exists that will distort un-cached audio when a video element is present in the DOM. You can avoid\r\n\t *\t       this bug by ensuring the audio and video audio share the same sample rate.\r\n\t *\t   </li>\r\n\t * </ul>\r\n\t * @class WebAudioPlugin\r\n\t * @extends AbstractPlugin\r\n\t * @constructor\r\n\t * @since 0.4.0\r\n\t */\r\n\tfunction WebAudioPlugin() {\r\n\t\tthis.AbstractPlugin_constructor();\r\n\r\n\r\n// Private Properties\r\n\t\t/**\r\n\t\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\r\n\t\t * @property _panningModel\r\n\t\t * @type {Number / String}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._panningModel = s._panningModel;;\r\n\r\n\t\t/**\r\n\t\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\r\n\t\t * need to be created within this context.\r\n\t\t * @property context\r\n\t\t * @type {AudioContext}\r\n\t\t */\r\n\t\tthis.context = s.context;\r\n\r\n\t\t/**\r\n\t\t * A DynamicsCompressorNode, which is used to improve sound quality and prevent audio distortion.\r\n\t\t * It is connected to <code>context.destination</code>.\r\n\t\t *\r\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.dynamicsCompressorNode.\r\n\t\t * @property dynamicsCompressorNode\r\n\t\t * @type {AudioNode}\r\n\t\t */\r\n\t\tthis.dynamicsCompressorNode = this.context.createDynamicsCompressor();\r\n\t\tthis.dynamicsCompressorNode.connect(this.context.destination);\r\n\r\n\t\t/**\r\n\t\t * A GainNode for controlling master volume. It is connected to {{#crossLink "WebAudioPlugin/dynamicsCompressorNode:property"}}{{/crossLink}}.\r\n\t\t *\r\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.gainNode.\r\n\t\t * @property gainNode\r\n\t\t * @type {AudioGainNode}\r\n\t\t */\r\n\t\tthis.gainNode = this.context.createGain();\r\n\t\tthis.gainNode.connect(this.dynamicsCompressorNode);\r\n\t\tcreatejs.WebAudioSoundInstance.destinationNode = this.gainNode;\r\n\r\n\t\tthis._capabilities = s._capabilities;\r\n\r\n\t\tthis._loaderClass = createjs.WebAudioLoader;\r\n\t\tthis._soundInstanceClass = createjs.WebAudioSoundInstance;\r\n\r\n\t\tthis._addPropsToClasses();\r\n\t}\r\n\tvar p = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin);\r\n\r\n\t// TODO: deprecated\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\r\n\r\n\r\n// Static Properties\r\n\tvar s = WebAudioPlugin;\r\n\t/**\r\n\t * The capabilities of the plugin. This is generated via the {{#crossLink "WebAudioPlugin/_generateCapabilities:method"}}{{/crossLink}}\r\n\t * method and is used internally.\r\n\t * @property _capabilities\r\n\t * @type {Object}\r\n\t * @default null\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._capabilities = null;\r\n\r\n\t/**\r\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\r\n\t * @property _panningModel\r\n\t * @type {Number / String}\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._panningModel = "equalpower";\r\n\r\n\t/**\r\n\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\r\n\t * need to be created within this context.\r\n\t *\r\n\t * Advanced users can set this to an existing context, but <b>must</b> do so before they call\r\n\t * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} or {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}.\r\n\t *\r\n\t * @property context\r\n\t * @type {AudioContext}\r\n\t * @static\r\n\t */\r\n\ts.context = null;\r\n\r\n\t/**\r\n\t * The scratch buffer that will be assigned to the buffer property of a source node on close.\r\n\t * Works around an iOS Safari bug: https://github.com/CreateJS/SoundJS/issues/102\r\n\t *\r\n\t * Advanced users can set this to an existing source node, but <b>must</b> do so before they call\r\n\t * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} or {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}.\r\n\t *\r\n\t * @property _scratchBuffer\r\n\t * @type {AudioBuffer}\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\t s._scratchBuffer = null;\r\n\r\n\t/**\r\n\t * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\r\n\t * empty sound.\r\n\t * @property _unlocked\r\n\t * @type {boolean}\r\n\t * @since 0.6.2\r\n\t * @private\r\n\t */\r\n\ts._unlocked = false;\r\n\r\n\r\n// Static Public Methods\r\n\t/**\r\n\t * Determine if the plugin can be used in the current browser/OS.\r\n\t * @method isSupported\r\n\t * @return {Boolean} If the plugin can be initialized.\r\n\t * @static\r\n\t */\r\n\ts.isSupported = function () {\r\n\t\t// check if this is some kind of mobile device, Web Audio works with local protocol under PhoneGap and it is unlikely someone is trying to run a local file\r\n\t\tvar isMobilePhoneGap = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;\r\n\t\t// OJR isMobile may be redundant with _isFileXHRSupported available.  Consider removing.\r\n\t\tif (location.protocol == "file:" && !isMobilePhoneGap && !this._isFileXHRSupported()) { return false; }  // Web Audio requires XHR, which is not usually available locally\r\n\t\ts._generateCapabilities();\r\n\t\tif (s.context == null) {return false;}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\r\n\t * require the first sound to be played inside of a user initiated event (touch/click).  This is called when\r\n\t * {{#crossLink "WebAudioPlugin"}}{{/crossLink}} is initialized (by Sound {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}\r\n\t * for example).\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *     function handleTouch(event) {\r\n\t *         createjs.WebAudioPlugin.playEmptySound();\r\n\t *     }\r\n\t *\r\n\t * @method playEmptySound\r\n\t * @static\r\n\t * @since 0.4.1\r\n\t */\r\n\ts.playEmptySound = function() {\r\n\t\tif (s.context == null) {return;}\r\n\t\tvar source = s.context.createBufferSource();\r\n\t\tsource.buffer = s._scratchBuffer;\r\n\t\tsource.connect(s.context.destination);\r\n\t\tsource.start(0, 0, 0);\r\n\t};\r\n\r\n\r\n// Static Private Methods\r\n\t/**\r\n\t * Determine if XHR is supported, which is necessary for web audio.\r\n\t * @method _isFileXHRSupported\r\n\t * @return {Boolean} If XHR is supported.\r\n\t * @since 0.4.2\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._isFileXHRSupported = function() {\r\n\t\t// it\'s much easier to detect when something goes wrong, so let\'s start optimistically\r\n\t\tvar supported = true;\r\n\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\ttry {\r\n\t\t\txhr.open("GET", "WebAudioPluginTest.fail", false); // loading non-existant file triggers 404 only if it could load (synchronous call)\r\n\t\t} catch (error) {\r\n\t\t\t// catch errors in cases where the onerror is passed by\r\n\t\t\tsupported = false;\r\n\t\t\treturn supported;\r\n\t\t}\r\n\t\txhr.onerror = function() { supported = false; }; // cause irrelevant\r\n\t\t// with security turned off, we can get empty success results, which is actually a failed read (status code 0?)\r\n\t\txhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != "")); };\r\n\t\ttry {\r\n\t\t\txhr.send();\r\n\t\t} catch (error) {\r\n\t\t\t// catch errors in cases where the onerror is passed by\r\n\t\t\tsupported = false;\r\n\t\t}\r\n\r\n\t\treturn supported;\r\n\t};\r\n\r\n\t/**\r\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}\r\n\t * method for an overview of plugin capabilities.\r\n\t * @method _generateCapabilities\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._generateCapabilities = function () {\r\n\t\tif (s._capabilities != null) {return;}\r\n\t\t// Web Audio can be in any formats supported by the audio element, from http://www.w3.org/TR/webaudio/#AudioContext-section\r\n\t\tvar t = document.createElement("audio");\r\n\t\tif (t.canPlayType == null) {return null;}\r\n\r\n\t\tif (s.context == null) {\r\n\t\t\tif (window.AudioContext) {\r\n\t\t\t\ts.context = new AudioContext();\r\n\t\t\t} else if (window.webkitAudioContext) {\r\n\t\t\t\ts.context = new webkitAudioContext();\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (s._scratchBuffer == null) {\r\n\t\t\ts._scratchBuffer = s.context.createBuffer(1, 1, 22050);\r\n\t\t}\r\n\r\n\t\ts._compatibilitySetUp();\r\n\r\n\t\t// Listen for document level clicks to unlock WebAudio on iOS. See the _unlock method.\r\n\t\tif ("ontouchstart" in window && s.context.state != "running") {\r\n\t\t\ts._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\r\n\t\t\tdocument.addEventListener("mousedown", s._unlock, true);\r\n\t\t\tdocument.addEventListener("touchend", s._unlock, true);\r\n\t\t}\r\n\r\n\r\n\t\ts._capabilities = {\r\n\t\t\tpanning:true,\r\n\t\t\tvolume:true,\r\n\t\t\ttracks:-1\r\n\t\t};\r\n\r\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\r\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\r\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\r\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\r\n\t\t\tvar ext = supportedExtensions[i];\r\n\t\t\tvar playType = extensionMap[ext] || ext;\r\n\t\t\ts._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");\r\n\t\t}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4\r\n\r\n\t\t// 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.\r\n\t\t// See http://www.w3.org/TR/webaudio/#AudioChannelSplitter for more details on channels.\r\n\t\tif (s.context.destination.numberOfChannels < 2) {\r\n\t\t\ts._capabilities.panning = false;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Set up compatibility if only deprecated web audio calls are supported.\r\n\t * See http://www.w3.org/TR/webaudio/#DeprecationNotes\r\n\t * Needed so we can support new browsers that don\'t support deprecated calls (Firefox) as well as old browsers that\r\n\t * don\'t support new calls.\r\n\t *\r\n\t * @method _compatibilitySetUp\r\n\t * @static\r\n\t * @protected\r\n\t * @since 0.4.2\r\n\t */\r\n\ts._compatibilitySetUp = function() {\r\n\t\ts._panningModel = "equalpower";\r\n\t\t//assume that if one new call is supported, they all are\r\n\t\tif (s.context.createGain) { return; }\r\n\r\n\t\t// simple name change, functionality the same\r\n\t\ts.context.createGain = s.context.createGainNode;\r\n\r\n\t\t// source node, add to prototype\r\n\t\tvar audioNode = s.context.createBufferSource();\r\n\t\taudioNode.__proto__.start = audioNode.__proto__.noteGrainOn;\t// note that noteGrainOn requires all 3 parameters\r\n\t\taudioNode.__proto__.stop = audioNode.__proto__.noteOff;\r\n\r\n\t\t// panningModel\r\n\t\ts._panningModel = 0;\r\n\t};\r\n\r\n\t/**\r\n\t * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\r\n\t * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\r\n\t * will fail if the user presses for too long, indicating a scroll event instead of a click event.\r\n\t *\r\n\t * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\r\n\t * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\r\n\t * stick with `mousedown` and `touchend`.\r\n\t * @method _unlock\r\n\t * @since 0.6.2\r\n\t * @private\r\n\t */\r\n\ts._unlock = function() {\r\n\t\tif (s._unlocked) { return; }\r\n\t\ts.playEmptySound();\r\n\t\tif (s.context.state == "running") {\r\n\t\t\tdocument.removeEventListener("mousedown", s._unlock, true);\r\n\t\t\tdocument.removeEventListener("touchend", s._unlock, true);\r\n\t\t\ts._unlocked = true;\r\n\t\t}\r\n\t};\r\n\r\n\r\n// Public Methods\r\n\tp.toString = function () {\r\n\t\treturn "[WebAudioPlugin]";\r\n\t};\r\n\r\n\r\n// Private Methods\r\n\t/**\r\n\t * Set up needed properties on supported classes WebAudioSoundInstance and WebAudioLoader.\r\n\t * @method _addPropsToClasses\r\n\t * @static\r\n\t * @protected\r\n\t * @since 0.6.0\r\n\t */\r\n\tp._addPropsToClasses = function() {\r\n\t\tvar c = this._soundInstanceClass;\r\n\t\tc.context = this.context;\r\n\t\tc._scratchBuffer = s._scratchBuffer;\r\n\t\tc.destinationNode = this.gainNode;\r\n\t\tc._panningModel = this._panningModel;\r\n\r\n\t\tthis._loaderClass.context = this.context;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Set the gain value for master audio. Should not be called externally.\r\n\t * @method _updateVolume\r\n\t * @protected\r\n\t */\r\n\tp._updateVolume = function () {\r\n\t\tvar newVolume = createjs.Sound._masterMute ? 0 : this._volume;\r\n\t\tif (newVolume != this.gainNode.gain.value) {\r\n\t\t\tthis.gainNode.gain.value = newVolume;\r\n\t\t}\r\n\t};\r\n\r\n\tcreatejs.WebAudioPlugin = createjs.promote(WebAudioPlugin, "AbstractPlugin");\r\n}());\r\n\r\n//##############################################################################\r\n// HTMLAudioTagPool.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * HTMLAudioTagPool is an object pool for HTMLAudio tag instances.\r\n\t * @class HTMLAudioTagPool\r\n\t * @param {String} src The source of the channel.\r\n\t * @protected\r\n\t */\r\n\tfunction HTMLAudioTagPool() {\r\n\t\t\tthrow "HTMLAudioTagPool cannot be instantiated";\r\n\t}\r\n\r\n\tvar s = HTMLAudioTagPool;\r\n\r\n// Static Properties\r\n\t/**\r\n\t * A hash lookup of each base audio tag, indexed by the audio source.\r\n\t * @property _tags\r\n\t * @type {{}}\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._tags = {};\r\n\r\n\t/**\r\n\t * An object pool for html audio tags\r\n\t * @property _tagPool\r\n\t * @type {TagPool}\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._tagPool = new TagPool();\r\n\r\n\t/**\r\n\t * A hash lookup of if a base audio tag is available, indexed by the audio source\r\n\t * @property _tagsUsed\r\n\t * @type {{}}\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._tagUsed = {};\r\n\r\n// Static Methods\r\n\t/**\r\n\t  * Get an audio tag with the given source.\r\n\t  * @method get\r\n\t  * @param {String} src The source file used by the audio tag.\r\n\t  * @static\r\n\t  */\r\n\t s.get = function (src) {\r\n\t\tvar t = s._tags[src];\r\n\t\tif (t == null) {\r\n\t\t\t// create new base tag\r\n\t\t\tt = s._tags[src] = s._tagPool.get();\r\n\t\t\tt.src = src;\r\n\t\t} else {\r\n\t\t\t// get base or pool\r\n\t\t\tif (s._tagUsed[src]) {\r\n\t\t\t\tt = s._tagPool.get();\r\n\t\t\t\tt.src = src;\r\n\t\t\t} else {\r\n\t\t\t\ts._tagUsed[src] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn t;\r\n\t };\r\n\r\n\t /**\r\n\t  * Return an audio tag to the pool.\r\n\t  * @method set\r\n\t  * @param {String} src The source file used by the audio tag.\r\n\t  * @param {HTMLElement} tag Audio tag to set.\r\n\t  * @static\r\n\t  */\r\n\t s.set = function (src, tag) {\r\n\t\t // check if this is base, if yes set boolean if not return to pool\r\n\t\t if(tag == s._tags[src]) {\r\n\t\t\t s._tagUsed[src] = false;\r\n\t\t } else {\r\n\t\t\t s._tagPool.set(tag);\r\n\t\t }\r\n\t };\r\n\r\n\t/**\r\n\t * Delete stored tag reference and return them to pool. Note that if the tag reference does not exist, this will fail.\r\n\t * @method remove\r\n\t * @param {String} src The source for the tag\r\n\t * @return {Boolean} If the TagPool was deleted.\r\n\t * @static\r\n\t */\r\n\ts.remove = function (src) {\r\n\t\tvar tag = s._tags[src];\r\n\t\tif (tag == null) {return false;}\r\n\t\ts._tagPool.set(tag);\r\n\t\tdelete(s._tags[src]);\r\n\t\tdelete(s._tagUsed[src]);\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Gets the duration of the src audio in milliseconds\r\n\t * @method getDuration\r\n\t * @param {String} src The source file used by the audio tag.\r\n\t * @return {Number} Duration of src in milliseconds\r\n\t * @static\r\n\t */\r\n\ts.getDuration= function (src) {\r\n\t\tvar t = s._tags[src];\r\n\t\tif (t == null || !t.duration) {return 0;}\t// OJR duration is NaN if loading has not completed\r\n\t\treturn t.duration * 1000;\r\n\t};\r\n\r\n\tcreatejs.HTMLAudioTagPool = HTMLAudioTagPool;\r\n\r\n\r\n// ************************************************************************************************************\r\n\t/**\r\n\t * The TagPool is an object pool for HTMLAudio tag instances.\r\n\t * #class TagPool\r\n\t * @param {String} src The source of the channel.\r\n\t * @protected\r\n\t */\r\n\tfunction TagPool(src) {\r\n\r\n// Public Properties\r\n\t\t/**\r\n\t\t * A list of all available tags in the pool.\r\n\t\t * #property tags\r\n\t\t * @type {Array}\r\n\t\t * @protected\r\n\t\t */\r\n\t\tthis._tags = [];\r\n\t};\r\n\r\n\tvar p = TagPool.prototype;\r\n\tp.constructor = TagPool;\r\n\r\n\r\n// Public Methods\r\n\t/**\r\n\t * Get an HTMLAudioElement for immediate playback. This takes it out of the pool.\r\n\t * #method get\r\n\t * @return {HTMLAudioElement} An HTML audio tag.\r\n\t */\r\n\tp.get = function () {\r\n\t\tvar tag;\r\n\t\tif (this._tags.length == 0) {\r\n\t\t\ttag = this._createTag();\r\n\t\t} else {\r\n\t\t\ttag = this._tags.pop();\r\n\t\t}\r\n\t\tif (tag.parentNode == null) {document.body.appendChild(tag);}\r\n\t\treturn tag;\r\n\t};\r\n\r\n\t/**\r\n\t * Put an HTMLAudioElement back in the pool for use.\r\n\t * #method set\r\n\t * @param {HTMLAudioElement} tag HTML audio tag\r\n\t */\r\n\tp.set = function (tag) {\r\n\t\t// OJR this first step seems unnecessary\r\n\t\tvar index = createjs.indexOf(this._tags, tag);\r\n\t\tif (index == -1) {\r\n\t\t\tthis._tags.src = null;\r\n\t\t\tthis._tags.push(tag);\r\n\t\t}\r\n\t};\r\n\r\n\tp.toString = function () {\r\n\t\treturn "[TagPool]";\r\n\t};\r\n\r\n\r\n// Private Methods\r\n\t/**\r\n\t * Create an HTML audio tag.\r\n\t * #method _createTag\r\n\t * @param {String} src The source file to set for the audio tag.\r\n\t * @return {HTMLElement} Returns an HTML audio tag.\r\n\t * @protected\r\n\t */\r\n\tp._createTag = function () {\r\n\t\tvar tag = document.createElement("audio");\r\n\t\ttag.autoplay = false;\r\n\t\ttag.preload = "none";\r\n\t\t//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.\r\n\t\treturn tag;\r\n\t};\r\n\r\n}());\r\n\r\n//##############################################################################\r\n// HTMLAudioSoundInstance.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * HTMLAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by\r\n\t * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\r\n\t *\r\n\t * @param {String} src The path to and file name of the sound.\r\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\r\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\r\n\t * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\r\n\t * @class HTMLAudioSoundInstance\r\n\t * @extends AbstractSoundInstance\r\n\t * @constructor\r\n\t */\r\n\tfunction HTMLAudioSoundInstance(src, startTime, duration, playbackResource) {\r\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\r\n\r\n\r\n// Private Properties\r\n\t\tthis._audioSpriteStopTime = null;\r\n\t\tthis._delayTimeoutId = null;\r\n\r\n\t\t// Proxies, make removing listeners easier.\r\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\r\n\t\tthis._readyHandler = createjs.proxy(this._handleTagReady, this);\r\n\t\tthis._stalledHandler = createjs.proxy(this._playFailed, this);\r\n\t\tthis._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this);\r\n\t\tthis._loopHandler = createjs.proxy(this._handleSoundComplete, this);\r\n\r\n\t\tif (duration) {\r\n\t\t\tthis._audioSpriteStopTime = (startTime + duration) * 0.001;\r\n\t\t} else {\r\n\t\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\r\n\t\t}\r\n\t}\r\n\tvar p = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);\r\n\r\n\t// TODO: deprecated\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\r\n\r\n\r\n// Public Methods\r\n\t/**\r\n\t * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master volume.\r\n\t * undoc\'d because it is not meant to be used outside of Sound\r\n\t * #method setMasterVolume\r\n\t * @param value\r\n\t */\r\n\tp.setMasterVolume = function (value) {\r\n\t\tthis._updateVolume();\r\n\t};\r\n\r\n\t/**\r\n\t * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master mute.\r\n\t * undoc\'d because it is not meant to be used outside of Sound\r\n\t * #method setMasterMute\r\n\t * @param value\r\n\t */\r\n\tp.setMasterMute = function (isMuted) {\r\n\t\tthis._updateVolume();\r\n\t};\r\n\r\n\tp.toString = function () {\r\n\t\treturn "[HTMLAudioSoundInstance]";\r\n\t};\r\n\r\n//Private Methods\r\n\tp._removeLooping = function() {\r\n\t\tif(this._playbackResource == null) {return;}\r\n\t\tthis._playbackResource.loop = false;\r\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\r\n\t};\r\n\r\n\tp._addLooping = function() {\r\n\t\tif(this._playbackResource == null  || this._audioSpriteStopTime) {return;}\r\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\r\n\t\tthis._playbackResource.loop = true;\r\n\t};\r\n\r\n\tp._handleCleanUp = function () {\r\n\t\tvar tag = this._playbackResource;\r\n\t\tif (tag != null) {\r\n\t\t\ttag.pause();\r\n\t\t\ttag.loop = false;\r\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\r\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\r\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\r\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\r\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\r\n\r\n\t\t\ttry {\r\n\t\t\t\ttag.currentTime = this._startTime;\r\n\t\t\t} catch (e) {\r\n\t\t\t} // Reset Position\r\n\t\t\tcreatejs.HTMLAudioTagPool.set(this.src, tag);\r\n\t\t\tthis._playbackResource = null;\r\n\t\t}\r\n\t};\r\n\r\n\tp._beginPlaying = function (playProps) {\r\n\t\tthis._playbackResource = createjs.HTMLAudioTagPool.get(this.src);\r\n\t\treturn this.AbstractSoundInstance__beginPlaying(playProps);\r\n\t};\r\n\r\n\tp._handleSoundReady = function (event) {\r\n\t\tif (this._playbackResource.readyState !== 4) {\r\n\t\t\tvar tag = this._playbackResource;\r\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\r\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\r\n\t\t\ttag.preload = "auto"; // This is necessary for Firefox, as it won\'t ever "load" until this is set.\r\n\t\t\ttag.load();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updateVolume();\r\n\t\tthis._playbackResource.currentTime = (this._startTime + this._position) * 0.001;\r\n\t\tif (this._audioSpriteStopTime) {\r\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\r\n\t\t} else {\r\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\r\n\t\t\tif(this._loop != 0) {\r\n\t\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\r\n\t\t\t\tthis._playbackResource.loop = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._playbackResource.play();\r\n\t};\r\n\r\n\t/**\r\n\t * Used to handle when a tag is not ready for immediate playback when it is returned from the HTMLAudioTagPool.\r\n\t * @method _handleTagReady\r\n\t * @param event\r\n\t * @protected\r\n\t */\r\n\tp._handleTagReady = function (event) {\r\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\r\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\r\n\r\n\t\tthis._handleSoundReady();\r\n\t};\r\n\r\n\tp._pause = function () {\r\n\t\tthis._playbackResource.pause();\r\n\t};\r\n\r\n\tp._resume = function () {\r\n\t\tthis._playbackResource.play();\r\n\t};\r\n\r\n\tp._updateVolume = function () {\r\n\t\tif (this._playbackResource != null) {\r\n\t\t\tvar newVolume = (this._muted || createjs.Sound._masterMute) ? 0 : this._volume * createjs.Sound._masterVolume;\r\n\t\t\tif (newVolume != this._playbackResource.volume) {this._playbackResource.volume = newVolume;}\r\n\t\t}\r\n\t};\r\n\r\n\tp._calculateCurrentPosition = function() {\r\n\t\treturn (this._playbackResource.currentTime * 1000) - this._startTime;\r\n\t};\r\n\r\n\tp._updatePosition = function() {\r\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\r\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\r\n\t\ttry {\r\n\t\t\tthis._playbackResource.currentTime = (this._position + this._startTime) * 0.001;\r\n\t\t} catch (error) { // Out of range\r\n\t\t\tthis._handleSetPositionSeek(null);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Used to enable setting position, as we need to wait for that seek to be done before we add back our loop handling seek listener\r\n\t * @method _handleSetPositionSeek\r\n\t * @param event\r\n\t * @protected\r\n\t */\r\n\tp._handleSetPositionSeek = function(event) {\r\n\t\tif (this._playbackResource == null) { return; }\r\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\r\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\r\n\t};\r\n\r\n\t/**\r\n\t * Timer used to loop audio sprites.\r\n\t * NOTE because of the inaccuracies in the timeupdate event (15 - 250ms) and in setting the tag to the desired timed\r\n\t * (up to 300ms), it is strongly recommended not to loop audio sprites with HTML Audio if smooth looping is desired\r\n\t *\r\n\t * @method _handleAudioSpriteLoop\r\n\t * @param event\r\n\t * @private\r\n\t */\r\n\tp._handleAudioSpriteLoop = function (event) {\r\n\t\tif(this._playbackResource.currentTime <= this._audioSpriteStopTime) {return;}\r\n\t\tthis._playbackResource.pause();\r\n\t\tif(this._loop == 0) {\r\n\t\t\tthis._handleSoundComplete(null);\r\n\t\t} else {\r\n\t\t\tthis._position = 0;\r\n\t\t\tthis._loop--;\r\n\t\t\tthis._playbackResource.currentTime = this._startTime * 0.001;\r\n\t\t\tif(!this._paused) {this._playbackResource.play();}\r\n\t\t\tthis._sendEvent("loop");\r\n\t\t}\r\n\t};\r\n\r\n\t// NOTE with this approach audio will loop as reliably as the browser allows\r\n\t// but we could end up sending the loop event after next loop playback begins\r\n\tp._handleLoop = function (event) {\r\n\t\tif(this._loop == 0) {\r\n\t\t\tthis._playbackResource.loop = false;\r\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\r\n\t\t}\r\n\t};\r\n\r\n\tp._updateStartTime = function () {\r\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\r\n\r\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\r\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\r\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\r\n\t\t}\r\n\t};\r\n\r\n\tp._updateDuration = function () {\r\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\r\n\r\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\r\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\r\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\r\n\t\t}\r\n\t};\r\n\r\n\tp._setDurationFromSource = function () {\r\n\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\r\n\t\tthis._playbackResource = null;\r\n\t};\r\n\r\n\tcreatejs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, "AbstractSoundInstance");\r\n}());\r\n\r\n//##############################################################################\r\n// HTMLAudioPlugin.js\r\n//##############################################################################\r\n\r\nthis.createjs = this.createjs || {};\r\n\r\n(function () {\r\n\r\n\t"use strict";\r\n\r\n\t/**\r\n\t * Play sounds using HTML &lt;audio&gt; tags in the browser. This plugin is the second priority plugin installed\r\n\t * by default, after the {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.  For older browsers that do not support html\r\n\t * audio, include and install the {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.\r\n\t *\r\n\t * <h4>Known Browser and OS issues for HTML Audio</h4>\r\n\t * <b>All browsers</b><br />\r\n\t * Testing has shown in all browsers there is a limit to how many audio tag instances you are allowed.  If you exceed\r\n\t * this limit, you can expect to see unpredictable results. Please use {{#crossLink "Sound.MAX_INSTANCES"}}{{/crossLink}} as\r\n\t * a guide to how many total audio tags you can safely use in all browsers.  This issue is primarily limited to IE9.\r\n\t *\r\n     * <b>IE html limitations</b><br />\r\n     * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\r\n     * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\r\n     * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\r\n     * <li>MP3 encoding will not always work for audio tags if it\'s not default.  We\'ve found default encoding with\r\n     * 64kbps works.</li>\r\n\t * <li>Occasionally very short samples will get cut off.</li>\r\n\t * <li>There is a limit to how many audio tags you can load or play at once, which appears to be determined by\r\n\t * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe estimate.\r\n\t * Note that audio sprites can be used as a solution to this issue.</li></ul>\r\n\t *\r\n\t * <b>Safari limitations</b><br />\r\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\r\n\t *\r\n\t * <b>iOS 6 limitations</b><br />\r\n\t * <ul><li>can only have one &lt;audio&gt; tag</li>\r\n\t * \t\t<li>can not preload or autoplay the audio</li>\r\n\t * \t\t<li>can not cache the audio</li>\r\n\t * \t\t<li>can not play the audio except inside a user initiated event.</li>\r\n\t *\t\t<li>Note it is recommended to use {{#crossLink "WebAudioPlugin"}}{{/crossLink}} for iOS (6+)</li>\r\n\t * \t\t<li>audio sprites can be used to mitigate some of these issues and are strongly recommended on iOS</li>\r\n\t * </ul>\r\n\t *\r\n\t * <b>Android Native Browser limitations</b><br />\r\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\r\n\t *      <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use a delay.</li></ul>\r\n\t * <b> Android Chrome 26.0.1410.58 specific limitations</b><br />\r\n\t * <ul> <li>Can only play 1 sound at a time.</li>\r\n\t *      <li>Sound is not cached.</li>\r\n\t *      <li>Sound can only be loaded in a user initiated touch/click event.</li>\r\n\t *      <li>There is a delay before a sound is played, presumably while the src is loaded.</li>\r\n\t * </ul>\r\n\t *\r\n\t * See {{#crossLink "Sound"}}{{/crossLink}} for general notes on known issues.\r\n\t *\r\n\t * @class HTMLAudioPlugin\r\n\t * @extends AbstractPlugin\r\n\t * @constructor\r\n\t */\r\n\tfunction HTMLAudioPlugin() {\r\n\t\tthis.AbstractPlugin_constructor();\r\n\r\n\r\n\t// Public Properties\r\n\t\t/**\r\n\t\t * This is no longer needed as we are now using object pooling for tags.\r\n\t\t *\r\n\t\t * <b>NOTE this property only exists as a limitation of HTML audio.</b>\r\n\t\t * @property defaultNumChannels\r\n\t\t * @type {Number}\r\n\t\t * @default 2\r\n\t\t * @since 0.4.0\r\n\t\t * @deprecated\r\n\t\t */\r\n\t\tthis.defaultNumChannels = 2;\r\n\r\n\t\tthis._capabilities = s._capabilities;\r\n\r\n\t\tthis._loaderClass = createjs.SoundLoader;\r\n\t\tthis._soundInstanceClass = createjs.HTMLAudioSoundInstance;\r\n\t}\r\n\r\n\tvar p = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin);\r\n\tvar s = HTMLAudioPlugin;\r\n\r\n\t// TODO: deprecated\r\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\r\n\r\n\r\n// Static Properties\r\n\t/**\r\n\t * The maximum number of instances that can be loaded or played. This is a browser limitation, primarily limited to IE9.\r\n\t * The actual number varies from browser to browser (and is largely hardware dependant), but this is a safe estimate.\r\n\t * Audio sprites work around this limitation.\r\n\t * @property MAX_INSTANCES\r\n\t * @type {Number}\r\n\t * @default 30\r\n\t * @static\r\n\t */\r\n\ts.MAX_INSTANCES = 30;\r\n\r\n\t/**\r\n\t * Event constant for the "canPlayThrough" event for cleaner code.\r\n\t * @property _AUDIO_READY\r\n\t * @type {String}\r\n\t * @default canplaythrough\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._AUDIO_READY = "canplaythrough";\r\n\r\n\t/**\r\n\t * Event constant for the "ended" event for cleaner code.\r\n\t * @property _AUDIO_ENDED\r\n\t * @type {String}\r\n\t * @default ended\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._AUDIO_ENDED = "ended";\r\n\r\n\t/**\r\n\t * Event constant for the "seeked" event for cleaner code.  We utilize this event for maintaining loop events.\r\n\t * @property _AUDIO_SEEKED\r\n\t * @type {String}\r\n\t * @default seeked\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._AUDIO_SEEKED = "seeked";\r\n\r\n\t/**\r\n\t * Event constant for the "stalled" event for cleaner code.\r\n\t * @property _AUDIO_STALLED\r\n\t * @type {String}\r\n\t * @default stalled\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._AUDIO_STALLED = "stalled";\r\n\r\n\t/**\r\n\t * Event constant for the "timeupdate" event for cleaner code.  Utilized for looping audio sprites.\r\n\t * This event callsback ever 15 to 250ms and can be dropped by the browser for performance.\r\n\t * @property _TIME_UPDATE\r\n\t * @type {String}\r\n\t * @default timeupdate\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._TIME_UPDATE = "timeupdate";\r\n\r\n\t/**\r\n\t * The capabilities of the plugin. This is generated via the {{#crossLink "HTMLAudioPlugin/_generateCapabilities"}}{{/crossLink}}\r\n\t * method. Please see the Sound {{#crossLink "Sound/getCapabilities"}}{{/crossLink}} method for an overview of all\r\n\t * of the available properties.\r\n\t * @property _capabilities\r\n\t * @type {Object}\r\n\t * @protected\r\n\t * @static\r\n\t */\r\n\ts._capabilities = null;\r\n\r\n\r\n// Static Methods\r\n\t/**\r\n\t * Determine if the plugin can be used in the current browser/OS. Note that HTML audio is available in most modern\r\n\t * browsers, but is disabled in iOS because of its limitations.\r\n\t * @method isSupported\r\n\t * @return {Boolean} If the plugin can be initialized.\r\n\t * @static\r\n\t */\r\n\ts.isSupported = function () {\r\n\t\ts._generateCapabilities();\r\n\t\treturn (s._capabilities != null);\r\n\t};\r\n\r\n\t/**\r\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}\r\n\t * method for an overview of plugin capabilities.\r\n\t * @method _generateCapabilities\r\n\t * @static\r\n\t * @protected\r\n\t */\r\n\ts._generateCapabilities = function () {\r\n\t\tif (s._capabilities != null) {return;}\r\n\t\tvar t = document.createElement("audio");\r\n\t\tif (t.canPlayType == null) {return null;}\r\n\r\n\t\ts._capabilities = {\r\n\t\t\tpanning:false,\r\n\t\t\tvolume:true,\r\n\t\t\ttracks:-1\r\n\t\t};\r\n\r\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\r\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\r\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\r\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\r\n\t\t\tvar ext = supportedExtensions[i];\r\n\t\t\tvar playType = extensionMap[ext] || ext;\r\n\t\t\ts._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");\r\n\t\t}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4\r\n\t};\r\n\r\n\r\n// public methods\r\n\tp.register = function (loadItem) {\r\n\t\tvar tag = createjs.HTMLAudioTagPool.get(loadItem.src);\r\n\t\tvar loader = this.AbstractPlugin_register(loadItem);\r\n\t\tloader.setTag(tag);\r\n\r\n\t\treturn loader;\r\n\t};\r\n\r\n\tp.removeSound = function (src) {\r\n\t\tthis.AbstractPlugin_removeSound(src);\r\n\t\tcreatejs.HTMLAudioTagPool.remove(src);\r\n\t};\r\n\r\n\tp.create = function (src, startTime, duration) {\r\n\t\tvar si = this.AbstractPlugin_create(src, startTime, duration);\r\n\t\tsi.setPlaybackResource(null);\r\n\t\treturn si;\r\n\t};\r\n\r\n\tp.toString = function () {\r\n\t\treturn "[HTMLAudioPlugin]";\r\n\t};\r\n\r\n\t// plugin does not support these\r\n\tp.setVolume = p.getVolume = p.setMute = null;\r\n\r\n\r\n\tcreatejs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, "AbstractPlugin");\r\n}());\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/soundjs-0.6.2.combined.js'),
define("soundjs",function(n){return function(){var e;return e||n.createjs}}(this)),eval('/* Web Font Loader v1.6.26 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.m=b||a;this.c=this.m.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}\nfunction w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\\s+/g," ").replace(/^\\s+|\\s+$/,"")}function y(a,b){for(var c=a.className.split(/\\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}\nfunction z(a){if("string"===typeof a.f)return a.f;var b=a.m.location.protocol;"about:"==b&&(b=a.a.location.protocol);return"https:"==b?"https:":"http:"}function ea(a){return a.m.location.hostname||a.a.location.hostname}\nfunction A(a,b,c){function d(){k&&e&&f&&(k(g),k=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,k=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}\nfunction B(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function C(){this.a=0;this.c=null}function D(a){a.a++;return function(){a.a--;E(a)}}function F(a,b){a.c=b;E(a)}function E(a){0==a.a&&a.c&&(a.c(),a.c=null)};function G(a){this.a=a||"-"}G.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\\W_]+/g,"").toLowerCase());return b.join(this.a)};function H(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return I(a)+" "+(a.f+"00")+" 300px "+J(a.c)}function J(a){var b=[];a=a.split(/,\\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/[\'"]/g,"");-1!=d.indexOf(" ")||/^\\d/.test(d)?b.push("\'"+d+"\'"):b.push(d)}return b.join(",")}function K(a){return a.a+a.f}function I(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}\nfunction ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.m.document.documentElement;this.h=b;this.a=new G("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);L(a,"loading")}function M(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}L(a,"inactive")}function L(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,K(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function N(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function O(a){u(a.c,"body",a.a)}function P(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+J(a.c)+";"+("font-style:"+I(a)+";font-weight:"+(a.f+"00")+";")};function Q(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}Q.prototype.start=function(){var a=this.c.m.document,b=this,c=q(),d=new Promise(function(d,e){function k(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(k,25)},function(){e()})}k()}),e=new Promise(function(a,d){setTimeout(d,b.f)});Promise.race([e,d]).then(function(){b.g(b.a)},function(){b.j(b.a)})};function R(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.o=this.j=this.h=this.g=null;this.g=new N(this.c,this.s);this.h=new N(this.c,this.s);this.j=new N(this.c,this.s);this.o=new N(this.c,this.s);a=new H(this.a.c+",serif",K(this.a));a=P(a);this.g.a.style.cssText=a;a=new H(this.a.c+",sans-serif",K(this.a));a=P(a);this.h.a.style.cssText=a;a=new H("serif",K(this.a));a=P(a);this.j.a.style.cssText=a;a=new H("sans-serif",K(this.a));a=\nP(a);this.o.a.style.cssText=a;O(this.g);O(this.h);O(this.j);O(this.o)}var S={D:"serif",C:"sans-serif"},T=null;function U(){if(null===T){var a=/AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(window.navigator.userAgent);T=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return T}R.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.o.a.offsetWidth;this.A=q();la(this)};\nfunction ma(a,b,c){for(var d in S)if(S.hasOwnProperty(d)&&b===a.f[S[d]]&&c===a.f[S[d]])return!0;return!1}function la(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=U()&&ma(a,b,c));d?q()-a.A>=a.w?U()&&ma(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):na(a):V(a,a.v)}function na(a){setTimeout(p(function(){la(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.o.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.o=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,K(a).toString(),"active")],[b.a.c("wf",a.c,K(a).toString(),"loading"),b.a.c("wf",a.c,K(a).toString(),"inactive")]);L(b,"fontactive",a);this.o=!0;oa(this)};\nW.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,K(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,K(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,K(a).toString(),"inactive"));w(b.f,d,e)}L(b,"fontinactive",a);oa(this)};function oa(a){0==--a.f&&a.j&&(a.o?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),L(a,"active")):M(a.a))};function pa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}pa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;qa(this,new ha(this.c,a),a)};\nfunction ra(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,k=d||null||{};if(0===c.length&&f)M(b.a);else{b.f+=c.length;f&&(b.j=f);var h,m=[];for(h=0;h<c.length;h++){var l=c[h],n=k[l.c],r=b.a,x=l;r.g&&w(r.f,[r.a.c("wf",x.c,K(x).toString(),"loading")]);L(r,"fontloading",x);r=null;null===X&&(X=window.FontFace?(x=/Gecko.*Firefox\\/(\\d+)/.exec(window.navigator.userAgent))?42<parseInt(x[1],10):!0:!1);X?r=new Q(p(b.g,b),p(b.h,b),b.c,l,b.s,n):r=new R(p(b.g,b),p(b.h,b),b.c,l,b.s,a,\nn);m.push(r)}for(h=0;h<m.length;h++)m[h].start()}},0)}function qa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){ra(a,f,b,d,c)})};function sa(a,b){this.c=a;this.a=b}function ta(a,b,c){var d=z(a.c);a=(a.a.api||"fast.fonts.net/jsapi").replace(/^.*http(s?):(\\/\\/)?/,"");return d+"//"+a+"/"+b+".js"+(c?"?v="+c:"")}\nsa.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var m=0;m<c.length;m++){var l=c[m].fontfamily;void 0!=c[m].fontStyle&&void 0!=c[m].fontWeight?(h=c[m].fontStyle+c[m].fontWeight,e.push(new H(l,h))):e.push(new H(l))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.m;B(this.c,ta(c,d,e),function(e){e?a([]):(f["__MonotypeConfiguration__"+d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+\nd}else a([])};function ua(a,b){this.c=a;this.a=b}ua.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new C;b=0;for(c=d.length;b<c;b++)A(this.c,d[b],D(g));var k=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),m=0;m<h.length;m+=1)k.push(new H(d[0],h[m]));else k.push(new H(d[0]));F(g,function(){a(k,f)})};function va(a,b,c){a?this.c=a:this.c=b+wa;this.a=[];this.f=[];this.g=c||""}var wa="//fonts.googleapis.com/css";function xa(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}\nfunction ya(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function za(a){this.f=a;this.a=[];this.c={}}\nvar Aa={latin:"BESbswy","latin-ext":"\\u00e7\\u00f6\\u00fc\\u011f\\u015f",cyrillic:"\\u0439\\u044f\\u0416",greek:"\\u03b1\\u03b2\\u03a3",khmer:"\\u1780\\u1781\\u1782",Hanuman:"\\u1780\\u1781\\u1782"},Ba={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ca={i:"i",italic:"i",n:"n",normal:"n"},\nDa=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;\nfunction Ea(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\\+/g," "),f=["n4"];if(2<=d.length){var g;var k=d[1];g=[];if(k)for(var k=k.split(","),h=k.length,m=0;m<h;m++){var l;l=k[m];if(l.match(/^[\\w-]+$/)){var n=Da.exec(l.toLowerCase());if(null==n)l="";else{l=n[2];l=null==l||""==l?"n":Ca[l];n=n[1];if(null==n||""==n)n="4";else var r=Ba[n],n=r?r:isNaN(n)?"4":n.substr(0,1);l=[l,n].join("")}}else l="";l&&g.push(l)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):\ng,0<d.length&&(d=Aa[d[0]])&&(a.c[e]=d))}a.c[e]||(d=Aa[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new H(e,f[d]))}};function Fa(a,b){this.c=a;this.a=b}var Ga={Arimo:!0,Cousine:!0,Tinos:!0};Fa.prototype.load=function(a){var b=new C,c=this.c,d=new va(this.a.api,z(c),this.a.text),e=this.a.families;xa(d,e);var f=new za(e);Ea(f);A(c,ya(d),D(b));F(b,function(){a(f.a,f.c,Ga)})};function Ha(a,b){this.c=a;this.a=b}Ha.prototype.load=function(a){var b=this.a.id,c=this.c.m;b?B(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],k=b[f+1],h=0;h<k.length;h++)e.push(new H(g,k[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(m){}a(e)}},2E3):a([])};function Ia(a,b){this.c=a;this.f=b;this.a=[]}Ia.prototype.load=function(a){var b=this.f.id,c=this.c.m,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,k=c.fonts.length;g<k;++g){var h=c.fonts[g];d.a.push(new H(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},B(this.c,z(this.c)+(this.f.api||"//f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new pa(window);Y.a.c.custom=function(a,b){return new ua(b,a)};Y.a.c.fontdeck=function(a,b){return new Ia(b,a)};Y.a.c.monotype=function(a,b){return new sa(b,a)};Y.a.c.typekit=function(a,b){return new Ha(b,a)};Y.a.c.google=function(a,b){return new Fa(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(\'webfontloader\',[],function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/webfontloader.js'),eval("define('data/fonts-array-core',[],function () {\r\n    return [\r\n    ];\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/data/fonts-array-core.js"),eval("define('data/fonts-array',[],function () {\r\n    return [\r\n        'winline-48',\r\n        'ochre-48',\r\n        'red-72',\r\n    ];\r\n});\n//# sourceURL=/modules/Vikings/src/js/data/fonts-array.js"),eval("define('data/fonts-css-array-core',[],function () {\r\n    return ['MYRIADPRO-SEMIEXT'];\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/data/fonts-css-array-core.js"),eval("define('data/fonts-css-array',[],function () {\r\n    return [];\r\n});\n//# sourceURL=/modules/Vikings/src/js/data/fonts-css-array.js"),eval('define(\'data/clip-textures-game-tablet-core\',[],function () {\r\n    return [\r\n        {\r\n            "imgPath": "Control_panel/buttons/circle_menu_transform",\r\n            "steps": 8,\r\n            "frameOffset": 0,\r\n            "spriteW": 124,\r\n            "spriteH": 124,\r\n            "cols": 8,\r\n            "animationSpeed": 30,\r\n            cacheToLayer: \'ui\',\r\n        },\r\n        {\r\n            "imgPath": "Control_panel/buttons/menu_circle_transform",\r\n            "steps": 8,\r\n            "frameOffset": 0,\r\n            "spriteW": 124,\r\n            "spriteH": 124,\r\n            "cols": 8,\r\n            "animationSpeed": 30,\r\n            cacheToLayer: \'ui\',\r\n        },\r\n        {\r\n            "imgPath": "Control_panel/buttons/spin_play_transform",\r\n            "steps": 6,\r\n            "frameOffset": 0,\r\n            "spriteW": 124,\r\n            "spriteH": 124,\r\n            "cols": 6,\r\n            "animationSpeed": 30,\r\n            cacheToLayer: \'ui\',\r\n        },\r\n        {\r\n            "imgPath": "Control_panel/buttons/play_spin_transform",\r\n            "steps": 6,\r\n            "frameOffset": 0,\r\n            "spriteW": 124,\r\n            "spriteH": 124,\r\n            "cols": 6,\r\n            "animationSpeed": 30,\r\n            cacheToLayer: \'ui\',\r\n        },\r\n        {\r\n            "imgPath": "Control_panel/coins_sheet",\r\n            "steps": 23,\r\n            "frameOffset": 2,\r\n            "spriteW": 339,\r\n            "spriteH": 201,\r\n            "cols": 6,\r\n            "animationSpeed": 17,\r\n            cacheToLayer: \'over\',\r\n        },\r\n        {\r\n            "imgPath": "Control_panel/WINGLOW_sheet",\r\n            "steps": 12,\r\n            "frameOffset": 2,\r\n            "spriteW": 326,\r\n            "spriteH": 42,\r\n            "cols": 3,\r\n            "animationSpeed": 30,\r\n            cacheToLayer: \'over\',\r\n        },\r\n        {\r\n            "imgPath": "Control_panel/teaser_sheet",\r\n            "steps": 8,\r\n            "frameOffset": 2,\r\n            "spriteW": 188,\r\n            "spriteH": 494,\r\n            "cols": 5,\r\n            "animationSpeed": 15,\r\n            cacheToLayer: \'top\',\r\n        },\r\n    ];\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/data/clip-textures-game-tablet-core.js'),eval('define(\'data/clip-textures-game-tablet\',[\'data/clip-textures-game-tablet-core\'], function (coreList) {\r\n    return coreList.concat([\r\n        {\r\n            "imgPath": "symbols/06_sheet",\r\n            "steps": 16,\r\n            "frameOffset": 2,\r\n            "spriteW": 118,\r\n            "spriteH": 118,\r\n            "cols": 8,\r\n            "animationSpeed": 15\r\n        },\r\n        {\r\n            "imgPath": "symbols/05cycle_sheet",\r\n            "steps": 30,\r\n            "frameOffset": 2,\r\n            "spriteW": 118,\r\n            "spriteH": 118,\r\n            "cols": 8,\r\n            "animationSpeed": 15\r\n        },\r\n        {\r\n            "imgPath": "symbols/05_sheet",\r\n            "steps": 30,\r\n            "frameOffset": 2,\r\n            "spriteW": 118,\r\n            "spriteH": 118,\r\n            "cols": 8,\r\n            "animationSpeed": 15\r\n        },\r\n        {\r\n            "imgPath": "symbols/01_sheet",\r\n            "steps": 20,\r\n            "frameOffset": 2,\r\n            "spriteW": 118,\r\n            "spriteH": 123,\r\n            "cols": 8,\r\n            "animationSpeed": 15\r\n        },\r\n        {\r\n            "imgPath": "symbols/scatter_sheet",\r\n            "steps": 44,\r\n            "frameOffset": 2,\r\n            "spriteW": 202,\r\n            "spriteH": 187,\r\n            "cols": 10,\r\n            "animationSpeed": 15\r\n        }\r\n    ]);\r\n});\n//# sourceURL=/modules/Vikings/src/js/data/clip-textures-game-tablet.js'),eval('define(\'data/sounds-core\',[],function () {\r\n    return {\r\n        loq: {\r\n            "rotate": [\r\n                4911,\r\n                true,\r\n                .05\r\n            ],\r\n            "teaser": [\r\n                4049,\r\n                false,\r\n                1\r\n            ],\r\n            "wintable": [\r\n                2011,\r\n                false,\r\n                .5\r\n            ],\r\n            "bell": [\r\n                1332,\r\n            ],\r\n            "actions_start": [\r\n                1175.1250000000014,\r\n                false,\r\n                .5\r\n            ],\r\n            "winline": [\r\n                549,\r\n            ],\r\n            "trigger": [\r\n                1097,\r\n            ],\r\n            "stop0": [\r\n                731.6562500000003,\r\n                false,\r\n                .2\r\n            ],\r\n            "stop1": [\r\n                890.3437499999995,\r\n                false,\r\n                .2\r\n            ],\r\n            "stop2": [\r\n                731.6562500000003,\r\n                false,\r\n                .2\r\n            ],\r\n            "stop3": [\r\n                890.3437499999995,\r\n                false,\r\n                .2\r\n            ],\r\n            "stop4": [\r\n                890.3437499999995,\r\n                false,\r\n                .2\r\n            ],\r\n            "accepting_credits": [\r\n                15357.3125,\r\n                true\r\n            ],\r\n            "auto_button_off": [\r\n                1461.7499999999986\r\n            ],\r\n            "auto_button_on": [\r\n                1195.1874999999993\r\n            ],\r\n            "credits_accept_finished": [\r\n                960.0000000000009\r\n            ],\r\n            "gamble_cards_close": [\r\n                648.9375000000024\r\n            ],\r\n            "gamble_card_open": [\r\n                599.937500000003\r\n            ],\r\n            "gamble_card_open_loss": [\r\n                1365.6250000000014\r\n            ],\r\n            "gamble_card_open_same": [\r\n                815.3124999999975\r\n            ],\r\n            "gamble_card_open_win": [\r\n                1349.499999999999\r\n            ],\r\n            "winner-short": [\r\n                862\r\n            ],\r\n            "winner-mid": [\r\n                1411\r\n            ],\r\n            "winner-long": [\r\n                2168\r\n            ],\r\n        },\r\n        hiq: {\r\n            "accepting_credits": [\r\n                15357.3125,\r\n                true\r\n            ],\r\n            "teaser": [\r\n                4049,\r\n                false,\r\n                .5\r\n            ],\r\n            "winline": [\r\n                549,\r\n            ],\r\n            "bell": [\r\n                1332,\r\n            ],\r\n            "auto_button_off": [\r\n                1461.7499999999986\r\n            ],\r\n            "auto_button_on": [\r\n                1195.1874999999993\r\n            ],\r\n            "credits_accept_finished": [\r\n                960.0000000000009\r\n            ],\r\n            "gamble_cards_close": [\r\n                648.9375000000024\r\n            ],\r\n            "gamble_card_open": [\r\n                599.937500000003\r\n            ],\r\n            "gamble_card_open_loss": [\r\n                1365.6250000000014\r\n            ],\r\n            "gamble_card_open_same": [\r\n                815.3124999999975\r\n            ],\r\n            "gamble_card_open_win": [\r\n                1349.499999999999\r\n            ],\r\n            "winner-short": [\r\n                862\r\n            ],\r\n            "winner-mid": [\r\n                1411\r\n            ],\r\n            "winner-long": [\r\n                2168\r\n            ],\r\n        }\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/data/sounds-core.js'),eval('define(\'data/sounds-game\',[],function () {\r\n    return {\r\n        loq: {\r\n            "win_$0$1$2$3": [\r\n                3500\r\n            ],\r\n            "win_$10$11$12": [\r\n                4000\r\n            ],\r\n            "win_$13$14$15": [\r\n                2500\r\n            ],\r\n            "win_$16$17$18": [\r\n                4000\r\n            ],\r\n            "win_$19$20$21": [\r\n                3000\r\n            ],\r\n            "win_$22$23$24$25$26$27": [\r\n                3000\r\n            ],\r\n            "win_$28$29$30": [\r\n                4500\r\n            ],\r\n            "win_$4$5$6": [\r\n                3500\r\n            ],\r\n            "win_$7$8$9": [\r\n                4000\r\n            ]\r\n        },\r\n        hiq: {\r\n            "background-base": [\r\n                82320,\r\n                true],\r\n            "background-fg": [\r\n                68616,\r\n                true],\r\n            "actions_start": [\r\n                991.1874999999987\r\n            ],\r\n            "end_wintable": [\r\n                7625.062499999998\r\n            ],\r\n            "start_wintable": [\r\n                3761.8124999999977\r\n            ],\r\n            "stop0": [\r\n                1408.1874999999968\r\n            ],\r\n            "stop1": [\r\n                1401.9375000000025\r\n            ],\r\n            "stop2": [\r\n                1396.8749999999943\r\n            ],\r\n            "stop3": [\r\n                1552.9374999999986\r\n            ],\r\n            "stop4": [\r\n                1345.8750000000066\r\n            ],\r\n            "trigger0": [\r\n                1096.500000000006\r\n            ],\r\n            "trigger1": [\r\n                1468.0000000000036\r\n            ],\r\n            "trigger2": [\r\n                2265.874999999994\r\n            ],\r\n            "trigger3": [\r\n                1492.9374999999964\r\n            ],\r\n            "trigger4": [\r\n                1096.5625000000045\r\n            ],\r\n            "win_$0$1$2$3": [\r\n                3500\r\n            ],\r\n            "win_$10$11$12": [\r\n                4000\r\n            ],\r\n            "win_$13$14$15": [\r\n                2500\r\n            ],\r\n            "win_$16$17$18": [\r\n                4000\r\n            ],\r\n            "win_$19$20$21": [\r\n                3000\r\n            ],\r\n            "win_$22$23$24$25$26$27": [\r\n                3000\r\n            ],\r\n            "win_$28$29$30": [\r\n                4500\r\n            ],\r\n            "win_$4$5$6": [\r\n                3500\r\n            ],\r\n            "win_$7$8$9": [\r\n                4000\r\n            ]\r\n        }\r\n    }\r\n});\n//# sourceURL=/modules/Vikings/src/js/data/sounds-game.js'),eval("// assets service\r\n// handles loading and access to game assets\r\n// including images, bitmap fonts, sounds and videos\r\ndefine('services/assets',[\r\n    'jquery',\r\n    'pixi',\r\n    'pubsub',\r\n    'soundjs',\r\n    'webfontloader',\r\n    'services/platform',\r\n    'services/engine',\r\n    'services/settings',\r\n    'data/fonts-array-core',\r\n    'data/fonts-array',\r\n    'data/fonts-css-array-core',\r\n    'data/fonts-css-array',\r\n    'data/clip-textures-game-tablet',\r\n    'data/sounds-core',\r\n    'data/sounds-game',\r\n    'data/config',\r\n], function (\r\n        $,\r\n        PIXI,\r\n        pubsub,\r\n        createjs,\r\n        webfontloader,\r\n        platform,\r\n        engine,\r\n        settings,\r\n        fontsArrayCore,\r\n        fontsArrayGame,\r\n        fontsArrayCssCore,\r\n        fontsArrayCss,\r\n        clipTexturesListTablet,\r\n        soundCoreObject,\r\n        soundGameObject,\r\n        globalConfig) {\r\n    var imagesCache = {};\r\n    var soundCache = {};\r\n    var videosCache = {};\r\n    var clipTextureDataCache = {};\r\n    var highQualitySoundEnabled = false;\r\n\r\n\r\n    // API\r\n    var API = {\r\n        // loads all startup assets\r\n        loadGameAssets: mLoadGame,\r\n        // provides access to sound assets\r\n        sound: function (path) {\r\n            if (!soundCache[path]) {\r\n                console.log('SOUND not cached: ' + path);\r\n                return null;\r\n            }\r\n            return soundCache[path];\r\n        },\r\n        // provides access to image assets\r\n        // if requested image is not found, use an empty GIF instead\r\n        img: function (path) {\r\n            if (imagesCache[path]) {\r\n                return imagesCache[path];\r\n            } else {\r\n                console.log('IMG not found: ' + path);\r\n                return PIXI.Texture.fromImage(\r\n                        'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==');\r\n            }\r\n        },\r\n        // provides access to sprite sheet textures\r\n        getMovieTexturesData: function (path) {\r\n            if (clipTextureDataCache[path]) {\r\n                return clipTextureDataCache[path];\r\n            }\r\n            if (imagesCache[path]) {\r\n                return {\r\n                    frameOffset: 0,\r\n                    frames: 1,\r\n                    speed: undefined,\r\n                    textures: [imagesCache[path]]\r\n                }\r\n            }\r\n        },\r\n        // provides access to video assets\r\n        video: function (path) {\r\n            return videosCache[path];\r\n        },\r\n        // returns CSS value for background property\r\n        // used by HTML elements\r\n        getCssImagePath: function (path) {\r\n            var result = 'url(' + window.assetsPathGame\r\n                    + platform.getImageBaseUrl() + path + '.png)';\r\n            return result;\r\n        },\r\n        isHighQualitySoundEnabled: function () {\r\n            return highQualitySoundEnabled;\r\n        },\r\n        // return whether we have downloaded sound assets\r\n        isSoundAvailable: function () {\r\n            return Object.keys(soundCache).length > 0;\r\n        },\r\n        // check whether we have loaded sounds\r\n        // if not, perform the download\r\n        loadSoundsIfNeeded: function (type, downloadCallback) {\r\n            pubsub.publish('request:showLoader', {\r\n                label: 'loaderDownloading'\r\n            });\r\n            mLoadSounds(type, null, function () {\r\n                pubsub.publish('request:hideLoader');\r\n                downloadCallback();\r\n            });\r\n        },\r\n    };\r\n\r\n    return API;\r\n\r\n    function mLoadGame(progressCallback, downloadCallback) {\r\n        // ref: specify assets weight in config\r\n        var imgWeight, soundWeight, texturesWeight;\r\n        if (settings.get().sound.master.active) {\r\n            imgWeight = 0.55;\r\n            soundWeight = 0.15;\r\n            texturesWeight = 0.3;\r\n        } else {\r\n            imgWeight = .7;\r\n            soundWeight = 0;\r\n            texturesWeight = 0.3;\r\n        }\r\n\r\n        var clipTexturesToLoad;\r\n        clipTexturesToLoad = clipTexturesListTablet;\r\n        var totalProgress = 0;\r\n        mLoadImages(\r\n                function (normDone) {\r\n                    // images progress\r\n                    totalProgress = imgWeight * normDone;\r\n                    progressCallback(totalProgress);\r\n                },\r\n                function () {\r\n                    mLoadFonts(fontsArrayCore, fontsArrayGame, fontsArrayCss,\r\n                            fontsArrayCssCore, function () {\r\n                                mLoadClipTextures(clipTexturesToLoad,\r\n                                        function (normDone) {\r\n                                            totalProgress = imgWeight + texturesWeight * normDone;\r\n                                            progressCallback(totalProgress);\r\n                                        },\r\n                                        function () {\r\n                                            if (settings.get().sound.master.active) {\r\n                                                mLoadSounds(settings.get().sound.background.active ?\r\n                                                        'background' : 'effects',\r\n                                                        function (normDone) {\r\n                                                            // sounds progress\r\n                                                            totalProgress = imgWeight + texturesWeight\r\n                                                                    + soundWeight * normDone;\r\n                                                            progressCallback(totalProgress);\r\n                                                        }, function () {\r\n                                                    downloadCallback();\r\n                                                });\r\n                                            } else {\r\n                                                downloadCallback();\r\n                                            }\r\n                                        });\r\n                            });\r\n                });\r\n    }\r\n\r\n    function mLoadImages(progressCallback, downloadCallback) {\r\n        function load(cb) {\r\n            var loader = new PIXI.loaders.Loader();\r\n            var ks = Object.keys(imgs);\r\n            var current = 0;\r\n            for (var i = 0; i < ks.length; i++) {\r\n                loader.add(ks[i], imgs[ks[i]]);\r\n            }\r\n            loader.on('progress', function (loader, item) {\r\n                setTimeout(function () {\r\n                    imagesCache[item.name] = item.texture;\r\n                    window.imagesCache = imagesCache;\r\n                    if (current === ks.length - 1) {\r\n                        cb();\r\n                    } else {\r\n                        current += 1;\r\n                    }\r\n                }, 100);\r\n                //>>includeStart(\"debug\", pragmas.debug);\r\n                //>>includeEnd(\"debug\");\r\n            });\r\n            loader.load();\r\n        }\r\n        function getPack(pack, getPackDone) {\r\n            function getJSON() {\r\n                $.ajax({\r\n                    xhr: function () {\r\n                        var xhr = new window.XMLHttpRequest();\r\n                        xhr.addEventListener(\"progress\", function (evt) {\r\n                            if (progressCallback && evt.loaded) {\r\n                                progressCallback((totalLoaded + evt.loaded) /\r\n                                        (totalLoaded + pack.size));\r\n                            }\r\n                        }, false);\r\n                        return xhr;\r\n                    },\r\n                    type: 'GET',\r\n                    dataType: 'json',\r\n                    url: pack.path,\r\n                    success: function (data) {\r\n                        json = data;\r\n                        ks = Object.keys(json);\r\n                        for (var i = 0; i < ks.length; i++) {\r\n                            imgs[ks[i]] = json[ks[i]];\r\n                        }\r\n                        totalLoaded += pack.size;\r\n                        getPackDone();\r\n                    },\r\n                    error: function () {\r\n                        pubsub.publish('notify:connectionError');\r\n                    }\r\n                });\r\n            }\r\n            var ks, json, totalLoaded = 0;\r\n            getJSON();\r\n        }\r\n        function getOneCheckNext() {\r\n            getPack(packs[currentPack], function () {\r\n                currentPack += 1;\r\n                if (currentPack < packs.length) {\r\n                    getOneCheckNext();\r\n                } else {\r\n                    load(downloadCallback);\r\n                }\r\n            });\r\n        }\r\n        var packs = [{\r\n                path: window.assetsPathCore + '/img/images-core.json',\r\n                size: globalConfig.IMAGES_CORE_JSON_SIZE_BYTES\r\n            }, {\r\n                path: window.assetsPathGame + '/img/images-game.json',\r\n                size: globalConfig.IMAGES_JSON_SIZE_BYTES\r\n            }];\r\n\r\n        var imgs = {};\r\n        var currentPack = 0;\r\n        getOneCheckNext();\r\n    }\r\n\r\n    function mLoadFonts(fontsArrayCoreBitmap, fontsArrayGameBitmap,\r\n            fontsArrayGameCss, fontsArrayCoreCss, successCallback) {\r\n        function loadBitmap(cb) {\r\n            function pixiLoadCb() {\r\n                var loader = new PIXI.loaders.Loader();\r\n                for (var i = 0; i < arr.length; i++) {\r\n                    loader.add(arr[i], arr[i]);\r\n                }\r\n                loader.once('complete', cb);\r\n                loader.load();\r\n            }\r\n\r\n            if (fontsArrayCoreBitmap.length === 0\r\n                    && fontsArrayGameBitmap.length === 0) {\r\n                cb();\r\n                return;\r\n            }\r\n            var arr = [];\r\n            for (var i = 0; i < fontsArrayCoreBitmap.length; i++) {\r\n                arr[arr.length] = window.assetsPathCore\r\n                        + '/css/' + fontsArrayCoreBitmap[i] + '.fnt';\r\n            }\r\n            for (var i = 0; i < fontsArrayGameBitmap.length; i++) {\r\n                arr[arr.length] = window.assetsPathGame\r\n                        + '/css/' + fontsArrayGameBitmap[i] + '.fnt';\r\n            }\r\n\r\n            //>>includeStart(\"debug\", pragmas.debug);\r\n            console.log('Loading bitmap fonts', arr);\r\n            //>>includeEnd(\"debug\");\r\n\r\n            (function () {\r\n                function getOne() {\r\n                    function success() {\r\n                        current += 1;\r\n                        if (current === ajaxArr.length) {\r\n                            pixiLoadCb();\r\n                        } else {\r\n                            getOne();\r\n                        }\r\n                    }\r\n                    function fail() {\r\n                        pubsub.publish('notify:connectionError');\r\n                    }\r\n                    $.ajax({\r\n                        type: 'GET',\r\n                        url: ajaxArr[current],\r\n                        success: success,\r\n                        error: fail,\r\n                    });\r\n                }\r\n                var ajaxArr = [];\r\n                var current = 0;\r\n                for (var i = 0; i < arr.length; i++) {\r\n                    ajaxArr.push(arr[i]);\r\n                    ajaxArr.push(arr[i].replace('.fnt', '.png'));\r\n                }\r\n                getOne();\r\n            }());\r\n\r\n        }\r\n        function loadCss(cb) {\r\n            var errortout = setTimeout(function () {\r\n                errortout = null;\r\n                pubsub.publish('notify:connectionError');\r\n            }, 10000);\r\n            webfontloader.load({\r\n                classes: false,\r\n                active: function (familyName, fvd) {\r\n                    if (errortout !== null) {\r\n                        clearTimeout(errortout);\r\n                        cb();\r\n                    } \r\n                },\r\n                custom: {\r\n                    families: fontsArrayCoreCss,\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        loadCss(function () {\r\n            loadBitmap(successCallback);\r\n        });\r\n    }\r\n\r\n    //\r\n    function mLoadClipTextures(texturesArray, progressCallback, successCallback) {\r\n        function cacheClipTextures(cb) {\r\n            function cacheOne() {\r\n                var texture = clipTextureDataCache[texturesArray[current].imgPath].textures[0];\r\n                var spr, cvs;\r\n                if (texture && texturesArray[current].cacheToLayer) {\r\n                    spr = new PIXI.Sprite(texture);\r\n                    spr.width = 1;\r\n                    spr.height = 1;\r\n                    spr.wrapper = fakeWrapper;\r\n                    pool.push(spr);\r\n                    cvs = engine.getContainer(texturesArray[current].cacheToLayer);\r\n                    cvs.addChild(spr);\r\n                    spr.cvs = cvs;\r\n                }\r\n                current++;\r\n                if (current < texturesArray.length) {\r\n                    progressCallback(current / texturesArray.length);\r\n                    setTimeout(function () {\r\n                        cacheOne();\r\n                    }, spr ? 250 : 0);\r\n                } else {\r\n                    setTimeout(cb, 500);\r\n//                    setTimeout(function () {\r\n//                        for (var i = 0; i < pool.length; i++) {\r\n//                            pool[i].cvs.removeChild(pool[i]);\r\n//                        }\r\n//                    }, 5000);\r\n                }\r\n            }\r\n            var pool = [];\r\n            var fakeWrapper = {zIndex: 1};\r\n            var current = 0;\r\n            cacheOne();\r\n        }\r\n\r\n        if (texturesArray.length === 0) {\r\n            successCallback();\r\n            return;\r\n        }\r\n        for (var i = 0; i < texturesArray.length; i++) {\r\n            clipTextureDataCache[texturesArray[i].imgPath]\r\n                    = generateTextures(texturesArray[i]);\r\n        }\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n        window.clipTextureDataCache = clipTextureDataCache;\r\n        //>>includeEnd(\"debug\");\r\n\r\n        successCallback();\r\n//        cacheClipTextures(successCallback);\r\n    }\r\n\r\n    function mLoadSounds(type, progressCallback, soundsCallback) {\r\n//        soundsCallback();\r\n//        return;\r\n\r\n        function afterLoad() {\r\n            if (current === keys.length - 1) {\r\n                soundsCallback();\r\n            } else {\r\n                current += 1;\r\n                load();\r\n            }\r\n        }\r\n        function load() {\r\n            function register(url, key, onComplete, onError) {\r\n                createjs.Sound._handleLoadError = onError;\r\n                createjs.Sound._handleLoadComplete = onComplete;\r\n                createjs.Sound.registerSound(url, key);\r\n            }\r\n\r\n            if (soundCache[keys[current]]) {\r\n                afterLoad();\r\n                return;\r\n            }\r\n\r\n            var url = soundDataObject[keys[current]];\r\n\r\n            register(url, keys[current],\r\n                    function (e) {\r\n                        progressCallback && progressCallback(current / keys.length - 1);\r\n                        soundCache[keys[current]] = soundGameObject[qId][keys[current]] ?\r\n                                soundGameObject[qId][keys[current]]\r\n                                : soundCoreObject[qId][keys[current]];\r\n                        soundCache[keys[current]][0] = e.result.duration * 1000;\r\n                        afterLoad();\r\n                    },\r\n                    function (e) {\r\n                        pubsub.publish('notify:connectionError');\r\n                    });\r\n        }\r\n        var format, keys, qId;\r\n        var soundDataObject = {};\r\n\r\n//        if (platform.isMobile() && platform.isIE()) {\r\n//            format = 'm4a';\r\n//        } else {\r\n        if (type === 'background' && !highQualitySoundEnabled) {\r\n            soundCache = {};\r\n//                createjs.Sound.removeAllSounds();\r\n            highQualitySoundEnabled = true;\r\n        }\r\n        if (highQualitySoundEnabled) {\r\n            qId = 'hiq';\r\n        } else {\r\n            qId = 'loq';\r\n        }\r\n        format = 'mp3';\r\n//        }\r\n\r\n        var coreKeys = Object.keys(soundCoreObject[qId]);\r\n        var gameKeys = Object.keys(soundGameObject[qId]);\r\n\r\n        for (var i = 0; i < coreKeys.length; i++) {\r\n            soundDataObject[coreKeys[i]] = window.assetsPathCore\r\n                    + globalConfig.SOUND_BASE_URL + '/' + qId + '/'\r\n                    + coreKeys[i] + '.' + format;\r\n        }\r\n        for (var i = 0; i < gameKeys.length; i++) {\r\n            soundDataObject[gameKeys[i]] = window.assetsPathGame\r\n                    + globalConfig.SOUND_BASE_URL + '/' + qId + '/'\r\n                    + gameKeys[i] + '.' + format;\r\n        }\r\n\r\n        keys = Object.keys(soundDataObject);\r\n\r\n//        createjs.Sound.registerPlugins([createjs.HTMLAudioPlugin]);\r\n//        createjs.Sound.alternateExtensions = ['m4a'];\r\n\r\n        var current = -1;\r\n        afterLoad();\r\n    }\r\n\r\n    function generateTextures(clipData) {\r\n        console.log('generateTextures: ', clipData);\r\n\r\n        var MAX_TEXTURE_SIZE = 4096;\r\n        var bTexture;\r\n        var textures = [];\r\n        var baseTextures = [];\r\n        var frameOffset = clipData.frameOffset;\r\n        var startOffsetX, startOffsetY;\r\n        var stepsInPart;\r\n        var srcTexture = API.img(clipData.imgPath).baseTexture;\r\n        var spriteW = clipData.spriteW || (srcTexture.width -\r\n                (clipData.steps - 1) * frameOffset) / clipData.steps;\r\n        var spriteH = clipData.spriteH || srcTexture.height;\r\n        var cols = clipData.cols || clipData.steps;\r\n        if (srcTexture.width > MAX_TEXTURE_SIZE) {\r\n            console.log('ERROR: texture max size exceeded');\r\n//            var data = generateSplitTextures(srcTexture, clipData.steps, frameOffset);\r\n//            baseTextures = data.parts;\r\n//            stepsInPart = data.stepsInPart;\r\n        } else {\r\n            baseTextures.push(srcTexture);\r\n            stepsInPart = clipData.steps;\r\n        }\r\n\r\n        for (var k = 0; k < baseTextures.length; k++) {\r\n            bTexture = baseTextures[k];\r\n            for (var i = 0;\r\n                    i < stepsInPart;\r\n                    i++) {\r\n                if (k === baseTextures.length - 1\r\n                        && (i + (baseTextures.length - 1)\r\n                                * stepsInPart) > clipData.steps) {\r\n                    continue;\r\n                }\r\n                startOffsetX = ((i % cols) * spriteW) + ((i % cols) * frameOffset);\r\n                var rowIndex = Math.floor(i / cols);\r\n                startOffsetY = rowIndex * spriteH + (rowIndex * frameOffset);\r\n\r\n//                console.log('rowIndex', rowIndex, 'frameOffset', frameOffset)\r\n//                console.log('bTexture', bTexture, 'startOffsetX', startOffsetX, 'startOffsetY', startOffsetY, 'spriteW', spriteW, 'spriteH', spriteH);\r\n\r\n                var txt = new PIXI.Texture(bTexture, new PIXI.Rectangle(\r\n                        startOffsetX, startOffsetY, spriteW, spriteH));\r\n                textures.push(txt);\r\n            }\r\n        }\r\n\r\n        if (baseTextures.length > 1) {\r\n            API.img(clipData.imgPath).destroy(true);\r\n        }\r\n\r\n        return{\r\n            textures: textures,\r\n            frameOffset: frameOffset,\r\n            frames: clipData.steps,\r\n            speed: clipData.animationSpeed\r\n        };\r\n    }\r\n\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/assets.js"),
eval("define('components/Sprite',[\r\n    'jquery',\r\n    'pixi',\r\n    'components/Element',\r\n    'services/assets'],\r\n        function (\r\n                $, PIXI, Element, assets) {\r\n\r\n            // basic image\r\n            return function create(options) {\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'Sprite';\r\n\r\n                if (options.shadow) {\r\n                    var shadowOptions = $.extend({}, options);\r\n                    var spriteOptions = $.extend({}, options);\r\n                    spriteOptions.shadow = null;\r\n                    var spriteEl = create(spriteOptions);\r\n                    shadowOptions.imgPath = options.shadow.imgPath;\r\n                    shadowOptions.left += options.shadow.offsetX < 0\r\n                            ? options.shadow.offsetX : 0;\r\n                    shadowOptions.top += options.shadow.offsetY < 0\r\n                            ? options.shadow.offsetY : 0;\r\n                    shadowOptions.width += Math.abs(options.shadow.offsetX);\r\n                    shadowOptions.height += Math.abs(options.shadow.offsetY);\r\n                    shadowOptions.opacity = options.shadow.opacity || 1;\r\n                    shadowOptions.maxOpacity = shadowOptions.opacity;\r\n\r\n                    shadowOptions.zIndex = options.zIndex - 0.01;\r\n                    shadowOptions.shadow = null;\r\n                    var shadowEl = create(shadowOptions);\r\n                    spriteEl.wrapper = self;\r\n                    shadowEl.wrapper = self;\r\n                    self.pixiEl = [spriteEl, shadowEl];\r\n\r\n                    self.set = function (setOptions) {\r\n                        spriteEl.set(setOptions);\r\n                        var shadowOptions = $.extend({}, setOptions);\r\n                        if (shadowOptions.width === undefined) {\r\n                            shadowOptions.width = options.width;\r\n                        }\r\n                        if (shadowOptions.height === undefined) {\r\n                            shadowOptions.height = options.height;\r\n                        }\r\n                        if (shadowOptions.width !== 0 && shadowOptions.height !== 0) {\r\n                            shadowOptions.left && (shadowOptions.left += options.shadow.offsetX < 0\r\n                                    ? options.shadow.offsetX : 0);\r\n                            shadowOptions.top && (shadowOptions.top += options.shadow.offsetY < 0\r\n                                    ? options.shadow.offsetY : 0);\r\n                            shadowOptions.width += Math.abs(options.shadow.offsetX);\r\n                            shadowOptions.height += Math.abs(options.shadow.offsetY);\r\n                        }\r\n                        shadowEl.set(shadowOptions);\r\n                    };\r\n\r\n                } else {\r\n                    self.imgPath = options.imgPath;\r\n                    self.click = options.click;\r\n                    self.mouseDown = options.mouseDown;\r\n                    self.mouseUp = options.mouseUp;\r\n                    self.mouseOver = options.mouseOver;\r\n                    self.mouseOut = options.mouseOut;\r\n                    self.mouseMove = options.mouseMove;\r\n                    self.mask = options.mask;\r\n\r\n                    // grab texture\r\n                    var texture = assets.img(self.imgPath);\r\n\r\n                    // compute height or width if not supplied\r\n                    if (self.height === undefined\r\n                            || self.width === undefined) {\r\n                        var ratio = texture.width / texture.height;\r\n                        if (self.height !== undefined) {\r\n                            self.width = self.height * ratio;\r\n                        } else if (self.width !== undefined) {\r\n                            self.height = self.width / ratio;\r\n                        }\r\n                    }\r\n\r\n                    var el = new PIXI.Sprite(texture);\r\n\r\n                    el.wrapper = self;\r\n                    self.pixiEl = el;\r\n\r\n                    self.setImgPath = function (imgPath) {\r\n                        if (self.imgPath !== imgPath) {\r\n                            self.imgPath = imgPath;\r\n                            el.texture = assets.img(self.imgPath);\r\n                            self.resize();\r\n                        }\r\n                    };\r\n\r\n                    // attach event handlers\r\n                    if (self.click) {\r\n                        el.interactive = true;\r\n                        el.click = el.tap = function (e) {\r\n                            self.click(e);\r\n                        };\r\n                    }\r\n                    if (self.mouseOver) {\r\n                        el.interactive = true;\r\n                        el.mouseover = self.mouseOver;\r\n                    }\r\n                    if (self.mouseOut) {\r\n                        el.interactive = true;\r\n                        el.mouseout = self.mouseOut;\r\n                    }\r\n                    if (self.mouseDown) {\r\n                        el.interactive = true;\r\n                        el.mousedown = self.mouseDown;\r\n                    }\r\n                    if (self.mouseUp) {\r\n                        el.interactive = true;\r\n                        el.mouseup = self.mouseUp;\r\n                    }\r\n                    if (self.mouseMove) {\r\n                        el.interactive = true;\r\n                        el.mousemove = self.mouseMove;\r\n                    }\r\n                    el.touchstart = el.mousedown;\r\n                    el.mouseupoutside = el.mouseup;\r\n                    el.touchend = el.mouseup;\r\n                    el.touchendoutside = el.mouseup;\r\n                    el.touchmove = el.mousemove;\r\n                }\r\n\r\n                self.resize();\r\n\r\n                return self;\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/Sprite.js"),eval("define('components/MovieClip',[\r\n    'pixi', 'services/assets'\r\n], function (PIXI, assets) {\r\n\r\n    // basic sprite sheet animation\r\n    return function create(wrapper) {\r\n        var data = assets.getMovieTexturesData(wrapper.imgPath);\r\n        var mc = new PIXI.extras.MovieClip(data.textures);\r\n        mc.frameOffset = data.frameOffset;\r\n        mc.animationSpeed = data.speed;\r\n        return mc;\r\n    };\r\n\r\n\r\n});\r\n\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/MovieClip.js"),eval("define('components/SpriteSheetAnimation',[\r\n    'pixi',\r\n    'components/Element',\r\n    'components/MovieClip',\r\n    'data/config',\r\n    'services/assets',\r\n], function (\r\n        PIXI, Element, MovieClip, config, assets) {\r\n\r\n    // basic sprite sheet animation\r\n    return function create(options) {\r\n\r\n        if (assets.img(options.imgPath) === null) {\r\n            return null;\r\n        }\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'SpriteSheetAnimation';\r\n        // sprite sheet path\r\n        self.imgPath = options.imgPath;\r\n        // number of frames\r\n        self.steps = options.steps || \r\n                assets.getMovieTexturesData(options.imgPath).frames;\r\n        // specifies whether the animation should run back and forth continually\r\n        self.reverse = options.reverse;\r\n        // animations container\r\n        self.animations = [];\r\n        // mask\r\n        self.mask = options.mask;\r\n\r\n        // current sprite sheet reading direction\r\n        self.direction = 'right';\r\n\r\n        var el = MovieClip(self);\r\n\r\n        // offset between separate frames in image\r\n        self.frameOffset = el.frameOffset;\r\n        // animation speed\r\n        self.speed = options.speed || el.animationSpeed || config.DEFAULT_ANIM_SPEED;\r\n\r\n        self.spriteIndex = null;\r\n\r\n        el.wrapper = self;\r\n        self.pixiEl = el;\r\n\r\n        // update animations callback\r\n        self.update = function (delta) {\r\n            var length = self.animations.length;\r\n            for (var i = 0; i < length; i++) {\r\n                if (self.animations[i].update(delta)) {\r\n                    self.render();\r\n                } else {\r\n                    self.animations.splice(i, 1);\r\n                }\r\n            }\r\n        };\r\n\r\n        // start animation\r\n        self.animate = function (options) {\r\n            options = options || {};\r\n            if (options.cycles) {\r\n                options.passedCycles = 0;\r\n            }\r\n            self.spriteIndex = options.spriteIndex || 0;\r\n            el.gotoAndStop(self.spriteIndex);\r\n            self.spriteChangeTreshold = 0;\r\n            self.animations = [{\r\n                    update: function (delta) {\r\n                        return updateAnim(delta, options);\r\n                    }\r\n                }];\r\n        };\r\n        // stop animation\r\n        self.stopAnimation = function () {\r\n            self.animations = [];\r\n        };\r\n\r\n        self.reset = function () {\r\n            self.spriteIndex = 0;\r\n            el.gotoAndStop(self.spriteIndex);\r\n        };\r\n\r\n        self.goToFrame = function (index) {\r\n            self.spriteIndex = index;\r\n            el.gotoAndStop(self.spriteIndex);\r\n        };\r\n\r\n        // hide & fadeOut overridden\r\n        // stop animation, then hide\r\n        self.superHide = self.hide.bind(self);\r\n        self.hide = function () {\r\n            self.stopAnimation();\r\n            self.superHide.apply(null, arguments);\r\n        };\r\n\r\n        self.resize();\r\n\r\n        return self;\r\n\r\n\r\n        // animation update handler\r\n        function updateAnim(delta, options) {\r\n            var spriteIndexDiff;\r\n            self.spriteChangeTreshold += delta * self.speed * config.ANIM_SPEED_MODIFIER;\r\n            if (self.spriteChangeTreshold >= 1) {\r\n                spriteIndexDiff = Math.floor(self.spriteChangeTreshold);\r\n                self.spriteChangeTreshold = self.spriteChangeTreshold - spriteIndexDiff;\r\n                if (self.direction === 'left') {\r\n                    spriteIndexDiff = -spriteIndexDiff;\r\n                }\r\n                self.spriteIndex += spriteIndexDiff;\r\n                if (options.frameCallback) {\r\n                    options.frameCallback(self.spriteIndex);\r\n                }\r\n                if (self.spriteIndex > self.steps - 1 || self.spriteIndex < 0) {\r\n                    if (options.cycles && self.spriteIndex > self.steps - 1) {\r\n                        options.passedCycles += 1;\r\n                        if (options.passedCycles === options.cycles) {\r\n                            self.spriteIndex = self.steps - 1;\r\n                            el.gotoAndStop(self.spriteIndex);\r\n                            if (options.callback) {\r\n                                options.callback();\r\n                                options.callback = null;\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    if (self.reverse) {\r\n                        if (self.direction === 'right') {\r\n                            self.direction = 'left';\r\n                            self.spriteIndex = self.steps - (self.spriteIndex - self.steps) - 1;\r\n                        } else {\r\n                            self.direction = 'right';\r\n                            self.spriteIndex = Math.abs(self.spriteIndex);\r\n                        }\r\n                    } else {\r\n                        self.spriteIndex = self.spriteIndex - self.steps;\r\n                    }\r\n                    if (options.cycleCallback) {\r\n                        options.cycleCallback();\r\n                    }\r\n                }\r\n                el.gotoAndStop(self.spriteIndex);\r\n            }\r\n            return true;\r\n        }\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/SpriteSheetAnimation.js"),eval("define('components/DomRectangle',['jquery',\r\n    'components/Element',\r\n    'services/assets'\r\n], function ($, Element, assets) {\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n        var $el, $innerEl;\r\n\r\n        self.name = options.name || 'DomRectangle';\r\n        self.color = options.color;\r\n        self.borderRadius = options.borderRadius || 0;\r\n        self.border = options.border;\r\n        self.borderLeft = options.borderLeft;\r\n        self.borderTop = options.borderTop;\r\n        self.borderRight = options.borderRight;\r\n        self.borderBottom = options.borderBottom;\r\n        self.zIndex = options.zIndex || 304;\r\n        self.marginPx = options.marginPx;\r\n\r\n        if (self.marginPx) {\r\n            self.top -= self.marginPx;\r\n            self.left -= self.marginPx;\r\n            $el = $('<div class=\"dom-rectangle\"><div></div></div>');\r\n            $innerEl = $el.find('div');\r\n            if (self.marginPx) {\r\n                $innerEl.css({\r\n                    'background-color': self.color,\r\n                    width: 'calc(100%-' + (2 * self.marginPx) + 'px)',\r\n                    height: self.height,\r\n                    margin: self.marginPx + 'px',\r\n                    border: self.border,\r\n                    'border-left': self.borderLeft,\r\n                    'border-right': self.borderRight,\r\n                    'border-top': self.borderTop,\r\n                    'border-bottom': self.borderBottom,\r\n                    'border-radius': self.borderRadius + 'px',\r\n                    '-webkit-border-radius': self.borderRadius + 'px',\r\n                    'box-sizing': 'border-box',\r\n                });\r\n                $el.css({\r\n                    width: self.width + self.marginPx * 2,\r\n                    height: self.height + self.marginPx * 2,\r\n                    'z-index': self.zIndex,\r\n                });\r\n            }\r\n        } else {\r\n            $el = $('<div class=\"dom-rectangle\"></div>');\r\n            $el.css({\r\n                'background-color': self.color,\r\n                width: self.width,\r\n                height: self.height,\r\n                border: self.border,\r\n                'border-left': self.borderLeft,\r\n                'border-right': self.borderRight,\r\n                'border-top': self.borderTop,\r\n                'border-bottom': self.borderBottom,\r\n                'border-radius': self.borderRadius + 'px',\r\n                '-webkit-border-radius': self.borderRadius + 'px',\r\n            });\r\n        }\r\n\r\n        $el.css({\r\n            'z-index': self.zIndex,\r\n            'box-sizing': 'border-box',\r\n            display: 'none'\r\n        });\r\n\r\n        if (options.mouseDown) {\r\n            self.mouseDown = options.mouseDown;\r\n            self.interactive = true;\r\n            $el.on('mousedown touchstart', self.mouseDown);\r\n        }\r\n        if (options.mouseUp) {\r\n            self.mouseUp = options.mouseUp;\r\n            self.interactive = true;\r\n            $el.on('mouseup touchend', self.mouseUp);\r\n        }\r\n\r\n        if (options.click) {\r\n            self.click = options.click;\r\n            self.interactive = true;\r\n            $el.on('click', self.click);\r\n        }\r\n\r\n        var superResize = self.resize.bind(self);\r\n        self.resize = function () {\r\n            superResize.apply(null, arguments);\r\n            if ($innerEl) {\r\n                $el.css({\r\n                    width: self.width + self.marginPx * 2,\r\n                    height: self.height + self.marginPx * 2,\r\n                });\r\n            }\r\n        };\r\n       \r\n        $el.wrapper = self;\r\n        self.jQueryEl = $el;\r\n\r\n        self.appendHTML();\r\n        self.resize();\r\n\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/DomRectangle.js"),eval("define('components/TextBitmap',[\r\n    'pubsub', 'data/config',\r\n    'components/Element', 'pixi', 'services/dimensions', 'services/engine',\r\n    'services/i18n'\r\n], function (pubsub, config, Element, PIXI, dimensions, engine, i18n) {\r\n    // Bitmap text\r\n    return function create(options) {\r\n\r\n        options.style = options.style || {};\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'BitmapText';\r\n        // font props\r\n        self.fontSize = options.fontSize || 20;\r\n        self.text = options.text;\r\n        self.lineHeight = options.style.lineHeight || options.lineHeight || undefined;\r\n        self.textAlign = options.textAlign || 'left';\r\n        // specify the font size that should always be used for bitmap font\r\n        // resolution selection regardless of actual size\r\n        self.forceSelectFontBySize = options.forceSelectFontBySize || null;\r\n        // specify whether bitmap font kerning should be applied\r\n        self.applyKerning = options.applyKerning !== undefined ? options.applyKerning : true;\r\n        self.style = options.style;\r\n        self.font = options.style.font;\r\n        self.originModifier = options.style.originModifier || 1;\r\n        self.maxWidth = options.maxWidth;\r\n        self.formatter = options.formatter;\r\n        self.mask = options.mask;\r\n        self.click = options.click;\r\n\r\n        if (options.scaleX) {\r\n            self.scaleX = options.scaleX;\r\n        } else if (options.style.scaleX) {\r\n            self.scaleX = options.style.scaleX;\r\n        }\r\n        if (options.scaleY) {\r\n            self.scaleY = options.scaleY;\r\n        } else if (options.style.scaleY) {\r\n            self.scaleY = options.style.scaleY;\r\n        }\r\n        if (options.rotate) {\r\n            self.rotate = options.rotate;\r\n        } else if (options.style.rotate) {\r\n            self.rotate = options.style.rotate;\r\n        }\r\n        if (options.opacity) {\r\n            self.opacity = options.opacity;\r\n        } else if (options.style.opacity) {\r\n            self.opacity = options.style.opacity;\r\n        }\r\n\r\n        var el = new PIXI.extras.BitmapText('', {\r\n            font: self.fontSize + 'px ' + getAppropriateFontName(),\r\n            align: self.textAlign,\r\n            lineHeight: self.lineHeight,\r\n            maxWidth: 20\r\n        });\r\n\r\n        if (self.click) {\r\n            el.interactive = true;\r\n            el.click = el.tap = self.click;\r\n        }\r\n\r\n        el.applyKerning = self.applyKerning;\r\n\r\n        el.wrapper = self;\r\n        self.pixiEl = el;\r\n\r\n        // store width on create for later usage in origin X adjustment\r\n        // because of weird side effects of reading the el.width property\r\n        // inside resize fn\r\n        var width = el.width;\r\n        var lastData = {\r\n            size: null,\r\n            text: null\r\n        };\r\n\r\n\r\n\r\n        // override resize because default originX setting using anchor property\r\n        // is not working for BitmapText\r\n        // and also to update bitmap font resolution\r\n        self.resize = function () {\r\n            options = options || {};\r\n            if (self.visible || options.forceResize) {\r\n                // update scale\r\n                el.scale = new PIXI.Point(1, 1);\r\n                if (self.scaleX) {\r\n                    el.scale.x *= self.scaleX;\r\n                }\r\n                if (self.scaleY) {\r\n                    el.scale.y *= self.scaleY;\r\n                }\r\n                if (self.opacity) {\r\n                    el.alpha = self.opacity;\r\n                }\r\n                if (self.rotate) {\r\n                    el.rotation = 2 * Math.PI * (self.rotate / 360);\r\n                }\r\n                if (self.lineHeight) {\r\n                    el.lineHeight = self.lineHeight;\r\n                }\r\n                // update font\r\n                if (lastData.text !== el.text\r\n                        || lastData.font !== self.font\r\n                        || lastData.size !== self.fontSize\r\n                        || lastData.lineHeight !== self.lineHeight\r\n                        || lastData.maxWidth !== self.maxWidth\r\n                        || dimensions.canvasScaleX !== lastData.canvasScaleX\r\n                        || dimensions.canvasScaleY !== lastData.canvasScaleY) {\r\n                    lastData.font = self.font;\r\n                    lastData.size = self.fontSize;\r\n                    lastData.text = el.text;\r\n                    lastData.canvasScaleX = dimensions.canvasScaleX;\r\n                    lastData.canvasScaleY = dimensions.canvasScaleY;\r\n                    lastData.lineHeight = dimensions.lineHeight;\r\n                    lastData.maxWidth = dimensions.maxWidth;\r\n                    el._font.size = self.fontSize;\r\n                    if (self.isReelsAreaElement) {\r\n                        el._font.size *= config.REELS_AREA_SCALE;\r\n                    }\r\n                    el._font.name = getAppropriateFontName();\r\n                    el.updateText();\r\n                    width = el.textWidth;\r\n                }\r\n                if (!width) {\r\n                    width = el.textWidth;\r\n                }\r\n\r\n                // update position\r\n                // update originX\r\n                if (self.originX !== 'left') {\r\n                    if (self.originX === 'center') {\r\n                        el.pivot.x = (el.textWidth ? el.textWidth : el.width) / 2;\r\n                    } else if (self.originX === 'right') {\r\n                        el.pivot.x = (el.textWidth ? el.textWidth : el.width);\r\n                    }\r\n                }\r\n                if (self.originY !== 'top') {\r\n                    if (self.originY === 'center') {\r\n                        el.pivot.y = (el.textHeight ? el.textHeight : el.height) / 2;\r\n                    } else if (self.originX === 'bottom') {\r\n                        el.pivot.y = (el.textHeight ? el.textHeight : el.height);\r\n                    }\r\n                }\r\n                var off = getParentOffset(self);\r\n                var x = self.left;\r\n                var y = self.top;\r\n                x += off.left;\r\n                y += off.top;\r\n\r\n                if (self.isReelsAreaElement) {\r\n                    x -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_WIDTH / 2) - x);\r\n                    y -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_HEIGHT / 2) - y);\r\n                    x += config.REELS_AREA_OFFSET_LEFT;\r\n                    y += config.REELS_AREA_OFFSET_TOP;\r\n                }\r\n\r\n                if (self.centerVertical) {\r\n                    if (dimensions.moveTop) {\r\n                        y += (dimensions.moveTop / dimensions.canvasScaleY);\r\n                    } else {\r\n                        y -= (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY\r\n                                - dimensions.topLevelWrappersOffsetBottom / dimensions.canvasScaleY);\r\n                    }\r\n                }\r\n\r\n                x += (dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX);\r\n                y += (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY);\r\n\r\n                el.x = x;\r\n                el.y = y;\r\n\r\n                if (self.mask) {\r\n                    if (!el.mask) {\r\n                        el.mask = new PIXI.Graphics();\r\n                        el.mask.beginFill();\r\n                        var height = self.mask.height;\r\n                        var width = self.mask.width;\r\n                        if (self.isReelsAreaElement) {\r\n                            width *= config.REELS_AREA_SCALE;\r\n                            height *= config.REELS_AREA_SCALE;\r\n                        }\r\n                        el.mask.drawRect(\r\n                                self.mask.left,\r\n                                self.mask.top,\r\n                                width, height);\r\n                        el.mask.endFill();\r\n                        el.mask.wrapper = self;\r\n                        engine.getContainer(self.canvasLayer).addChild(el.mask);\r\n                    }\r\n\r\n                    el.mask.x = off.left;\r\n                    el.mask.y = off.top;\r\n\r\n                    if (self.isReelsAreaElement) {\r\n                        el.mask.x -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_WIDTH / 2) - (el.mask.x + self.mask.left));\r\n                        el.mask.y -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_HEIGHT / 2) - (el.mask.y + self.mask.top));\r\n                        el.mask.x += config.REELS_AREA_OFFSET_LEFT;\r\n                        el.mask.y += config.REELS_AREA_OFFSET_TOP;\r\n                    }\r\n\r\n                    el.mask.x += (dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX);\r\n                    el.mask.y += (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY);\r\n                }\r\n\r\n                self.render();\r\n            }\r\n        };\r\n        // set text value\r\n        self.setText = function (txt) {\r\n            if (txt === undefined) {\r\n                txt = '';\r\n            }\r\n            var localized = txt;\r\n            if (txt !== '') {\r\n                localized = i18n.localize(txt);\r\n                if (self.formatter) {\r\n                    localized = self.formatter(localized);\r\n                }\r\n            }\r\n            self.text = txt;\r\n            el.text = localized;\r\n            width = null;\r\n            setTimeout(self.resize, 0);\r\n        };\r\n\r\n        self.setStyle = function (style) {\r\n            self.style = style;\r\n            self.font = style.font;\r\n            self.originModifier = style.originModifier || 1;\r\n            if (style.scaleX) {\r\n                self.scaleX = style.scaleX;\r\n            }\r\n            if (style.scaleY) {\r\n                self.scaleY = style.scaleY;\r\n            }\r\n            if (style.rotate) {\r\n                self.rotate = style.rotate;\r\n            }\r\n            if (style.lineHeight) {\r\n                self.lineHeight = style.lineHeight;\r\n            }\r\n            if (style.opacity) {\r\n                self.opacity = style.opacity;\r\n            }\r\n            self.resize();\r\n        };\r\n\r\n        self.setText(self.text);\r\n        self.resize();\r\n\r\n        pubsub.subscribe('request:updateLocalizedLabels', function () {\r\n            self.setText(self.text);\r\n        });\r\n        if (self.formatter) {\r\n//            pubsub.subscribe('request:updateViewsWithModels', function () {\r\n//                self.setText(self.text);\r\n//            });\r\n        }\r\n\r\n        return self;\r\n\r\n        // pick good looking bitmap font resolution based on current font size\r\n        function getAppropriateFontName() {\r\n            var testFs = self.forceSelectFontBySize\r\n                    ? self.forceSelectFontBySize\r\n                    : (dimensions.canvasScaleY * self.fontSize);\r\n            testFs += 5;\r\n            var steps = [24, 36, 48, 72];\r\n            var i = 0;\r\n            while (testFs > steps[i] && i < steps.length - 1) {\r\n                i++;\r\n            }\r\n            var fontName;\r\n            if (PIXI.extras.BitmapText.fonts[self.font + '-' + steps[i]]) {\r\n                fontName = self.font + '-' + steps[i];\r\n            } else {\r\n                var k = 1;\r\n                while (!fontName) {\r\n                    if (steps[i - k]\r\n                            && PIXI.extras.BitmapText.fonts[self.font + '-' + steps[i - k]]) {\r\n                        // try smaller font\r\n                        fontName = self.font + '-' + steps[i - k];\r\n                    } else if (steps[i + k]\r\n                            && PIXI.extras.BitmapText.fonts[self.font + '-' + steps[i + k]]) {\r\n                        // try bigger font\r\n                        fontName = self.font + '-' + steps[i + k];\r\n                    } else {\r\n                        k++;\r\n                    }\r\n                }\r\n            }\r\n//            console.log('testFs', testFs, 'fontName', fontName, 'i', i, 'k', k);\r\n            return fontName;\r\n        }\r\n        function getParentOffset(el) {\r\n            var off = {\r\n                left: 0,\r\n                top: 0\r\n            };\r\n            while (el.parent) {\r\n                off.left += el.parent.left;\r\n                off.top += el.parent.top;\r\n                el = el.parent;\r\n            }\r\n            return off;\r\n        }\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/TextBitmap.js"),eval("define('components/TextPixi',[\r\n    'pubsub', 'services/i18n', 'data/config',\r\n    'components/Element', 'pixi', 'services/dimensions'], function (\r\n        pubsub, i18n, config, Element, PIXI, dimensions) {\r\n    return function create(options) {\r\n\r\n        options.style = options.style || {};\r\n\r\n        // basic text element\r\n        var self = Element(options);\r\n        self.name = options.name || 'Text';\r\n        // current text value\r\n        self.text = options.text || '';\r\n        self.fontSize = options.fontSize || 20;\r\n        self.fontWeight = options.fontWeight || 'normal';\r\n        self.textAlign = options.textAlign || 'left';\r\n        self.fontFamily = options.font || options.style.font || 'Arial';\r\n        self.color = options.color || options.style.color || 'black';\r\n        self.shadow = options.shadow || options.style.shadow;\r\n        self.strokeColor = options.strokeColor || options.style.strokeColor || 'black';\r\n        self.strokeThickness = options.strokeThickness || options.style.strokeThickness || 0;\r\n        self.lineHeight = options.lineHeight || options.style.lineHeight;\r\n        self.baselineAdjustment = options.baselineAdjustment || options.style.baselineAdjustment;\r\n        self.wordWrap = options.wordWrap || options.style.wordWrap;\r\n        self.formatter = options.formatter;\r\n        self.click = options.click;\r\n\r\n        if (options.style.scaleX) {\r\n            self.scaleX = options.style.scaleX;\r\n        }\r\n        if (options.style.scaleY) {\r\n            self.scaleY = options.style.scaleY;\r\n        }\r\n        if (options.style.rotate) {\r\n            self.rotate = options.style.rotate;\r\n        }\r\n\r\n        var font = self.fontWeight + ' ' + self.fontSize + 'px ' + self.fontFamily;\r\n\r\n        var style = {\r\n            font: font,\r\n            lineHeight: self.lineHeight,\r\n            align: self.textAlign,\r\n            stroke: self.strokeColor,\r\n            strokeThickness: self.strokeThickness,\r\n            fill: self.color,\r\n            baselineAdjustment: self.baselineAdjustment\r\n        };\r\n\r\n        if (self.shadow) {\r\n            style.dropShadow = true;\r\n            style.dropShadowColor = self.shadow.color;\r\n            if (self.shadow.offsetX) {\r\n                style.dropShadowDistance = self.shadow.offsetX;\r\n            } else if (self.shadow.distance) {\r\n                style.dropShadowDistance = self.shadow.distance;\r\n                style.dropShadowAngle = ((180 + (360 - self.shadow.angle)) / 360) * (2 * Math.PI);\r\n            }\r\n        }\r\n        if (self.wordWrap) {\r\n            style.wordWrap = true;\r\n            style.wordWrapWidth = self.wordWrap;\r\n        }\r\n\r\n        var el = new PIXI.Text(self.text, style);\r\n\r\n        if (self.click) {\r\n            el.interactive = true;\r\n            el.click = el.tap = self.click;\r\n        }\r\n\r\n        el.wrapper = self;\r\n        self.pixiEl = el;\r\n\r\n        var lastData = {\r\n            size: null,\r\n            text: null,\r\n            lineHeight: null,\r\n        };\r\n\r\n        // override default resize function\r\n        self.resize = function () {\r\n            // update position\r\n            var off = getParentOffset(self);\r\n            el.x = off.left + self.left;\r\n            el.y = off.top + self.top;\r\n\r\n            if (self.isReelsAreaElement) {\r\n                el.x -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_WIDTH / 2) - el.x);\r\n                el.y -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_HEIGHT / 2) - el.y);\r\n                el.x += config.REELS_AREA_OFFSET_LEFT;\r\n                el.y += config.REELS_AREA_OFFSET_TOP;\r\n            }\r\n            if (self.centerVertical) {\r\n                if (dimensions.moveTop) {\r\n                    el.y += (dimensions.moveTop / dimensions.canvasScaleY);\r\n                } else {\r\n                    el.y -= (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY\r\n                            - dimensions.topLevelWrappersOffsetBottom / dimensions.canvasScaleY);\r\n                }\r\n            }\r\n\r\n\r\n            el.x += (dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX);\r\n            el.y += (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY);\r\n\r\n            // update size and scale\r\n//            el.scale = new PIXI.Point(1, 1);\r\n\r\n//            el.scale.x *= .5;\r\n//            el.scale.y *= .5;\r\n//\r\n//            if (self.scaleX) {\r\n//                el.scale.x *= self.scaleX;\r\n//            }\r\n//            if (self.scaleY) {\r\n//                el.scale.y *= self.scaleY;\r\n//            }\r\n\r\n            var anchorX = 0;\r\n            var anchorY = 0;\r\n\r\n            // update originX\r\n            if (self.originX !== 'left') {\r\n                if (self.originX === 'center') {\r\n                    anchorX = .5;\r\n                } else if (self.originX === 'right') {\r\n                    anchorX = 1;\r\n                }\r\n            }\r\n            if (self.originY !== 'top') {\r\n                if (self.originY === 'center') {\r\n                    anchorY = .5;\r\n                } else if (self.originY === 'right') {\r\n                    anchorY = 1;\r\n                }\r\n            }\r\n\r\n            el.anchor = new PIXI.Point(anchorX, anchorY);\r\n\r\n            // update opacity\r\n            if (self.opacity) {\r\n                el.alpha = self.opacity;\r\n            }\r\n\r\n            //update rotation\r\n            if (self.rotate) {\r\n                el.rotation = 2 * Math.PI * (self.rotate / 360);\r\n            }\r\n\r\n            // update text & font\r\n            if (lastData.text !== el.text\r\n                    || lastData.size !== self.fontSize\r\n                    || lastData.lineHeight !== self.lineHeight\r\n                    || lastData.wordWrap !== self.wordWrap\r\n                    || lastData.baselineAdjustment !== self.baselineAdjustment\r\n                    || lastData.color !== self.color\r\n                    || lastData.rotate !== self.rotate\r\n                    ) {\r\n                lastData.size = self.fontSize;\r\n                lastData.text = el.text;\r\n                lastData.lineHeight = self.lineHeight;\r\n                lastData.color = self.color;\r\n                lastData.wordWrap = self.wordWrap;\r\n                lastData.baselineAdjustment = self.baselineAdjustment;\r\n                lastData.rotate = self.rotate;\r\n\r\n\r\n                var fs = self.fontSize;\r\n                if (self.isReelsAreaElement) {\r\n                    el.fontSize *= config.REELS_AREA_SCALE;\r\n                }\r\n                el.style.font = self.fontWeight + ' '\r\n                        + fs + 'px '\r\n                        + self.fontFamily;\r\n                if (self.lineHeight) {\r\n                    el.style.lineHeight = self.lineHeight;\r\n                }\r\n                el.updateText();\r\n            }\r\n\r\n            self.render();\r\n        };\r\n\r\n        // set text value\r\n        self.setText = function (txt) {\r\n            if (txt === undefined) {\r\n                txt = '';\r\n            }\r\n            var localized = txt;\r\n            if (txt !== '') {\r\n                localized = i18n.localize(txt);\r\n                if (self.formatter) {\r\n                    localized = self.formatter(localized);\r\n                }\r\n            }\r\n            self.text = txt;\r\n            el.text = localized;\r\n            self.resize();\r\n        };\r\n\r\n        self.superSet = self.set.bind(self);\r\n        self.set = function (options) {\r\n            self.superSet(options);\r\n            if (options.style) {\r\n                if (options.style.color) {\r\n                    self.color = options.style.color;\r\n                    el.style.fill = options.style.color;\r\n                }\r\n                if (options.style.rotate) {\r\n                    self.rotate = options.style.rotate;\r\n                    el.rotation = 2 * Math.PI * (self.rotate / 360);\r\n                }\r\n            }\r\n            if (options.wordWrap) {\r\n                self.wordWrap = options.wordWrap;\r\n                el.style.wordWrap = true;\r\n                el.style.wordWrapWidth = self.wordWrap;\r\n            }\r\n            options.baselineAdjustment && (self.baselineAdjustment = options.baselineAdjustment);\r\n            self.resize();\r\n        };\r\n        self.setText(self.text);\r\n        self.resize();\r\n\r\n        pubsub.subscribe('request:updateLocalizedLabels', function () {\r\n            self.setText(self.text);\r\n        });\r\n\r\n        return self;\r\n\r\n        function getParentOffset(el) {\r\n            var off = {\r\n                left: 0,\r\n                top: 0\r\n            };\r\n            while (el.parent) {\r\n                off.left += el.parent.left;\r\n                off.top += el.parent.top;\r\n                el = el.parent;\r\n            }\r\n            return off;\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/TextPixi.js"),
eval("define('components/TextCss',['jquery', 'pubsub', 'components/Element', 'services/dimensions', 'services/i18n'],\r\n        function ($, pubsub, Element, dimensions, i18n) {\r\n            return function create(options) {\r\n\r\n                // basic text element\r\n                var self = Element(options);\r\n\r\n                var lastUpdate = {};\r\n\r\n                self.name = options.name || 'Text';\r\n                // current text value\r\n                self.text = options.text;\r\n                self.localized = '';\r\n                self.fontSize = options.fontSize || 20;\r\n                self.fontWeight = options.fontWeight || 'normal';\r\n                self.textAlign = options.textAlign || 'left';\r\n                self.fontFamily = options.style.font || 'Arial';\r\n                self.color = options.style.color || 'white';\r\n                self.shadow = options.style.shadow;\r\n                self.lineHeight = options.style.lineHeight || 1;\r\n                self.formatter = options.formatter;\r\n                self.zIndex = 305;\r\n\r\n                if (options.style.scaleX) {\r\n                    self.scaleX = options.style.scaleX;\r\n                }\r\n                if (options.style.scaleY) {\r\n                    self.scaleY = options.style.scaleY;\r\n                }\r\n                if (options.style.rotate) {\r\n                    self.rotate = options.style.rotate;\r\n                }\r\n                if (options.scaleX) {\r\n                    self.scaleX = options.scaleX;\r\n                }\r\n                if (options.scaleY) {\r\n                    self.scaleY = options.scaleY;\r\n                }\r\n\r\n                var style = {\r\n                    display: 'none',\r\n                    'font-size': self.fontSize + 'px',\r\n                    'font-family': self.fontFamily,\r\n                    'line-height': (self.lineHeight * self.fontSize) + 'px',\r\n                    'text-align': self.textAlign,\r\n                    'font-weight': self.fontWeight,\r\n                    'pointer-events': 'none',\r\n                    color: self.color,\r\n                    'z-index': self.zIndex,\r\n                };\r\n\r\n                if (self.shadow) {\r\n                    style['text-shadow'] = self.shadow.offsetX + 'px ' + self.shadow.offsetY + 'px '\r\n                            + self.shadow.color;\r\n                }\r\n                var $el = $('<div></div>');\r\n                $el.wrapper = self;\r\n                $el.css(style);\r\n                self.jQueryEl = $el;\r\n\r\n                self.appendHTML();\r\n\r\n                // set text value\r\n                self.setText = function (txt) {\r\n                    if (txt === undefined) {\r\n                        txt = '';\r\n                    }\r\n                    self.localized = txt;\r\n                    if (txt !== '') {\r\n                        self.localized = i18n.localize(txt);\r\n                        self.localized.replace && (self.localized =\r\n                                self.localized.replace(/\\n/g, '<br/>'));\r\n                        if (self.formatter) {\r\n                            self.localized = self.formatter(self.localized);\r\n                        }\r\n                    }\r\n                    self.text = txt;\r\n                    $el.html(self.localized);\r\n                    self.resize();\r\n                };\r\n\r\n                self.superSet = self.set.bind(self);\r\n                self.set = function (options) {\r\n                    self.superSet(options);\r\n                    if (options.style) {\r\n                        if (options.style.color) {\r\n                            self.color = options.style.color;\r\n                        }\r\n                    }\r\n                    self.resize();\r\n                };\r\n\r\n                self.resize = function () {\r\n                    function removeUnnecessaryUpdate(update) {\r\n                        var ks = Object.keys(update);\r\n                        var ksLen = ks.length;\r\n                        for (var i = 0; i < ks.length; i++) {\r\n                            if (update.hasOwnProperty(ks[i])) {\r\n                                if (lastUpdate[ks[i]] !== undefined\r\n                                        && lastUpdate[ks[i]] === update[ks[i]]) {\r\n                                    delete update[ks[i]];\r\n                                    ksLen -= 1;\r\n                                } else {\r\n                                    lastUpdate[ks[i]] = update[ks[i]];\r\n                                }\r\n                            }\r\n                        }\r\n                        return ksLen === 0 ? null : update;\r\n                    }\r\n                    function getParentOffset(el) {\r\n                        var off = {\r\n                            left: 0,\r\n                            top: 0\r\n                        };\r\n                        while (el.parent) {\r\n                            off.left += el.parent.left;\r\n                            off.top += el.parent.top;\r\n                            el = el.parent;\r\n                        }\r\n                        return off;\r\n                    }\r\n\r\n                    var update = {};\r\n                    var parentsOffset = getParentOffset(self);\r\n                    var left = parentsOffset.left + self.left;\r\n                    var top = parentsOffset.top + self.top;\r\n\r\n                    update['font-size'] = self.fontSize + 'px';\r\n                    update['line-height'] = self.lineHeight * self.fontSize + 'px';\r\n\r\n                    var lines = self.localized ? (1\r\n                            + (self.localized.match(/<br/g) || []).length) : 1;\r\n                    if (self.originY === 'center') {\r\n                        top -= lines * (self.lineHeight * self.fontSize / 2);\r\n                    }\r\n                    if (self.originY === 'bottom') {\r\n                        top -= lines * (self.lineHeight * self.fontSize);\r\n                    }\r\n                    if (self.centerVertical) {\r\n                        if (dimensions.moveTop) {\r\n                            top += (dimensions.moveTop / dimensions.canvasScaleY);\r\n                        } else {\r\n                            top -= (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY\r\n                                    - dimensions.topLevelWrappersOffsetBottom / dimensions.canvasScaleY);\r\n                        }\r\n                    }\r\n\r\n                    if (self.originX === 'center') {\r\n                        update.width = 400 + 'px';\r\n                        left -= 400 / 2;\r\n                        update['text-align'] = 'center';\r\n                    }\r\n                    if (self.originX === 'right') {\r\n                        update.width = 400 + 'px';\r\n                        left -= 400;\r\n                        update['text-align'] = 'right';\r\n                    }\r\n\r\n                    update.left = left;\r\n                    update.top = top;\r\n\r\n                    if (self.opacity !== undefined) {\r\n                        update.opacity = self.opacity;\r\n                    }\r\n                    if (self.zIndex) {\r\n                        update['z-index'] = self.zIndex;\r\n                    }\r\n                    update = removeUnnecessaryUpdate(update);\r\n                    if (update) {\r\n                        $el.css(update);\r\n                    }\r\n                };\r\n\r\n                self.setText(self.text);\r\n                self.resize();\r\n\r\n                pubsub.subscribe('request:updateLocalizedLabels', function () {\r\n                    self.setText(self.text);\r\n                });\r\n\r\n                return self;\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/TextCss.js"),eval("define('components/Text',[\r\n    'components/TextBitmap',\r\n    'components/TextPixi',\r\n    'components/TextCss',\r\n], function (TextBitmap, TextPixi, TextCss) {\r\n    // Bitmap text\r\n    return function create(options) {\r\n//       console.log('options', options);\r\n        var style = options.style;\r\n        if (style.adjustment) {\r\n            options.left += style.adjustment.x ? style.adjustment.x : 0;\r\n            options.top += style.adjustment.y ? style.adjustment.y : 0;\r\n            options.fontSize += style.adjustment.size ? style.adjustment.size : 0;\r\n        }\r\n        if (style.type === 'bitmap') {\r\n            return TextBitmap(options);\r\n        } else if (style.type === 'css') {\r\n            return TextCss(options);\r\n        } else {\r\n//            return TextCss(options);\r\n            return TextPixi(options);\r\n        }\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/Text.js"),eval("// math library service\r\n// specifies easing functions used in animations\r\ndefine('services/math',[],function () {\r\n    var EasingFunctions = {\r\n        // no easing, no acceleration\r\n        linear: function (t) {\r\n            return t\r\n        },\r\n        easeInSine: function (t) {\r\n            return 1 - Math.cos(t * Math.PI / 2);\r\n        },\r\n        easeOutSine: function (t) {\r\n            return 1 - (1 - Math.cos(t * Math.PI / 2));\r\n        },\r\n        // accelerating from zero velocity\r\n        easeInQuad: function (t) {\r\n            return t * t\r\n        },\r\n        // decelerating to zero velocity\r\n        easeOutQuad: function (t) {\r\n            return t * (2 - t)\r\n        },\r\n        // acceleration until halfway, then deceleration\r\n        easeInOutQuad: function (t) {\r\n            return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        },\r\n        // accelerating from zero velocity\r\n        easeInCubic: function (t) {\r\n            return t * t * t\r\n        },\r\n        // decelerating to zero velocity\r\n        easeOutCubic: function (t) {\r\n            return (--t) * t * t + 1\r\n        },\r\n        // acceleration until halfway, then deceleration\r\n        easeInOutCubic: function (t) {\r\n            return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1\r\n        },\r\n        // accelerating from zero velocity\r\n        easeInQuart: function (t) {\r\n            return t * t * t * t\r\n        },\r\n        // decelerating to zero velocity\r\n        easeOutQuart: function (t) {\r\n            return 1 - (--t) * t * t * t\r\n        },\r\n        // acceleration until halfway, then deceleration\r\n        easeInOutQuart: function (t) {\r\n            return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t\r\n        },\r\n        // accelerating from zero velocity\r\n        easeInQuint: function (t) {\r\n            return t * t * t * t * t\r\n        },\r\n        // decelerating to zero velocity\r\n        easeOutQuint: function (t) {\r\n            return 1 + (--t) * t * t * t * t\r\n        },\r\n        // acceleration until halfway, then deceleration\r\n        easeInOutQuint: function (t) {\r\n            return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t\r\n        }\r\n    };\r\n\r\n    return EasingFunctions;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/math.js"),eval("define('components/SpinButton',[\r\n    'components/Element',\r\n    'components/Sprite',\r\n    'components/SpriteSheetAnimation',\r\n    'components/DomRectangle',\r\n    'components/Text',\r\n    'services/dimensions',\r\n    'services/math',\r\n    'services/pause',\r\n], function (\r\n        Element, Sprite, SpriteSheetAnimation, DomRectangle, Text,\r\n        dimensions, math, pause) {\r\n\r\n// spin control button\r\n    return function create(options) {\r\n\r\n        function resetButton() {\r\n            self.pressed = false;\r\n            self.dragging = false;\r\n            draggedPastTreshold = false;\r\n        }\r\n\r\n\r\n        var playAnimationActive = false;\r\n        var animTimeout = null;\r\n        var draggedPastTreshold = false;\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'SpinButton';\r\n\r\n        self.imgPathSpin = options.imgPath;\r\n        self.imgPathDown = options.imgPathDown;\r\n        self.imgPathAuto = options.imgPathAuto;\r\n        self.imgPathPlay = options.imgPathPlay;\r\n        self.imgPathTurbo = options.imgPathTurbo;\r\n        self.imgPathSpinToPlay = options.imgPathSpinToPlay;\r\n        self.imgPathPlayToSpin = options.imgPathPlayToSpin;\r\n\r\n        self.maxDragPx = 0;\r\n        self.currentDragNormalized = 0;\r\n        self.autoDragTreshold = options.autoDragTreshold;\r\n        self.turboDragTreshold = options.turboDragTreshold;\r\n        self.maxBounceTimeMs = options.maxBounceTimeMs;\r\n        self.clickable = true;\r\n\r\n        self.textLeftLabelLeft = options.textLeftLabelLeft;\r\n        self.textRightLabelLeft = options.textRightLabelLeft;\r\n        self.textLabelTop = options.textLabelTop;\r\n        self.textLabelBackLeft = options.textLabelBackLeft;\r\n        self.textLabelBackTop = options.textLabelBackTop;\r\n        self.textLabelBackWidth = options.textLabelBackWidth;\r\n        self.textLabelBackHeight = options.textLabelBackHeight;\r\n\r\n        self.playButtonOffsetLeft = options.playButtonOffsetLeft;\r\n        self.playButtonOffsetTop = options.playButtonOffsetTop;\r\n        self.playAnimationWidth = options.playAnimationWidth;\r\n        self.playAnimationHeight = options.playAnimationHeight;\r\n        self.playStaticDelayMs = options.playStaticDelayMs;\r\n        self.eStaticDelayMs = options.eStaticDelayMs;\r\n\r\n        self.centerVertical = options.centerVertical;\r\n\r\n        // events\r\n        self.evthandler = options.evthandler;\r\n        self.click = function () {\r\n            self.evthandler(self.mode.actionClick);\r\n        };\r\n        self.onAutoDragLeft = function () {\r\n            self.evthandler(self.mode.actionAutoDrag);\r\n        };\r\n        self.onTurboDragLeft = function () {\r\n            self.evthandler(self.mode.actionTurboDrag);\r\n        };\r\n        self.mode = {};\r\n        self.setMode = function (newMode) {\r\n            self.mode = newMode;\r\n            updateState();\r\n        };\r\n\r\n        self.setClickable = function (val) {\r\n            self.clickable = val;\r\n            if (!val && self.pressed) {\r\n                self.pressed = false;\r\n            }\r\n            updateState();\r\n        };\r\n\r\n        var mDownHandler = function (data) {\r\n            if (self.clickable && (!self.mode.disabled || self.mode.draggable)) {\r\n                self.setAnimatePlayButton(false);\r\n                self.pressed = true;\r\n                updateState();\r\n                self.evthandler('touchstart');\r\n            }\r\n        };\r\n        var mMoveHandler = function (e) {\r\n            if (self.pressed && self.mode.draggable) {\r\n                self.dragging = true;\r\n                resolveDrag(e.data);\r\n                updateState();\r\n            }\r\n        };\r\n        var mUpHandler = function (data) {\r\n            if (self.pressed) {\r\n                if (self.dragging) {\r\n                    resolveDragRelease(data);\r\n                } else if (self.mode.disabled === false) {\r\n                    self.click();\r\n                }\r\n                resetButton();\r\n                updateState();\r\n                self.evthandler('touchend');\r\n            }\r\n        };\r\n\r\n        // button element\r\n        var imgEl = Sprite({\r\n            groupCtrl: self.groupCtrl,\r\n            name: self.name + '-spritesheet-button',\r\n            imgPath: self.imgPathSpin,\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            canvasLayer: self.canvasLayer,\r\n            centerVertical: self.centerVertical,\r\n            mouseDown: function (data) {\r\n                mDownHandler(data);\r\n            },\r\n            mouseMove: function (data) {\r\n                mMoveHandler(data);\r\n            },\r\n            mouseUp: function (data) {\r\n                mUpHandler(data);\r\n            },\r\n            zIndex: self.zIndex\r\n        });\r\n\r\n        var spinToPlayAnim = SpriteSheetAnimation({\r\n            groupCtrl: self.groupCtrl,\r\n            name: 'spin-play-animation',\r\n            imgPath: self.imgPathSpinToPlay,\r\n            left: self.left + self.playButtonOffsetLeft,\r\n            top: self.top + self.playButtonOffsetTop,\r\n            width: self.playAnimationWidth,\r\n            height: self.playAnimationHeight,\r\n            centerVertical: self.centerVertical,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            steps: 6,\r\n            canvasLayer: self.canvasLayer,\r\n            zIndex: self.zIndex,\r\n        });\r\n\r\n        var playToSpinAnim = SpriteSheetAnimation({\r\n            groupCtrl: self.groupCtrl,\r\n            name: 'play-spin-animation',\r\n            imgPath: self.imgPathPlayToSpin,\r\n            left: self.left + self.playButtonOffsetLeft,\r\n            top: self.top + self.playButtonOffsetTop,\r\n            width: self.playAnimationWidth,\r\n            height: self.playAnimationHeight,\r\n            centerVertical: self.centerVertical,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            steps: 6,\r\n            canvasLayer: self.canvasLayer,\r\n            zIndex: self.zIndex,\r\n        });\r\n\r\n        var textLabelBack = DomRectangle({\r\n            groupCtrl: self.groupCtrl,\r\n            name: self.name + '-back',\r\n            left: self.textLabelBackLeft,\r\n            top: self.textLabelBackTop,\r\n            width: self.textLabelBackWidth,\r\n            height: self.textLabelBackHeight,\r\n            color: 'rgba(0,0,0,.5)',\r\n            css: {\r\n                'border-bottom': '1px solid #969696',\r\n            }\r\n        });\r\n        var textLabelLeft = Text({\r\n            groupCtrl: self.groupCtrl,\r\n            left: self.textLeftLabelLeft,\r\n            top: self.textLabelTop,\r\n            text: '',\r\n            style: {\r\n                type: 'css',\r\n                font: 'myriadpro-semiext',\r\n                lineHeight: 1.2,\r\n                color: 'white'\r\n            },\r\n            fontSize: 24,\r\n        });\r\n        var textLabelRight = Text({\r\n            groupCtrl: self.groupCtrl,\r\n            left: self.textRightLabelLeft,\r\n            top: self.textLabelTop,\r\n            text: '',\r\n            style: {\r\n                type: 'css',\r\n                font: 'myriadpro-semiext',\r\n                lineHeight: 1.2,\r\n                color: 'white'\r\n            },\r\n            fontSize: 24,\r\n            originX: 'right',\r\n        });\r\n\r\n        self.pixiEl = [imgEl, spinToPlayAnim, playToSpinAnim];\r\n        self.jQueryEl = [textLabelLeft, textLabelRight, textLabelBack];\r\n\r\n        // override show to refresh state\r\n        self.superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            if (!self.visible) {\r\n                self.visible = true;\r\n                resetButton();\r\n                self.set({\r\n                    currentDragNormalized: 0\r\n                });\r\n                updateState();\r\n            }\r\n        };\r\n        self.superHide = self.hide.bind(self);\r\n        self.hide = function () {\r\n            if (self.visible) {\r\n                imgEl.hide.apply(imgEl, arguments);\r\n                spinToPlayAnim.hide.apply(spinToPlayAnim, arguments);\r\n                playToSpinAnim.hide.apply(playToSpinAnim, arguments);\r\n                resetButton();\r\n                self.set({\r\n                    currentDragNormalized: 0\r\n                });\r\n                self.visible = false;\r\n            }\r\n        };\r\n        self.fadeIn = self.show;\r\n        self.fadeOut = self.hide;\r\n\r\n        self.set = function (opts) {\r\n            opts.left !== undefined && (self.left = opts.left);\r\n            opts.maxDragPx !== undefined && (self.maxDragPx = opts.maxDragPx);\r\n            opts.currentDragNormalized !== undefined &&\r\n                    (self.currentDragNormalized = opts.currentDragNormalized);\r\n            var addPx = self.currentDragNormalized * self.maxDragPx;\r\n            var imgOpts = {\r\n                left: self.left + addPx,\r\n            };\r\n\r\n            imgEl.set(imgOpts);\r\n            spinToPlayAnim.set(imgOpts);\r\n            playToSpinAnim.set(imgOpts);\r\n        };\r\n\r\n        self.setAnimatePlayButton = function (state) {\r\n            if (state && self.mode.disabled) {\r\n                return;\r\n            }\r\n            if (state !== playAnimationActive) {\r\n                playAnimationActive = state;\r\n                if (playAnimationActive) {\r\n                    self.showPlayButton();\r\n                } else {\r\n                    updateState();\r\n                }\r\n            }\r\n        };\r\n\r\n        self.showPlayButton = function () {\r\n            imgEl.set({\r\n                opacity: .001\r\n            });\r\n            spinToPlayAnim.show();\r\n            spinToPlayAnim.animate({\r\n                cycles: 1,\r\n                callback: function () {\r\n                    spinToPlayAnim.hide();\r\n                    imgEl.setImgPath(self.imgPathPlay);\r\n                    imgEl.set({opacity: 1});\r\n                    animTimeout = pause.setTimeout(self.hidePlayButton,\r\n                            self.playStaticDelayMs);\r\n                }\r\n            });\r\n        };\r\n        self.hidePlayButton = function () {\r\n            if (playAnimationActive && imgEl.visible && imgEl.imgPath === self.imgPathPlay) {\r\n                imgEl.set({\r\n                    opacity: .001\r\n                });\r\n                playToSpinAnim.show();\r\n                playToSpinAnim.animate({\r\n                    cycles: 1,\r\n                    callback: function () {\r\n                        playToSpinAnim.hide();\r\n                        imgEl.setImgPath(self.imgPathSpin);\r\n                        imgEl.set({opacity: 1});\r\n                        animTimeout = pause.setTimeout(self.showPlayButton,\r\n                                self.eStaticDelayMs);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        self.animations = [];\r\n        self.update = function (delta) {\r\n            spinToPlayAnim.visible && spinToPlayAnim.update(delta);\r\n            playToSpinAnim.visible && playToSpinAnim.update(delta);\r\n            for (var i = 0; i < self.animations.length; i++) {\r\n                if (!self.animations[i].update(delta)) {\r\n                    self.animations.splice(i, 1);\r\n                }\r\n            }\r\n        };\r\n\r\n        self.updateLayout(self.currentLayout);\r\n        self.resize();\r\n\r\n        return self;\r\n\r\n        function resolveDrag(data) {\r\n\r\n            var x = data.global.x - dimensions.topLevelWrappersOffsetX /\r\n                    dimensions.canvasScaleX;\r\n            var limitA = self.left;\r\n            var limitB = self.left + self.maxDragPx;\r\n            if (limitA < limitB) {\r\n                x < limitA && (x = limitA);\r\n                x > limitB && (x = limitB);\r\n            } else {\r\n                x < limitB && (x = limitB);\r\n                x > limitA && (x = limitA);\r\n            }\r\n            var dragNormalized = Math.abs((self.left - x) / self.maxDragPx);\r\n            self.set({\r\n                currentDragNormalized: dragNormalized\r\n            });\r\n            if (dragNormalized > .25) {\r\n                draggedPastTreshold = true;\r\n            }\r\n            updateState();\r\n            updateLabels(dragNormalized);\r\n        }\r\n        function resolveDragRelease(data) {\r\n            var activeElement = imgEl;\r\n            var dragNormalized = Math.abs((activeElement.left - self.left) / self.maxDragPx);\r\n            if (dragNormalized > self.turboDragTreshold) {\r\n                self.onTurboDragLeft();\r\n            } else if (dragNormalized > self.autoDragTreshold) {\r\n                self.onAutoDragLeft();\r\n            } else if (!draggedPastTreshold) {\r\n                self.click();\r\n            }\r\n            bounceBack();\r\n            updateLabels();\r\n        }\r\n        function bounceBack(ms) {\r\n            var dragNormalized = self.currentDragNormalized;\r\n            if (dragNormalized) {\r\n                self.bouncing = true;\r\n                var progress = 0;\r\n                var fn;\r\n                var bounceTime = ms ? ms : (dragNormalized * self.maxBounceTimeMs);\r\n                var progressPerSecond = 1 / (bounceTime / 1000);\r\n                self.animations = [{\r\n                        update: function (delta) {\r\n                            progress += delta * progressPerSecond;\r\n                            if (progress >= 1) {\r\n                                self.set({currentDragNormalized: 0});\r\n                                self.bouncing = false;\r\n                                return false;\r\n                            } else {\r\n                                fn = math.easeInOutQuad(progress);\r\n                                self.set({\r\n                                    currentDragNormalized: dragNormalized\r\n                                            - fn * dragNormalized\r\n                                });\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }];\r\n            }\r\n        }\r\n\r\n// update view to reflect current state\r\n        function updateState() {\r\n            if (!self.visible) {\r\n                return;\r\n            }\r\n\r\n            if (playAnimationActive) {\r\n                if (!self.clickable || self.mode.disabled || self.pressed) {\r\n                    self.setAnimatePlayButton(false);\r\n                } else {\r\n                    return;\r\n                }\r\n            } else {\r\n                animTimeout && pause.clearTimeout(animTimeout);\r\n                spinToPlayAnim.hide();\r\n                playToSpinAnim.hide();\r\n            }\r\n\r\n            imgEl.show();\r\n\r\n            var opacity = self.mode.disabled ? .5 : 1;\r\n            imgEl.set({opacity: opacity});\r\n\r\n            var scale = self.pressed ? .95 : 1;\r\n            imgEl.set({scaleX: scale, scaleY: scale});\r\n\r\n            if (self.pressed) {\r\n                if (self.mode.logo2) {\r\n                    imgEl.setImgPath(self.imgPathTurbo);\r\n                } else if (self.mode.logo) {\r\n                    if (self.currentDragNormalized > self.turboDragTreshold) {\r\n                        imgEl.setImgPath(self.imgPathTurbo);\r\n                    } else {\r\n                        imgEl.setImgPath(self.imgPathAuto);\r\n                    }\r\n                } else {\r\n                    if (self.currentDragNormalized > self.turboDragTreshold) {\r\n                        imgEl.setImgPath(self.imgPathTurbo);\r\n                    } else if (self.currentDragNormalized > self.autoDragTreshold) {\r\n                        imgEl.setImgPath(self.imgPathAuto);\r\n                    } else {\r\n                        imgEl.setImgPath(self.imgPathDown);\r\n                    }\r\n                }\r\n            } else if (self.mode.logo2) {\r\n                imgEl.setImgPath(self.imgPathTurbo);\r\n            } else if (self.mode.logo) {\r\n                imgEl.setImgPath(self.imgPathAuto);\r\n            } else {\r\n                imgEl.setImgPath(self.imgPathSpin);\r\n            }\r\n        }\r\n\r\n        function updateLabels(dragNormalized) {\r\n            if (dragNormalized > self.autoDragTreshold) {\r\n                if (self.mode.logo) {\r\n                    if (dragNormalized > self.turboDragTreshold) {\r\n                        textLabelRight.setText('turbo');\r\n                        textLabelLeft.setText('dragAgainToStopAuto');\r\n                    } else {\r\n                        textLabelLeft.setText('');\r\n                        textLabelRight.setText('stopAutoplay');\r\n                    }\r\n                } else if (self.mode.logo2) {\r\n                    textLabelLeft.setText('');\r\n                    textLabelRight.setText('stopAutoplay');\r\n                } else if (dragNormalized > self.turboDragTreshold) {\r\n                    textLabelRight.setText('turbo');\r\n                    textLabelLeft.setText('dragAgainToStopAuto');\r\n                } else {\r\n                    textLabelRight.setText('auto');\r\n                    textLabelLeft.setText('dragAgainToStopAuto');\r\n                }\r\n                textLabelRight.show();\r\n                textLabelLeft.show();\r\n                textLabelBack.show();\r\n            } else {\r\n                textLabelLeft.setText('');\r\n                textLabelRight.setText('');\r\n                textLabelLeft.hide();\r\n                textLabelRight.hide();\r\n                textLabelBack.hide();\r\n            }\r\n        }\r\n    };\r\n});\r\n\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/SpinButton.js"),eval("define('components/SpriteSheetButton',[\r\n    'pubsub',\r\n    'components/Element',\r\n    'components/MovieClip'\r\n], function (\r\n        pubsub, Element, MovieClip) {\r\n\r\n    // sprite sheet button\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'SpriteSheetButton';\r\n        self.imgPath = options.imgPath;\r\n\r\n        // number of frames in sprite sheet\r\n        self.steps = options.steps;\r\n        // up frame index\r\n        self.upSprite = options.upSprite || 0;\r\n        // down-pressed frame index\r\n        self.downSprite = options.downSprite;\r\n        // disabled frame index\r\n        self.disabledSprite = options.disabledSprite;\r\n        // inactive flah\r\n        self.inactive = options.inactive;\r\n        // specifies if the button may be clicked\r\n        self.clickable = options.clickable === undefined ? true : options.clickable;\r\n        // specifies if the button is disabled\r\n        self.disabled = options.disabled;\r\n        self.disabledOpacity = options.disabledOpacity || 1;\r\n        // scale on press on/off\r\n        self.scaleOnPress = options.scaleOnPress;\r\n\r\n        // event handlers\r\n        self.click = options.click;\r\n        self.mouseDown = options.mouseDown;\r\n        self.mouseUp = options.mouseUp;\r\n        self.mouseMove = options.mouseMove;\r\n\r\n        // button click sound\r\n        self.downSound = options.downSound;\r\n\r\n        // specifies sides which should handle touch events little further\r\n        // beyond the borders of the image to allow easy touch\r\n        self.hitAreaAdjustment = options.hitAreaAdjustment;\r\n\r\n        var el = MovieClip(self);\r\n\r\n        // offset in pixels between each frame in sprite sheet\r\n        self.frameOffset = el.frameOffset;\r\n\r\n        // attach event handlers\r\n        el.interactive = true;\r\n\r\n        el.mousedown = function (data) {\r\n            if (!self.disabled && self.clickable) {\r\n                self.pressed = true;\r\n                self.updateState(self);\r\n                self.mouseDown && self.mouseDown(data);\r\n            }\r\n        };\r\n\r\n        el.mouseup = function (data) {\r\n            if (!self.disabled && self.clickable) {\r\n                if (self.pressed) {\r\n                    self.click && self.click(data);\r\n                    if (self.downSound) {\r\n                        pubsub.publish('request:playSound', {sound: self.downSound});\r\n                    }\r\n                }\r\n                self.mouseUp && self.mouseUp(data);\r\n            }\r\n            self.pressed = false;\r\n            self.updateState(self);\r\n        };\r\n\r\n        el.mousemove = function (data) {\r\n            if (!self.disabled && self.clickable) {\r\n                self.mouseMove && self.mouseMove(data);\r\n            }\r\n        };\r\n\r\n        el.touchstart = el.mousedown;\r\n        el.touchend = el.mouseup;\r\n        el.touchmove = el.mousemove;\r\n        el.touchendoutside = el.mouseupoutside = function () {\r\n            self.pressed = false;\r\n            el.mouseup && el.mouseup();\r\n        };\r\n\r\n        el.wrapper = self;\r\n        self.pixiEl = el;\r\n\r\n        // update clickable flag and refresh view\r\n        self.setDisabled = function (state) {\r\n            self.disabled = state;\r\n            self.opacity = self.disabled ? self.disabledOpacity : 1;\r\n            self.updateState(self);\r\n        };\r\n        // update clickable flag and refresh view\r\n        self.setClickable = function (state) {\r\n            self.clickable = state;\r\n            self.updateState(self);\r\n        };\r\n        // update inactive flag and refresh view\r\n        self.setInactive = function (state) {\r\n            self.inactive = state;\r\n            self.updateState(self);\r\n        };\r\n\r\n\r\n        self.superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            self.superShow.apply(self, arguments);\r\n            self.pressed = false;\r\n        };\r\n\r\n\r\n        // update displayed sprite sheet frame according to button state\r\n        self.updateState = function () {\r\n            if (self.pressed && (self.disabled || !self.clickable)) {\r\n                self.pressed = false;\r\n            }\r\n            if (self.disabled) {\r\n                if (self.disabledSprite !== undefined) {\r\n                    el.spriteIndex = self.disabledSprite;\r\n                }\r\n            } else if (self.pressed) {\r\n                el.spriteIndex = self.downSprite;\r\n            } else {\r\n                el.spriteIndex = self.upSprite;\r\n            }\r\n            if (self.inactive) {\r\n                el.spriteIndex += 1;\r\n            }\r\n            if (self.scaleOnPress) {\r\n                if (self.pressed) {\r\n                    self.scaleX = .95;\r\n                    self.scaleY = .95;\r\n                } else {\r\n                    self.scaleX = 1;\r\n                    self.scaleY = 1;\r\n                }\r\n            }\r\n            if (el.spriteIndex < self.steps) {\r\n                el.gotoAndStop(el.spriteIndex);\r\n            }\r\n            self.resize();\r\n        };\r\n\r\n        self.updateState(self);\r\n\r\n        return self;\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/SpriteSheetButton.js"),
eval("define('components/TextButton',[\r\n    'pubsub',\r\n    'components/Element',\r\n    'components/SpriteSheetButton',\r\n    'components/Text',\r\n    'data/config',\r\n    'services/pause',\r\n], function (\r\n        pubsub, Element, SpriteSheetButton, Text, globalConfig, pause) {\r\n\r\n    // a button with text label\r\n    // used for control buttons in bottom left and right groups\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'TextButton';\r\n        // current text value\r\n        self.text = options.text;\r\n\r\n        // background image sprite sheet path\r\n        self.imgPath = options.imgPath;\r\n        // sprite sheet frame count\r\n        self.steps = options.steps;\r\n        //\r\n        self.scaleOnPress = self.steps === 1;\r\n        // up frame index\r\n        self.upSprite = options.upSprite || 0;\r\n        // hover frame index\r\n        self.hoverSprite = options.hoverSprite;\r\n        // down-pressed frame index\r\n        self.downSprite = options.downSprite;\r\n        // disabled frame index\r\n        self.disabledSprite = options.disabledSprite;\r\n\r\n        self.disabledOpacity = options.disabledOpacity || 1;\r\n        // button click sound\r\n        self.downSound = options.downSound;\r\n        // disabled state flag\r\n        self.disabled = options.disabled;\r\n        // clickable state flag\r\n        self.clickable = options.clickable === undefined ? true : options.clickable;\r\n        // specifies whether the font should have glow animation\r\n        self.glowable = options.glowable;\r\n        // specify whether font kerning should be applied\r\n        self.applyKerning = options.applyKerning !== undefined ? options.applyKerning : true;\r\n        // specifies sides which should handle touch events little further\r\n        // beyond the borders of the image to allow easy touch\r\n        self.hitAreaAdjustment = options.hitAreaAdjustment;\r\n\r\n        // font properties\r\n        self.fontSize = options.fontSize;\r\n        self.lineHeight = options.lineHeight;\r\n        self.textOriginX = options.textOriginX;\r\n        self.textOriginY = options.textOriginY;\r\n        self.downScale = .95;\r\n\r\n        self.textLeft = self.left;\r\n        self.textTop = self.top + 3;\r\n        self.downOffsetX = 0;\r\n        self.downOffsetY = 0;\r\n\r\n        // event handlers\r\n        self.click = options.click;\r\n        self.mouseDown = options.mouseDown;\r\n        self.mouseUp = options.mouseUp;\r\n        self.mouseOver = options.mouseOver;\r\n        self.mouseOut = options.mouseOut;\r\n        self.mouseMove = options.mouseMove;\r\n\r\n        // button element\r\n        var imgEl = SpriteSheetButton({\r\n            groupCtrl: self.groupCtrl,\r\n            name: self.name + '-spritesheet-button',\r\n            imgPath: self.imgPath,\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            hoverSprite: self.hoverSprite,\r\n            downSprite: self.downSprite,\r\n            disabledSprite: self.disabledSprite,\r\n            disabled: self.disabled,\r\n            disabledOpacity: self.disabledOpacity,\r\n            flipX: self.flipX,\r\n            steps: self.steps,\r\n            scaleOnPress: self.scaleOnPress,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            click: function () {\r\n                self.click(self);\r\n                if (self.downSound) {\r\n                    pubsub.publish('request:playSound', {sound: self.downSound});\r\n                }\r\n            },\r\n            centerVertical: self.centerVertical,\r\n            hitAreaAdjustment: self.hitAreaAdjustment,\r\n            canvasLayer: self.canvasLayer,\r\n            mouseUp: function () {\r\n                self.pressed = false;\r\n                updateState();\r\n                if (self.mouseUp) {\r\n                    self.mouseUp();\r\n                }\r\n            },\r\n            mouseDown: function () {\r\n                self.pressed = true;\r\n                updateState();\r\n                if (self.mouseDown) {\r\n                    self.mouseDown();\r\n                }\r\n            },\r\n            mouseOver: function () {\r\n                setTimeout(function () {\r\n                    self.hovered = true;\r\n                    updateState();\r\n                    if (self.mouseOver) {\r\n                        self.mouseOver();\r\n                    }\r\n                }, 0);\r\n            },\r\n            mouseOut: function () {\r\n                self.hovered = false;\r\n                self.pressed = false;\r\n                updateState();\r\n                if (self.mouseOut) {\r\n                    self.mouseOut();\r\n                }\r\n            },\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex\r\n        });\r\n\r\n        // text up state element\r\n        var textElUp = Text({\r\n            groupCtrl: self.groupCtrl,\r\n            name: self.name + '-text-up',\r\n            left: self.textLeft,\r\n            top: self.textTop,\r\n            text: self.text,\r\n            fontSize: self.fontSize,\r\n            lineHeight: self.lineHeight,\r\n            centerVertical: self.centerVertical,\r\n            zIndex: self.zIndex + .1,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            textAlign: 'center',\r\n            originX: 'center',\r\n            originY: 'center',\r\n            style: globalConfig.BIG_BUTTON_TEXT_STYLE_UP,\r\n            state: 'up',\r\n            applyKerning: self.applyKerning,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // text hover state element\r\n        var textElOver = Text({\r\n            groupCtrl: self.groupCtrl,\r\n            name: self.name + '-text-over',\r\n            left: self.textLeft,\r\n            top: self.textTop,\r\n            text: self.text,\r\n            fontSize: self.fontSize,\r\n            lineHeight: self.lineHeight,\r\n            centerVertical: self.centerVertical,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex + .1,\r\n            textAlign: 'center',\r\n            originX: 'center',\r\n            originY: 'center',\r\n            style: globalConfig.BIG_BUTTON_TEXT_STYLE_HOVER,\r\n            state: 'hover',\r\n            applyKerning: self.applyKerning,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // text down state element\r\n        var textElDown = Text({\r\n            groupCtrl: self.groupCtrl,\r\n            name: self.name + '-text-down',\r\n            text: self.text,\r\n            fontSize: self.fontSize * self.downScale,\r\n            lineHeight: self.lineHeight,\r\n            centerVertical: self.centerVertical,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex + .1,\r\n            textAlign: 'center',\r\n            originX: 'center',\r\n            originY: 'center',\r\n            style: globalConfig.BIG_BUTTON_TEXT_STYLE_DOWN,\r\n            state: 'down',\r\n            top: self.textTop + self.downOffsetY,\r\n            left: self.textLeft + self.downOffsetX,\r\n            applyKerning: self.applyKerning,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // text disabled state element\r\n        var textElDisabled = Text({\r\n            groupCtrl: self.groupCtrl,\r\n            name: self.name + '-text-disabled',\r\n            left: self.textLeft,\r\n            top: self.textTop,\r\n            text: self.text,\r\n            fontSize: self.fontSize,\r\n            lineHeight: self.lineHeight,\r\n            centerVertical: self.centerVertical,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex + .1,\r\n            textAlign: 'center',\r\n            originX: 'center',\r\n            originY: 'center',\r\n            state: 'disabled',\r\n            style: globalConfig.BIG_BUTTON_TEXT_STYLE_DISABLED,\r\n            opacity: self.disabledOpacity,\r\n            applyKerning: self.applyKerning,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n\r\n        self.pixiEl = [imgEl, textElUp, textElOver, textElDown, textElDisabled];\r\n\r\n        // add elements and override show/hide if the element should have glow animation\r\n        if (self.glowable) {\r\n            // glow element 1\r\n            var textGlowEl1 = Text({\r\n                groupCtrl: self.groupCtrl,\r\n                name: self.name + '-text-glow',\r\n                left: self.textLeft,\r\n                top: self.textTop,\r\n                text: self.text,\r\n                fontSize: self.fontSize,\r\n                lineHeight: self.lineHeight,\r\n                centerVertical: self.centerVertical,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex + .1,\r\n                textAlign: 'center',\r\n                originX: 'center',\r\n                originY: 'center',\r\n                style: globalConfig.BIG_BUTTON_TEXT_STYLE_UP,\r\n                state: 'glow',\r\n                applyKerning: self.applyKerning,\r\n                canvasLayer: self.canvasLayer,\r\n            });\r\n            // glow element 2\r\n            var textGlowEl2 = Text({\r\n                groupCtrl: self.groupCtrl,\r\n                name: self.name + '-text-glow',\r\n                left: self.textLeft,\r\n                top: self.textTop,\r\n                text: self.text,\r\n                fontSize: self.fontSize,\r\n                lineHeight: self.lineHeight,\r\n                centerVertical: self.centerVertical,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex + .1,\r\n                textAlign: 'center',\r\n                originX: 'center',\r\n                originY: 'center',\r\n                style: globalConfig.BIG_BUTTON_TEXT_STYLE_UP,\r\n                state: 'glow',\r\n                applyKerning: self.applyKerning,\r\n                canvasLayer: self.canvasLayer,\r\n            });\r\n            // override show method to  refresh state && add glow animation\r\n            var glowInterval;\r\n            self.superShow = self.show.bind(self);\r\n            self.show = function () {\r\n                self.superShow.apply(null, arguments);\r\n                self.pressed = false;\r\n                updateState();\r\n                if (glowInterval) {\r\n                    pause.clearInterval(glowInterval);\r\n                }\r\n                textGlowEl1.opacity = 0;\r\n                textGlowEl2.opacity = 0;\r\n                var animStart = Date.now();\r\n                var diff;\r\n                var animDuration = 1250;\r\n                glowInterval = pause.setInterval(function () {\r\n                    diff = Date.now() - animStart;\r\n                    diff %= animDuration;\r\n                    if (diff <= animDuration / 2) {\r\n                        textGlowEl1.opacity = diff / (animDuration / 2);\r\n                        textGlowEl2.opacity = diff / (animDuration / 2);\r\n                    } else {\r\n                        diff -= animDuration / 2;\r\n                        textGlowEl1.opacity = 1 - diff / (animDuration / 2);\r\n                        textGlowEl2.opacity = 1 - diff / (animDuration / 2);\r\n                    }\r\n                    textGlowEl1.resize();\r\n                    textGlowEl2.resize();\r\n                }, 10);\r\n            };\r\n            // override hide method to clean glow animation\r\n            self.superHide = self.hide.bind(self);\r\n            self.hide = function () {\r\n                self.superHide.apply(null, arguments);\r\n                if (glowInterval) {\r\n                    pause.clearInterval(glowInterval);\r\n                }\r\n            };\r\n            self.pixiEl.push(textGlowEl1);\r\n            self.pixiEl.push(textGlowEl2);\r\n        } else {\r\n            // override show to refresh state\r\n            self.superShow = self.show.bind(self);\r\n            self.show = function () {\r\n                self.superShow.apply(null, arguments);\r\n                self.pressed = false;\r\n                updateState();\r\n            };\r\n        }\r\n        self.superFadeIn = self.fadeIn.bind(self);\r\n        self.fadeIn = function () {\r\n            self.pressed = false;\r\n            self.superFadeIn.apply(null, arguments);\r\n            updateState();\r\n        };\r\n\r\n        self.set = function (opts) {\r\n            opts.left !== undefined && (self.left = opts.left);\r\n            opts.top !== undefined && (self.top = opts.top);\r\n            opts.flipX !== undefined && (self.flipX = opts.flipX);\r\n            opts.textLeft !== undefined && (self.textLeft = opts.textLeft);\r\n            opts.textTop !== undefined && (self.textTop = opts.textTop);\r\n            opts.downOffsetX !== undefined && (self.downOffsetX = opts.downOffsetX);\r\n            opts.downOffsetY !== undefined && (self.downOffsetY = opts.downOffsetY);\r\n\r\n\r\n            self.textLeft = self.left;\r\n            self.textTop = self.top + 3;\r\n\r\n            var imgOpts = {\r\n                left: self.left,\r\n                top: self.top,\r\n                flipX: self.flipX\r\n            };\r\n            imgEl.set(imgOpts);\r\n\r\n            var txtOpts = {\r\n                left: self.textLeft,\r\n                top: self.textTop\r\n            };\r\n            var downTxtOpts = $.extend({}, txtOpts);\r\n            downTxtOpts.left += self.downOffsetX;\r\n            downTxtOpts.top += self.downOffsetY;\r\n\r\n            imgEl.set(imgOpts);\r\n            textElUp.set(txtOpts);\r\n            textElOver.set(txtOpts);\r\n            if (textGlowEl1) {\r\n                textGlowEl1.set(txtOpts);\r\n                textGlowEl2.set(txtOpts);\r\n            }\r\n            textElDown.set(downTxtOpts);\r\n            textElDisabled.set(txtOpts);\r\n        };\r\n\r\n        // disabled flag setter\r\n        self.setDisabled = function (state) {\r\n            if (state !== self.disabled) {\r\n                self.disabled = state;\r\n                imgEl.setDisabled(state);\r\n                updateState();\r\n            }\r\n        };\r\n\r\n        self.updateLayout(self.currentLayout);\r\n        self.resize();\r\n\r\n        return self;\r\n\r\n        // update view to reflect current state\r\n        function updateState() {\r\n            if (!self.visible) {\r\n                return;\r\n            }\r\n            imgEl.setDisabled(self.disabled);\r\n            imgEl.updateState(self);\r\n            textElUp.hide();\r\n            textElDown.hide();\r\n            textElOver.hide();\r\n            textElDisabled.hide();\r\n            if (self.disabled) {\r\n                textElDisabled.show();\r\n            } else {\r\n                if (self.pressed) {\r\n                    textElDown.show();\r\n                    if (textGlowEl1) {\r\n                        textGlowEl1.hide();\r\n                        textGlowEl2.hide();\r\n                    }\r\n                } else if (self.hovered) {\r\n                    textElOver.show();\r\n                    if (textGlowEl1) {\r\n                        textGlowEl1.hide();\r\n                        textGlowEl2.hide();\r\n                    }\r\n                } else {\r\n                    textElUp.show();\r\n                    if (textGlowEl1) {\r\n                        textGlowEl1.show();\r\n                        textGlowEl2.show();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n});\r\n\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/TextButton.js"),eval("// mainButtonsView\r\n// contains\r\ndefine('layers/mainButtons/mainButtonsView',['data/config',\r\n    'data/config-mainButtons',\r\n    'data/config-menu',\r\n    'components/SpinButton',\r\n    'components/TextButton',\r\n    'components/SpriteSheetAnimation'\r\n], function (\r\n        globalConfig,\r\n        config,\r\n        menuConfig,\r\n        SpinButton,\r\n        TextButton,\r\n        SpriteSheetAnimation) {\r\n\r\n    return function mCreate(ctrl) {\r\n\r\n        var elements = {\r\n            spinButton: SpinButton({\r\n                groupCtrl: ctrl,\r\n                name: 'spin-button',\r\n                imgPath: 'Control_panel/buttons/spin_btn',\r\n                imgPathAuto: 'Control_panel/buttons/auto_btn',\r\n                imgPathDown: 'Control_panel/buttons/spin_down',\r\n                imgPathPlay: 'Control_panel/buttons/play_btn',\r\n                imgPathTurbo: 'Control_panel/buttons/turbo_btn',\r\n                imgPathSpinToPlay: 'Control_panel/buttons/spin_play_transform',\r\n                imgPathPlayToSpin: 'Control_panel/buttons/play_spin_transform',\r\n                top: config.CONTROL_BUTTON_TOP,\r\n                width: config.CONTROL_BUTTON_WIDTH,\r\n                height: config.CONTROL_BUTTON_HEIGHT,\r\n                textLabelBackLeft: menuConfig.TOP_RIGHT_TEXT_LABEL_BACK_LEFT,\r\n                textLabelBackTop: menuConfig.TOP_RIGHT_TEXT_LABEL_BACK_TOP,\r\n                textLabelBackWidth: menuConfig.TOP_RIGHT_TEXT_LABEL_BACK_WIDTH,\r\n                textLabelBackHeight: menuConfig.TOP_RIGHT_TEXT_LABEL_BACK_HEIGHT,\r\n                textRightLabelLeft: menuConfig.TOP_RIGHT_TEXT_LABEL_LEFT,\r\n                textLeftLabelLeft: menuConfig.TOP_LEFT_TEXT_LABEL_LEFT,\r\n                textLabelTop: menuConfig.TOP_RIGHT_TEXT_LABEL_TOP,\r\n                textLabelFontSize: menuConfig.TOP_RIGHT_TEXT_LABEL_FONT_SIZE,\r\n                playAnimationWidth: config.PLAY_INFLATE_ANIMATION_WIDTH,\r\n                playAnimationHeight: config.PLAY_INFLATE_ANIMATION_HEIGHT,\r\n                playButtonOffsetLeft: config.PLAY_BUTTON_OFFSET_LEFT,\r\n                playButtonOffsetTop: config.PLAY_BUTTON_OFFSET_TOP,\r\n                playStaticDelayMs: config.PLAY_BUTTON_STATIC_DELAY_MS,\r\n                eStaticDelayMs: config.E_BUTTON_STATIC_DELAY_MS,\r\n                currentLayout: 'righthand',\r\n                layouts: {\r\n                    'lefthand': {\r\n                        props: {\r\n                            left: config.LEFT_CONTROL_BUTTON_LEFT,\r\n                            maxDragPx: 347,\r\n                        }\r\n                    },\r\n                    'righthand': {\r\n                        props: {\r\n                            left: config.RIGHT_CONTROL_BUTTON_LEFT,\r\n                            maxDragPx: -347,\r\n                        }\r\n                    }\r\n                },\r\n                autoDragTreshold: .3,\r\n                turboDragTreshold: .99,\r\n                maxBounceTimeMs: 200,\r\n                evthandler: ctrl.viewActions.evthandler,\r\n                centerVertical: true,\r\n                zIndex: 26,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            takeWinButton: TextButton({\r\n                groupCtrl: ctrl,\r\n                text: 'takeWin',\r\n                name: 'take-win-button',\r\n                imgPath: 'Control_panel/buttons/round_btn',\r\n                currentLayout: 'righthand',\r\n                layouts: {\r\n                    'lefthand': {\r\n                        props: {\r\n                            left: config.LEFT_CONTROL_BUTTON_LEFT,\r\n                            top: config.CONTROL_BUTTON_TOP,\r\n                        }\r\n                    },\r\n                    'righthand': {\r\n                        props: {\r\n                            left: config.RIGHT_CONTROL_BUTTON_LEFT,\r\n                            top: config.CONTROL_BUTTON_TOP,\r\n                        }\r\n                    }\r\n                },\r\n                width: config.CONTROL_BUTTON_WIDTH,\r\n                height: config.CONTROL_BUTTON_HEIGHT,\r\n                fontSize: config.BUTTONS_FONT_SIZE,\r\n                lineHeight: config.BUTTONS_LINE_HEIGHT,\r\n                downSprite: 1,\r\n                disabledSprite: 0,\r\n                disabledOpacity: .5,\r\n                steps: 1,\r\n                click: ctrl.viewActions.takeWinButtonClick,\r\n                centerVertical: true,\r\n                zIndex: 25,\r\n                canvasLayer: 'ui',\r\n                downSound: globalConfig.BUTTON_CLICK_SOUND,\r\n            }),\r\n            takeRiskButton: TextButton({\r\n                groupCtrl: ctrl,\r\n                text: 'takeRisk',\r\n                name: 'take-risk-button',\r\n                imgPath: 'Control_panel/buttons/round_btn',\r\n                currentLayout: 'righthand',\r\n                layouts: {\r\n                    'lefthand': {\r\n                        props: {\r\n                            left: config.RIGHT_CONTROL_BUTTON_LEFT,\r\n                            top: config.CONTROL_BUTTON_TOP,\r\n                        }\r\n                    },\r\n                    'righthand': {\r\n                        props: {\r\n                            left: config.LEFT_CONTROL_BUTTON_LEFT,\r\n                            top: config.CONTROL_BUTTON_TOP,\r\n                        }\r\n                    }\r\n                },\r\n                width: config.CONTROL_BUTTON_WIDTH,\r\n                height: config.CONTROL_BUTTON_HEIGHT,\r\n                fontSize: config.BUTTONS_FONT_SIZE,\r\n                lineHeight: config.BUTTONS_LINE_HEIGHT,\r\n                downSprite: 1,\r\n                disabledSprite: 0,\r\n                disabledOpacity: .5,\r\n                steps: 1,\r\n                click: function () {\r\n                    ctrl.viewActions.takeRiskButtonClick();\r\n                },\r\n                centerVertical: true,\r\n                zIndex: 25,\r\n                canvasLayer: 'ui',\r\n                downSound: globalConfig.BUTTON_CLICK_SOUND,\r\n            }),\r\n            inflateArrowAnimation: SpriteSheetAnimation({\r\n                groupCtrl: ctrl,\r\n                name: 'inflate-arrow-animation',\r\n                imgPath: 'Control_panel/buttons/menu_circle_transform',\r\n                layouts: {\r\n                    'lefthand': {\r\n                        props: {\r\n                            left: config.LEFTHAND_ARROW_INFLATE_ANIMATION_LEFT,\r\n                        }\r\n                    },\r\n                    'righthand': {\r\n                        props: {\r\n                            left: config.RIGHTHAND_ARROW_INFLATE_ANIMATION_LEFT,\r\n                        }\r\n                    },\r\n                },\r\n                top: config.ARROW_INFLATE_ANIMATION_TOP,\r\n                width: config.ARROW_INFLATE_ANIMATION_WIDTH,\r\n                height: config.ARROW_INFLATE_ANIMATION_HEIGHT,\r\n                centerVertical: true,\r\n                zIndex: 25,\r\n                steps: 8,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            deflateCircleAnimation: SpriteSheetAnimation({\r\n                groupCtrl: ctrl,\r\n                name: 'deflate-circle-animation',\r\n                imgPath: 'Control_panel/buttons/circle_menu_transform',\r\n                layouts: {\r\n                    'lefthand': {\r\n                        props: {\r\n                            left: config.LEFTHAND_ARROW_INFLATE_ANIMATION_LEFT\r\n                                    - config.ARROW_INFLATE_MOVE_LEFT_OFFSET_RIGHTHAND,\r\n                        }\r\n                    },\r\n                    'righthand': {\r\n                        props: {\r\n                            left: config.RIGHTHAND_ARROW_INFLATE_ANIMATION_LEFT\r\n                                    + config.ARROW_INFLATE_MOVE_LEFT_OFFSET_RIGHTHAND,\r\n                        }\r\n                    },\r\n                },\r\n                top: config.ARROW_INFLATE_ANIMATION_TOP,\r\n                width: config.ARROW_INFLATE_ANIMATION_WIDTH,\r\n                height: config.ARROW_INFLATE_ANIMATION_HEIGHT,\r\n                centerVertical: true,\r\n                zIndex: 25,\r\n                steps: 8,\r\n                canvasLayer: 'ui',\r\n            }),\r\n        };\r\n\r\n        // API\r\n        return {\r\n            elements: elements,\r\n            actions: {\r\n                animateArrow: function (direction, callback) {\r\n                    if (direction === 'inflate') {\r\n                        elements.deflateCircleAnimation.hide();\r\n                        elements.inflateArrowAnimation.show();\r\n                        elements.inflateArrowAnimation.set({\r\n                            width: config.ARROW_INFLATE_ANIMATION_WIDTH,\r\n                            height: config.ARROW_INFLATE_ANIMATION_HEIGHT,\r\n                            top: config.ARROW_INFLATE_ANIMATION_TOP,\r\n                        });\r\n                        elements.inflateArrowAnimation.animate({\r\n                            cycles: 1,\r\n                            frameCallback: function (frameId) {\r\n                                var progress = frameId / elements.inflateArrowAnimation.steps;\r\n                                var offsetX = progress * config.ARROW_INFLATE_MOVE_LEFT_OFFSET_RIGHTHAND;\r\n                                var offsetY = progress * config.ARROW_INFLATE_MOVE_TOP_OFFSET;\r\n                                var scale = 1 + progress * (config.ARROW_INFLATE_SCALE - 1);\r\n                                if (elements.inflateArrowAnimation.currentLayout === 'righthand') {\r\n                                    elements.inflateArrowAnimation.set({\r\n                                        left: config.RIGHTHAND_ARROW_INFLATE_ANIMATION_LEFT\r\n                                                + offsetX,\r\n                                    });\r\n                                } else {\r\n                                    elements.inflateArrowAnimation.set({\r\n                                        left: config.LEFTHAND_ARROW_INFLATE_ANIMATION_LEFT\r\n                                                - offsetX});\r\n                                }\r\n                                elements.inflateArrowAnimation.set({\r\n                                    top: config.ARROW_INFLATE_ANIMATION_TOP\r\n                                            + offsetY,\r\n                                    width: config.ARROW_INFLATE_ANIMATION_WIDTH * scale,\r\n                                    height: config.ARROW_INFLATE_ANIMATION_HEIGHT * scale});\r\n                            },\r\n                            callback: function () {\r\n                                elements.inflateArrowAnimation.hide();\r\n                                callback && callback();\r\n                            }\r\n                        });\r\n                    }\r\n                    if (direction === 'deflate') {\r\n                        elements.inflateArrowAnimation.hide();\r\n                        elements.deflateCircleAnimation.show();\r\n                        elements.deflateCircleAnimation.set({\r\n                            width: config.ARROW_INFLATE_ANIMATION_WIDTH * config.ARROW_INFLATE_SCALE,\r\n                            height: config.ARROW_INFLATE_ANIMATION_HEIGHT * config.ARROW_INFLATE_SCALE,\r\n                            top: config.ARROW_INFLATE_ANIMATION_TOP + config.ARROW_INFLATE_MOVE_TOP_OFFSET});\r\n                        elements.deflateCircleAnimation.animate({\r\n                            cycles: 1,\r\n                            frameCallback: function (frameId) {\r\n                                var progress = frameId / elements.deflateCircleAnimation.steps;\r\n                                var offsetX = progress * config.ARROW_INFLATE_MOVE_LEFT_OFFSET_RIGHTHAND;\r\n                                var offsetY = config.ARROW_INFLATE_MOVE_TOP_OFFSET\r\n                                        - progress * (config.ARROW_INFLATE_MOVE_TOP_OFFSET);\r\n                                var scale = config.ARROW_INFLATE_SCALE\r\n                                        - progress * (config.ARROW_INFLATE_SCALE - 1);\r\n                                if (elements.deflateCircleAnimation.currentLayout === 'righthand') {\r\n                                    elements.deflateCircleAnimation.set({\r\n                                        left: config.RIGHTHAND_ARROW_INFLATE_ANIMATION_LEFT\r\n                                                + config.ARROW_INFLATE_MOVE_LEFT_OFFSET_RIGHTHAND\r\n                                                - offsetX});\r\n                                } else {\r\n                                    elements.deflateCircleAnimation.set({\r\n                                        left: config.LEFTHAND_ARROW_INFLATE_ANIMATION_LEFT\r\n                                                - config.ARROW_INFLATE_MOVE_LEFT_OFFSET_RIGHTHAND\r\n                                                + offsetX});\r\n                                }\r\n                                elements.deflateCircleAnimation.set({\r\n                                    top: config.ARROW_INFLATE_ANIMATION_TOP\r\n                                            + offsetY,\r\n                                    width: config.ARROW_INFLATE_ANIMATION_WIDTH * scale,\r\n                                    height: config.ARROW_INFLATE_ANIMATION_HEIGHT * scale});\r\n                            },\r\n                            callback: function () {\r\n                                elements.deflateCircleAnimation.hide();\r\n                                callback && callback();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                ,\r\n            }\r\n        };\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/mainButtons/mainButtonsView.js"),eval("// mainButtonsCtrl\r\n//\r\ndefine('layers/mainButtons/mainButtonsCtrl',[\r\n    'pubsub',\r\n    'data/config',\r\n    'components/GroupCtrl',\r\n    'services/settings',\r\n    'services/pause',\r\n    'layers/mainButtons/mainButtonsView',\r\n], function (pubsub, globalConfig, GroupCtrl, settings, pause, mainButtonsView) {\r\n\r\n// initialize self\r\n    var self = GroupCtrl();\r\n    var lastTakeRiskState = 'hidden';\r\n    var btnStatePending = null;\r\n    var btnStateRunning = null;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        evthandler: function (action) {\r\n            switch (action) {\r\n                case 'touchstart':\r\n                    pubsub.publish('notify:spinButtonTouch', 'down');\r\n                    break;\r\n                case 'touchend':\r\n                    pubsub.publish('notify:spinButtonTouch', 'end');\r\n                    break;\r\n                case 'spin':\r\n                    pubsub.publish('notify:spinButtonClicked');\r\n                    break;\r\n                case 'auto':\r\n                    pubsub.publish('notify:autoButtonClicked');\r\n                    break;\r\n                case 'turbo':\r\n                    pubsub.publish('notify:turboButtonClicked');\r\n                    break;\r\n                case 'stop':\r\n                    pubsub.publish('notify:stopButtonClicked');\r\n                    break;\r\n            }\r\n        },\r\n        takeRiskButtonClick: function () {\r\n            pubsub.publish('notify:takeRiskButtonClicked');\r\n        },\r\n        takeWinButtonClick: function () {\r\n            pubsub.publish('notify:takeWinButtonClicked');\r\n        },\r\n    };\r\n    // initialize view\r\n    self.view = mainButtonsView(self);\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        'request:adjustControls': mAdjustControls,\r\n        'notify:gameIdle': function (id, data) {\r\n            self.view.elements.spinButton.setAnimatePlayButton(true);\r\n        },\r\n        'notify:activityAfterStart': function (id, data) {\r\n            self.view.elements.spinButton.setAnimatePlayButton(false);\r\n        },\r\n        'notify:subactivityStarted': function (id, data) {\r\n            if (data.activity === 'idle' && data.subactivity !== 'spinButton') {\r\n                setSpinButtonClickable(false);\r\n            }\r\n            if (data.activity === 'idle' && data.subactivity === 'menu') {\r\n                self.view.elements.spinButton.setAnimatePlayButton(false);\r\n            }\r\n        },\r\n        'notify:subactivityFinished': function (id, data) {\r\n            if (data.activity === 'idle' && data.subactivity !== 'spinButton') {\r\n                setSpinButtonClickable(true);\r\n            }\r\n        }\r\n    });\r\n    return self;\r\n    // update button state\r\n    // according to config JSON\r\n    function mAdjustControls(id, data) {\r\n\r\n        var btn, btnWin, btnRisk, winNewState, riskNewState,\r\n                arrowLastVisible, arrowNewVisible;\r\n\r\n        if (btnStateRunning) {\r\n            btnStatePending = data;\r\n            return;\r\n        } else {\r\n            btnStatePending = null;\r\n        }\r\n\r\n        if (globalConfig.UI_TYPE === 'original') {\r\n            self.hideAll();\r\n            return;\r\n        }\r\n\r\n        btnWin = self.view.elements.takeWinButton;\r\n        btnRisk = self.view.elements.takeRiskButton;\r\n        winNewState = data['takeWinButton'];\r\n        riskNewState = data['takeRiskButton'];\r\n        arrowLastVisible = lastTakeRiskState === 'hidden';\r\n        arrowNewVisible = riskNewState === 'hidden'\r\n                && data['menuButton'] !== 'hidden';\r\n\r\n        if (data['spinButton']) {\r\n            btn = self.view.elements.spinButton;\r\n            if (data['spinButton'] === 'hidden') {\r\n                btn.hide();\r\n            } else if (typeof data['spinButton'] === 'object') {\r\n                // object specifies button mode\r\n                btn.setMode(data['spinButton']);\r\n                btn.show();\r\n            }\r\n        }\r\n\r\n        if (winNewState === 'hidden') {\r\n            btnWin.hide();\r\n        } else {\r\n            btnWin.setDisabled(winNewState === 'disabled');\r\n            btnWin.show();\r\n        }\r\n\r\n        if (arrowLastVisible && riskNewState !== 'hidden') {\r\n            // arrow -> risk\r\n            btnRisk.hide();\r\n            btnRisk.setDisabled(riskNewState === 'disabled');\r\n            pubsub.publish('request:hideMenuHandle');\r\n            btnStateRunning = true;\r\n            self.view.actions.animateArrow('inflate', function () {\r\n                btnRisk.setDisabled(riskNewState === 'disabled');\r\n                btnRisk.show();\r\n                btnStateRunning = false;\r\n                if (btnStatePending) {\r\n                    mAdjustControls(null, btnStatePending);\r\n                }\r\n            });\r\n        } else if (!arrowLastVisible && arrowNewVisible) {\r\n            // risk -> arrow\r\n            btnRisk.hide();\r\n            btnStateRunning = true;\r\n            self.view.actions.animateArrow('deflate', function () {\r\n                pubsub.publish('request:showMenuHandle');\r\n                btnStateRunning = false;\r\n                if (btnStatePending) {\r\n                    mAdjustControls(null, btnStatePending);\r\n                }\r\n            });\r\n        } else {\r\n            if (riskNewState === 'hidden') {\r\n                btnRisk.hide();\r\n            } else {\r\n                btnRisk.setDisabled(riskNewState === 'disabled');\r\n                btnRisk.show();\r\n            }\r\n            if (arrowNewVisible) {\r\n                pubsub.publish('request:showMenuHandle');\r\n            } else if (!arrowNewVisible) {\r\n                pubsub.publish('request:hideMenuHandle');\r\n            }\r\n        }\r\n\r\n        lastTakeRiskState = data['takeRiskButton'];\r\n\r\n    }\r\n\r\n    function setSpinButtonClickable(val) {\r\n        self.view.elements.spinButton.setClickable(val);\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/mainButtons/mainButtonsCtrl.js"),
eval("define('components/DomButton',[\r\n    'jquery',\r\n    'pubsub',\r\n    'data/config',\r\n    'components/Element',\r\n    'services/assets'],\r\n        function (\r\n                $, pubsub, globalConfig, Element, assets) {\r\n\r\n            // basic image\r\n            return function create(options) {\r\n\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'DomButton';\r\n                self.click = options.click;\r\n                self.imgPath = options.imgPath;\r\n                self.disabledOpacity = options.disabledOpacity;\r\n                self.interactive = true;\r\n                self.viewUpdateCallback = options.viewUpdateCallback;\r\n\r\n                self.disabled = options.disabled || false;\r\n\r\n                var pressed = false;\r\n                var $doc = $(document);\r\n\r\n                var $el = $('<div class=\"dom-sprite\"></div>');\r\n\r\n                $el.css({\r\n                    'background-image': 'url('\r\n                            + assets.img(self.imgPath).baseTexture.imageUrl + ')',\r\n                    'background-size': '100% 100%',\r\n                    width: self.width,\r\n                    height: self.height,\r\n                    display: 'none'\r\n                });\r\n\r\n                $el.on('mousedown touchstart', function (e) {\r\n                    e.preventDefault();\r\n                    e.stopImmediatePropagation();\r\n                    if (globalConfig.TOGGLE_FULL_SCREEN_ON_POINTER\r\n                            && !globalConfig.DUMMY_DATA) {\r\n                        pubsub.publish('request:setFullScreen', {\r\n                            fullScreen: true\r\n                        });\r\n                    }\r\n                    if (!self.disabled) {\r\n                        pressed = true;\r\n                        updateView();\r\n                        $doc.on('mouseup.dombutton touchend.dombutton',\r\n                                function (e) {\r\n                                    e.preventDefault();\r\n                                    e.stopImmediatePropagation();\r\n                                    $doc.off('mouseup.dombutton touchend.dombutton');\r\n                                    if (pressed) {\r\n                                        pressed = false;\r\n                                        updateView();\r\n                                        if (e.target === $el[0]) {\r\n                                            self.click && self.click();\r\n                                        }\r\n                                    }\r\n                                    return false;\r\n                                });\r\n                    }\r\n                    return false;\r\n                });\r\n\r\n                self.jQueryEl = $el;\r\n                self.appendHTML();\r\n\r\n                self.setDisabled = function (d) {\r\n                    self.disabled = d;\r\n                    pressed = false;\r\n                    updateView();\r\n                };\r\n\r\n                return self;\r\n\r\n                function updateView() {\r\n                    if (pressed) {\r\n                        self.scaleX = .95;\r\n                        self.scaleY = .95;\r\n                    } else {\r\n                        self.scaleX = 1;\r\n                        self.scaleY = 1;\r\n                    }\r\n                    self.opacity = self.disabled ? (self.disabledOpacity ? self.disabledOpacity : .7) : 1;\r\n                    self.resize();\r\n                    if (self.viewUpdateCallback) {\r\n                        self.viewUpdateCallback();\r\n                    }\r\n                }\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/DomButton.js"),eval("define('components/MenuWrapper',[\r\n    'components/Element',\r\n    'components/SpriteSheetButton',\r\n    'components/DomRectangle',\r\n    'components/DomButton',\r\n], function (\r\n        Element, SpriteSheetButton, DomRectangle, DomButton) {\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'MenuWrapper';\r\n        self.homeButtonImgPath = 'menu/menu_btn';\r\n        self.canvasWidth = options.canvasWidth;\r\n        self.canvasHeight = options.canvasHeight;\r\n        self.height = self.canvasHeight;\r\n        self.left = 0;\r\n        self.top = 0;\r\n        self.menuButtonLeftLeftHand = options.menuButtonLeftLeftHand;\r\n        self.menuButtonLeftRightHand = options.menuButtonLeftRightHand;\r\n        self.menuButtonTop = options.menuButtonTop;\r\n        self.menuButtonWidth = options.menuButtonWidth;\r\n        self.menuButtonHeight = options.menuButtonHeight;\r\n        self.menuButtonZIndex = options.menuButtonZIndex;\r\n        self.contentOffsetLeft = options.contentOffsetLeft;\r\n        self.contentOffsetTop = options.contentOffsetTop;\r\n        self.bottomPanelLeft = options.bottomPanelLeft;\r\n        self.bottomPanelTop = options.bottomPanelTop;\r\n        self.bottomPanelWidth = options.bottomPanelWidth;\r\n        self.bottomPanelHeight = options.bottomPanelHeight;\r\n\r\n        self.disabled = options.disabled;\r\n        self.click = options.click;\r\n        self.bottomPanelClick = options.bottomPanelClick;\r\n\r\n// create PIXI element\r\n        var background = DomRectangle({\r\n            groupCtrl: self.groupCtrl,\r\n            color: 'rgba(0,0,0,.9)',\r\n            width: self.canvasWidth,\r\n            height: self.canvasHeight,\r\n            left: self.left,\r\n            top: self.top,\r\n            zIndex: 300,\r\n        });\r\n        var pagesContentWrap = DomRectangle({\r\n            groupCtrl: self.groupCtrl,\r\n            name: 'menu-pages-content-wrap',\r\n            color: 'none',\r\n            left: self.contentOffsetLeft,\r\n            top: self.contentOffsetTop,\r\n            width: self.canvasWidth,\r\n            height: self.canvasHeight,\r\n            zIndex: 300,\r\n        });\r\n        var bottomPanel = DomButton({\r\n            groupCtrl: self.groupCtrl,\r\n            name: 'menu-pages-bottom-panel',\r\n            left: self.bottomPanelLeft,\r\n            top: self.bottomPanelTop,\r\n            width: self.bottomPanelWidth,\r\n            height: self.bottomPanelHeight,\r\n            click: self.bottomPanelClick,\r\n        });\r\n        var menuButton = SpriteSheetButton({\r\n            groupCtrl: self.groupCtrl,\r\n            name: 'menu-handle-arrow',\r\n            imgPath: self.homeButtonImgPath,\r\n            currentLayout: 'righthand',\r\n            layouts: {\r\n                'lefthand': {\r\n                    props: {\r\n                        left: self.menuButtonLeftLeftHand,\r\n                    }\r\n                },\r\n                'righthand': {\r\n                    props: {\r\n                        left: self.menuButtonLeftRightHand,\r\n                    }\r\n                }\r\n            },\r\n            top: self.menuButtonTop,\r\n            width: self.menuButtonWidth,\r\n            height: self.menuButtonHeight,\r\n            centerVertical: true,\r\n            zIndex: self.menuButtonZIndex + .2,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            canvasLayer: 'ui',\r\n            disabled: self.disabled,\r\n            disabledOpacity: .5,\r\n            steps: 1,\r\n            scaleOnPress: true,\r\n            click: self.click,\r\n        });\r\n\r\n        self.jQueryEl = [background, pagesContentWrap, bottomPanel];\r\n        self.pixiEl = [menuButton];\r\n\r\n        self.setDisabled = function (val) {\r\n            self.disabled = val;\r\n            menuButton.setDisabled(self.disabled);\r\n        };\r\n        self.setOpen = function (open) {\r\n            if (open) {\r\n                self.open();\r\n            } else {\r\n                self.close();\r\n            }\r\n        };\r\n        self.open = function () {\r\n            self.show();\r\n            options.onOpen && options.onOpen();\r\n        };\r\n\r\n        self.show = function () {\r\n            self.visible = true;\r\n            menuButton.show();\r\n            background.show();\r\n            pagesContentWrap.show();\r\n            bottomPanel.show();\r\n        };\r\n\r\n        self.showHandle = function () {\r\n            self.visible = true;\r\n            menuButton.show();\r\n        };\r\n        self.hideHandle = function () {\r\n            self.visible = false;\r\n            menuButton.hide();\r\n        };\r\n\r\n        return self;\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/MenuWrapper.js"),eval("define('components/DomSprite',['jquery',\r\n    'components/Element',\r\n    'services/assets'\r\n], function ($, Element, assets) {\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'DomSprite';\r\n        self.imgPath = options.imgPath;\r\n\r\n        var $el = $('<div class=\"dom-sprite\"></div>');\r\n\r\n        $el.css({\r\n            'background-image': 'url('\r\n                    + assets.img(self.imgPath).baseTexture.imageUrl + ')',\r\n            'background-size': '100% 100%',\r\n            width: self.width,\r\n            height: self.height,\r\n            originX: self.originX,\r\n            'z-index': self.zIndex,\r\n            display: 'none'\r\n        });\r\n\r\n        if (self.flipX) {\r\n            $el.addClass('flipX');\r\n        }\r\n\r\n        $el.wrapper = self;\r\n\r\n        self.jQueryEl = $el;\r\n        self.appendHTML();\r\n        self.resize();\r\n\r\n\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/DomSprite.js"),eval("define('components/LabeledDomButton',[\r\n    'components/Element',\r\n    'components/DomButton',\r\n    'components/DomSprite',\r\n    'components/TextCss'],\r\n        function (\r\n                Element, DomButton, DomSprite, TextCss) {\r\n\r\n            // basic image\r\n            return function create(options) {\r\n\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'LabeledDomButton';\r\n                self.label = options.label;\r\n                self.labelStyle = options.labelStyle;\r\n                self.labelSize = options.labelSize;\r\n                self.labelOffsetTop = options.labelOffsetY;\r\n                self.zIndex = 302;\r\n\r\n                var sprite = DomSprite({\r\n                    groupCtrl: self.groupCtrl,\r\n                    parent: self.parent,\r\n                    imgPath: options.imgPath,\r\n                    left: self.left,\r\n                    top: self.top,\r\n                    width: self.width,\r\n                    height: self.height,\r\n                    zIndex: self.zIndex,\r\n                    originX: 'center',\r\n                    originY: 'center',\r\n                });\r\n\r\n                var btn = DomButton({\r\n                    groupCtrl: self.groupCtrl,\r\n                    parent: self.parent,\r\n                    imgPath: '',\r\n                    left: self.left,\r\n                    top: self.top,\r\n                    width: self.width + 70,\r\n                    height: self.height + 70,\r\n                    zIndex: self.zIndex,\r\n                    originX: 'center',\r\n                    originY: 'center',\r\n                    click: options.click,\r\n                    viewUpdateCallback: function () {\r\n                        sprite.set({\r\n                            scaleX: btn.scaleX,\r\n                            scaleY: btn.scaleY,\r\n                        });\r\n                        label.set({\r\n                            fontSize: btn.scaleX * self.labelSize,\r\n                        });\r\n                    }\r\n                });\r\n\r\n                var label = TextCss({\r\n                    groupCtrl: self.groupCtrl,\r\n                    parent: self.parent,\r\n                    left: self.left,\r\n                    top: self.top + sprite.height + self.labelOffsetTop,\r\n                    text: self.label,\r\n                    style: self.labelStyle,\r\n                    fontSize: self.labelSize,\r\n                    zIndex: self.zIndex,\r\n                    originX: 'center',\r\n                    originY: 'center',\r\n                });\r\n\r\n                self.pixiEl = [sprite, btn, label];\r\n\r\n                self.setDisabled = function (val) {\r\n                    btn.setDisabled(val);\r\n                    self.resize();\r\n                };\r\n\r\n                self.resize = function () {\r\n                    label.set({\r\n                        top: self.top + self.labelOffsetTop\r\n                    });\r\n                    btn.set({\r\n                        top: self.top,\r\n                        left: self.left,\r\n                        width: self.width + 70,\r\n                        height: self.height + 70,\r\n                    });\r\n                    label.set({\r\n                        opacity: btn.disabled ? 0.5 : 1\r\n                    });\r\n                    sprite.set({\r\n                        opacity: btn.disabled ? 0.5 : 1\r\n                    });\r\n                    sprite.resize();\r\n                    btn.resize();\r\n                    label.resize();\r\n                };\r\n\r\n\r\n                return self;\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/LabeledDomButton.js"),eval("define('components/DomTogglableButton',[\r\n    'components/Element',\r\n    'components/DomButton'\r\n], function (\r\n        Element, DomButton) {\r\n\r\n    // sprite sheet button\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'DomTogglableButton';\r\n        self.imgPathActive = options.imgPath;\r\n        self.imgPathInactive = options.imgPathInactive;\r\n\r\n        // inactive flag\r\n        self.inactive = options.inactive;\r\n        // event handlers\r\n        self.click = options.click;\r\n        // specify whether to switch inactive state of element by itself\r\n        self.doNotToggleInternally = options.doNotToggleInternally;\r\n\r\n        var elActive = DomButton({\r\n            parent: options.parent,\r\n            name: self.name + '-active',\r\n            imgPath: self.imgPathActive,\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            originX: self.originX,\r\n            originY: self.originY,\r\n            click: onClick,\r\n        });\r\n        var elInactive = DomButton({\r\n            parent: options.parent,\r\n            name: self.name + '-inactive',\r\n            imgPath: self.imgPathInactive,\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            originX: self.originX,\r\n            originY: self.originY,\r\n            click: onClick,\r\n        });\r\n\r\n        self.jQueryEl = [elActive, elInactive];\r\n\r\n        self.show = function () {\r\n            self.visible = true;\r\n            !self.inactive && elActive.show();\r\n            self.inactive && elInactive.show();\r\n        };\r\n\r\n        // update inactive flag\r\n        self.setInactive = function (state) {\r\n            if (state !== self.inactive) {\r\n                toggleState();\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function onClick() {\r\n            if (!self.doNotToggleInternally) {\r\n                toggleState();\r\n            }\r\n            self.click(self.inactive);\r\n        }\r\n        function toggleState() {\r\n            self.inactive = !self.inactive;\r\n            if (self.inactive) {\r\n                elActive.hide();\r\n                elInactive.show();\r\n            } else {\r\n                elInactive.hide();\r\n                elActive.show();\r\n            }\r\n        }\r\n\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/DomTogglableButton.js"),eval("// menuView\r\n// contains basic menu frame and main buttons elements\r\ndefine('layers/menu/menuView',[\r\n    'data/config',\r\n    'data/config-menu',\r\n    'components/MenuWrapper',\r\n    'components/Text',\r\n    'components/DomButton',\r\n    'components/DomRectangle',\r\n    'components/LabeledDomButton',\r\n    'components/DomTogglableButton',\r\n], function (globalConfig, config, MenuWrapper, Text,\r\n        DomButton, DomRectangle, LabeledDomButton, DomTogglableButton) {\r\n\r\n    return function mCreate(ctrl) {\r\n\r\n        function positionButtons(arr) {\r\n            var sizeX = config.MENU_MAIN_BUTTONS_WIDTH;\r\n            var sizeY = config.MENU_MAIN_BUTTONS_HEIGHT;\r\n            var centerX = config.MENU_MAIN_BUTTONS_CENTER_X;\r\n            var centerY = config.MENU_MAIN_BUTTONS_CENTER_Y;\r\n            var marginX = config.MENU_MAIN_BUTTONS_MARGIN_X;\r\n            var marginY = config.MENU_MAIN_BUTTONS_MARGIN_Y;\r\n            var rows = 2;\r\n            var cols = Math.ceil(arr.length / rows);\r\n            var startX = centerX + sizeX / 2 - (((cols * sizeX)\r\n                    + marginX * (cols - 1)) / 2);\r\n            var startY = centerY + sizeY / 2 - (((rows * sizeY)\r\n                    + marginY * (rows - 1)) / 2);\r\n            var item, row, col;\r\n            for (row = 0; row < rows; row++) {\r\n                for (col = 0; col < cols; col++) {\r\n                    item = arr[row * cols + col];\r\n                    item && item.set({\r\n                        left: startX + col * (sizeX + marginX),\r\n                        top: startY + row * (sizeY + marginY),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        var elements = {};\r\n        elements.container = MenuWrapper({\r\n            groupCtrl: ctrl,\r\n            name: 'menu-container',\r\n            currentLayout: 'righthand',\r\n            menuButtonLeftLeftHand: config.MENU_BUTTON_LEFT_LEFTHAND,\r\n            menuButtonLeftRightHand: config.MENU_BUTTON_LEFT_RIGHTHAND,\r\n            menuButtonTop: config.MENU_BUTTON_TOP,\r\n            menuButtonWidth: config.MENU_BUTTON_WIDTH,\r\n            menuButtonHeight: config.MENU_BUTTON_HEIGHT,\r\n            canvasWidth: globalConfig.CANVAS_BASE_WIDTH,\r\n            canvasHeight: globalConfig.CANVAS_BASE_HEIGHT,\r\n            contentOffsetTop: config.PAGES_CONTENT_OFFSET_TOP,\r\n            contentOffsetLeft: config.PAGES_CONTENT_OFFSET_LEFT,\r\n            bottomPanelLeft: config.BOTTOM_PANEL_LEFT,\r\n            bottomPanelTop: config.BOTTOM_PANEL_TOP,\r\n            bottomPanelWidth: config.BOTTOM_PANEL_WIDTH,\r\n            bottomPanelHeight: config.BOTTOM_PANEL_HEIGHT,\r\n            zIndex: 20,\r\n            menuButtonZIndex: 25,\r\n            canvasLayer: 'ui',\r\n            click: ctrl.viewActions.menuArrowClicked,\r\n            bottomPanelClick: ctrl.viewActions.closeButtonClicked,\r\n        });\r\n        elements.dividers = DomRectangle({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-dividers',\r\n            color: 'none',\r\n            css: {\r\n                'border-top': '1px solid #4e5251',\r\n                'border-bottom': '1px solid #4e5251',\r\n            },\r\n            left: 0,\r\n            top: config.TOP_DIVIDER_TOP,\r\n            height: config.BOTTOM_DIVIDER_TOP - config.TOP_DIVIDER_TOP,\r\n            width: globalConfig.CANVAS_BASE_WIDTH,\r\n            zIndex: 302,\r\n        });\r\n        elements.headerLeft = Text({\r\n            name: 'menu-menu-header-left',\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[1],\r\n            left: config.MENU_LEFT_HEADER_LEFT,\r\n            top: config.MENU_HEADER_TOP,\r\n            text: 'menu',\r\n            fontSize: config.MENU_HEADER_FONT_SIZE,\r\n            originX: 'left',\r\n            zIndex: 22,\r\n            style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n            canvasLayer: 'ui',\r\n        });\r\n        elements.headerRight = Text({\r\n            name: 'menu-menu-header-right',\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[1],\r\n            left: config.MENU_RIGHT_HEADER_LEFT,\r\n            top: config.MENU_HEADER_TOP,\r\n            text: '!' + globalConfig.GAME_NAME,\r\n            fontSize: config.MENU_HEADER_FONT_SIZE,\r\n            originX: 'right',\r\n            zIndex: 22,\r\n            style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n            canvasLayer: 'ui',\r\n        });\r\n        elements.rulesButton = LabeledDomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-rules-button',\r\n            imgPath: 'menu/paytable_btn',\r\n            left: 0,\r\n            top: 0,\r\n            width: config.MENU_MAIN_BUTTONS_WIDTH,\r\n            height: config.MENU_MAIN_BUTTONS_HEIGHT,\r\n            disabledOpacity: .5,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            label: 'menuRules',\r\n            labelStyle: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            labelSize: config.MENU_MAIN_BUTTONS_FONT_SIZE,\r\n            labelOffsetY: config.MENU_MAIN_BUTTONS_LABEL_OFFSET_Y,\r\n            click: ctrl.viewActions.rulesButtonClicked,\r\n        });\r\n        elements.betButton = LabeledDomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-bet-button',\r\n            imgPath: 'menu/bet_settings',\r\n            left: 0,\r\n            top: 0,\r\n            width: config.MENU_MAIN_BUTTONS_WIDTH,\r\n            height: config.MENU_MAIN_BUTTONS_HEIGHT,\r\n            disabledOpacity: .5,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            label: 'menuBet',\r\n            labelStyle: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            labelSize: config.MENU_MAIN_BUTTONS_FONT_SIZE,\r\n            labelOffsetY: config.MENU_MAIN_BUTTONS_LABEL_OFFSET_Y,\r\n            click: ctrl.viewActions.betButtonClicked,\r\n        });\r\n        elements.optionsButton = LabeledDomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-options-button',\r\n            imgPath: 'menu/autoplay_settings_btn',\r\n            left: 0,\r\n            top: 0,\r\n            width: config.MENU_MAIN_BUTTONS_WIDTH,\r\n            height: config.MENU_MAIN_BUTTONS_HEIGHT,\r\n            disabledOpacity: .5,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            label: 'menuAutoplay',\r\n            labelStyle: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            labelSize: config.MENU_MAIN_BUTTONS_FONT_SIZE,\r\n            labelOffsetY: config.MENU_MAIN_BUTTONS_LABEL_OFFSET_Y,\r\n            click: ctrl.viewActions.optionsButtonClicked,\r\n        });\r\n        elements.localeButton = LabeledDomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-locale-button',\r\n            imgPath: 'menu/language_settings_btn',\r\n            left: 0,\r\n            top: 0,\r\n            width: config.MENU_MAIN_BUTTONS_WIDTH,\r\n            height: config.MENU_MAIN_BUTTONS_HEIGHT,\r\n            disabledOpacity: .5,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            label: 'menuLocale',\r\n            labelStyle: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            labelSize: config.MENU_MAIN_BUTTONS_FONT_SIZE,\r\n            labelOffsetY: config.MENU_MAIN_BUTTONS_LABEL_OFFSET_Y,\r\n            click: ctrl.viewActions.localeButtonClicked,\r\n        });\r\n\r\n        elements.videoButton = LabeledDomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-video-button',\r\n            imgPath: 'menu/interface_settings_btn',\r\n            left: 0,\r\n            top: 0,\r\n            width: config.INTERFACE_BUTTON_WIDTH,\r\n            height: config.INTERFACE_BUTTON_HEIGHT,\r\n            disabledOpacity: .5,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            label: 'menuInterface',\r\n            labelStyle: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            labelSize: config.MENU_MAIN_BUTTONS_FONT_SIZE,\r\n            labelOffsetY: config.MENU_MAIN_BUTTONS_LABEL_OFFSET_Y,\r\n            click: ctrl.viewActions.videoButtonClicked,\r\n        });\r\n\r\n        elements.soundButton = LabeledDomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-sound-button',\r\n            imgPath: 'menu/sound_settings_btn',\r\n            left: 0,\r\n            top: 0,\r\n            width: config.SOUND_BUTTON_WIDTH,\r\n            height: config.SOUND_BUTTON_HEIGHT,\r\n            disabledOpacity: .5,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            label: 'menuSound',\r\n            labelStyle: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            labelSize: config.MENU_MAIN_BUTTONS_FONT_SIZE,\r\n            labelOffsetY: config.MENU_MAIN_BUTTONS_LABEL_OFFSET_Y,\r\n            click: ctrl.viewActions.soundButtonClicked,\r\n        });\r\n        elements.soundToggleButton = DomTogglableButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-sound-toggle-button',\r\n            imgPath: 'menu/sound_toggle_on',\r\n            imgPathInactive: 'menu/sound_toggle_off',\r\n            left: config.SOUND_TOGGLE_BUTTON_LEFT,\r\n            top: config.SOUND_TOGGLE_BUTTON_TOP,\r\n            width: config.SOUND_TOGGLE_BUTTON_WIDTH,\r\n            height: config.SOUND_TOGGLE_BUTTON_HEIGHT,\r\n            inactive: true,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            click: ctrl.viewActions.soundToggleButtonClicked,\r\n        });\r\n        elements.homeButton = DomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-home-button',\r\n            imgPath: 'menu/exit_btn',\r\n            left: config.HOME_BUTTON_LEFT,\r\n            top: config.HOME_BUTTON_TOP,\r\n            width: config.HOME_BUTTON_WIDTH,\r\n            height: config.HOME_BUTTON_HEIGHT,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            click: ctrl.viewActions.homeButtonClicked,\r\n        });\r\n        elements.backButton = DomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-back-button',\r\n            imgPath: 'menu/menu_btn',\r\n            currentLayout: 'righthand',\r\n            layouts: {\r\n                'righthand': {\r\n                    props: {\r\n                        left: config.MENU_BUTTON_LEFT_RIGHTHAND,\r\n                    }\r\n                },\r\n                'lefthand': {\r\n                    props: {\r\n                        left: config.MENU_BUTTON_LEFT_LEFTHAND,\r\n                    }\r\n                }\r\n\r\n            },\r\n            top: config.MENU_BUTTON_TOP,\r\n            width: config.MENU_BUTTON_WIDTH,\r\n            height: config.MENU_BUTTON_HEIGHT,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            centerVertical: true,\r\n            click: ctrl.viewActions.backButtonClicked,\r\n        });\r\n        elements.closeButton = DomButton({\r\n            groupCtrl: ctrl,\r\n            parent: elements.container.jQueryEl[0],\r\n            name: 'menu-close-button',\r\n            imgPath: 'menu/back_btn',\r\n            currentLayout: 'righthand',\r\n            layouts: {\r\n                'righthand': {\r\n                    props: {\r\n                        left: config.CLOSE_BUTTON_LEFT_RIGHTHAND,\r\n                        flipX: false,\r\n                    }\r\n                },\r\n                'lefthand': {\r\n                    props: {\r\n                        left: config.CLOSE_BUTTON_LEFT_LEFTHAND,\r\n                        flipX: true,\r\n                    }\r\n                }\r\n\r\n            },\r\n            top: config.CLOSE_BUTTON_TOP,\r\n            width: config.CLOSE_BUTTON_WIDTH,\r\n            height: config.CLOSE_BUTTON_HEIGHT,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            centerVertical: true,\r\n            click: ctrl.viewActions.closeButtonClicked,\r\n        });\r\n\r\n        elements.container.jQueryEl[1].addChildren([\r\n            elements.headerLeft,\r\n            elements.headerRight,\r\n        ]);\r\n        elements.container.jQueryEl[0].addChildren([\r\n            elements.dividers,\r\n            elements.rulesButton,\r\n            elements.betButton,\r\n            elements.optionsButton,\r\n            elements.localeButton,\r\n            elements.videoButton,\r\n            elements.soundButton,\r\n            elements.soundToggleButton,\r\n            elements.homeButton,\r\n            elements.backButton\r\n        ]);\r\n        positionButtons([\r\n            elements.rulesButton,\r\n            elements.betButton,\r\n            elements.optionsButton,\r\n            elements.videoButton,\r\n            elements.soundButton,\r\n            elements.localeButton,\r\n        ]);\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n            }\r\n        };\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menu/menuView.js"),eval("// menuCtrl\r\n// controls the basic menu frame\r\n// and main buttons (info, autoplay, graphics, sound)\r\ndefine('layers/menu/menuCtrl',[\r\n    'pubsub',\r\n    'components/GroupCtrl',\r\n    'layers/menu/menuView',\r\n    'services/settings',\r\n    'services/i18n',\r\n], function (pubsub, GroupCtrl, menuView, settings, i18n) {\r\n\r\n// initialize self\r\n    var self = GroupCtrl();\r\n    var lastDisplayedPage = 0;\r\n    var currentActivity = null;\r\n    var $html = $('html');\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        menuArrowClicked: function () {\r\n            lastDisplayedPage = 0;\r\n            pubsub.publish('request:loadMenu');\r\n        },\r\n        onOpen: function () {\r\n            closeMenu();\r\n        },\r\n        rulesButtonClicked: function () {\r\n            setMenuControlsVisible(false);\r\n            pubsub.publish('request:hideMenuPages');\r\n            pubsub.publish('request:showMenuPage5');\r\n            lastDisplayedPage = 5;\r\n        },\r\n        betButtonClicked: function () {\r\n            setMenuControlsVisible(false);\r\n            pubsub.publish('request:hideMenuPages');\r\n            pubsub.publish('request:showMenuPage1');\r\n            lastDisplayedPage = 1;\r\n        },\r\n        optionsButtonClicked: function () {\r\n            setMenuControlsVisible(false);\r\n            pubsub.publish('request:hideMenuPages');\r\n            pubsub.publish('request:showMenuPage2');\r\n            lastDisplayedPage = 2;\r\n        },\r\n        localeButtonClicked: function () {\r\n            setMenuControlsVisible(false);\r\n            pubsub.publish('request:hideMenuPages');\r\n            pubsub.publish('request:showMenuPage6');\r\n            lastDisplayedPage = 6;\r\n        },\r\n        videoButtonClicked: function () {\r\n            setMenuControlsVisible(false);\r\n            pubsub.publish('request:hideMenuPages');\r\n            pubsub.publish('request:showMenuPage3');\r\n            lastDisplayedPage = 3;\r\n        },\r\n        soundButtonClicked: function () {\r\n            setMenuControlsVisible(false);\r\n            pubsub.publish('request:hideMenuPages');\r\n            pubsub.publish('request:showMenuPage4');\r\n            lastDisplayedPage = 4;\r\n        },\r\n        backButtonClicked: function () {\r\n            if (lastDisplayedPage === 0) {\r\n                closeMenu();\r\n            } else {\r\n                pubsub.publish('request:hideMenuPages');\r\n                setMenuControlsVisible(true);\r\n                lastDisplayedPage = 0;\r\n            }\r\n        },\r\n        soundToggleButtonClicked: function () {\r\n            pubsub.publish('notify:masterSoundSwitchChanged', {\r\n                callback: function () {\r\n                    updateView(settings.get());\r\n                }\r\n            });\r\n        },\r\n        homeButtonClicked: function () {\r\n            pubsub.publish('request:showDialog', {\r\n                text: i18n.localize('doYouWishToExitGame'),\r\n                buttonRight: 'tick',\r\n                buttonLeft: 'cross',\r\n                oneLiner: true,\r\n                buttonRightAction: function () {\r\n                    pubsub.publish('request:exit');\r\n                },\r\n                buttonLeftAction: function () {\r\n                },\r\n            });\r\n        },\r\n        closeButtonClicked: function () {\r\n            closeMenu();\r\n        },\r\n    };\r\n    // initialize view\r\n    self.view = menuView(self);\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:showMenu': function (id, data) {\r\n            $html.addClass('menu');\r\n            self.showAll();\r\n            var rq;\r\n            if (data.page !== undefined) {\r\n                lastDisplayedPage = data.page;\r\n            }\r\n            rq = 'request:showMenuPage' + lastDisplayedPage;\r\n            if (lastDisplayedPage === 0) {\r\n                setMenuControlsVisible(true);\r\n            } else {\r\n                setMenuControlsVisible(false);\r\n                pubsub.publish(rq);\r\n            }\r\n            updateView(data.settings);\r\n            pubsub.publish('request:initMenuViews', {\r\n                model: data.settings,\r\n                gameModel: data.gameModel,\r\n                betModel: data.betModel\r\n            });\r\n            pubsub.publish('notify:menuStateChange', 'openEnd');\r\n        },\r\n        'request:closeMenu': function (id, data) {\r\n            closeMenu();\r\n        },\r\n        'request:adjustControls': function (id, data) {\r\n            if (data.menuButton === 'hidden') {\r\n            } else if (data.menuButton === 'disabled') {\r\n                self.view.elements.container.setDisabled(true);\r\n            } else if (data.menuButton === 'active') {\r\n                self.view.elements.container.setDisabled(false);\r\n            }\r\n        },\r\n        'request:showMenuHandle': function (id, data) {\r\n            self.view.elements.container.showHandle();\r\n        },\r\n        'request:hideMenuHandle': function (id, data) {\r\n            self.view.elements.container.hideHandle();\r\n        },\r\n        'notify:activityAfterStart': function (id, data) {\r\n            currentActivity = data.activity;\r\n        },\r\n        'notify:subactivityStarted': function (id, data) {\r\n            if (data.activity === 'idle') {\r\n                setMenuDisabled(true);\r\n            }\r\n        },\r\n        'notify:subactivityFinished': function (id, data) {\r\n            if (data.activity === 'idle') {\r\n                setMenuDisabled(false);\r\n            }\r\n        },\r\n        'request:updateSoundViews': function () {\r\n            updateView(settings.get());\r\n        },\r\n    });\r\n    return self;\r\n    // helpers\r\n    function setMenuControlsVisible(visible) {\r\n        if (visible) {\r\n            self.view.elements.headerLeft.show();\r\n            self.view.elements.rulesButton.show();\r\n            self.view.elements.betButton.show();\r\n            self.view.elements.optionsButton.show();\r\n            self.view.elements.localeButton.show();\r\n            self.view.elements.videoButton.show();\r\n            self.view.elements.soundButton.show();\r\n            if (currentActivity === 'idle') {\r\n                self.view.elements.betButton.setDisabled(false);\r\n            } else {\r\n                self.view.elements.betButton.setDisabled(true);\r\n            }\r\n        } else {\r\n            self.view.elements.headerLeft.hide();\r\n            self.view.elements.rulesButton.hide();\r\n            self.view.elements.betButton.hide();\r\n            self.view.elements.optionsButton.hide();\r\n            self.view.elements.localeButton.hide();\r\n            self.view.elements.videoButton.hide();\r\n            self.view.elements.soundButton.hide();\r\n        }\r\n    }\r\n    function updateView(model) {\r\n        self.view.elements.soundToggleButton.setInactive(!model.sound.master.active);\r\n    }\r\n    function setMenuDisabled(val) {\r\n        self.view.elements.container.setDisabled(val);\r\n    }\r\n    function closeMenu() {\r\n        $html.removeClass('menu');\r\n        self.hideAll();\r\n        pubsub.publish('notify:menuStateChange', 'closeEnd');\r\n        pubsub.publish('request:viewUpdate');\r\n        pubsub.publish('request:hideMenuPages');\r\n        settings.save();\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menu/menuCtrl.js"),
eval("// reelsView\r\n// contains reel symbol elements in viewModel\r\n// representing the reelsCtrl model\r\n// handles resizing and rendering of the model\r\ndefine('layers/reels/reelsView',[\r\n    'pixi',\r\n    'data/config',\r\n    'services/engine',\r\n    'services/assets',\r\n    'services/dimensions',\r\n], function (PIXI, config, engine, assets, dimensions) {\r\n\r\n    var ctrl = null;\r\n    // view model contains PIXI sprite elements representing the controller model\r\n    var viewModel = null;\r\n    // specified whether the view is currently visible\r\n    var visible = null;\r\n    // represent the main PIXI container for the stage\r\n    var container = null;\r\n    // define vars used by view functions\r\n    var model, element, i, k, x, y, reel, firstChecked, positionOffset,\r\n            drawnSymbolIndex, symbol, prerendered;\r\n    // reels background data\r\n    var spritePool = {};\r\n    var background = null;\r\n    var API = {\r\n        show: mShow,\r\n        hide: mHide,\r\n        initialize: mInitialize,\r\n        update: renderStage,\r\n        resize: mResize,\r\n        inject: mInject,\r\n        remove: mRemove,\r\n        setBackground: mSetBackground,\r\n        viewModel: null,\r\n        background: null,\r\n    };\r\n    return API;\r\n    // show all symbols\r\n    function mShow() {\r\n        visible = true;\r\n        mResize();\r\n    }\r\n    // hide all symbols\r\n    function mHide() {\r\n        if (viewModel) {\r\n            var elKeys = Object.keys(viewModel);\r\n            for (var m = 0; m < elKeys.length; m++) {\r\n                if (viewModel[elKeys] !== null) {\r\n                    viewModel[elKeys].visible = false;\r\n                }\r\n            }\r\n        }\r\n        visible = false;\r\n        container.needsRepaint = true;\r\n    }\r\n    // initialize with current controller model\r\n    function mInitialize(mCtrl) {\r\n        if (!ctrl) {\r\n            ctrl = mCtrl;\r\n            container = engine.getContainer('back');\r\n        }\r\n        cacheSymbols();\r\n        updateSizes();\r\n        return API;\r\n    }\r\n    // resize and render the view elements\r\n    function mResize() {\r\n        if (visible) {\r\n            updateSizes();\r\n            renderStage();\r\n        }\r\n    }\r\n    // set current reels background\r\n    function mSetBackground(data) {\r\n        if (!data) {\r\n            return;\r\n        }\r\n        if (background && background.sprite) {\r\n            if (background.imgPath === data.imgPath\r\n                    && container.children.indexOf(background.sprite) > -1) {\r\n                return;\r\n            }\r\n            container.removeChild(background.sprite);\r\n            releaseSprite(background.sprite);\r\n        }\r\n        background = data;\r\n        background.sprite = getSprite(data.imgPath);\r\n        background.sprite.wrapper = {zIndex: 5};\r\n        background.sprite.width = data.width * config.REELS_AREA_SCALE;\r\n        background.sprite.height = data.height * config.REELS_AREA_SCALE;\r\n        background.sprite.visible = true;\r\n        background.resize = function () {\r\n            background.sprite.x = data.left;\r\n            background.sprite.x -= (config.REELS_AREA_SCALE - 1)\r\n                    * ((config.CANVAS_BASE_WIDTH / 2) - background.sprite.x);\r\n            background.sprite.x += config.REELS_AREA_OFFSET_LEFT;\r\n            background.sprite.y = data.top;\r\n            background.sprite.y -= (config.REELS_AREA_SCALE - 1)\r\n                    * ((config.CANVAS_BASE_HEIGHT / 2) - background.sprite.y);\r\n            background.sprite.y += config.REELS_AREA_OFFSET_TOP;\r\n            background.sprite.x += (dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX);\r\n            background.sprite.y += (dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY);\r\n        };\r\n        background.resize();\r\n        container.addChild(background.sprite);\r\n        container.reorder();\r\n        container.needsRepaint = true;\r\n        API.background = background;\r\n    }\r\n    // render the view\r\n    function renderStage() {\r\n        model = ctrl.model;\r\n        for (i = 0; i < model.length; i++) {\r\n            reel = model[i];\r\n            var testPos = reel.position - model[0].dragOffset;\r\n            firstChecked = Math.floor(testPos);\r\n            positionOffset = testPos - firstChecked;\r\n            for (k = -ctrl.currentReelSet.SAFE_INJECTION_POSITION_DELTA;\r\n                    k < reel.symbols.length\r\n                    - ctrl.currentReelSet.SAFE_INJECTION_POSITION_DELTA; k++) {\r\n                drawnSymbolIndex = adjustPosition(reel, firstChecked + k);\r\n                element = viewModel[i][drawnSymbolIndex];\r\n                if (element === null) {\r\n                    continue;\r\n                }\r\n                symbol = reel.symbols[drawnSymbolIndex];\r\n\r\n                if (k > ctrl.currentReelSet.INJECTION_ROWS_OFFSET\r\n                        + ctrl.currentReelSet.VISIBLE_SYMBOLS_ON_REEL\r\n                        || reel.hiddenSymbols.indexOf(drawnSymbolIndex) > -1\r\n                        || (k < -ctrl.currentReelSet.INJECTION_ROWS_OFFSET\r\n                                && !symbol.size)\r\n                        ) {\r\n\r\n                    // element is out of view\r\n                    // or is requested to be hidden by controller\r\n//                    if (i === 0) {\r\n//                        console.log('not rendering: ' + drawnSymbolIndex);\r\n//                    }\r\n\r\n                    element.visible = false;\r\n                    element.shadow && (element.shadow.visible = false);\r\n                    continue;\r\n                }\r\n\r\n                element.visible = true;\r\n                element.shadow && (element.shadow.visible = true);\r\n                var symbolSet = symbol.symbolSet;\r\n\r\n                //>>includeStart(\"debug\", pragmas.debug);\r\n                if (window.forceSymbolSet) {\r\n                    symbolSet = forceSymbolSet;\r\n                    if (window.forceSymbol && symbol.name === 'f' + forceSymbol) {\r\n                        symbol = symbolSet.symbols[forceSymbol];\r\n                    }\r\n                }\r\n                //>>includeEnd(\"debug\");\r\n\r\n                // update position on screen\r\n                x = ctrl.currentReelSet.REELS_CANVAS_LEFT\r\n                        + symbolSet.ALL_REELS_OFFSET_LEFT\r\n                        + i * symbolSet.SYMBOL_OUTER_WIDTH;\r\n                if (symbolSet.SPECIFIC_REELS_OFFSETS_LEFT[i]) {\r\n                    x += symbolSet.SPECIFIC_REELS_OFFSETS_LEFT[i];\r\n                }\r\n                if (symbol.offsetX) {\r\n                    x += symbol.offsetX;\r\n                }\r\n                y = ctrl.currentReelSet.REELS_CANVAS_TOP\r\n                        + symbolSet.ALL_REELS_OFFSET_TOP\r\n                        - positionOffset * symbolSet.SYMBOL_OUTER_HEIGHT\r\n                        + k * symbolSet.SYMBOL_OUTER_HEIGHT;\r\n                if (symbol.keepProportions && symbol.anchor === 'bottom') {\r\n                    y += symbolSet.SYMBOL_DEFAULT_RENDER_HEIGHT\r\n                            - element.defaultHeight;\r\n                }\r\n                if (symbol.offsetY) {\r\n                    y += symbol.offsetY;\r\n                }\r\n                if (symbol.offsets) {\r\n                    y += symbol.offsets[symbol.static].y;\r\n                    x += symbol.offsets[symbol.static].x;\r\n                }\r\n\r\n                if (element.shadow) {\r\n                    element.shadow.x = x + symbolSet.SYMBOLS_SHADOW.offsetX;\r\n                    element.shadow.y = y + symbolSet.SYMBOLS_SHADOW.offsetY;\r\n                    element.shadow.x -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_WIDTH / 2) - element.shadow.x);\r\n                    element.shadow.y -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_HEIGHT / 2) - element.shadow.y);\r\n                    element.shadow.x += config.REELS_AREA_OFFSET_LEFT;\r\n                    element.shadow.y += config.REELS_AREA_OFFSET_TOP;\r\n                    element.shadow.x += dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX;\r\n                    element.shadow.y += dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY;\r\n                }\r\n\r\n                x -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_WIDTH / 2) - x);\r\n                y -= (config.REELS_AREA_SCALE - 1) * ((config.CANVAS_BASE_HEIGHT / 2) - y);\r\n\r\n                x += config.REELS_AREA_OFFSET_LEFT;\r\n                y += config.REELS_AREA_OFFSET_TOP;\r\n\r\n                x += dimensions.topLevelWrappersOffsetX / dimensions.canvasScaleX;\r\n                y += dimensions.topLevelWrappersOffsetY / dimensions.canvasScaleY;\r\n\r\n                element.x = x;\r\n                element.y = y;\r\n\r\n            }\r\n        }\r\n        container.needsRepaint = true;\r\n    }\r\n\r\n\r\n    // inject spin result symbols in the spinning reel\r\n    // according to the reel controller model\r\n    function mInject(reelIndex, positionsArray) {\r\n        var reel = ctrl.model[reelIndex];\r\n        var symbol, element;\r\n        for (i = 0; i < positionsArray.length; i++) {\r\n            var pos = positionsArray[i];\r\n            symbol = reel.symbols[pos];\r\n            element = viewModel[reelIndex][pos];\r\n            if (element) {\r\n                if (element.shadow) {\r\n                    container.removeChild(element.shadow);\r\n                    releaseSprite(element.shadow);\r\n                }\r\n                container.removeChild(element);\r\n                releaseSprite(element);\r\n            }\r\n//          console.log('reel = ' + reelIndex + ', positionsArray = ' + positionsArray);\r\n            if (symbol.segment) {\r\n                if (symbol.segment === '00') {\r\n                    element = getSprite(symbol.static);\r\n                } else {\r\n                    viewModel[reelIndex][pos] = null;\r\n                    continue;\r\n                }\r\n            } else {\r\n                element = getSprite(symbol.static);\r\n            }\r\n\r\n            element.visible = false;\r\n            element.wrapper = {zIndex: symbol.stayOnTop ? 10 : 9};\r\n            element.wrapper.zIndex -= i / 100;\r\n            element.name = symbol.name;\r\n            container.addChild(element);\r\n            viewModel[reelIndex][pos] = element;\r\n\r\n            if (symbol.shadow) {\r\n                element.shadow = getSprite(symbol.symbolSet.SYMBOLS_SHADOW.img);\r\n                element.shadow.visible = false;\r\n                element.shadow.wrapper = {zIndex: 7};\r\n                container.addChild(element.shadow);\r\n            }\r\n\r\n            resizeSprite(element, symbol);\r\n        }\r\n        container.reorder();\r\n    }\r\n    // remove old symbols from previous spin after they slide off the screen\r\n    // during spin\r\n    function mRemove(reelIndex, deleteIndexes) {\r\n        var el;\r\n        for (var i = 0; i < deleteIndexes.length; i++) {\r\n            el = viewModel[reelIndex][deleteIndexes[i]];\r\n            if (el) {\r\n                if (el.shadow) {\r\n                    container.removeChild(el.shadow);\r\n                    releaseSprite(el.shadow);\r\n                }\r\n                container.removeChild(el);\r\n                releaseSprite(el);\r\n                delete viewModel[reelIndex][deleteIndexes[i]];\r\n            }\r\n        }\r\n    }\r\n    // resize all symbols\r\n    function updateSizes() {\r\n        model = ctrl.model;\r\n        for (i = 0; i < model.length; i++) {\r\n            reel = model[i];\r\n            var symbols = reel.symbols;\r\n            for (k = 0; k < symbols.length; k++) {\r\n                element = viewModel[i][k];\r\n                if (element !== null) {\r\n                    resizeSprite(element, symbols[k]);\r\n                }\r\n            }\r\n        }\r\n        background && background.resize();\r\n    }\r\n\r\n    // resize single symbol\r\n    function resizeSprite(element, symbol) {\r\n        var symbolSet = symbol.symbolSet;\r\n        var width, height;\r\n        if (symbol.width) {\r\n            if (typeof (symbol.width) === 'object') {\r\n                width = symbol.width[symbol.static];\r\n            } else {\r\n                width = symbol.width;\r\n            }\r\n        } else {\r\n            if (symbol.size && symbol.size.x > 1) {\r\n                width = symbolSet.SYMBOL_DEFAULT_RENDER_WIDTH * symbol.size.x\r\n                        + (symbol.size.x - 1 * (symbolSet.SYMBOL_OUTER_WIDTH -\r\n                                symbolSet.SYMBOL_DEFAULT_RENDER_WIDTH));\r\n            } else {\r\n                width = symbolSet.SYMBOL_DEFAULT_RENDER_WIDTH;\r\n            }\r\n        }\r\n        if (symbol.keepProportions) {\r\n            var imgH = assets.img(symbol.static).height;\r\n            var imgW = assets.img(symbol.static).width;\r\n            var ratio = imgH / imgW;\r\n            height = width * ratio;\r\n        } else if (symbol.height) {\r\n            if (typeof (symbol.height) === 'object') {\r\n                height = symbol.height[symbol.static];\r\n            } else {\r\n                height = symbol.height;\r\n            }\r\n        } else {\r\n            if (symbol.size && symbol.size.y > 1) {\r\n                height = symbolSet.SYMBOL_DEFAULT_RENDER_HEIGHT * symbol.size.y\r\n                        + (symbol.size.y - 1 * (symbolSet.SYMBOL_OUTER_HEIGHT\r\n                                - symbolSet.SYMBOL_DEFAULT_RENDER_HEIGHT));\r\n            } else {\r\n                height = symbolSet.SYMBOL_DEFAULT_RENDER_HEIGHT;\r\n            }\r\n        }\r\n\r\n        element.defaultHeight = height * config.REELS_AREA_SCALE;\r\n        element.width = width * config.REELS_AREA_SCALE;\r\n        element.height = height * config.REELS_AREA_SCALE;\r\n\r\n        if (element.shadow) {\r\n            element.shadow.width = symbol.symbolSet.SYMBOLS_SHADOW.width * config.REELS_AREA_SCALE;\r\n            element.shadow.height = symbol.symbolSet.SYMBOLS_SHADOW.height * config.REELS_AREA_SCALE;\r\n        }\r\n    }\r\n\r\n    // generate PIXI sprites for each symbol in model\r\n    // and add them in container element\r\n    function cacheSymbols() {\r\n        var ch = container.children.length;\r\n        for (var i = 0; i < ch; i++) {\r\n            if (!background || container.children[i] !== background.sprite) {\r\n                releaseSprite(container.children[i]);\r\n                container.removeChildAt(i);\r\n                i--;\r\n                ch--;\r\n            }\r\n        }\r\n        viewModel = {};\r\n        API.viewModel = viewModel;\r\n        model = ctrl.model;\r\n        for (i = 0; i < model.length; i++) {\r\n            if (!viewModel[i]) {\r\n                viewModel[i] = {};\r\n            }\r\n            reel = model[i];\r\n            var symbols = reel.symbols;\r\n            for (k = 0; k < symbols.length; k++) {\r\n                prerendered = {};\r\n                var symIndex = adjustPosition(reel, k + reel.position);\r\n                symbol = symbols[symIndex];\r\n                if (symbol.segment) {\r\n                    if (symbol.segment === '00') {\r\n                        prerendered = getSprite(symbol.static);\r\n                    } else {\r\n                        viewModel[i][symIndex] = null;\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    prerendered = getSprite(symbol.static);\r\n                }\r\n\r\n                prerendered.wrapper = {zIndex: symbol.stayOnTop ? 10 : 9};\r\n                prerendered.wrapper.zIndex -= k / 50;\r\n                prerendered.visible = false;\r\n                prerendered.name = symbol.name;\r\n                viewModel[i][symIndex] = prerendered;\r\n                container.addChild(prerendered);\r\n\r\n                if (symbol.shadow) {\r\n                    prerendered.shadow = getSprite(symbol.symbolSet.SYMBOLS_SHADOW.img);\r\n                    prerendered.shadow.visible = false;\r\n                    prerendered.shadow.wrapper = {zIndex: 7};\r\n                    container.addChild(prerendered.shadow);\r\n                }\r\n            }\r\n        }\r\n        container.reorder();\r\n    }\r\n    // adjust position of looping counter\r\n    function adjustPosition(reel, position) {\r\n        position = position % reel.symbols.length;\r\n        if (position < 0) {\r\n            position = reel.symbols.length + position;\r\n        }\r\n        return position;\r\n    }\r\n\r\n    function releaseSprite(sprite) {\r\n        sprite.shadow = undefined;\r\n        if (spritePool[sprite.imgPath]) {\r\n            spritePool[sprite.imgPath].push(sprite);\r\n        } else {\r\n            spritePool[sprite.imgPath] = [sprite];\r\n        }\r\n    }\r\n    function getSprite(path) {\r\n        var s;\r\n        if (spritePool[path] && spritePool[path].length) {\r\n            s = spritePool[path].pop();\r\n        } else {\r\n            s = new PIXI.Sprite(assets.img(path));\r\n            s.imgPath = path;\r\n        }\r\n        return s;\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/reels/reelsView.js"),eval("\r\ndefine('data/config-symbolSet',[], function () {\r\n    var SPIN = {\r\n        \"ALL_REELS_OFFSET_LEFT\": 5,\r\n        \"ALL_REELS_OFFSET_TOP\": 2.5,\r\n        \"SYMBOL_DEFAULT_RENDER_WIDTH\": 125,\r\n        \"SYMBOL_DEFAULT_RENDER_HEIGHT\": 125,\r\n        \"SYMBOL_OUTER_HEIGHT\": 125.5,\r\n        \"SYMBOL_OUTER_WIDTH\": 138.8,\r\n        SPECIFIC_REELS_OFFSETS_LEFT: {\r\n//            4: 1\r\n        },\r\n        SCATTER_FRAME_OFFSET_LEFT: -6.5,\r\n        SCATTER_FRAME_OFFSET_TOP: -6.5,\r\n        \"SCATTER_FRAME_HEIGHT\": 138,\r\n        \"SCATTER_FRAME_WIDTH\": 138,\r\n        LOOP_ANIMATION: true,\r\n        SCATTER_SYMBOL_ID: [9],\r\n        WILD_SYMBOL_ID: [10],\r\n        symbols: {\r\n            '0': {\r\n                name: '0',\r\n                static: 'symbols/01_00001',\r\n                animationCycle: 'symbols/01_sheet',\r\n                reverse: true,\r\n                height: 130.3,\r\n                offsetY: -5.3,\r\n                occurrence: 1 / 11,\r\n            },\r\n            '1': {\r\n                name: '1',\r\n                static: 'symbols/02_00001',\r\n                fromImage: 'symbols/02_00001',\r\n                toImage: 'symbols/02_00040',\r\n                height: 129.24,\r\n                offsetY: -4.24,\r\n                occurrence: 1 / 11,\r\n            },\r\n            '2': {\r\n                name: '2',\r\n                static: 'symbols/03_00001',\r\n                fromImage: 'symbols/03_00001',\r\n                toImage: 'symbols/03_00040',\r\n                height: 141.949,\r\n                offsetY: -16.949,\r\n                occurrence: 1 / 11\r\n            },\r\n            '3': {\r\n                name: '3',\r\n                static: 'symbols/04_00001',\r\n                fromImage: 'symbols/04_00001',\r\n                toImage: 'symbols/04_00040',\r\n                height: 131.356,\r\n                offsetY: -6.356,\r\n                occurrence: 1 / 11,\r\n            },\r\n            '4': {\r\n                name: '4',\r\n                static: 'symbols/06_00001',\r\n                animationCycle: 'symbols/06_sheet',\r\n                reverse: true,\r\n                occurrence: 1.25 / 11,\r\n            },\r\n            '5': {\r\n                name: '5',\r\n                static: 'symbols/05_00001',\r\n                animationStart: 'symbols/05_sheet',\r\n                animationCycle: 'symbols/05cycle_sheet',\r\n                occurrence: 1 / 11,\r\n            },\r\n            '6': {\r\n                name: '6',\r\n                static: 'symbols/07_00001',\r\n                fromImage: 'symbols/07_00001',\r\n                toImage: 'symbols/07_00050',\r\n                occurrence: 1.25 / 11\r\n            },\r\n            '7': {\r\n                name: '7',\r\n                static: 'symbols/08_00001',\r\n                fromImage: 'symbols/08_00001',\r\n                toImage: 'symbols/08_00050',\r\n                occurrence: 1.25 / 11\r\n            },\r\n            '8': {\r\n                name: '8',\r\n                static: 'symbols/09_00001',\r\n                fromImage: 'symbols/09_00001',\r\n                toImage: 'symbols/09_00050',\r\n                occurrence: 1.25 / 11\r\n            },\r\n            '9': {\r\n                name: '9',\r\n                static: 'symbols/scatter_00001',\r\n                animationCycle: 'symbols/scatter_sheet',\r\n                reverse: true,\r\n                height: {\r\n                    'symbols/scatter_00001': 125,\r\n                    'symbols/scatter_sheet': 198.09,\r\n                },\r\n                width: {\r\n                    'symbols/scatter_00001': 125,\r\n                    'symbols/scatter_sheet': 213.983,\r\n                },\r\n                offsets: {\r\n                    'symbols/scatter_00001': {x: 0, y: 0},\r\n                    'symbols/scatter_sheet': {x: -44.4915, y: -45.045},\r\n                },\r\n                occurrence: .5 / 11\r\n            },\r\n            '10': {\r\n                name: '10',\r\n                static: 'symbols/Wild_00001',\r\n                fromImage: 'symbols/Wild_00001',\r\n                toImage: 'symbols/Wild_00040',\r\n                width: {\r\n                    'symbols/Wild_00001': 125,\r\n                    'symbols/Wild_00040': 142.949,\r\n                },\r\n                height: {\r\n                    'symbols/Wild_00001': 142.949,\r\n                    'symbols/Wild_00040': 142.949,\r\n                },\r\n                offsets: {\r\n                    'symbols/Wild_00001': {x: 0, y: -9},\r\n                    'symbols/Wild_00040': {x: -9.149, y: -9},\r\n                },\r\n                occurrence: .5 / 11\r\n            },\r\n        }\r\n    };\r\n    return {\r\n        SPIN: SPIN,\r\n        FREE_SPIN: SPIN\r\n    };\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-symbolSet.js"),eval("// reelsCtrl\r\n// controls reels model initialization and spin animation\r\ndefine('layers/reels/reelsCtrl',[\r\n    'jquery',\r\n    'pubsub',\r\n    'layers/reels/reelsView',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'services/math',\r\n    'services/pause',\r\n    'services/assets',\r\n], function ($, pubsub, reelsView, config, symbolSet, easing, pause, assets) {\r\n\r\n// initialize self\r\n    var self = {};\r\n    // array of symbol sets that are currently used in reels model\r\n    self.activeSymbolSets = [];\r\n    // reels model\r\n    self.model = null;\r\n    self.initData = null;\r\n    var savedReels = null;\r\n    var currentActivity;\r\n    // current reelset\r\n    self.currentReelSet = null;\r\n    // latest used symbol set\r\n    var latestSymbolSet = null;\r\n    // indicates that reels force stop is requested\r\n    var forceStopFlag = null;\r\n    var forceStopActive = false;\r\n    // used to synchronize bounce start time when force stopping all reels at once\r\n    var firstBounceStartTime = null;\r\n    // number of scatter symbols in stopped reels - needed to determine\r\n    // which sound to play when next reel with scatter symbol stops\r\n    var scatterCount = null;\r\n    // hold the update function\r\n    // null when the reels are not spinning\r\n    var frameCallback = null;\r\n    // timeout to hide win symbols to make space for win animation\r\n    var hideReelsTimeout = null;\r\n    // holds audio data for spin animation events\r\n    var soundData = {};\r\n    // dirty symbols clear position counter\r\n    var dirtySymbolsAwayPositionOffset = null;\r\n    // flag signals whether the multiple row/collumn symbols\r\n    // are cleared from spinning reelset\r\n    var multiSymbolsBlocksCleared = null;\r\n    // view action handlers\r\n    self.viewActions = {\r\n    };\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        // request to initialize reels model with specified data\r\n        'request:initReels': initReels,\r\n        // spin request\r\n        'request:spinReels': function (id, data) {\r\n            var direction = 'down';\r\n            addDragOffsetToPosition();\r\n            startSpin(direction);\r\n        },\r\n        // stop request\r\n        'request:stopReels': function (id, data) {\r\n            if (!window.noStopReels) {\r\n                stopReels(data);\r\n            }\r\n        },\r\n        // force stop requested\r\n        'request:forceStopReels': function (id, data) {\r\n            forceStopFlag = true;\r\n        },\r\n        // resize requested\r\n        'notify:dimensionsChanged': function (id, data) {\r\n            if (self.view) {\r\n                self.view.resize();\r\n            }\r\n        },\r\n        // request to hide winning symbols - make space for win animations\r\n        'request:hideWinSymbolsOnReel': function (id, data) {\r\n            hideReelsTimeout = pause.setTimeout(function () {\r\n                hideSymbolsOnReels(data);\r\n            }, (data && data.timeout) ? data.timeout : 0);\r\n        },\r\n        // request to refresh reels = show all symbols\r\n        'request:refreshReelsView': refreshReelsView,\r\n        // set reels background\r\n        'request:setReelsBackground': function (id, data) {\r\n            self.view.setBackground(data);\r\n        },\r\n        'notify:reelSurfaceDrag': reelsDrag,\r\n        'notify:reelSurfaceTouchEnd': reelsTouchEnd,\r\n        'notify:activityAfterStart': function (id, data) {\r\n            currentActivity = data.activity;\r\n        },\r\n        'request:saveReels': function () {\r\n            savedReels = {\r\n                initData: $.extend(true, {}, self.initData),\r\n                model: $.extend(true, [], self.model)\r\n            };\r\n            for (var i = 0; i < savedReels.model.length; i++) {\r\n                savedReels.model[i].hiddenSymbols = [];\r\n                savedReels.model[i].stopped = false;\r\n                savedReels.model[i].stopSoundPlayed = false;\r\n                savedReels.model[i].spinningFaster = false;\r\n            }\r\n        },\r\n        'request:loadReels': function () {\r\n            if (savedReels) {\r\n                initReels(null, savedReels.initData, savedReels.model);\r\n                self.view.update();\r\n                savedReels = null;\r\n            }\r\n        },\r\n    });\r\n    // update function\r\n    // called on each tick\r\n    self.update = function (delta) {\r\n        if (frameCallback) {\r\n            frameCallback(delta);\r\n            self.view.update();\r\n        }\r\n    };\r\n    return self;\r\n    function initReels(id, data, model) {\r\n        var i;\r\n        self.initData = data;\r\n        self.currentReelSet = data.reelSet;\r\n        resetSpinData();\r\n        soundData = data.soundData || {};\r\n        if (model) {\r\n            self.model = model;\r\n            self.activeSymbolSets = [data.symbolSet];\r\n            latestSymbolSet = data.symbolSet;\r\n        } else {\r\n            initModel(data);\r\n        }\r\n\r\n        if (!data.visibleSymbols && !data.slideInPrevious) {\r\n            // randomize reels position\r\n            for (i = 0; i < self.model.length; i++) {\r\n                self.model[i].position = Math.floor(\r\n                        Math.random() * self.model[i].symbols.length);\r\n            }\r\n        }\r\n\r\n        self.view = reelsView.initialize(self);\r\n        if (data.visibleSymbols) {\r\n            for (i = 0; i < self.model.length; i++) {\r\n                injectToReel(self.model[i], data.visibleSymbols[i]);\r\n            }\r\n        }\r\n\r\n        self.view.show();\r\n    }\r\n\r\n// clear spin data to prepare for next spin\r\n    function resetSpinData() {\r\n        if (self.model) {\r\n            for (var i = 0; i < self.model.length; i++) {\r\n                self.model[i].target = null;\r\n                self.model[i].stopped = null;\r\n                self.model[i].stopSoundPlayed = false;\r\n                self.model[i].spinningFaster = false;\r\n            }\r\n        }\r\n        scatterCount = 0;\r\n        multiSymbolsBlocksCleared = false;\r\n        forceStopFlag = null;\r\n        forceStopActive = false;\r\n        firstBounceStartTime = null;\r\n        dirtySymbolsAwayPositionOffset = self.currentReelSet.INJECTABLE_BLOCK_ROWS;\r\n    }\r\n\r\n// adjust position of looping counter\r\n    function adjustPosition(reel, position) {\r\n        position = position % reel.symbols.length;\r\n        if (position < 0) {\r\n            position = reel.symbols.length + position;\r\n        }\r\n        return position;\r\n    }\r\n// get random symbol based on symbol occurrence probability\r\n    function getRandomSymbol(symbols, reelIndex) {\r\n        function getRnd() {\r\n            var rnd = Math.random();\r\n            var ks = Object.keys(symbols);\r\n            var progress = 0;\r\n            for (var i = 0; i < ks.length; i++) {\r\n                progress += symbols[ks[i]].occurrence ? symbols[ks[i]].occurrence\r\n                        : (1 / ks.length);\r\n                if (rnd < progress) {\r\n                    return ks[i];\r\n                }\r\n            }\r\n        }\r\n        var rnd;\r\n        do {\r\n            rnd = getRnd();\r\n        } while (symbols[rnd].excludeOnReels\r\n                && symbols[rnd].excludeOnReels.indexOf(reelIndex) !== -1);\r\n        return rnd;\r\n    }\r\n// create symbol object for reels model\r\n    function getModelSymbol(symbolSet, symId) {\r\n        var sym = {};\r\n        if (String(symId).indexOf('_') > -1) {\r\n            var parsed = String(symId).split('_');\r\n            sym = $.extend(sym, symbolSet.symbols[parsed[0]]);\r\n            sym.segment = parsed[1];\r\n        } else {\r\n            sym = $.extend(sym, symbolSet.symbols[symId]);\r\n        }\r\n        sym.symbolSet = symbolSet;\r\n        return sym;\r\n    }\r\n\r\n// initialize reels model\r\n    function initModel(data) {\r\n\r\n        var newSymbolSet = data.symbolSet;\r\n        var newModel = [];\r\n        for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n            newModel[i] = {\r\n                index: i,\r\n                symbols: [],\r\n                hiddenSymbols: [],\r\n                position: 0,\r\n                target: null,\r\n                stopping: null,\r\n                stopped: null,\r\n                stopSoundPlayed: false,\r\n                spinningFaster: false,\r\n            };\r\n            for (var k = 0; k < data.stripes[i].length; k++) {\r\n                newModel[i].symbols[k] = getModelSymbol(newSymbolSet, data.stripes[i][k]);\r\n            }\r\n        }\r\n        newModel[0].dragOffset = 0;\r\n        // if requested, leave visible symbols from previous reel model on screen\r\n        // so that they slide out of view only when the next spin starts\r\n        // the old symbols are removed as soon as they slide out of view\r\n        if (data.slideInPrevious) {\r\n            var oldModel = self.model;\r\n            for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n                var newReel = newModel[i];\r\n                var oldReel = oldModel[i];\r\n                var previousInjectableBlockSymbols = [];\r\n                for (var i2 = 0; i2 < self.currentReelSet.INJECTABLE_BLOCK_ROWS; i2++) {\r\n                    previousInjectableBlockSymbols[i2] = oldReel.symbols[adjustPosition(\r\n                            oldReel, oldReel.position + i2)];\r\n                    previousInjectableBlockSymbols[i2].prevSymbol = null;\r\n                    previousInjectableBlockSymbols[i2].dirty = true;\r\n                }\r\n                newReel.position = newReel.symbols.length;\r\n                newReel.symbols = newReel.symbols.concat(previousInjectableBlockSymbols);\r\n            }\r\n            var index = self.activeSymbolSets.indexOf(newSymbolSet);\r\n            if (index !== -1) {\r\n                self.activeSymbolSets.splice(index, 1);\r\n            }\r\n            self.activeSymbolSets.push(newSymbolSet);\r\n        } else {\r\n            self.activeSymbolSets = [newSymbolSet];\r\n        }\r\n\r\n        latestSymbolSet = self.activeSymbolSets[self.activeSymbolSets.length - 1];\r\n        self.model = newModel;\r\n    }\r\n\r\n// refresh reels = show all symbols\r\n    function refreshReelsView() {\r\n        if (hideReelsTimeout) {\r\n            pause.clearTimeout(hideReelsTimeout);\r\n        }\r\n        for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n            var reel = self.model[i];\r\n            reel.hiddenSymbols = [];\r\n        }\r\n        self.view.update();\r\n    }\r\n// remove from reels the symbols left-over from previous model\r\n// this happens when old symbols slide out of view\r\n    function removeDirtySymbols() {\r\n        var reel, injectedPos, deleteIndexes;\r\n        for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n            var reel = self.model[i];\r\n            injectedPos = [];\r\n            deleteIndexes = [];\r\n//            console.log('*** dirty clean pre', i, getSymsCurrent(self.model[i].symbols));\r\n            for (var k = 0; k < reel.symbols.length; k++) {\r\n                if (reel.symbols[k].dirty) {\r\n                    if (reel.symbols[k].prevSymbol) {\r\n                        injectedPos.push(k);\r\n                        reel.symbols[k] = reel.symbols[k].prevSymbol;\r\n                    } else {\r\n                        deleteIndexes.push(k);\r\n                    }\r\n                }\r\n            }\r\n            for (var k = deleteIndexes.length - 1; k >= 0; k--) {\r\n                reel.symbols.splice(deleteIndexes[k], 1);\r\n            }\r\n//            console.log('*** dirty clean post', i, getSymsCurrent(self.model[i].symbols));\r\n            self.view.inject(i, injectedPos);\r\n            self.view.remove(i, deleteIndexes);\r\n        }\r\n    }\r\n// run the spin\r\n    function startSpin(direction) {\r\n// adjust reel position on tick while the reels are spinning\r\n// (not stopping/bouncing)\r\n        var posDelta;\r\n        function tick(delta, reel) {\r\n            if (reel.spinningFaster) {\r\n                posDelta = delta * config.SPIN_SPEED\r\n                        * config.FASTER_SPIN_SPEED_MODIFIER;\r\n                if (reel.target && reel.target.timeout < 1) {\r\n                    if (reel.target.timeout <= 0) {\r\n                        posDelta *= 0.6;\r\n                    } else {\r\n                        posDelta *= 0.6 + 0.4 * reel.target.timeout;\r\n                    }\r\n                }\r\n            } else {\r\n                posDelta = delta * config.SPIN_SPEED;\r\n            }\r\n            if (direction === 'down') {\r\n                reel.position -= posDelta;\r\n                if (reel.position < 0) {\r\n                    reel.position = reel.symbols.length + reel.position;\r\n                }\r\n\r\n            } else if (direction === 'up') {\r\n                reel.position += posDelta;\r\n                if (reel.position >= reel.symbols.length) {\r\n                    reel.position = 0;\r\n                }\r\n            }\r\n            return posDelta;\r\n        }\r\n// adjust reel position on update while the reels are stopping\r\n// (bounce animation)\r\n        var stopping, bounceType, timeDiff, posOff, newPos;\r\n        function bounce(delta, reel) {\r\n            stopping = reel.target.stopping;\r\n            bounceType = stopping.bounce;\r\n            timeDiff = (Date.now() - stopping.bounceStart) /\r\n                    self.currentReelSet.BOUNCE_DURATION_MS;\r\n            timeDiff *= config.GAME_SPEED_MODIFIER;\r\n            newPos = undefined;\r\n            if (bounceType === 1) {\r\n                // the reel is going down in the bounce animation\r\n                timeDiff *= 1.63;\r\n                posOff = easing.easeOutCubic(timeDiff) * self.currentReelSet.BOUNCE_HEIGHT_POSITIONS;\r\n                if (timeDiff >= 1) {\r\n                    stopping.bounceStart = Date.now();\r\n                    stopping.bounce = 2;\r\n                } else {\r\n                    if (direction === 'down') {\r\n                        newPos = stopping.position - posOff;\r\n                    } else if (direction === 'up') {\r\n                        newPos = stopping.position + posOff;\r\n                    }\r\n                }\r\n            } else if (bounceType === 2) {\r\n                // the reel is going up in the bounce animation\r\n                timeDiff *= 0.37;\r\n                posOff = easing.easeOutCubic(timeDiff) * self.currentReelSet.BOUNCE_HEIGHT_POSITIONS;\r\n                if (timeDiff >= 1) {\r\n                    // the bounce is finished\r\n                    stopping.bounce = 'done';\r\n                } else {\r\n                    if (direction === 'down') {\r\n                        newPos = stopping.position\r\n                                - self.currentReelSet.BOUNCE_HEIGHT_POSITIONS + posOff;\r\n                    } else if (direction === 'up') {\r\n                        newPos = stopping.position +\r\n                                +self.currentReelSet.BOUNCE_HEIGHT_POSITIONS - posOff;\r\n                    }\r\n                    if (direction === 'down' && newPos >= stopping.position) {\r\n                        newPos = stopping.position;\r\n                        stopping.bounce = 'done';\r\n                    }\r\n                }\r\n            }\r\n            if (newPos) {\r\n                newPos = adjustPosition(reel, newPos);\r\n                reel.position = newPos;\r\n            }\r\n        }\r\n\r\n        function injectTargetSymbolsToReel(reel) {\r\n            var incomingPositions = [];\r\n            var highestInjectedIndex = self.currentReelSet.INJECTABLE_BLOCK_ROWS - 1;\r\n            if (direction === 'down') {\r\n                incomingPositions[highestInjectedIndex] = Math.floor(reel.position)\r\n                        - self.currentReelSet.SAFE_INJECTION_POSITION_DELTA;\r\n                for (var i = highestInjectedIndex; i >= 0; i--) {\r\n                    incomingPositions[i] = adjustPosition(\r\n                            reel,\r\n                            incomingPositions[highestInjectedIndex]\r\n                            - (highestInjectedIndex - i));\r\n                }\r\n            } else if (direction === 'up') {\r\n// not used\r\n            }\r\n\r\n            injectToReel(reel, reel.target.symbols, incomingPositions);\r\n            return adjustPosition(reel, incomingPositions[0]);\r\n        }\r\n\r\n        function clearMultiSymbols() {\r\n            function replaceSymbol(reel, pos) {\r\n                var rnd;\r\n                do {\r\n                    rnd = getRandomSymbol(latestSymbolSet.symbols, reel.index);\r\n                } while (latestSymbolSet.symbols[rnd].size);\r\n                reel.symbols[pos] = $.extend(true, {},\r\n                        latestSymbolSet.symbols[rnd]);\r\n                reel.symbols[pos].symbolSet = latestSymbolSet;\r\n            }\r\n\r\n            var reels = self.model;\r\n\r\n            for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n                var reel = reels[i];\r\n                var safeReplacePositionCount = reel.symbols.length\r\n                        - self.currentReelSet.VISIBLE_SYMBOLS_ON_REEL\r\n                        - 1;\r\n                var safeReplacePositionStart = Math.floor(\r\n                        adjustPosition(reel, reel.position\r\n                                + self.currentReelSet.VISIBLE_SYMBOLS_ON_REEL + 1));\r\n                var replacedPositions = [];\r\n                for (var i2 = 0; i2 < safeReplacePositionCount; i2++) {\r\n                    var pos = adjustPosition(reel, safeReplacePositionStart + i2);\r\n                    if (reels[i].symbols[pos].segment) {\r\n                        var segmentY = Number(reels[i].symbols[pos].segment[1]);\r\n                        if (self.currentReelSet.SAFE_INJECTION_POSITION_DELTA - segmentY\r\n                                <= safeReplacePositionCount - i2) {\r\n                            replaceSymbol(reels[i], pos);\r\n                            replacedPositions.push(pos);\r\n                        }\r\n                    }\r\n                }\r\n\r\n//                for (var i3 = 0; i3 < self.currentReelSet.REELS_COUNT; i3++) {\r\n//                    console.log('FLOW: multi cleared from', safeReplacePositionStart,\r\n//                            ', total', safeReplacePositionCount, i3, getSymsCurrent(reels[i3].symbols));\r\n//                }\r\n\r\n                self.view.inject(i, replacedPositions);\r\n            }\r\n            var isMultipleSymbolOnReels = false;\r\n            for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n                for (var i2 = 0; i2 < reels[i].symbols[i2].length; i2++) {\r\n                    if (reels[i].symbols[i2].segment) {\r\n                        isMultipleSymbolOnReels = true;\r\n                    }\r\n                }\r\n            }\r\n            if (!isMultipleSymbolOnReels) {\r\n                multiSymbolsBlocksCleared = true;\r\n            } else {\r\n//                console.log('waiting for multi clear')\r\n            }\r\n        }\r\n\r\n// check whether we have reached the target stop position\r\n        function isTargetPositionHit(reel) {\r\n// safety check for lags\r\n            if (reel.target.stopping.passedPositions >\r\n                    self.currentReelSet.INJECTABLE_BLOCK_ROWS\r\n                    + self.currentReelSet.SAFE_INJECTION_POSITION_DELTA + 1) {\r\n                return true;\r\n            }\r\n// position check\r\n            var maxDiff = 0.8;\r\n            var current = reel.position;\r\n            var target = reel.target.stopping.position;\r\n            if (direction === 'down') {\r\n                var maxDiffPos = target - maxDiff;\r\n                if (maxDiffPos >= 0) {\r\n                    if (current <= target && current >= maxDiffPos) {\r\n                        return true;\r\n                    }\r\n                } else if (current >= reel.symbols.length - maxDiff) {\r\n                    return true;\r\n                }\r\n            } else if (direction === 'up') {\r\n// unused\r\n            }\r\n            return false;\r\n        }\r\n// runs when a reel has stopped\r\n// finalize reel position and fire events if appropriate\r\n        function reelSpinFinished(reel) {\r\n// bouncing done, finalizePosition\r\n            reel.position = reel.target.stopping.position;\r\n//            console.log('** reelSpinFinished ', reel.index, ' finished, setting pos ', reel.position)\r\n            pubsub.publish('notify:reelStopped', {index: reel.index});\r\n            reel.stopped = true;\r\n            if (reel.index === self.currentReelSet.REELS_COUNT - 2) {\r\n// next to last reel finished\r\n// fire event\r\n                pubsub.publish('notify:nextToLastReelStopped');\r\n            }\r\n            var allFinished = true;\r\n            for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n                if (!self.model[i].stopped) {\r\n                    allFinished = false;\r\n                }\r\n            }\r\n            if (allFinished) {\r\n// last reel finished\r\n// stop animation\r\n                frameCallback = null;\r\n// fire event\r\n                pubsub.publish('request:stopSound', {\r\n                    sound: config.TEASER_SOUND\r\n                });\r\n                pubsub.publish('notify:spinFinished');\r\n                resetSpinData();\r\n            }\r\n        }\r\n// runs on each frame when spinning\r\n// controls the spin progress - spin, bounce down, bounce up, stop\r\n        function onFrame(delta) {\r\n            function dirtySymbolsCheckRemove() {\r\n                if (dirtySymbolsAwayPositionOffset > 0) {\r\n                    dirtySymbolsAwayPositionOffset -= delta * config.SPIN_SPEED;\r\n                } else if (dirtySymbolsAwayPositionOffset !== null) {\r\n                    removeDirtySymbols();\r\n                    dirtySymbolsAwayPositionOffset = null;\r\n                }\r\n            }\r\n            function multiSymbolsCheckRemove() {\r\n                if (dirtySymbolsAwayPositionOffset === null\r\n                        && self.model[0].target\r\n                        && !multiSymbolsBlocksCleared) {\r\n                    clearMultiSymbols();\r\n                    if (self.model[0].target.timeout <= 0 && !multiSymbolsBlocksCleared) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            dirtySymbolsCheckRemove();\r\n            var waitingForMultiClear = multiSymbolsCheckRemove();\r\n            for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n                if (!frameCallback) {\r\n                    break;\r\n                }\r\n                var reel = self.model[i];\r\n                if (reel.stopped) {\r\n                    continue;\r\n                }\r\n                if (!reel.target || dirtySymbolsAwayPositionOffset > 0) {\r\n// target not set (no result from server yet)\r\n// or dirty symbols cleanup pending\r\n// => continue spinning\r\n                    tick(delta, reel);\r\n                } else {\r\n// we have spin result from server\r\n                    if (!reel.target.stopping) {\r\n// still spinning, no stop request yet\r\n// subtract time passed from reel stop timeout value\r\n//                        console.log('- target subtract', reel.index, reel.target.timeout);\r\n                        tick(delta, reel);\r\n                        if (!waitingForMultiClear) {\r\n                            reel.target.timeout -= delta;\r\n                        }\r\n                        if (forceStopFlag && !forceStopActive &&\r\n                                self.model[self.currentReelSet.REELS_COUNT - 1]\r\n                                .target.timeout > .2) {\r\n// if there was a force stop request,\r\n// set all stop timeouts to zero for immediate stop\r\n                            forceStopActive = true;\r\n                            for (var k = 0; k < self.currentReelSet.REELS_COUNT; k++) {\r\n                                self.model[k].target.timeout > .2 && (self.model[k].target.timeout = .2);\r\n                            }\r\n                        }\r\n                        if (!reel.stopSoundPlayed\r\n                                && multiSymbolsBlocksCleared && reel.target.timeout <= .2) {\r\n                            playStopSound(reel);\r\n                            reel.stopSoundPlayed = true;\r\n                        }\r\n                        if (multiSymbolsBlocksCleared && reel.target.timeout <= 0) {\r\n// stop timeout expired\r\n// and reels cleared of multi symbols\r\n// we should begin stopping reels\r\n// inject spin result symbols to model\r\n// set stopping flag on reel\r\n                            reel.target.stopping = {\r\n                                position: injectTargetSymbolsToReel(reel),\r\n                                passedPositions: 0,\r\n                                bounce: null\r\n                            };\r\n                        }\r\n                    } else {\r\n// the reel is in stopping stage\r\n                        var stopping = reel.target.stopping;\r\n                        if (!stopping.bounce) {\r\n// still spinning, waiting for target position\r\n                            stopping.passedPositions += tick(delta, reel);\r\n                            if (isTargetPositionHit(reel)) {\r\n// we have reached target spin position\r\n// check whether teaser animation is scheduled for\r\n// next reel. if yes, start the animation and\r\n// fire event\r\n                                var nextOne = self.model[reel.index + 1];\r\n                                if (nextOne && nextOne.target.fasterSpin) {\r\n                                    nextOne.spinningFaster = true;\r\n                                    if (!forceStopFlag) {\r\n                                        pubsub.publish('notify:fasterSpinStarted', {\r\n                                            reelIndex: nextOne.index\r\n                                        });\r\n                                        pubsub.publish('request:stopSound', {\r\n                                            sound: config.TEASER_SOUND\r\n                                        });\r\n                                        pubsub.publish('request:playSound', {\r\n                                            sound: config.TEASER_SOUND\r\n                                        });\r\n                                    }\r\n                                }\r\n// set bounce stage to 1\r\n                                stopping.bounce = 1;\r\n                                pubsub.publish('notify:reelBounceStart', {\r\n                                    index: reel.index,\r\n                                });\r\n                                // store bounce start time\r\n                                if (forceStopFlag) {\r\n// when force stopping all reels at once,\r\n// synchronize the bounce with all reels by\r\n// setting the same bounce start time\r\n                                    if (!firstBounceStartTime) {\r\n                                        firstBounceStartTime = Date.now();\r\n                                    }\r\n                                    stopping.bounceStart = firstBounceStartTime;\r\n                                } else {\r\n                                    stopping.bounceStart = Date.now();\r\n                                }\r\n                            }\r\n                        } else {\r\n// the reel is in bounce stage\r\n                            if (stopping.bounce === 'done') {\r\n// reel has stopped\r\n                                reelSpinFinished(reel);\r\n                            } else if (stopping.bounce === 1) {\r\n// bouncing in direction of spin\r\n                                bounce(delta, reel);\r\n                            } else if (stopping.bounce === 2) {\r\n// bouncing against direction of spin\r\n                                bounce(delta, reel);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            self.view.update();\r\n        }\r\n        frameCallback = onFrame;\r\n    }\r\n\r\n// runs upon receiving spin result from server\r\n// sets the specified result parameters on individual reels\r\n    function stopReels(data) {\r\n        function getHasScatter(reel) {\r\n            for (var i = 0; i < self.currentReelSet.VISIBLE_SYMBOLS_ON_REEL; i++) {\r\n                if (typeof reel.sym[i] === 'string' && String(reel.sym).indexOf('_') > -1) {\r\n                    if (latestSymbolSet.SCATTER_SYMBOL_ID.indexOf(Number(reel.sym[i].split('_')[0])) > -1) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (latestSymbolSet.SCATTER_SYMBOL_ID.indexOf(reel.sym[i]) > -1) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        var positions = data.setup.rs;\r\n        var stopTimeout;\r\n        var timeoutAdd = 0;\r\n\r\n        for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n            stopTimeout = config.REELS_STOP_TIMEOUT[i];\r\n\r\n            if (positions[i].teaser) {\r\n                timeoutAdd += 3.000;\r\n            }\r\n\r\n            self.model[i].target = {\r\n                // timeout before the reel should stop\r\n                timeout: stopTimeout + timeoutAdd,\r\n                // spin result symbols\r\n                symbols: positions[i].sym,\r\n                // specifies whether the reel should display teaser animation\r\n                // when stopping\r\n                fasterSpin: positions[i].teaser,\r\n                // specifies whether the result contains scatter symbol\r\n                hasScatter: getHasScatter(positions[i])\r\n            };\r\n        }\r\n    }\r\n\r\n// push symbols to reel\r\n    function injectToReel(reel, symbols, positions) {\r\n//        console.log('** inject reel pre', reel.index, getSymsCurrent(reel.symbols));\r\n\r\n        var i, prevSymbol;\r\n        if (!positions) {\r\n            positions = [];\r\n            for (i = 0; i < self.currentReelSet.INJECTABLE_BLOCK_ROWS; i++) {\r\n                positions.push(adjustPosition(reel, reel.position + i));\r\n            }\r\n        }\r\n\r\n        for (i = 0; i <= positions.length; i++) {\r\n            prevSymbol = reel.symbols[positions[i]];\r\n            reel.symbols[positions[i]] =\r\n                    getModelSymbol(latestSymbolSet, symbols[i]);\r\n            reel.symbols[positions[i]].dirty = true;\r\n            reel.symbols[positions[i]].prevSymbol = prevSymbol;\r\n        }\r\n\r\n        self.view.inject(reel.index, positions);\r\n//        console.log('** inject reel post', reel.index, getSymsCurrent(reel.symbols));\r\n\r\n    }\r\n\r\n// hide winning symbols as to make place for animation\r\n    function hideSymbolsOnReels(data) {\r\n        if (!data || !data.ws) {\r\n            for (var k = 0; k < self.currentReelSet.REELS_COUNT; k++) {\r\n                var reel = self.model[k];\r\n                for (var i = 0; i < reel.symbols.length; i++) {\r\n                    reel.hiddenSymbols.push(i);\r\n                }\r\n            }\r\n        } else {\r\n            var winPositions = [];\r\n            var winModel = data.ws;\r\n            var keys = Object.keys(winModel);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var post = winModel[keys[i]].post;\r\n                var postKeys = Object.keys(post);\r\n                for (var k = 0; k < postKeys.length; k++) {\r\n                    winPositions.push(post[postKeys[k]]);\r\n                }\r\n            }\r\n            for (var i = 0; i < winPositions.length; i++) {\r\n                var x = winPositions[i][0];\r\n                var y = winPositions[i][1];\r\n                var reel = self.model[x];\r\n                var reelPos = reel.position;\r\n                var targetPos = (reelPos + y) % (reel.symbols.length);\r\n//                console.log('targetPos', winPositions, targetPos, reelPos, x, y, reel.symbols.length)\r\n                if (self.model[x].symbols[targetPos].size\r\n                        && (self.model[x].symbols[targetPos].size.x > 1\r\n                                || self.model[x].symbols[targetPos].size.y > 1)) {\r\n// do not hide symbols with multiple segments\r\n                    continue;\r\n                }\r\n                if (reel.hiddenSymbols.indexOf(targetPos) === -1) {\r\n                    reel.hiddenSymbols.push(targetPos);\r\n                }\r\n            }\r\n        }\r\n        self.view.update();\r\n    }\r\n\r\n// runs when reel has stopped\r\n// play appropriate sound\r\n    function playStopSound(reel) {\r\n\r\n        var data = assets.isHighQualitySoundEnabled() ?\r\n                soundData : config.LIGHTWEIGHT_SPIN_SOUND_DATA;\r\n\r\n        var playScatterSound =\r\n                data.scatterSound\r\n                && reel.target.hasScatter\r\n                && ((reel.index < self.currentReelSet.REELS_COUNT - 2)\r\n                        || scatterCount > 0);\r\n        if (playScatterSound) {\r\n            pubsub.publish('request:playSound', {\r\n                sound: data.scatterSound[scatterCount]\r\n            });\r\n            scatterCount += 1;\r\n        } else if (data.stopSound) {\r\n            pubsub.publish('request:playSound', {\r\n                sound: data.stopSound[reel.index]\r\n            });\r\n        }\r\n    }\r\n\r\n    function reelsDrag(id, dragPx) {\r\n        if (currentActivity === 'idle') {\r\n            pubsub.publish('request:refreshReelsView');\r\n            pubsub.publish('request:clearWinAnimations');\r\n            self.model[0].dragOffset = dragPx / symbolSet.SPIN.SYMBOL_OUTER_HEIGHT;\r\n            self.view.update();\r\n        }\r\n    }\r\n    function reelsTouchEnd(id, data) {\r\n        function bounceBack() {\r\n            var interval = pause.setInterval(function () {\r\n                if (self.model[0].dragOffset <= 0) {\r\n                    self.model[0].dragOffset = 0;\r\n                    pause.clearInterval(interval);\r\n                } else {\r\n                    self.model[0].dragOffset -= 0.05;\r\n                }\r\n                self.view.update();\r\n            }, 5);\r\n        }\r\n        if (!data.actionTriggerTresholdPassed && self.model[0].dragOffset) {\r\n            bounceBack();\r\n        }\r\n        self.view.update();\r\n    }\r\n    function addDragOffsetToPosition() {\r\n        for (var i = 0; i < self.currentReelSet.REELS_COUNT; i++) {\r\n            self.model[i].position = adjustPosition(self.model[i],\r\n                    self.model[i].position - self.model[0].dragOffset);\r\n        }\r\n        self.model[0].dragOffset = 0;\r\n    }\r\n\r\n    function getSymsCurrent(arr) {\r\n        var syms = [];\r\n        for (var i = 0; i < arr.length; i++) {\r\n            syms[i] = arr[i].name;\r\n        }\r\n        return syms;\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/reels/reelsCtrl.js"),
eval("define('data/config-statusBottom',{\r\n    BACK_LEFT: 0,\r\n    BACK_TOP: 531,\r\n    BACK_WIDTH: 1020,\r\n    BOX_TOP: 554,\r\n    LABELS_FONT_SIZE: 18,\r\n    BASE_OFFSET_LEFT: 0,\r\n    BET_VALUE_LEFT: 0,\r\n    LINES_VALUE_LEFT: 105,\r\n    TOTALBET_VALUE_LEFT: 210,\r\n    WIN_VALUE_LEFT: 317,\r\n    DENOM_VALUE_LEFT: 644,\r\n    CREDITS_VALUE_LEFT: 759,\r\n    BET_BOX_WIDTH: 105,\r\n    LINES_BOX_WIDTH: 105,\r\n    TOTALBET_BOX_WIDTH: 107,\r\n    DENOM_BOX_WIDTH: 115,\r\n    WIN_BOX_WIDTH: 327,\r\n    CREDITS_BOX_WIDTH: 201,\r\n    BOX_HEIGHT: 39  ,\r\n    INFO_BACK_HEIGHT: 23,\r\n    WIN_LABEL_LEFT: 335,\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-statusBottom.js"),eval("define('components/Rectangle',['components/Element', 'pixi'],\r\n        function (Element, PIXI) {\r\n            // basic single colored PIXI rectangle\r\n            return function create(options) {\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'Rectangle';\r\n                self.color = options.color;\r\n                self.strokeColor = options.strokeColor;\r\n                self.strokeThickness = options.strokeThickness;\r\n                self.interactive = options.interactive;\r\n                self.click = options.click;\r\n                self.mouseDown = options.mouseDown;\r\n                self.mouseUp = options.mouseUp;\r\n                self.mouseOut = options.mouseOut;\r\n\r\n                var el = new PIXI.Graphics();\r\n\r\n                el.beginFill(self.color);\r\n                if (self.strokeColor) {\r\n                    el.lineStyle(self.strokeThickness || 1, self.strokeColor);\r\n                }\r\n                if (self.color === null) {\r\n                    el.fillAlpha = 0;\r\n                }\r\n                el.drawRect(0, 0, self.width, self.height);\r\n                el.endFill();\r\n\r\n                el.wrapper = self;\r\n                self.pixiEl = el;\r\n\r\n                el.interactive = self.click ? true : self.interactive;\r\n                if (el.interactive) {\r\n                    el.click = el.tap = function (e) {\r\n                        self.click && self.click(e);\r\n                    };\r\n                    el.touchstart = el.mousedown = function (e) {\r\n                        self.mouseDown && self.mouseDown(e);\r\n                    };\r\n                    el.touchend = el.mouseup = function (e) {\r\n                        self.mouseUp && self.mouseUp(e);\r\n                    };\r\n                    el.touchendoutside = el.mouseout = function (e) {\r\n                        self.mouseOut && self.mouseOut(e);\r\n                    };\r\n                }\r\n\r\n                return self;\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/Rectangle.js"),eval("define('components/TextBox',[\r\n    'components/Element',\r\n    'components/DomRectangle',\r\n    'components/Text'],\r\n        function (\r\n                Element, DomRectangle, Text) {\r\n\r\n            // basic image\r\n            return function create(options) {\r\n\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'TextBox';\r\n                self.textTop = options.textTop;\r\n                self.textBottom = options.textBottom;\r\n                self.style = options.style;\r\n                self.fontSize = options.fontSize;\r\n                self.width = options.width;\r\n                self.height = options.height;\r\n                self.colorBack = options.colorBack;\r\n                self.colorTextTop = options.colorTextTop;\r\n                self.colorTextBottom = options.colorTextBottom;\r\n                self.backCss = options.backCss;\r\n\r\n                var spaceRemaining = self.height - 2 * self.fontSize;\r\n                self.textTopOffsetTop = spaceRemaining / 3 + 3;\r\n                self.textBottomOffsetTop = self.fontSize + 2 * (spaceRemaining / 3) +1;\r\n\r\n                self.styleTop = $.extend({}, self.style);\r\n                self.styleBottom = $.extend({}, self.style);\r\n                self.styleTop.color = self.colorTextTop;\r\n                self.styleBottom.color = self.colorTextBottom;\r\n\r\n                self.singleLineMode = false;\r\n\r\n                var back = DomRectangle({\r\n                    groupCtrl: self.groupCtrl,\r\n                    name: self.name + '-back',\r\n                    left: self.left,\r\n                    top: self.top,\r\n                    width: self.width,\r\n                    height: self.height,\r\n                    zIndex: self.zIndex,\r\n                    color: self.colorBack,\r\n                    css: self.backCss,\r\n                });\r\n\r\n                var textTop = Text({\r\n                    groupCtrl: self.groupCtrl,\r\n                    left: self.left + self.width / 2,\r\n                    top: self.top + self.textTopOffsetTop,\r\n                    text: self.textTop,\r\n                    style: self.styleTop,\r\n                    fontSize: self.fontSize,\r\n                    zIndex: self.zIndex + 1,\r\n                    originX: 'center',\r\n                });\r\n\r\n                var textBottom = Text({\r\n                    groupCtrl: self.groupCtrl,\r\n                    left: self.left + self.width / 2,\r\n                    top: self.top + self.textBottomOffsetTop,\r\n                    text: self.textBottom,\r\n                    style: self.styleBottom,\r\n                    fontSize: self.fontSize,\r\n                    zIndex: self.zIndex + 1,\r\n                    originX: 'center',\r\n                });\r\n\r\n                self.jQueryEl = [back, textTop, textBottom];\r\n\r\n                self.setTextTop = function (txt) {\r\n                    textTop.setText(txt);\r\n                };\r\n                self.setTextBottom = function (txt) {\r\n                    textBottom.setText(txt);\r\n                };\r\n\r\n                self.setSingleLine = function (val) {\r\n                    self.singleLineMode = val;\r\n                    if (self.visible) {\r\n                        if (self.singleLineMode) {\r\n                            textTop.hide();\r\n                            textBottom.show();\r\n                            textBottom.set({\r\n                                top: self.top + self.height / 2\r\n                                        - (self.fontSize * 1.76) / 2 + 3,\r\n                                fontSize: self.fontSize * 1.76\r\n                            });\r\n                        } else {\r\n                            textTop.set({\r\n                                top: self.top + self.textTopOffsetTop\r\n                            });\r\n                            textBottom.set({\r\n                                top: self.top + self.textBottomOffsetTop,\r\n                                fontSize: self.fontSize\r\n                            });\r\n                            textTop.show();\r\n                            textBottom.show();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                var superShow = self.show.bind(self);\r\n                self.show = function () {\r\n                    superShow.apply(null, arguments);\r\n                    self.setSingleLine(self.singleLineMode);\r\n                };\r\n\r\n                self.resize();\r\n\r\n                return self;\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/TextBox.js"),eval("// statusBottomView\r\n// contains bottom informative panel\r\ndefine('layers/statusBottom/statusBottomView',[\r\n    'data/config-statusBottom',\r\n    'components/Rectangle',\r\n    'components/DomRectangle',\r\n    'components/TextBox',\r\n    'services/math'\r\n], function (\r\n        config,\r\n        Rectangle,\r\n        DomRectangle,\r\n        TextBox,\r\n        math) {\r\n\r\n    return function mCreate(ctrl) {\r\n\r\n        function bounceWin() {\r\n            var duration = 1000;\r\n            var scale = 1.42;\r\n            var passedMs = .28 * duration;\r\n            var initFs = elements.winBox.jQueryEl[2].fontSize;\r\n            var initTop = elements.winBox.jQueryEl[2].top;\r\n            var fs;\r\n            var progress = 0;\r\n            elements.winBox.update = function (delta) {\r\n                passedMs += delta * 1000;\r\n                if (passedMs >= duration) {\r\n                    progress = 1;\r\n                } else {\r\n                    progress = math.easeInOutQuint(passedMs / duration);\r\n                }\r\n                fs = progress <= .5\r\n                        ? initFs * (1 + 2 * progress * (scale - 1))\r\n                        : initFs * (scale\r\n                                - 2 * (progress - .5) * (scale - 1));\r\n                elements.winBox.jQueryEl[2].set({\r\n                    fontSize: fs,\r\n                    top: initTop - ((fs - initFs) / 2)*0.7\r\n                });\r\n                if (progress === 1) {\r\n                    elements.winBox.update = null;\r\n                }\r\n            };\r\n        }\r\n\r\n        var elements = {\r\n            topInfoBack: DomRectangle({\r\n                groupCtrl: ctrl,\r\n                name: 'bet-status-info-back',\r\n                left: config.BACK_LEFT,\r\n                top: config.BACK_TOP,\r\n                width: config.BACK_WIDTH,\r\n                height: config.INFO_BACK_HEIGHT,\r\n                zIndex: 20,\r\n                color: 'rgba(0,0,0,.7)',\r\n                css: {\r\n                    'border-top': '1px solid rgb(139,139,139)',\r\n                    'border-bottom': '1px solid #969696',\r\n                },\r\n            }),\r\n            bottomBack: DomRectangle({\r\n                groupCtrl: ctrl,\r\n                name: 'bet-status-bottom-back',\r\n                left: config.BACK_LEFT,\r\n                top: config.BOX_TOP,\r\n                width: config.BACK_WIDTH,\r\n                height: config.BOX_HEIGHT + 1,\r\n                zIndex: 20,\r\n                color: 'rgba(0,0,0,.7)',\r\n            }),\r\n            clickablePanel: Rectangle({\r\n                groupCtrl: ctrl,\r\n                name: 'bet-status-bottom-clickable',\r\n                left: config.BACK_LEFT,\r\n                top: config.BACK_TOP,\r\n                width: config.BACK_WIDTH,\r\n                height: config.INFO_BACK_HEIGHT + config.BOX_HEIGHT + 1,\r\n                zIndex: 20,\r\n                color: null,\r\n                canvasLayer: 'ui',\r\n                click: ctrl.viewActions.panelClicked,\r\n            }),\r\n            creditsBox: TextBox({\r\n                groupCtrl: ctrl,\r\n                name: 'credits-box',\r\n                left: config.BASE_OFFSET_LEFT + config.CREDITS_VALUE_LEFT,\r\n                top: config.BOX_TOP,\r\n                textTop: '^credits',\r\n                textBottom: '',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    lineHeight: 1,\r\n                },\r\n                fontSize: config.LABELS_FONT_SIZE,\r\n                width: config.CREDITS_BOX_WIDTH,\r\n                height: config.BOX_HEIGHT,\r\n                colorBack: 'none',\r\n                colorTextTop: 'rgb(150,150,150)',\r\n                colorTextBottom: 'white',\r\n                zIndex: 21,\r\n            }),\r\n            denomBox: TextBox({\r\n                groupCtrl: ctrl,\r\n                name: 'denom-box',\r\n                left: config.BASE_OFFSET_LEFT + config.DENOM_VALUE_LEFT,\r\n                top: config.BOX_TOP,\r\n                textTop: '^denom',\r\n                textBottom: '',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    lineHeight: 1,\r\n                },\r\n                fontSize: config.LABELS_FONT_SIZE,\r\n                width: config.DENOM_BOX_WIDTH,\r\n                height: config.BOX_HEIGHT,\r\n                colorBack: 'none',\r\n                colorTextTop: 'rgb(150,150,150)',\r\n                colorTextBottom: 'white',\r\n                zIndex: 21,\r\n            }),\r\n            betBox: TextBox({\r\n                groupCtrl: ctrl,\r\n                name: 'bet-box',\r\n                left: config.BASE_OFFSET_LEFT + config.BET_VALUE_LEFT,\r\n                top: config.BOX_TOP,\r\n                textTop: '^bet',\r\n                textBottom: '',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    lineHeight: 1,\r\n                },\r\n                fontSize: config.LABELS_FONT_SIZE,\r\n                width: config.BET_BOX_WIDTH,\r\n                height: config.BOX_HEIGHT,\r\n                colorBack: 'none',\r\n                colorTextTop: 'rgb(150,150,150)',\r\n                colorTextBottom: 'white',\r\n                zIndex: 21,\r\n            }),\r\n            linesBox: TextBox({\r\n                groupCtrl: ctrl,\r\n                name: 'lines-box',\r\n                left: config.BASE_OFFSET_LEFT + config.LINES_VALUE_LEFT,\r\n                top: config.BOX_TOP,\r\n                textTop: '^lines',\r\n                textBottom: '',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    lineHeight: 1,\r\n                },\r\n                fontSize: config.LABELS_FONT_SIZE,\r\n                width: config.LINES_BOX_WIDTH,\r\n                height: config.BOX_HEIGHT,\r\n                colorBack: 'none',\r\n                colorTextTop: 'rgb(150,150,150)',\r\n                colorTextBottom: 'white',\r\n                zIndex: 21,\r\n            }),\r\n            totalBetBox: TextBox({\r\n                groupCtrl: ctrl,\r\n                name: 'total-bet-box',\r\n                left: config.BASE_OFFSET_LEFT + config.TOTALBET_VALUE_LEFT,\r\n                top: config.BOX_TOP,\r\n                textTop: '^totalBet',\r\n                textBottom: '',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    lineHeight: 1,\r\n                },\r\n                fontSize: config.LABELS_FONT_SIZE,\r\n                width: config.TOTALBET_BOX_WIDTH,\r\n                height: config.BOX_HEIGHT,\r\n                colorBack: 'none',\r\n                colorTextTop: 'rgb(150,150,150)',\r\n                colorTextBottom: 'white',\r\n                zIndex: 21,\r\n                backCss: {\r\n                    'border-right': '1px solid #969696',\r\n                },\r\n            }),\r\n            winBox: TextBox({\r\n                groupCtrl: ctrl,\r\n                name: 'win-box',\r\n                left: config.BASE_OFFSET_LEFT + config.WIN_VALUE_LEFT,\r\n                top: config.BOX_TOP,\r\n                textTop: '',\r\n                textBottom: '',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    lineHeight: 1,\r\n                },\r\n                fontSize: config.LABELS_FONT_SIZE,\r\n                width: config.WIN_BOX_WIDTH,\r\n                height: config.BOX_HEIGHT,\r\n                colorBack: 'none',\r\n                colorTextTop: 'rgb(150,150,150)',\r\n                colorTextBottom: 'white',\r\n                zIndex: 21,\r\n                backCss: {\r\n                    'border-right': '1px solid #969696',\r\n                },\r\n            }),\r\n        };\r\n        // API\r\n        return {\r\n            elements: elements,\r\n            actions: {\r\n                bounceWin: bounceWin\r\n            }\r\n        };\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/statusBottom/statusBottomView.js"),eval('/* big.js v3.1.3 https://github.com/MikeMcl/big.js/LICENCE */(function(global){"use strict";var DP=20,RM=1,MAX_DP=1e6,MAX_POWER=1e6,E_NEG=-7,E_POS=21,P={},isValid=/^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,Big;function bigFactory(){function Big(n){var x=this;if(!(x instanceof Big)){return n===void 0?bigFactory():new Big(n)}if(n instanceof Big){x.s=n.s;x.e=n.e;x.c=n.c.slice()}else{parse(x,n)}x.constructor=Big}Big.prototype=P;Big.DP=DP;Big.RM=RM;Big.E_NEG=E_NEG;Big.E_POS=E_POS;return Big}function format(x,dp,toE){var Big=x.constructor,i=dp-(x=new Big(x)).e,c=x.c;if(c.length>++dp){rnd(x,i,Big.RM)}if(!c[0]){++i}else if(toE){i=dp}else{c=x.c;i=x.e+i+1}for(;c.length<i;c.push(0)){}i=x.e;return toE===1||toE&&(dp<=i||i<=Big.E_NEG)?(x.s<0&&c[0]?"-":"")+(c.length>1?c[0]+"."+c.join("").slice(1):c[0])+(i<0?"e":"e+")+i:x.toString()}function parse(x,n){var e,i,nL;if(n===0&&1/n<0){n="-0"}else if(!isValid.test(n+="")){throwErr(NaN)}x.s=n.charAt(0)=="-"?(n=n.slice(1),-1):1;if((e=n.indexOf("."))>-1){n=n.replace(".","")}if((i=n.search(/e/i))>0){if(e<0){e=i}e+=+n.slice(i+1);n=n.substring(0,i)}else if(e<0){e=n.length}for(i=0;n.charAt(i)=="0";i++){}if(i==(nL=n.length)){x.c=[x.e=0]}else{for(;n.charAt(--nL)=="0";){}x.e=e-i-1;x.c=[];for(e=0;i<=nL;x.c[e++]=+n.charAt(i++)){}}return x}function rnd(x,dp,rm,more){var u,xc=x.c,i=x.e+dp+1;if(rm===1){more=xc[i]>=5}else if(rm===2){more=xc[i]>5||xc[i]==5&&(more||i<0||xc[i+1]!==u||xc[i-1]&1)}else if(rm===3){more=more||xc[i]!==u||i<0}else{more=false;if(rm!==0){throwErr("!Big.RM!")}}if(i<1||!xc[0]){if(more){x.e=-dp;x.c=[1]}else{x.c=[x.e=0]}}else{xc.length=i--;if(more){for(;++xc[i]>9;){xc[i]=0;if(!i--){++x.e;xc.unshift(1)}}}for(i=xc.length;!xc[--i];xc.pop()){}}return x}function throwErr(message){var err=new Error(message);err.name="BigError";throw err}P.abs=function(){var x=new this.constructor(this);x.s=1;return x};P.cmp=function(y){var xNeg,x=this,xc=x.c,yc=(y=new x.constructor(y)).c,i=x.s,j=y.s,k=x.e,l=y.e;if(!xc[0]||!yc[0]){return!xc[0]?!yc[0]?0:-j:i}if(i!=j){return i}xNeg=i<0;if(k!=l){return k>l^xNeg?1:-1}i=-1;j=(k=xc.length)<(l=yc.length)?k:l;for(;++i<j;){if(xc[i]!=yc[i]){return xc[i]>yc[i]^xNeg?1:-1}}return k==l?0:k>l^xNeg?1:-1};P.div=function(y){var x=this,Big=x.constructor,dvd=x.c,dvs=(y=new Big(y)).c,s=x.s==y.s?1:-1,dp=Big.DP;if(dp!==~~dp||dp<0||dp>MAX_DP){throwErr("!Big.DP!")}if(!dvd[0]||!dvs[0]){if(dvd[0]==dvs[0]){throwErr(NaN)}if(!dvs[0]){throwErr(s/0)}return new Big(s*0)}var dvsL,dvsT,next,cmp,remI,u,dvsZ=dvs.slice(),dvdI=dvsL=dvs.length,dvdL=dvd.length,rem=dvd.slice(0,dvsL),remL=rem.length,q=y,qc=q.c=[],qi=0,digits=dp+(q.e=x.e-y.e)+1;q.s=s;s=digits<0?0:digits;dvsZ.unshift(0);for(;remL++<dvsL;rem.push(0)){}do{for(next=0;next<10;next++){if(dvsL!=(remL=rem.length)){cmp=dvsL>remL?1:-1}else{for(remI=-1,cmp=0;++remI<dvsL;){if(dvs[remI]!=rem[remI]){cmp=dvs[remI]>rem[remI]?1:-1;break}}}if(cmp<0){for(dvsT=remL==dvsL?dvs:dvsZ;remL;){if(rem[--remL]<dvsT[remL]){remI=remL;for(;remI&&!rem[--remI];rem[remI]=9){}--rem[remI];rem[remL]+=10}rem[remL]-=dvsT[remL]}for(;!rem[0];rem.shift()){}}else{break}}qc[qi++]=cmp?next:++next;if(rem[0]&&cmp){rem[remL]=dvd[dvdI]||0}else{rem=[dvd[dvdI]]}}while((dvdI++<dvdL||rem[0]!==u)&&s--);if(!qc[0]&&qi!=1){qc.shift();q.e--}if(qi>digits){rnd(q,dp,Big.RM,rem[0]!==u)}return q};P.eq=function(y){return!this.cmp(y)};P.gt=function(y){return this.cmp(y)>0};P.gte=function(y){return this.cmp(y)>-1};P.lt=function(y){return this.cmp(y)<0};P.lte=function(y){return this.cmp(y)<1};P.sub=P.minus=function(y){var i,j,t,xLTy,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;if(a!=b){y.s=-b;return x.plus(y)}var xc=x.c.slice(),xe=x.e,yc=y.c,ye=y.e;if(!xc[0]||!yc[0]){return yc[0]?(y.s=-b,y):new Big(xc[0]?x:0)}if(a=xe-ye){if(xLTy=a<0){a=-a;t=xc}else{ye=xe;t=yc}t.reverse();for(b=a;b--;t.push(0)){}t.reverse()}else{j=((xLTy=xc.length<yc.length)?xc:yc).length;for(a=b=0;b<j;b++){if(xc[b]!=yc[b]){xLTy=xc[b]<yc[b];break}}}if(xLTy){t=xc;xc=yc;yc=t;y.s=-y.s}if((b=(j=yc.length)-(i=xc.length))>0){for(;b--;xc[i++]=0){}}for(b=i;j>a;){if(xc[--j]<yc[j]){for(i=j;i&&!xc[--i];xc[i]=9){}--xc[i];xc[j]+=10}xc[j]-=yc[j]}for(;xc[--b]===0;xc.pop()){}for(;xc[0]===0;){xc.shift();--ye}if(!xc[0]){y.s=1;xc=[ye=0]}y.c=xc;y.e=ye;return y};P.mod=function(y){var yGTx,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;if(!y.c[0]){throwErr(NaN)}x.s=y.s=1;yGTx=y.cmp(x)==1;x.s=a;y.s=b;if(yGTx){return new Big(x)}a=Big.DP;b=Big.RM;Big.DP=Big.RM=0;x=x.div(y);Big.DP=a;Big.RM=b;return this.minus(x.times(y))};P.add=P.plus=function(y){var t,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;if(a!=b){y.s=-b;return x.minus(y)}var xe=x.e,xc=x.c,ye=y.e,yc=y.c;if(!xc[0]||!yc[0]){return yc[0]?y:new Big(xc[0]?x:a*0)}xc=xc.slice();if(a=xe-ye){if(a>0){ye=xe;t=yc}else{a=-a;t=xc}t.reverse();for(;a--;t.push(0)){}t.reverse()}if(xc.length-yc.length<0){t=yc;yc=xc;xc=t}a=yc.length;for(b=0;a;){b=(xc[--a]=xc[a]+yc[a]+b)/10|0;xc[a]%=10}if(b){xc.unshift(b);++ye}for(a=xc.length;xc[--a]===0;xc.pop()){}y.c=xc;y.e=ye;return y};P.pow=function(n){var x=this,one=new x.constructor(1),y=one,isNeg=n<0;if(n!==~~n||n<-MAX_POWER||n>MAX_POWER){throwErr("!pow!")}n=isNeg?-n:n;for(;;){if(n&1){y=y.times(x)}n>>=1;if(!n){break}x=x.times(x)}return isNeg?one.div(y):y};P.round=function(dp,rm){var x=this,Big=x.constructor;if(dp==null){dp=0}else if(dp!==~~dp||dp<0||dp>MAX_DP){throwErr("!round!")}rnd(x=new Big(x),dp,rm==null?Big.RM:rm);return x};P.sqrt=function(){var estimate,r,approx,x=this,Big=x.constructor,xc=x.c,i=x.s,e=x.e,half=new Big("0.5");if(!xc[0]){return new Big(x)}if(i<0){throwErr(NaN)}i=Math.sqrt(x.toString());if(i===0||i===1/0){estimate=xc.join("");if(!(estimate.length+e&1)){estimate+="0"}r=new Big(Math.sqrt(estimate).toString());r.e=((e+1)/2|0)-(e<0||e&1)}else{r=new Big(i.toString())}i=r.e+(Big.DP+=4);do{approx=r;r=half.times(approx.plus(x.div(approx)))}while(approx.c.slice(0,i).join("")!==r.c.slice(0,i).join(""));rnd(r,Big.DP-=4,Big.RM);return r};P.mul=P.times=function(y){var c,x=this,Big=x.constructor,xc=x.c,yc=(y=new Big(y)).c,a=xc.length,b=yc.length,i=x.e,j=y.e;y.s=x.s==y.s?1:-1;if(!xc[0]||!yc[0]){return new Big(y.s*0)}y.e=i+j;if(a<b){c=xc;xc=yc;yc=c;j=a;a=b;b=j}for(c=new Array(j=a+b);j--;c[j]=0){}for(i=b;i--;){b=0;for(j=a+i;j>i;){b=c[j]+yc[i]*xc[j-i-1]+b;c[j--]=b%10;b=b/10|0}c[j]=(c[j]+b)%10}if(b){++y.e}if(!c[0]){c.shift()}for(i=c.length;!c[--i];c.pop()){}y.c=c;return y};P.toString=P.valueOf=P.toJSON=function(){var x=this,Big=x.constructor,e=x.e,str=x.c.join(""),strL=str.length;if(e<=Big.E_NEG||e>=Big.E_POS){str=str.charAt(0)+(strL>1?"."+str.slice(1):"")+(e<0?"e":"e+")+e}else if(e<0){for(;++e;str="0"+str){}str="0."+str}else if(e>0){if(++e>strL){for(e-=strL;e--;str+="0"){}}else if(e<strL){str=str.slice(0,e)+"."+str.slice(e)}}else if(strL>1){str=str.charAt(0)+"."+str.slice(1)}return x.s<0&&x.c[0]?"-"+str:str};P.toExponential=function(dp){if(dp==null){dp=this.c.length-1}else if(dp!==~~dp||dp<0||dp>MAX_DP){throwErr("!toExp!")}return format(this,dp,1)};P.toFixed=function(dp){var str,x=this,Big=x.constructor,neg=Big.E_NEG,pos=Big.E_POS;Big.E_NEG=-(Big.E_POS=1/0);if(dp==null){str=x.toString()}else if(dp===~~dp&&dp>=0&&dp<=MAX_DP){str=format(x,x.e+dp);if(x.s<0&&x.c[0]&&str.indexOf("-")<0){str="-"+str}}Big.E_NEG=neg;Big.E_POS=pos;if(!str){throwErr("!toFix!")}return str};P.toPrecision=function(sd){if(sd==null){return this.toString()}else if(sd!==~~sd||sd<1||sd>MAX_DP){throwErr("!toPre!")}return format(this,sd-1,2)};Big=bigFactory();if(typeof define==="function"&&define.amd){define(\'big\',[],function(){return Big})}else if(typeof module!=="undefined"&&module.exports){module.exports=Big}else{global.Big=Big}})(this);\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/big.min.js'),eval("// format\r\n//\r\ndefine('services/format',['pubsub', 'big', 'services/settings'], function (pubsub, big, settings) {\r\n\r\n    function formatMoney(n, c, d, t) {\r\n        var c = isNaN(c = Math.abs(c)) ? 2 : c,\r\n                d = d == undefined ? \".\" : d,\r\n                t = t == undefined ? \",\" : t,\r\n                s = n < 0 ? \"-\" : \"\",\r\n                i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + \"\",\r\n                j = (j = i.length) > 3 ? j % 3 : 0;\r\n        return s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : \"\");\r\n    }\r\n\r\n    function formatCash(amt, decimalPlaces) {\r\n        amt = Number(amt);\r\n        if (isNaN(amt)) {\r\n            return amt;\r\n        }\r\n        !decimalPlaces && (decimalPlaces = 2);\r\n        return formatMoney(amt, decimalPlaces, '.', ' ');\r\n    }\r\n\r\n    function formatAmountWithDenom(credits, decimalPlaces) {\r\n        credits = Number(credits);\r\n        if (isNaN(credits) || credits === '') {\r\n            return credits;\r\n        }\r\n        !decimalPlaces && (decimalPlaces = 2);\r\n        if (settings.get().credits.showInCash) {\r\n            return formatMoney(getCashForCredits(credits), decimalPlaces, '.', ' ');\r\n        } else {\r\n            return formatCredits(credits);\r\n        }\r\n    }\r\n\r\n    function formatDenom(amt) {\r\n        if (isNaN(amt) || amt === '') {\r\n            return amt;\r\n        }\r\n\r\n        amt = String(amt);\r\n        while ((amt[amt.length - 1] === '0'\r\n                && amt.indexOf('.') > -1)\r\n                || amt[amt.length - 1] === '.') {\r\n            amt = amt.substr(0, amt.length - 1);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function formatCredits(amt) {\r\n        amt = Number(amt);\r\n        if (isNaN(amt)) {\r\n            return amt;\r\n        }\r\n        return formatMoney(amt, 0, '', ' ');\r\n    }\r\n\r\n    function getCashForCredits(credits) {\r\n        return Number(big(credits).times(denom).valueOf());\r\n    }\r\n\r\n    var denom = 0;\r\n\r\n    pubsub.subscribeBatch({\r\n        'request:updateViewsWithModels': function (id, data) {\r\n            denom = data.betModel.denomination;\r\n        },\r\n        'notify:denominationChanged': function (id, val) {\r\n            denom = val;\r\n        },\r\n    });\r\n\r\n    var API = {\r\n        formatCredits: formatCredits,\r\n        formatDenom: formatDenom,\r\n        formatAmount: formatCash,\r\n        formatAmountWithDenom: formatAmountWithDenom,\r\n        getCashForCredits: getCashForCredits,\r\n    };\r\n\r\n    return API;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/format.js"),eval("// statusBottomCtrl\r\n// controls bottom informative panel\r\ndefine('layers/statusBottom/statusBottomCtrl',[\r\n    'pubsub',\r\n    'data/config',\r\n    'components/GroupCtrl',\r\n    'layers/statusBottom/statusBottomView',\r\n    'services/settings',\r\n    'services/format',\r\n    'services/platform',\r\n], function (pubsub, globalConfig, GroupCtrl, statusBottomView, settings, format,\r\n        platform) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var lastWin = null;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        panelClicked: function (evt) {\r\n            if (!platform.isMobile() || evt.data.originalEvent.touches.length === 0) {\r\n// do not allow multi touch when user wants to open menu\r\n                // to prevent dragging reels/spin button while opening menu\r\n                pubsub.publish('notify:bottomPanelClicked');\r\n            }\r\n        }\r\n    };\r\n\r\n    // initialize view\r\n    self.view = statusBottomView(self);\r\n\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        'request:adjustControls': mAdjustControls,\r\n        'request:updateViewsWithModels': function (id, data) {\r\n            showAmount({\r\n                cash: data.betModel.cash,\r\n                credits: data.betModel.credits,\r\n                currency: data.betModel.currency,\r\n            });\r\n            self.view.elements.betBox.setTextBottom('!'\r\n                    + format.formatAmountWithDenom(data.betModel.bet));\r\n            self.view.elements.denomBox.setTextBottom('!'\r\n                    + format.formatDenom(data.betModel.denomination));\r\n            self.view.elements.totalBetBox.setTextBottom('!'\r\n                    + format.formatAmountWithDenom(data.betModel.totalBet));\r\n            self.view.elements.linesBox.setTextBottom('!'\r\n                    + data.betModel.activeLines);\r\n        },\r\n        'request:subtractTotalBetFromView': function (id, data) {\r\n            showAmount({\r\n                cash: data.betModel.cash - format.getCashForCredits(\r\n                        data.betModel.totalBet),\r\n                credits: data.betModel.credits - data.betModel.totalBet,\r\n                currency: data.betModel.currency,\r\n            });\r\n        },\r\n        'request:winAmountAnimationUpdate': function (id, data) {\r\n            if (data.currentCash) {\r\n                showAmount({\r\n                    cash: data.currentCash,\r\n                    credits: data.currentCredits,\r\n                    currency: data.betModel.currency,\r\n                });\r\n            }\r\n            if (data.finished) {\r\n                hideWin();\r\n            } else {\r\n                self.view.elements.winBox.setSingleLine(true);\r\n                if (settings.get().credits.showInCash) {\r\n                    self.view.elements.winBox.setTextBottom(\r\n                            ['win', '! '\r\n                                        + format.formatAmount(data.currentCountdownCash)]);\r\n                } else {\r\n                    self.view.elements.winBox.setTextBottom(\r\n                            ['win', '! '\r\n                                        + data.currentCountdownCredits]);\r\n                }\r\n            }\r\n        },\r\n        'request:bounceWinText': function (id, data) {\r\n            self.view.actions.bounceWin();\r\n        },\r\n        'request:showWinningsHeader': function (id, data) {\r\n            if (data.winnings) {\r\n                self.view.elements.winBox.setSingleLine(true);\r\n                self.view.elements.winBox.setTextBottom(['win', '! '\r\n                            + format.formatAmountWithDenom(data.winnings)]);\r\n            }\r\n        },\r\n        'notify:winAccepted': winAccepted,\r\n        'request:hideWinningsHeader': hideWin,\r\n    });\r\n\r\n    return self;\r\n\r\n    function winAccepted(id, data) {\r\n        if (data.gameModel.lastSpinResult.totalWin > 0) {\r\n            lastWin = data.gameModel.lastSpinResult.totalWin;\r\n        }\r\n    }\r\n    function hideWin(id, data) {\r\n        if (lastWin) {\r\n            self.view.elements.winBox.setSingleLine(false);\r\n            self.view.elements.winBox.setTextTop('^lastWin');\r\n            self.view.elements.winBox.setTextBottom(\r\n                    format.formatAmountWithDenom(lastWin));\r\n        } else {\r\n            self.view.elements.winBox.setSingleLine(true);\r\n            self.view.elements.winBox.setTextBottom('');\r\n        }\r\n    }\r\n    function showAmount(data) {\r\n        if (settings.get().credits.showInCash) {\r\n            self.view.elements.creditsBox.setTextTop('^cash');\r\n            self.view.elements.creditsBox.setTextBottom('!' +\r\n                    format.formatAmount(data.cash) + ' ' + data.currency);\r\n        } else {\r\n            self.view.elements.creditsBox.setTextTop('^credits');\r\n            self.view.elements.creditsBox.setTextBottom('!'\r\n                    + format.formatCredits(data.credits));\r\n        }\r\n    }\r\n\r\n    // update button state\r\n    // according to config JSON\r\n    function mAdjustControls(id, data) {\r\n        if (globalConfig.UI_TYPE === 'original') {\r\n            self.hideAll();\r\n            return;\r\n        }\r\n        if (data.bottomControls === 'active') {\r\n            self.showAll();\r\n        } else {\r\n            self.hideAll();\r\n            return;\r\n        }\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/statusBottom/statusBottomCtrl.js"),
eval('define(\'data/config-betlines\',{\r\n    LINE_SEGMENT_FIRST_LEFT: 133,\r\n    LINE_SEGMENT_ROW_TOP: {\r\n        1: 198,\r\n        2: 323.5,\r\n        3: 449\r\n    },\r\n    LINES_ROWS_OFFSET_TOP: {\r\n        1: 0,\r\n        2: 0,\r\n        3: 0,\r\n    },\r\n    LINE_SEGMENT_WIDTH: 138.8,\r\n    LINES_DIMENSIONS_MODIFIER: {\r\n        x: 1,\r\n        y: 1\r\n    },\r\n    BETLINES_POSITIONS: {\r\n        "0": {\r\n            "line": [2, 2, 2, 2, 2]\r\n        },\r\n        "1": {\r\n            "line": [1, 1, 1, 1, 1]\r\n        },\r\n        "2": {\r\n            "line": [3, 3, 3, 3, 3]\r\n        },\r\n        "3": {\r\n            "line": [1, 2, 3, 2, 1]\r\n        },\r\n        "4": {\r\n            "line": [3, 2, 1, 2, 3]\r\n        },\r\n        "5": {\r\n            "line": [1, 1, 2, 1, 1]\r\n        },\r\n        "6": {\r\n            "line": [3, 3, 2, 3, 3]\r\n        },\r\n        "7": {\r\n            "line": [2, 1, 1, 1, 2]\r\n        },\r\n        "8": {\r\n            "line": [2, 3, 3, 3, 2]\r\n        },\r\n        "9": {\r\n            "line": [2, 1, 2, 1, 2]\r\n        },\r\n        "10": {\r\n            "line": [2, 3, 2, 3, 2]\r\n        },\r\n        "11": {\r\n            "line": [1, 2, 1, 2, 1]\r\n        },\r\n        "12": {\r\n            "line": [3, 2, 3, 2, 3]\r\n        },\r\n        "13": {\r\n            "line": [2, 2, 1, 2, 2, ]\r\n        },\r\n        "14": {\r\n            "line": [2, 2, 3, 2, 2]\r\n        },\r\n        "15": {\r\n            "line": [1, 2, 2, 2, 3]\r\n        },\r\n        "16": {\r\n            "line": [3, 2, 2, 2, 1]\r\n        },\r\n        "17": {\r\n            "line": [1, 1, 2, 3, 3]\r\n        },\r\n        "18": {\r\n            "line": [3, 3, 2, 1, 1]\r\n        },\r\n        "19": {\r\n            "line": [2, 1, 3, 1, 2]\r\n        }\r\n    },\r\n    LINES_EXCHANGEABILITY: {\r\n        2: 1,\r\n        3: 1,\r\n    },\r\n    LINE_RELATIVE_Y_POSITIONS: {\r\n        "1": {\r\n            "LINE": [\r\n                -11,\r\n                -11,\r\n                -11,\r\n                -11,\r\n                -11\r\n            ],\r\n            "WIN": [\r\n                -69,\r\n                -72,\r\n                -72,\r\n                -72,\r\n                -69\r\n            ]\r\n        },\r\n        "4": {\r\n            "LINE": [\r\n                -13,\r\n                71,\r\n                171,\r\n                69,\r\n                -9\r\n            ],\r\n            "WIN": [\r\n                -63,\r\n                47,\r\n                166,\r\n                51,\r\n                -62\r\n            ]\r\n        },\r\n        "5": {\r\n            "LINE": [\r\n                -92,\r\n                -194,\r\n                -245,\r\n                -194,\r\n                -92\r\n            ],\r\n            "WIN": [\r\n                -87,\r\n                -193,\r\n                -294,\r\n                -192,\r\n                -93\r\n            ]\r\n        },\r\n        "6": {\r\n            "LINE": [\r\n                -10,\r\n                -12,\r\n                35,\r\n                -14,\r\n                -6\r\n            ],\r\n            "WIN": [\r\n                -63,\r\n                -63,\r\n                39,\r\n                -63,\r\n                -63\r\n            ]\r\n        },\r\n        "7": {\r\n            "LINE": [\r\n                -10,\r\n                -65,\r\n                -111,\r\n                -65,\r\n                -6\r\n            ],\r\n            "WIN": [\r\n                -71,\r\n                -71,\r\n                -192,\r\n                -71,\r\n                -68\r\n            ]\r\n        },\r\n        "8": {\r\n            "LINE": [\r\n                -58,\r\n                -101,\r\n                -98,\r\n                -100,\r\n                -62\r\n            ],\r\n            "WIN": [\r\n                -69,\r\n                -178,\r\n                -178,\r\n                -177,\r\n                -69\r\n            ]\r\n        },\r\n        "9": {\r\n            "LINE": [\r\n                -6,\r\n                38,\r\n                82,\r\n                40,\r\n                -9\r\n            ],\r\n            "WIN": [\r\n                -73,\r\n                43,\r\n                40,\r\n                43,\r\n                -69\r\n            ]\r\n        },\r\n        "10": {\r\n            "LINE": [\r\n                -74,\r\n                -110,\r\n                -48,\r\n                -110,\r\n                -74\r\n            ],\r\n            "WIN": [\r\n                -69,\r\n                -178,\r\n                -68,\r\n                -177,\r\n                -70\r\n            ]\r\n        },\r\n        "11": {\r\n            "LINE": [\r\n                -10,\r\n                20,\r\n                3,\r\n                28,\r\n                -10\r\n            ],\r\n            "WIN": [\r\n                -68,\r\n                31,\r\n                -70,\r\n                26,\r\n                -70\r\n            ]\r\n        },\r\n        "12": {\r\n            "LINE": [\r\n                -13,\r\n                28,\r\n                16,\r\n                28,\r\n                -8\r\n            ],\r\n            "WIN": [\r\n                -63,\r\n                28,\r\n                -63,\r\n                35,\r\n                -62\r\n            ]\r\n        },\r\n        "13": {\r\n            "LINE": [\r\n                -48,\r\n                -115,\r\n                -91,\r\n                -119,\r\n                -54\r\n            ],\r\n            "WIN": [\r\n                -70,\r\n                -188,\r\n                -97,\r\n                -182,\r\n                -75\r\n            ]\r\n        },\r\n        "14": {\r\n            "LINE": [\r\n                -11,\r\n                -63,\r\n                -179,\r\n                -58,\r\n                -13\r\n            ],\r\n            "WIN": [\r\n                -69,\r\n                -69,\r\n                -178,\r\n                -65,\r\n                -71\r\n            ]\r\n        },\r\n        "15": {\r\n            "LINE": [\r\n                -11,\r\n                -16,\r\n                41,\r\n                -13,\r\n                -11\r\n            ],\r\n            "WIN": [\r\n                -72,\r\n                -69,\r\n                38,\r\n                -71,\r\n                -68\r\n            ]\r\n        },\r\n        "16": {\r\n            "LINE": [\r\n                -7,\r\n                42,\r\n                89,\r\n                89,\r\n                167\r\n            ],\r\n            "WIN": [\r\n                -63,\r\n                45,\r\n                51,\r\n                51,\r\n                167\r\n            ]\r\n        },\r\n        "17": {\r\n            "LINE": [\r\n                -65,\r\n                -143,\r\n                -143,\r\n                -196,\r\n                -240\r\n            ],\r\n            "WIN": [\r\n                -68,\r\n                -183,\r\n                -182,\r\n                -188,\r\n                -296\r\n            ]\r\n        },\r\n        "18": {\r\n            "LINE": [\r\n                -7,\r\n                -7,\r\n                42,\r\n                141,\r\n                226\r\n            ],\r\n            "WIN": [\r\n                -63,\r\n                -62,\r\n                37,\r\n                148,\r\n                167\r\n            ]\r\n        },\r\n        "19": {\r\n            "LINE": [\r\n                -10,\r\n                -90,\r\n                -189,\r\n                -240,\r\n                -240\r\n            ],\r\n            "WIN": [\r\n                -68,\r\n                -89,\r\n                -196,\r\n                -294,\r\n                -293\r\n            ]\r\n        },\r\n        "20": {\r\n            "LINE": [\r\n                -68,\r\n                -123,\r\n                -9,\r\n                -124,\r\n                -67\r\n            ],\r\n            "WIN": [\r\n                -69,\r\n                -178,\r\n                -14,\r\n                -178,\r\n                -68\r\n            ]\r\n        }\r\n    },\r\n    LINE_RELATIVE_Y_POSITIONS_ADJUSTMENT: {\r\n        "1": {\r\n            "LINE": [\r\n            ],\r\n            "WIN": [\r\n                -5\r\n            ]\r\n        },\r\n        "4": {LINE: [-1.5, 7.3, 8.2, -9.5, -7.3], WIN: [-5.5, 9.3, 9.7, -10.3, -9.3]},\r\n        "5": {\r\n            "LINE": [-5.5, -9.2, -6, 5.7, 9.2], "WIN": [-5, -11, -10.5, 9.5, 9]\r\n        },\r\n        "6": {LINE: [-1, -1.1, 4, -5.3, .5], WIN: [-5.6, 0, 9.2, -9.2]},\r\n        "7": {LINE: [0, -4.5, -5, 4.9, 4.3], WIN: [-4.7, 0, -9.8, 10.3]},\r\n        "8": {LINE: [-4.5, -5, .4, -.4, 4.8], WIN: [-4.9, -10.3, 0, -1, 8.7]},\r\n        "9": {LINE: [0, 4.4, 4.2, -4, -5.3], WIN: [-4.7, 9.6, 0 - .2, 0, -10.7]},\r\n        "10": {LINE: [-6.1, -3.7, 6.2, -6.2, 3.7], WIN: [-5.4, -10.5, 9.5, -10.6, 9.4]},\r\n        "11": {LINE: [-1.5, 4.7, -3, 3.3, -4.7], WIN: [-5.8, 9, -10, 9.3, -9.5]},\r\n        "12": {LINE: [-1, 5, -2.6, 2.6, -3.5], WIN: [-5.1, 9, -8.8, 7.5, -8.6]},\r\n        "13": {LINE: [-2.5, -7, 4.3, -3.5, 6.5], WIN: [-3.5, -10.5, 9.2, -8.8, 9.4]},\r\n        "14": {LINE: [-.4, -5, -10, 10.5, 3.3], WIN: [-5, -.2, -10.4, 9.2, -.2]},\r\n        "15": {LINE: [0, -.9, 6, -5.7, 1.2], WIN: [-5, .3, 9.8, -10.5]},\r\n        "16": {LINE: [-1, 5.3, 4.5, 0, 7.2], WIN: [-5, 9, 0, -.3, 9.6]},\r\n        "17": {LINE: [-3.5, -7, 0, -4, -4], WIN: [-2.5, -11, -.8, .2, -9.2]},\r\n        "18": {LINE: [0, -.2, 5.3, 8.9, 6.5], WIN: [-3.8, -.8, 8.6, 8.7, 1.2]},\r\n        "19": {LINE: [0, -5.7, -8.7, -6.5, 0], WIN: [-5, -1.5, -9.8, -9.9, -1.2]},\r\n        "20": {LINE: [-5, -5.7, 11.2, -12.7, 5.5], WIN: [-5, -10.2, 15, -15.3, 9.5]},\r\n    },\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-betlines.js'),eval("// betlinesView\r\n// contains betline segment & scatter frame elements\r\n// constructs the elements based on game configuration\r\ndefine('layers/betlines/betlinesView',[\r\n    'data/config',\r\n    'data/config-betlines',\r\n    'services/assets',\r\n    'components/Sprite'\r\n], function (globalConfig, config, assets, Sprite) {\r\n\r\n\r\n    //>>includeStart(\"debug\", pragmas.debug);\r\n    window.betlinesConfig = config;\r\n    //>>includeEnd(\"debug\");\r\n\r\n\r\n    return function mCreate(ctrl, model) {\r\n\r\n        var elements = {};\r\n// API\r\n        var API = {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n                reinit: reinit\r\n            }\r\n        };\r\n\r\n        return API;\r\n\r\n        // helpers start\r\n        function reinit(mModel, reelSet) {\r\n            if (mModel) {\r\n                mClearLines();\r\n                mInitLines(mModel, reelSet);\r\n            }\r\n        }\r\n        function mClearLines() {\r\n            var keys = Object.keys(elements);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                delete elements[keys[i]];\r\n            }\r\n        }\r\n        function mInitLines(model, reelSet) {\r\n\r\n            if (model.previewLines.length > 0) {\r\n                var length = model.previewLines.length;\r\n                for (var i = 0; i < length; i++) {\r\n                    var line = model.previewLines[i];\r\n                    mInitLine(line, 'preview', model, reelSet);\r\n                }\r\n            }\r\n            if (model.hoverLine) {\r\n                mInitLine(model.hoverLine, 'hover', model, reelSet);\r\n            }\r\n            if (model.winLine) {\r\n                mInitLine(model.winLine, 'win', model, reelSet);\r\n            }\r\n        }\r\n\r\n        function mInitLine(line, type, model, reelSet) {\r\n            function initBetline() {\r\n                function getPathSegmentString(lineNumber) {\r\n                    var res = String(lineNumber);\r\n                    if (res.length === 1) {\r\n                        res = '0' + res;\r\n                    }\r\n                    return res;\r\n                }\r\n                var lineNumber = lineIndex + 1;\r\n                var adjustedLineNumber = lineIndex + 1;\r\n                if (config.LINES_EXCHANGEABILITY\r\n                        && config.LINES_EXCHANGEABILITY[adjustedLineNumber] !== undefined) {\r\n                    adjustedLineNumber = config.LINES_EXCHANGEABILITY[adjustedLineNumber];\r\n                }\r\n                var lineNumberPathSegment = getPathSegmentString(adjustedLineNumber);\r\n                var useSecondImageForMiddleLine = lineIndex < reelSet.VISIBLE_SYMBOLS_ON_REEL;\r\n\r\n                var firstColRow = model.betlineData[lineIndex].line[0];\r\n                for (var colIndex = 0; colIndex < reelSet.REELS_COUNT; colIndex++) {\r\n\r\n                    var imgPath = 'Control_panel/lines/' + lineNumberPathSegment + '_';\r\n                    var isWinElement = winColIndexes.indexOf(colIndex) > -1;\r\n                    if (isWinElement) {\r\n                        imgPath += 'win_0';\r\n                    } else {\r\n                        imgPath += 'line_0';\r\n                    }\r\n                    var collumnNumber = colIndex + 1;\r\n                    if (collumnNumber > 2 && collumnNumber < reelSet.REELS_COUNT\r\n                            && useSecondImageForMiddleLine) {\r\n                        imgPath += '2';\r\n                    } else {\r\n                        imgPath += collumnNumber;\r\n                    }\r\n\r\n                    var name = type + '-betline-' + lineIndex + '-sprite-' + colIndex + Math.random();\r\n\r\n                    var txt = assets.img(imgPath);\r\n                    var imgW = txt.width;\r\n                    var imgH = txt.height;\r\n                    var ratio = imgW / config.LINE_SEGMENT_WIDTH;\r\n                    var left, top, width, height;\r\n                    left = (config.LINE_SEGMENT_FIRST_LEFT + colIndex * config.LINE_SEGMENT_WIDTH);\r\n\r\n                    height = (imgH / ratio);\r\n\r\n                    width = config.LINE_SEGMENT_WIDTH;\r\n                    top = (config.ALL_LINES_OFFSET_TOP || 0)\r\n                            + config.LINE_SEGMENT_ROW_TOP[firstColRow];\r\n\r\n                    if (config.LINES_ROWS_OFFSET_TOP[firstColRow]) {\r\n                        top += config.LINES_ROWS_OFFSET_TOP[firstColRow];\r\n                    }\r\n\r\n                    var relConfig1 = config.LINE_RELATIVE_Y_POSITIONS;\r\n                    var relConfig2 = config.LINE_RELATIVE_Y_POSITIONS_ADJUSTMENT;\r\n                    var sType = isWinElement ? 'WIN' : 'LINE';\r\n                    var addTop = 0;\r\n                    if (relConfig1[String(lineNumber)]\r\n                            && relConfig1[String(lineNumber)][sType][colIndex] !== undefined) {\r\n                        addTop += relConfig1[String(lineNumber)][sType][colIndex];\r\n                    } else if (relConfig1[String(adjustedLineNumber)]\r\n                            && relConfig1[String(adjustedLineNumber)][sType][colIndex] !== undefined) {\r\n                        addTop += relConfig1[String(adjustedLineNumber)][sType][colIndex];\r\n                    }\r\n                    if (relConfig2[String(lineNumber)]\r\n                            && relConfig2[String(lineNumber)][sType].length > 0) {\r\n                        for (var i = 0; i <= colIndex; i++) {\r\n                            if (relConfig2[String(lineNumber)][sType][i]) {\r\n                                addTop += relConfig2[String(lineNumber)][sType][i];\r\n                            }\r\n                        }\r\n                    } else if (relConfig2[String(adjustedLineNumber)]\r\n                            && relConfig2[String(adjustedLineNumber)][sType].length > 0) {\r\n                        for (var i = 0; i <= colIndex; i++) {\r\n                            if (relConfig2[String(adjustedLineNumber)][sType][i]) {\r\n                                addTop += relConfig2[String(adjustedLineNumber)][sType][i];\r\n                            }\r\n                        }\r\n                    }\r\n                    top += addTop;\r\n\r\n                    if (config.LINES_DIMENSIONS_MODIFIER) {\r\n                        var modifier = config.LINES_DIMENSIONS_MODIFIER;\r\n                        if (modifier.y) {\r\n                            top *= modifier.y;\r\n                            height *= modifier.y;\r\n                        }\r\n                        if (modifier.x) {\r\n                            left *= modifier.x;\r\n                            width *= modifier.x;\r\n                        }\r\n                    }\r\n\r\n                    var zIndex = (config.BETLINES_Z_INDEX || 15.1) + lineIndex * 0.01;\r\n\r\n                    elements[name] = Sprite({\r\n                        groupCtrl: ctrl,\r\n                        name: name,\r\n                        imgPath: imgPath,\r\n                        left: left,\r\n                        top: top,\r\n                        width: width,\r\n                        height: height,\r\n                        isReelsAreaElement: true,\r\n                        zIndex: zIndex,\r\n                        canvasLayer: config.BETLINES_CANVAS_LAYER || 'top',\r\n                    });\r\n\r\n                    if (type === 'hover') {\r\n                        var zIndexGlow = zIndex - 0.1;\r\n                        var shadow = {\r\n                            color: 'rgba(255,255,255,.55)',\r\n                            offsetX: 0,\r\n                            offsetY: 0,\r\n                            blur: 16\r\n                        };\r\n                        elements[name + '-triple-glow-1'] = Sprite({\r\n                            groupCtrl: ctrl,\r\n                            name: name,\r\n                            imgPath: imgPath,\r\n                            left: left,\r\n                            top: top,\r\n                            width: width,\r\n                            height: height,\r\n                            isReelsAreaElement: true,\r\n                            zIndex: zIndexGlow,\r\n                            canvasLayer: config.BETLINES_CANVAS_LAYER || 'top',\r\n                            shadow: shadow,\r\n                        });\r\n                        elements[name + '-triple-glow-2'] = Sprite({\r\n                            groupCtrl: ctrl,\r\n                            name: name,\r\n                            imgPath: imgPath,\r\n                            left: left,\r\n                            top: top,\r\n                            width: width,\r\n                            height: height,\r\n                            isReelsAreaElement: true,\r\n                            zIndex: zIndexGlow,\r\n                            canvasLayer: config.BETLINES_CANVAS_LAYER || 'top',\r\n                            shadow: shadow,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            function initScatter() {\r\n                var keys = Object.keys(line.winPositions);\r\n                for (var i = 0; i < keys.length; i++) {\r\n                    var posX = line.winPositions[keys[i]][0];\r\n                    var posY = line.winPositions[keys[i]][1];\r\n\r\n                    var name = type + '-betline-' + lineIndex + '-sprite-' + posX + '-' + posY;\r\n                    var left, top, width, height;\r\n                    left = reelSet.REELS_CANVAS_LEFT\r\n                            + model.symbolSet.ALL_REELS_OFFSET_LEFT\r\n                            + posX * model.symbolSet.SYMBOL_OUTER_WIDTH\r\n                            + model.symbolSet.SCATTER_FRAME_OFFSET_LEFT;\r\n\r\n                    if (model.symbolSet.SPECIFIC_REELS_OFFSETS_LEFT[posX]) {\r\n                        left += model.symbolSet.SPECIFIC_REELS_OFFSETS_LEFT[posX];\r\n                    }\r\n                    top = reelSet.REELS_CANVAS_TOP\r\n                            + model.symbolSet.ALL_REELS_OFFSET_TOP\r\n                            + posY * model.symbolSet.SYMBOL_OUTER_HEIGHT\r\n                            + model.symbolSet.SCATTER_FRAME_OFFSET_TOP;\r\n\r\n                    width = model.symbolSet.SCATTER_FRAME_WIDTH;\r\n                    height = model.symbolSet.SCATTER_FRAME_HEIGHT;\r\n\r\n                    elements[name] = Sprite({\r\n                        groupCtrl: ctrl,\r\n                        name: name,\r\n                        imgPath: 'Control_panel/lines/scatter_frame',\r\n                        left: left,\r\n                        top: top,\r\n                        width: width,\r\n                        height: height,\r\n                        isReelsAreaElement: true,\r\n                        zIndex: config.BETLINES_Z_INDEX || 15,\r\n                        canvasLayer: config.BETLINES_CANVAS_LAYER || 'top',\r\n                    });\r\n                }\r\n            }\r\n\r\n            var lineIndex = line.index;\r\n            var winColIndexes = line.winColIndexes || [];\r\n            if (lineIndex >= 99) {\r\n                initScatter();\r\n            } else {\r\n                initBetline();\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/betlines/betlinesView.js"),eval("// betlinesCtrl\r\n// controls the behavior of betlines\r\ndefine('layers/betlines/betlinesCtrl',[\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-betlines',\r\n    'components/GroupCtrl',\r\n    'services/pause',\r\n    'layers/betlines/betlinesView'\r\n], function (pubsub, globalConfig, config, GroupCtrl, pause, betlinesView) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var currentReelSet = null;\r\n\r\n    var winLinesAnimationTimeout = null;\r\n    var hideLinesTimeout = null;\r\n    var animationsPaused = false;\r\n    var previewPaused = false;\r\n\r\n    var model = {\r\n        betlineData: config.BETLINES_POSITIONS,\r\n        hoverLine: null,\r\n        winLine: null,\r\n        previewLines: [],\r\n    };\r\n\r\n    //>>includeStart(\"debug\", pragmas.debug);\r\n    window.betlinemodel = model;\r\n    //>>includeEnd(\"debug\");\r\n\r\n    self.view = betlinesView(self, model);\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n    };\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initReels': function (id, data) {\r\n            currentReelSet = data.reelSet;\r\n        },\r\n        'request:animateWinLines': animateWinLines,\r\n        'request:initBetlines': function (id, data) {\r\n            model.symbolSet = data.symbolSet;\r\n            // initialize view\r\n            self.view = betlinesView(self, model);\r\n        },\r\n        'notify:betlineButtonHoveredIn': function (id, index) {\r\n            var winIndexes = [];\r\n            if (typeof index === 'object') {\r\n                for (var i = 0; i < index.win; i++) {\r\n                    winIndexes.push(i);\r\n                }\r\n                index = index.index;\r\n            }\r\n            model.previewLines = [\r\n                {\r\n                    index: index,\r\n                    winColIndexes: winIndexes,\r\n                    winPositions: {},\r\n                }\r\n            ];\r\n            reinitView();\r\n        },\r\n        'notify:betlineButtonHoveredOut': function (id, index) {\r\n            if (model.hoverLine && model.hoverLine.index === index) {\r\n                model.hoverLine = null;\r\n                reinitView();\r\n            }\r\n        },\r\n        'request:previewBetlines': function (id, activeLines) {\r\n            if (!previewPaused) {\r\n                previewLines(activeLines - 1);\r\n            }\r\n        },\r\n        'request:clearWinAnimations': function () {\r\n            stopWinLinesAnimation();\r\n        },\r\n        'request:pauseWinAnimations': function () {\r\n            self.hideAll();\r\n            animationsPaused = true;\r\n        },\r\n        'request:resumeWinAnimations': function () {\r\n            animationsPaused = false;\r\n        },\r\n        'request:pauseBetlinePreview': function () {\r\n            self.hideAll();\r\n            previewPaused = true;\r\n        },\r\n        'request:resumeBetlinePreview': function () {\r\n            previewPaused = false;\r\n        },\r\n    });\r\n\r\n    return self;\r\n\r\n    // actions\r\n    function previewLines(index) {\r\n\r\n        model.hoverLine = null;\r\n        model.winLine = null;\r\n        model.previewLines = [];\r\n\r\n        if (hideLinesTimeout) {\r\n            pause.clearTimeout(hideLinesTimeout);\r\n        }\r\n\r\n        var linesArray = [];\r\n        for (var i = 0; i < index + 1; i++) {\r\n            linesArray.push({\r\n                index: i,\r\n                winColIndexes: [],\r\n                winPositions: {},\r\n            });\r\n        }\r\n        model.previewLines = linesArray;\r\n        reinitView();\r\n        hideLinesTimeout = pause.setTimeout(function () {\r\n            hideLinesTimeout = null;\r\n            model.previewLines = [];\r\n            reinitView();\r\n        }, globalConfig.BETLINES_PREVIEW_TIMEOUT);\r\n    }\r\n\r\n    function animateWinLines(id, data) {\r\n        function initWinLines() {\r\n            model.hoverLine = null;\r\n            model.winLine = null;\r\n            model.previewLines = [];\r\n\r\n            if (hideLinesTimeout) {\r\n                pause.clearTimeout(hideLinesTimeout);\r\n            }\r\n\r\n            var keys = Object.keys(data.ws);\r\n            var length = keys.length;\r\n            for (var i = 0; i < length; i++) {\r\n                var lineIndex = data.ws[keys[i]].betline;\r\n                var winPositions = data.ws[keys[i]].post;\r\n                var winSym = data.ws[keys[i]].sym;\r\n                var line = {\r\n                    index: lineIndex,\r\n                    winColIndexes: [],\r\n                    winPositions: winPositions,\r\n                    winSym: winSym,\r\n                };\r\n                var positions = data.ws[keys[i]].post;\r\n                var posKeys = Object.keys(positions);\r\n                var posLength = posKeys.length;\r\n                for (var z = 0; z < posLength; z++) {\r\n                    var pos = positions[posKeys[z]];\r\n                    var x = pos[0];\r\n                    line.winColIndexes.push(x);\r\n                }\r\n                linesArray.push(line);\r\n            }\r\n        }\r\n\r\n        function showLine(index) {\r\n            var timeout;\r\n            var notifyFirstPass = false;\r\n\r\n            if (firstPass) {\r\n                if (index === 0) {\r\n                    timeout = data.firstLineDisplayTime;\r\n                } else {\r\n                    timeout = globalConfig.WIN_LINES_CYCLE_VIEW_DURATION_FIRST_PASS;\r\n                }\r\n                if (index > 0 && data.otherLinesDisplayCallback) {\r\n                    data.otherLinesDisplayCallback();\r\n                }\r\n                if ((data.showFirstWinLineAsLast && index === 0)\r\n                        || (!data.showFirstWinLineAsLast && index === linesArray.length - 1)) {\r\n                    firstPass = false;\r\n                    notifyFirstPass = true;\r\n                }\r\n            } else {\r\n                timeout = globalConfig.WIN_LINES_CYCLE_VIEW_DURATION;\r\n            }\r\n\r\n            if (!animationsPaused) {\r\n                model.winLine = {\r\n                    index: linesArray[index].index,\r\n                    winColIndexes: linesArray[index].winColIndexes,\r\n                    winPositions: linesArray[index].winPositions,\r\n                    winSym: linesArray[index].winSym,\r\n                };\r\n                reinitView();\r\n                pubsub.publish('notify:winLineDisplayed', {\r\n                    line: data.ws[index],\r\n                    timeout: timeout\r\n                });\r\n            }\r\n            winLinesAnimationTimeout = pause.setTimeout(function () {\r\n                if ((data.showFirstWinLineAsLast && index === 0)\r\n                        || (!data.showFirstWinLineAsLast && index === linesArray.length - 1)) {\r\n                    model.winLine = null;\r\n                    reinitView();\r\n                    winLinesAnimationTimeout = pause.setTimeout(function () {\r\n                        if (data.showFirstWinLineAsLast) {\r\n                            showLine(1);\r\n                        } else {\r\n                            showLine(0);\r\n                        }\r\n                    }, globalConfig.WIN_LINES_CYCLE_PAUSE_DURATION);\r\n                } else {\r\n                    showLine(index + 1 >= linesArray.length ? 0 : index + 1);\r\n                }\r\n                if (notifyFirstPass) {\r\n                    if (data.firstPassCallback) {\r\n                        data.firstPassCallback();\r\n                    }\r\n                }\r\n            }, timeout);\r\n        }\r\n\r\n        function showAllWinlines() {\r\n            var previewArray = [];\r\n            for (var i = 0; i < linesArray.length; i++) {\r\n                previewArray.push({\r\n                    index: linesArray[i].index,\r\n                    winColIndexes: [],\r\n                    winPositions: linesArray[i].winPositions,\r\n                    winSym: linesArray[i].winSym,\r\n                });\r\n            }\r\n            model.previewLines = previewArray;\r\n            reinitView();\r\n            pubsub.publish('notify:allWinLinesPreviewDisplayed', {\r\n                array: previewArray,\r\n                timeout: data.firstViewDuration\r\n            });\r\n        }\r\n\r\n        model.hoverLine = null;\r\n        model.winLine = null;\r\n        model.previewLines = [];\r\n        model.symbolSet = data.symbolSet;\r\n\r\n        var linesArray = [];\r\n        var firstPass = true;\r\n        initWinLines();\r\n        showAllWinlines();\r\n        if (data.showFirstWinLineAsLast) {\r\n            winLinesAnimationTimeout = pause.setTimeout(function () {\r\n                if (data.firstViewCallback) {\r\n                    data.firstViewCallback();\r\n                }\r\n                model.previewLines = [];\r\n                showLine(linesArray.length > 1 ? 1 : 0);\r\n            }, data.firstViewDuration);\r\n        } else {\r\n            winLinesAnimationTimeout = pause.setTimeout(function () {\r\n                if (data.firstViewCallback) {\r\n                    data.firstViewCallback();\r\n                }\r\n                model.previewLines = [];\r\n                showLine(0);\r\n            }, data.firstViewDuration);\r\n        }\r\n    }\r\n\r\n    function stopWinLinesAnimation() {\r\n        if (hideLinesTimeout) {\r\n            pause.clearTimeout(hideLinesTimeout);\r\n            model.previewLines = [];\r\n        }\r\n        if (winLinesAnimationTimeout) {\r\n            pause.clearTimeout(winLinesAnimationTimeout);\r\n            model.previewLines = [];\r\n            model.winLine = null;\r\n        }\r\n        reinitView();\r\n    }\r\n\r\n    // helpers start\r\n    function reinitView() {\r\n        self.hideAll();\r\n        self.view.actions.reinit(model, currentReelSet);\r\n        self.showAll();\r\n    }\r\n\r\n    // helpers end\r\n\r\n\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/betlines/betlinesCtrl.js"),
eval("define('data/config-infoText',{\r\n    TOP_TEXT_BACKGROUND_TOP: 0,\r\n    TOP_TEXT_BACKGROUND_WIDTH: 532,\r\n    TOP_TEXT_BACKGROUND_HEIGHT: 145,\r\n    TOP_TEXT_TOP: 72,\r\n    TOP_TEXT_COUNT_TOP: 74,\r\n    WINNINGS_COUNT_OFFSET_LEFT: 185,\r\n    TOP_TEXT_LEFT: 385,\r\n    TOP_TEXT_FONT_SIZE: 45,\r\n    TOP_TEXT_COUNT_FONT_SIZE: 45,\r\n    LINE_TEXT_FONT_SIZE: 42,\r\n    LINE_TEXT_OFFSET_LEFT: 1,\r\n    LINE_TEXT_OFFSET_TOP: 1,\r\n    WINLINE_CENTER_TEXT_LEFT: 480,\r\n    WINLINE_CENTER_TEXT_TOP: 332\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-infoText.js"),eval("// infoTextView\r\n// contains some of the text elements\r\n// bottom text = text displaying additional info (eg. GOOD LUCK, LINE XY PAYS 123)\r\n// winline info text = text displayed next to the winning betline\r\ndefine('layers/infoText/infoTextView',[\r\n    'data/config',\r\n    'data/config-menu',\r\n    'data/config-infoText',\r\n    'components/Text',\r\n    'services/pause',\r\n    'services/format',\r\n], function (globalConfig, menuConfig, config, Text, pause, format) {\r\n\r\n    return function mCreate(ctrl) {\r\n\r\n        // timeout used to hide winline info text\r\n        var winLineTextHideTimeout = null;\r\n        // timeout used by winline info scale animation\r\n        var winInfoAnimationTimeout = null;\r\n\r\n        var elements = {\r\n            bottomLeftText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'bottom-left-info-text',\r\n                left: menuConfig.BOTTOM_TEXT_LEFT,\r\n                top: menuConfig.BOTTOM_TEXT_TOP,\r\n                text: '',\r\n                fontSize: menuConfig.BOTTOM_TEXT_FONT_SIZE,\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    color: 'rgb(150,150,150)',\r\n                    lineHeight: 1,\r\n                },\r\n                zIndex: 21,\r\n            }),\r\n            bottomCenterText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'bottom-info-text',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: menuConfig.BOTTOM_TEXT_TOP,\r\n                text: '',\r\n                fontSize: menuConfig.BOTTOM_TEXT_FONT_SIZE,\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    color: 'white',\r\n                    lineHeight: 1,\r\n                },\r\n                originX: 'center',\r\n                zIndex: 21,\r\n            }),\r\n            bottomRightText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'bottom-right-info-text',\r\n                left: menuConfig.BOTTOM_RIGHT_TEXT_LEFT,\r\n                top: menuConfig.BOTTOM_TEXT_TOP,\r\n                text: '',\r\n                fontSize: menuConfig.BOTTOM_TEXT_FONT_SIZE,\r\n                originX: 'right',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    color: 'rgb(150,150,150)',\r\n                    lineHeight: 1,\r\n                },\r\n                zIndex: 21,\r\n            }),\r\n            winLineText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'line-info-text',\r\n                left: 0,\r\n                top: 0,\r\n                text: '',\r\n                fontSize: config.LINE_TEXT_FONT_SIZE,\r\n                style: globalConfig.MAIN_TEXT_STYLE_6,\r\n                originX: 'left',\r\n                originY: 'top',\r\n                textAlign: 'center',\r\n                type: 'winLineText',\r\n                forceSelectFontBySize: config.LINE_TEXT_FONT_SIZE,\r\n                formatter: format.formatAmountWithDenom,\r\n                isReelsAreaElement: true,\r\n                zIndex: 15.5,\r\n                canvasLayer: 'top'\r\n            }),\r\n        };\r\n        // API\r\n        return {\r\n            elements: elements,\r\n            actions: {\r\n                showWinLineInfo: mShowWinLineInfo,\r\n                hideWinLineInfo: mHideWinLineInfo,\r\n            }\r\n        };\r\n        function mShowWinLineInfo(data) {\r\n            function showInsideLineText() {\r\n                if (data.showInsideSymbol) {\r\n                    elements.winLineText.left = data.reelSet.REELS_CANVAS_LEFT\r\n                            + data.symbolSet.ALL_REELS_OFFSET_LEFT\r\n                            + data.x\r\n                            * data.symbolSet.SYMBOL_OUTER_WIDTH\r\n                            + config.LINE_TEXT_OFFSET_LEFT;\r\n                    elements.winLineText.top = data.reelSet.REELS_CANVAS_TOP\r\n                            + data.symbolSet.ALL_REELS_OFFSET_TOP\r\n                            + data.y\r\n                            * data.symbolSet.SYMBOL_OUTER_HEIGHT\r\n                            + config.LINE_TEXT_OFFSET_TOP;\r\n\r\n                    elements.winLineText.setText('!' + String(data.value));\r\n                    elements.winLineText.baseLeft = elements.winLineText.left;\r\n                    elements.winLineText.baseTop = elements.winLineText.top;\r\n                    if (data.font) {\r\n                        elements.winLineText.setStyle(data.font);\r\n                    }\r\n                    elements.winLineText.resize();\r\n                    elements.winLineText.show();\r\n                    if (config.WINLINE_TEXT_ANIMATION !== false) {\r\n                        mAnimateWinLineText();\r\n                    }\r\n                } else if (data.showCentered) {\r\n                    elements.winLineText.left = config.WINLINE_CENTER_TEXT_LEFT;\r\n                    elements.winLineText.top = config.WINLINE_CENTER_TEXT_TOP;\r\n                    elements.winLineText.setText('!' + String(data.value));\r\n                    elements.winLineText.baseLeft = elements.winLineText.left;\r\n                    elements.winLineText.baseTop = elements.winLineText.top;\r\n                    if (data.font) {\r\n                        elements.winLineText.setStyle(data.font);\r\n                    }\r\n                    elements.winLineText.resize();\r\n                    elements.winLineText.show();\r\n                    if (config.WINLINE_TEXT_ANIMATION !== false) {\r\n                        mAnimateWinLineText({\r\n                            centeredAnimation: true\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            mHideWinLineInfo();\r\n            showInsideLineText();\r\n\r\n            if (data.bottomTextLeft) {\r\n                elements.bottomLeftText.setText(data.bottomTextLeft);\r\n                elements.bottomLeftText.show();\r\n            }\r\n            winLineTextHideTimeout = pause.setTimeout(function () {\r\n                if (elements.winLineText) {\r\n                    elements.winLineText.hide();\r\n                }\r\n            }, data.timeout);\r\n        }\r\n        function mHideWinLineInfo() {\r\n            if (winLineTextHideTimeout) {\r\n                pause.clearTimeout(winLineTextHideTimeout);\r\n            }\r\n            if (elements.winLineText) {\r\n                elements.winLineText.hide();\r\n            }\r\n            elements.bottomLeftText.setText('');\r\n        }\r\n        function mAnimateWinLineText(options) {\r\n            options = options || {};\r\n            if (winInfoAnimationTimeout) {\r\n                pause.clearTimeout(winInfoAnimationTimeout);\r\n            }\r\n            var startTime = Date.now();\r\n            var diff;\r\n            var scale, scaleDiff, oldFs, textWidth, textHeight;\r\n            var tick = function () {\r\n                if (elements.winLineText && elements.winLineText.visible) {\r\n                    diff = Date.now() - startTime;\r\n                    if (diff >= 450) {\r\n                        scale = 1;\r\n                    } else if (diff >= 350) {\r\n                        scale = 1;\r\n                    } else if (diff >= 300) {\r\n                        diff -= 300;\r\n                        scale = 1.1 - 0.1 * diff / 50;\r\n                    } else if (diff >= 100) {\r\n                        scale = 1.1 * (diff / 300);\r\n                    } else {\r\n                        scale = 0.01;\r\n                    }\r\n                    oldFs = elements.winLineText.fontSize;\r\n                    elements.winLineText.fontSize = scale * config.LINE_TEXT_FONT_SIZE;\r\n                    elements.winLineText.fontSize < 1 && (elements.winLineText.fontSize = 1);\r\n                    if (options.centeredAnimation) {\r\n                        scaleDiff = elements.winLineText.fontSize / oldFs;\r\n                        textWidth = elements.winLineText.pixiEl.textWidth\r\n                                ? elements.winLineText.pixiEl.textWidth\r\n                                : elements.winLineText.pixiEl.width;\r\n                        textWidth /= globalConfig.REELS_AREA_SCALE;\r\n                        textWidth *= scaleDiff;\r\n                        textHeight = elements.winLineText.pixiEl.textHeight\r\n                                ? elements.winLineText.pixiEl.textHeight\r\n                                : elements.winLineText.pixiEl.height;\r\n                        textHeight /= globalConfig.REELS_AREA_SCALE;\r\n                        textHeight *= scaleDiff;\r\n                        elements.winLineText.left = elements.winLineText.baseLeft\r\n                                - textWidth / 2;\r\n                        elements.winLineText.top = elements.winLineText.baseTop\r\n                                - textHeight / 2;\r\n                    }\r\n                    elements.winLineText.resize();\r\n                    winInfoAnimationTimeout = pause.setTimeout(tick, 10);\r\n                }\r\n            };\r\n            elements.winLineText.fontSize = 1;\r\n            elements.winLineText.resize({forceResize: true});\r\n            winInfoAnimationTimeout = pause.setTimeout(tick, 0);\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/infoText/infoTextView.js"),eval("// infoTextCtrl\r\n// controls the behavior of some of the texts in the game\r\n// top text = text displaying total win value (eg. WINNINGS 150)\r\n// bottom text = text displaying additional info (eg. GOOD LUCK, LINE XY PAYS 123)\r\n// winline info text = text displayed next to the winning betline\r\ndefine('layers/infoText/infoTextCtrl',[\r\n    'pubsub',\r\n    'services/format',\r\n    'data/config',\r\n    'data/config-betlines',\r\n    'components/GroupCtrl',\r\n    'layers/infoText/infoTextView',\r\n    'services/settings',\r\n], function (pubsub, format, globalConfig, betlinesConfig, GroupCtrl, infoTextView, settings) {\r\n\r\n// initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var currentReelSet = null;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        winAmountAnimationFinished: function () {\r\n            pubsub.publish('notify:winAmountAnimationFinished');\r\n            self.view.actions.hideTop();\r\n        },\r\n    };\r\n    // initialize view\r\n    self.view = infoTextView(self);\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initReels': function (id, data) {\r\n            currentReelSet = data.reelSet;\r\n        },\r\n        'notify:activityBeforeStart': function () {\r\n            self.view.elements.bottomCenterText.setText('');\r\n        },\r\n        'request:clearWinAnimations': function () {\r\n            self.view.actions.hideWinLineInfo();\r\n            self.view.elements.bottomCenterText.setText('');\r\n        },\r\n        'request:pauseWinAnimations': function () {\r\n            self.view.actions.hideWinLineInfo();\r\n        },\r\n        'request:showBottomInfo': function (id, data) {\r\n            self.view.elements.bottomCenterText.setText(data.text);\r\n            self.view.elements.bottomCenterText.show();\r\n        },\r\n        'request:showBottomRightInfo': function (id, data) {\r\n            self.view.elements.bottomRightText.setText(data.text);\r\n            self.view.elements.bottomRightText.show();\r\n        },\r\n        'request:showBottomLeftInfo': function (id, data) {\r\n            self.view.elements.bottomLeftText.setText(data.text);\r\n            self.view.elements.bottomLeftText.show();\r\n        },\r\n        'request:showWinlineInfoText': function (id, data) {\r\n            if (data.showBottomText) {\r\n                // show win info text\r\n                var betlineIndex = data.line.betline;\r\n                var posX, posY;\r\n                if (betlineIndex < 99) {\r\n                    var lineData = betlinesConfig.BETLINES_POSITIONS[betlineIndex].line;\r\n                    posX = 0;\r\n                    posY = lineData[0] - 1;\r\n                }\r\n                var timeout = data.timeout;\r\n                var value = data.line.win;\r\n\r\n                var infoData = {};\r\n                if (betlinesConfig.LINES_DATA\r\n                        && betlinesConfig.LINES_DATA[betlineIndex]\r\n                        && betlinesConfig.LINES_DATA[betlineIndex].font) {\r\n                    infoData.font = {\r\n                        type: 'bitmap',\r\n                        font: 'winline-' + betlinesConfig.LINES_DATA[betlineIndex].font\r\n                    };\r\n                }\r\n\r\n                if (data.freeSpinsWin && betlineIndex === 99) {\r\n                    self.view.elements.bottomCenterText.setText('youWonFreeGames');\r\n                    self.view.elements.bottomCenterText.show();\r\n                } else if (betlineIndex >= 99) {\r\n                    if (globalConfig.SHOW_SCATTER_WIN_OVER_REELS) {\r\n                        infoData.showCentered = true;\r\n                        infoData.symbolSet = data.symbolSet;\r\n                        infoData.value = value;\r\n                    }\r\n                    infoData.bottomTextLeft = ['scatter', '! ', 'pays'\r\n                                , '! ', '!' + format.formatAmountWithDenom(value)];\r\n                } else {\r\n                    infoData.showInsideSymbol = true;\r\n                    infoData.symbolSet = data.symbolSet;\r\n                    infoData.x = posX;\r\n                    infoData.y = posY;\r\n                    infoData.value = value;\r\n                    infoData.bottomTextLeft = ['line', ' ', (betlineIndex + 1), '! ',\r\n                        'pays', '! ', '!' + format.formatAmountWithDenom(value)];\r\n                }\r\n\r\n                infoData.timeout = timeout;\r\n\r\n                infoData.reelSet = currentReelSet;\r\n\r\n                self.view.actions.showWinLineInfo(infoData);\r\n            }\r\n        },\r\n    });\r\n    return self;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/infoText/infoTextCtrl.js"),eval("define('data/config-menuPage1',{\r\n    LINE_1_TOP: 45,\r\n    LINE_2_TOP: 130,\r\n    LINE_3_TOP: 215,\r\n    LINE_4_TOP: 300,\r\n    LINE_5_TOP: 385,\r\n    FLIPSWITCH_LEFT: 495,\r\n    FLIPSWITCH_OFFSET_TOP: -21,\r\n    SLIDER_LEFT: 380,\r\n    SLIDER_OFFSET_TOP: -26,\r\n    TOTAL_BET_LEFT: 566,\r\n    REFRESH_BALANCE_BUTTON_TEXT_STYLE: {\r\n        type: 'css',\r\n        font: 'arial',\r\n        color: '#c3c2c0',\r\n    },\r\n    REFRESH_BALANCE_BUTTON_FONT_SIZE: 12,\r\n    REFRESH_BALANCE_BUTTON_LEFT: 845,\r\n    REFRESH_BALANCE_BUTTON_TOP: 396,\r\n    REFRESH_BALANCE_BUTTON_WIDTH: 32,\r\n    REFRESH_BALANCE_BUTTON_HEIGHT: 32,\r\n    REFRESH_BALANCE_BUTTON_TEXT_OFFSET_TOP: 0,\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-menuPage1.js"),eval("define('components/FlipSwitch',[\r\n    'pubsub',\r\n    'components/Element',\r\n    'services/i18n',\r\n], function (\r\n        pubsub, Element, i18n) {\r\n\r\n// FlipSwitch element with ON-OFF options\r\n    return function create(options) {\r\n        function updateLabels() {\r\n            $elLeft.html(i18n.localize(self.leftText));\r\n            $elRight.html(i18n.localize(self.rightText));\r\n        }\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'FlipSwitch';\r\n        self.leftText = options.leftText;\r\n        self.rightText = options.rightText;\r\n        self.isOn = options.onState;\r\n        self.onChange = options.onChange;\r\n        self.activeBtn = options.activeBtn || null;\r\n        self.disableSelfUpdate = options.disableSelfUpdate;\r\n        self.interactive = true;\r\n        self.fontSize = options.fontSize;\r\n\r\n        var btnStyle = {\r\n            'display': 'inline-block',\r\n            position: 'absolute',\r\n            'font-size': self.fontSize + 'px',\r\n            'line-height': '59px',\r\n            'font-family': 'myriadpro-semiext',\r\n            'color': 'white',\r\n            'text-align': 'center',\r\n            'z-index': self.zIndex,\r\n        };\r\n\r\n        var backgroundStyle = {\r\n            'border': '2px solid white',\r\n            'height': '55px',\r\n            'min-width': '138px',\r\n            'border-radius': '30px',\r\n            '-webkit-border-radius': '30px',\r\n            'z-index': self.zIndex + 1,\r\n        };\r\n        var ballStyle = {\r\n            position: 'absolute',\r\n            'display': 'inline-block',\r\n            'background-color': 'white',\r\n            width: '38px',\r\n            height: '38px',\r\n            top: '8px',\r\n            'border-radius': '19px',\r\n            '-webkit-border-radius': '19px',\r\n            'z-index': self.zIndex,\r\n        };\r\n\r\n        var $el = $('<div class=\"dom-flipswitch\"><span class=flipswitch-left></span>'\r\n                + '<span class=flipswitch-right></span><span class=flipswitch-ball></span></div>');\r\n        var $elLeft = $el.find('span.flipswitch-left');\r\n        var $elRight = $el.find('span.flipswitch-right');\r\n        var $ball = $el.find('span.flipswitch-ball');\r\n\r\n        $el.css(backgroundStyle);\r\n        $ball.css(ballStyle);\r\n        $elLeft.css(btnStyle);\r\n        $elRight.css(btnStyle);\r\n\r\n        updateLabels();\r\n        pubsub.subscribe('request:updateLocalizedLabels', function () {\r\n            updateLabels();\r\n        });\r\n\r\n        $el.on('click', function () {\r\n            if (!self.disableSelfUpdate) {\r\n                if (self.activeBtn === 'left') {\r\n                    self.setActiveBtn('right');\r\n                } else if (self.activeBtn === 'right') {\r\n                    self.setActiveBtn('left');\r\n                }\r\n                self.onChange(self.activeBtn);\r\n            } else {\r\n                self.onChange();\r\n            }\r\n        });\r\n\r\n        self.jQueryEl = $el;\r\n\r\n        // set current ON/OFF state\r\n        self.setActiveBtn = function (btn) {\r\n            self.activeBtn = btn;\r\n            refreshView();\r\n        };\r\n\r\n        var superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            superShow.apply(null, arguments);\r\n            refreshView();\r\n        };\r\n\r\n\r\n        self.appendHTML();\r\n        refreshView();\r\n\r\n        return self;\r\n\r\n        // update inner button position to represent current ON/OFF value\r\n        function refreshView() {\r\n            $elLeft.css({\r\n                left: 0.325 * $el.width() - $elLeft.width() / 2\r\n            });\r\n            $elRight.css({\r\n                left: 0.675 * $el.width() - $elRight.width() / 2\r\n            });\r\n            if (self.activeBtn === 'left') {\r\n                $elLeft.show();\r\n                $elRight.hide();\r\n                $ball.css({\r\n                    right: '13px',\r\n                    left: 'initial',\r\n                });\r\n            } else if (self.activeBtn === 'right') {\r\n                $elRight.show();\r\n                $elLeft.hide();\r\n                $ball.css({\r\n                    left: '13px',\r\n                    right: 'initial',\r\n                });\r\n            }\r\n\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/FlipSwitch.js"),eval("define('components/DomDraggableCircle',['jquery',\r\n    'components/Element',\r\n    'services/dimensions'\r\n], function ($, Element, dimensions) {\r\n    return function create(options) {\r\n\r\n        function getX(e) {\r\n            var x;\r\n            if (e.clientX !== undefined) {\r\n                x = e.clientX;\r\n            }\r\n            e = e.originalEvent;\r\n            if (e.touches) {\r\n                x = e.touches[0].clientX;\r\n            }\r\n            x -= dimensions.topLevelWrappersOffsetX;\r\n            x /= dimensions.canvasScaleX;\r\n            if (self.domContainerParent) {\r\n                x -= self.domContainerParent.left;\r\n            }\r\n            return x;\r\n        }\r\n\r\n        var self = Element(options);\r\n        var dragStartValue, dragging;\r\n        var $el = $('<div class=\"dom-circle\"><div></div></div>');\r\n        var $elInner = $el.find('div');\r\n        var $doc = $(document);\r\n        var touchMargin = 20;\r\n\r\n        self.name = options.name || 'DomDraggableCircle';\r\n        self.color = options.color;\r\n        self.disabled = options.disabled;\r\n        self.minLeft = options.minLeft;\r\n        self.maxLeft = options.maxLeft;\r\n        self.roundPercent = options.roundPercent;\r\n        self.onDrag = options.onDrag;\r\n        self.onDragEnd = options.onDragEnd;\r\n        self.onDragStart = options.onDragStart;\r\n        self.interactive = true;\r\n\r\n        var p = self.parent;\r\n        while (p) {\r\n            self.minLeft += p.left;\r\n            self.maxLeft += p.left;\r\n            p = p.parent;\r\n        }\r\n        if (self.domContainerParent) {\r\n            if (self.domContainerParent.parent) {\r\n                self.minLeft += self.domContainerParent.parent.left;\r\n                self.maxLeft += self.domContainerParent.parent.left;\r\n            }\r\n        }\r\n\r\n        $el.css({\r\n            width: self.width,\r\n            height: self.height,\r\n            originX: self.originX,\r\n            'z-index': self.zIndex,\r\n            display: 'none'\r\n        });\r\n        $elInner.css({\r\n            'background-color': self.color,\r\n            margin: touchMargin + 'px',\r\n            width: self.width - 2 * +touchMargin,\r\n            height: self.height - 2 * +touchMargin,\r\n            originX: self.originX,\r\n            'border-radius': '50%',\r\n            '-webkit-border-radius': '50%',\r\n            'z-index': self.zIndex,\r\n        });\r\n\r\n        $el.wrapper = self;\r\n\r\n        self.jQueryEl = $el;\r\n\r\n        self.mouseUp = function () {\r\n            if (dragging) {\r\n                dragging = false;\r\n                self.onDragEnd && self.onDragEnd(self.value);\r\n                $doc.off('mousemove.domdraggablecircle touchmove.domdraggablecircle')\r\n                $doc.off('mouseup.domdraggablecircle touchend.domdraggablecircle')\r\n            }\r\n        }\r\n        self.mouseDown = function () {\r\n            if (!self.disabled) {\r\n                dragStartValue = self.value;\r\n                self.onDragStart && self.onDragStart(self.value);\r\n                dragging = true;\r\n                $doc.on('mousemove.domdraggablecircle touchmove.domdraggablecircle',\r\n                        self.mouseMove);\r\n                $doc.on('mouseup.domdraggablecircle touchend.domdraggablecircle',\r\n                        self.mouseUp);\r\n            }\r\n        }\r\n        self.mouseMove = function (e) {\r\n            var x = getX(e);\r\n            if (x < self.minLeft) {\r\n                x = self.minLeft;\r\n            } else if (x > self.maxLeft) {\r\n                x = self.maxLeft;\r\n            }\r\n            self.setValue(100 * ((x - self.minLeft) / (self.maxLeft - self.minLeft)));\r\n            self.onDrag(self.value);\r\n        }\r\n\r\n        $el.on('mousedown touchstart', self.mouseDown);\r\n\r\n        // set current value and adjust postition\r\n        self.setValue = function (newVal) {\r\n            self.value = newVal;\r\n            self.left = (self.minLeft + (self.value / 100) * (self.maxLeft - self.minLeft))\r\n                    - .5 * self.width;\r\n            self.roundPercent && (self.value = Math.round(self.value));\r\n            var p = self.parent;\r\n            while (p) {\r\n                self.left -= p.left;\r\n                p = p.parent;\r\n            }\r\n            if (self.domContainerParent) {\r\n                if (self.domContainerParent.parent) {\r\n                    self.left -= self.domContainerParent.parent.left;\r\n                }\r\n            }\r\n            self.resize();\r\n        };\r\n\r\n        self.setDisabled = function (val) {\r\n            self.disabled = val;\r\n        };\r\n\r\n        self.appendHTML();\r\n        self.resize();\r\n\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/DomDraggableCircle.js"),eval("define('components/RangeSlider',[\r\n    'components/Element',\r\n    'components/DomRectangle',\r\n    'components/DomDraggableCircle',\r\n    'components/Text',\r\n], function (\r\n        Element, DomRectangle, DomDraggableCircle, Text) {\r\n\r\n    // range slider element allows to pick percentage value\r\n    // by dragging the control button\r\n    // user in game menu\r\n    return function create(options) {\r\n        function getX(e) {\r\n            var x;\r\n            if (e.clientX !== undefined) {\r\n                x = e.clientX;\r\n            }\r\n            e = e.originalEvent;\r\n            if (e.touches) {\r\n                x = e.touches[0].clientX;\r\n            }\r\n            x /= dimensions.canvasScaleX;\r\n            if (self.domContainerParent) {\r\n                x -= self.domContainerParent.left;\r\n            }\r\n            return x;\r\n        }\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'RangeSlider';\r\n        self.value = options.value;\r\n        self.values = options.values;\r\n        self.formatter = options.formatter;\r\n        self.onChange = options.onChange;\r\n        self.roundPercent = options.roundPercent;\r\n        self.zIndex = 305;\r\n        self.suffix = options.suffix ? options.suffix : self.values ? '' : '!%';\r\n        self.prefix = options.prefix ? options.prefix : '';\r\n        self.offStateAvailable = options.offStateAvailable;\r\n        self.showPrefixSuffixOnSides = options.showPrefixSuffixOnSides;\r\n        self.formatter = options.formatter;\r\n\r\n        var leftTextLeft = self.left + 35;\r\n        var grayTextStyle = {type: 'css', font: 'myriadpro-semiext', color: '#acaca9', lineHeight: 1, scaleX: .95};\r\n        var whiteTextStyle = {type: 'css', font: 'myriadpro-semiext', color: 'white', lineHeight: 1, scaleX: .95};\r\n        var grayTextFS = 15;\r\n        var whiteTextFS = 20;\r\n\r\n        var sideTextTop = self.top + 28;\r\n\r\n        var lineLeft = leftTextLeft + 13;\r\n        var lineTop = self.top + 34;\r\n        var lineWidth = 267;\r\n        var lineHeight = 4;\r\n\r\n        var rightTextLeft = lineLeft + lineWidth + 13;\r\n\r\n        var buttonSize = 60;\r\n\r\n        var oldVal = null;\r\n\r\n        // control button\r\n        var button = DomDraggableCircle({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-button',\r\n            color: 'white',\r\n            left: lineLeft,\r\n            top: lineTop + lineHeight / 2 - buttonSize / 2,\r\n            width: buttonSize,\r\n            height: buttonSize,\r\n            minLeft: lineLeft,\r\n            maxLeft: lineLeft + lineWidth,\r\n            value: self.value,\r\n            onDrag: onDrag,\r\n            onDragStart: onDragStart,\r\n            onDragEnd: onDragEnd,\r\n            roundPercent: self.roundPercent,\r\n            zIndex: self.zIndex + 3,\r\n            domContainerParent: self.domContainerParent,\r\n        });\r\n        // background (groove)\r\n        var back = DomRectangle({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-back',\r\n            color: 'black   ',\r\n            border: '1px solid #737273',\r\n            left: lineLeft - 1,\r\n            top: lineTop - 1,\r\n            width: lineWidth + 1,\r\n            height: lineHeight + 1,\r\n            borderRadius: 5,\r\n            zIndex: self.zIndex + 1,\r\n            domContainerParent: self.domContainerParent,\r\n            marginPx: 13,\r\n            mouseDown: function (e) {\r\n                lineMouseDown(e);\r\n            },\r\n        });\r\n        var backFill = DomRectangle({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-back',\r\n            color: 'white',\r\n            left: lineLeft,\r\n            top: lineTop,\r\n            width: 0,\r\n            height: lineHeight,\r\n            borderRadius: 3,\r\n            zIndex: self.zIndex + 2,\r\n            domContainerParent: self.domContainerParent,\r\n            marginPx: 13,\r\n            mouseDown: function (e) {\r\n                lineMouseDown(e);\r\n            },\r\n        });\r\n        var textLeft = Text({\r\n            name: self.name + '-text',\r\n            parent: self.parent,\r\n            groupCtrl: self.groupCtrl,\r\n            left: leftTextLeft,\r\n            top: sideTextTop,\r\n            text: self.values ? self.values[0] : (self.offStateAvailable ? 'off' : '!0'),\r\n            formatter: self.formatter,\r\n            fontSize: grayTextFS,\r\n            originX: 'right',\r\n            zIndex: self.zIndex + 1,\r\n            style: grayTextStyle,\r\n            domContainerParent: self.domContainerParent,\r\n        });\r\n        var textRight = Text({\r\n            name: self.name + '-text',\r\n            parent: self.parent,\r\n            groupCtrl: self.groupCtrl,\r\n            left: rightTextLeft,\r\n            top: sideTextTop,\r\n            text: self.values ? (self.showPrefixSuffixOnSides ? [self.prefix,\r\n                '!' + self.values[self.values.length - 1], self.suffix]\r\n                    : '!' + self.values[self.values.length - 1])\r\n                    : '!100',\r\n            formatter: self.formatter,\r\n            fontSize: grayTextFS,\r\n            originX: 'left',\r\n            zIndex: self.zIndex + 1,\r\n            style: grayTextStyle,\r\n            domContainerParent: self.domContainerParent,\r\n        });\r\n        var textTop = Text({\r\n            name: self.name + '-text',\r\n            parent: self.parent,\r\n            groupCtrl: self.groupCtrl,\r\n            left: lineLeft,\r\n            top: self.top,\r\n            text: '',\r\n            formatter: self.formatter,\r\n            fontSize: whiteTextFS,\r\n            originX: 'center',\r\n            zIndex: self.zIndex + 1,\r\n            style: whiteTextStyle,\r\n            domContainerParent: self.domContainerParent,\r\n        });\r\n\r\n        self.jQueryEl = [back, backFill, button, textLeft, textRight, textTop];\r\n\r\n        self.setValue = function (value) {\r\n            if (self.values) {\r\n                var i = self.values.indexOf(value);\r\n                if (i > -1) {\r\n                    self.value = value;\r\n                    button.setValue(i === 0 ? 0 :\r\n                            i / (self.values.length - 1) * 100);\r\n                    updateText();\r\n                    updateSlidingElementsPositions();\r\n                }\r\n            } else {\r\n                self.value = value;\r\n                button.setValue(self.value);\r\n                updateText();\r\n                updateSlidingElementsPositions();\r\n            }\r\n        };\r\n        self.setSelectedIndex = function (i) {\r\n            if (self.values) {\r\n                self.value = self.values[i];\r\n                button.setValue(i === 0 ? 0 :\r\n                        i / (self.values.length - 1) * 100);\r\n                updateText();\r\n                updateSlidingElementsPositions();\r\n            }\r\n        };\r\n        self.dropFocus = function () {\r\n            button.mouseUp();\r\n        };\r\n\r\n        return self;\r\n\r\n        function lineMouseDown(e) {\r\n            button.mouseMove(e);\r\n            button.mouseDown();\r\n        }\r\n\r\n        function updateSlidingElementsPositions() {\r\n            textTop.set({\r\n                left: button.left + buttonSize / 2\r\n            });\r\n            backFill.set({\r\n                width: button.left - lineLeft + buttonSize / 2\r\n            });\r\n        }\r\n        function onDragStart() {\r\n            textTop.set({top: self.top - 20, zIndex: 350});\r\n        }\r\n        function onDragEnd() {\r\n            textTop.set({top: self.top, zIndex: self.zIndex + 1});\r\n        }\r\n\r\n        function onDrag(newValue) {\r\n            if (self.values) {\r\n                newValue /= 100;\r\n                self.value = self.values[Math.round(newValue * (self.values.length - 1))];\r\n            } else {\r\n                self.value = newValue;\r\n            }\r\n            if (oldVal !== self.value) {\r\n                updateText();\r\n                if (self.values) {\r\n                    if (self.offStateAvailable && self.values.indexOf(self.value) === 0) {\r\n                        self.onChange(null, 0);\r\n                    } else {\r\n                        self.onChange(self.value, self.values.indexOf(self.value));\r\n                    }\r\n                } else {\r\n                    if (self.offStateAvailable && self.value === 0) {\r\n                        self.onChange(null);\r\n                    } else {\r\n                        self.onChange(self.value);\r\n                    }\r\n                }\r\n                oldVal = self.value;\r\n            }\r\n            updateSlidingElementsPositions();\r\n        }\r\n        function updateText() {\r\n            if (self.values) {\r\n                if (self.offStateAvailable && self.values.indexOf(self.value) === 0) {\r\n                    textTop.setText(self.value);\r\n                } else {\r\n                    textTop.setText([self.prefix, '!' + self.value, self.suffix]);\r\n                }\r\n            } else {\r\n                if (self.offStateAvailable && self.value === 0) {\r\n                    textTop.setText('off');\r\n                } else {\r\n                    textTop.setText([self.prefix, '!' + self.value, self.suffix]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/RangeSlider.js"),
eval("// menuPage1View\r\n// contains elements for BET menu page\r\ndefine('layers/menuPage1/menuPage1View',[\r\n    'data/config',\r\n    'data/config-menu',\r\n    'data/config-menuPage1',\r\n    'components/FlipSwitch',\r\n    'components/Text',\r\n    'components/DomRectangle',\r\n    'components/RangeSlider',\r\n    'components/DomButton',\r\n    'services/format',\r\n], function (globalConfig, menuConfig, config,\r\n        FlipSwitch, Text, DomRectangle, RangeSlider, DomButton, format) {\r\n\r\n    return function mCreate(ctrl, contentParent) {\r\n        var elements = {\r\n            header: Text({\r\n                name: 'menu-bet-header',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_LEFT_HEADER_LEFT,\r\n                top: menuConfig.MENU_HEADER_TOP,\r\n                text: 'betSettings',\r\n                fontSize: menuConfig.MENU_HEADER_FONT_SIZE,\r\n                originX: 'left',\r\n                zIndex: 22,\r\n                style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            denomLabel: Text({\r\n                name: 'menu-denom-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + menuConfig.LEVEL_1_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_1_TOP,\r\n                text: 'denomination',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            betLabel: Text({\r\n                name: 'menu-bet-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + menuConfig.LEVEL_1_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_2_TOP,\r\n                text: 'bet',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            linesLabel: Text({\r\n                name: 'menu-lines-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + menuConfig.LEVEL_1_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_3_TOP,\r\n                text: 'lines',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            cashCreditsLabel: Text({\r\n                name: 'menu-cash-credits-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + menuConfig.LEVEL_1_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_4_TOP,\r\n                text: 'showBalanceIn',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            totalBetLabel: Text({\r\n                name: 'menu-totalbet-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + menuConfig.LEVEL_1_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_5_TOP,\r\n                text: 'totalBetInCredits',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            totalBetValue: Text({\r\n                name: 'menu-totalbet-value',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.TOTAL_BET_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_5_TOP,\r\n                text: 0,\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n                originX: 'center',\r\n            }),\r\n            denomSlider: RangeSlider({\r\n                name: 'menu-denom-slider',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.SLIDER_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_1_TOP\r\n                        + config.SLIDER_OFFSET_TOP,\r\n                value: 0,\r\n                values: globalConfig.DENOMINATION_STEPS,\r\n                formatter: format.formatDenom,\r\n                onChange: ctrl.viewActions.denomChanged,\r\n            }),\r\n            betSlider: RangeSlider({\r\n                name: 'menu-bet-slider',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.SLIDER_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_2_TOP\r\n                        + config.SLIDER_OFFSET_TOP,\r\n                value: 0,\r\n                values: globalConfig.BET_STEPS,\r\n                onChange: ctrl.viewActions.betChanged,\r\n            }),\r\n            linesSlider: RangeSlider({\r\n                name: 'menu-lines-slider',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.SLIDER_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_3_TOP\r\n                        + config.SLIDER_OFFSET_TOP,\r\n                value: 0,\r\n                values: globalConfig.LINES_STEPS,\r\n                onChange: ctrl.viewActions.linesChanged,\r\n            }),\r\n            cashCreditsFlipSwitch: FlipSwitch({\r\n                name: 'menu-cash-credits-switch',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.FLIPSWITCH_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_4_TOP\r\n                        + config.FLIPSWITCH_OFFSET_TOP,\r\n                leftText: 'cash',\r\n                rightText: 'credits',\r\n                fontSize: 19,\r\n                onChange: ctrl.viewActions.cashCreditsFlipSwitchChanged,\r\n            }),\r\n            refreshBalanceButton: DomButton({\r\n                name: 'menu-refresh-balance-button',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                imgPath: 'menu/refresh-balance',\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.REFRESH_BALANCE_BUTTON_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.REFRESH_BALANCE_BUTTON_TOP,\r\n                width: config.REFRESH_BALANCE_BUTTON_WIDTH,\r\n                height: config.REFRESH_BALANCE_BUTTON_HEIGHT,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                zIndex: 22,\r\n                canvasLayer: 'ui',\r\n                click: ctrl.viewActions.balanceClicked,\r\n            }),\r\n        };\r\n\r\n        contentParent.addChildren(elements);\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n            }\r\n        };\r\n\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage1/menuPage1View.js"),eval("// menuPage1Ctrl\r\ndefine('layers/menuPage1/menuPage1Ctrl',[\r\n    'pubsub',\r\n    'big',\r\n    'data/config',\r\n    'components/GroupCtrl',\r\n    'layers/menuPage1/menuPage1View',\r\n    'layers/menu/menuCtrl',\r\n    'services/format',\r\n    'services/settings',\r\n], function (pubsub, big, globalConfig, GroupCtrl, menuPage1View, menuCtrl, format, settings) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var model = null;\r\n    var betModel;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        denomChanged: function (value) {\r\n            checkLimit({\r\n                bet: betModel.bet,\r\n                denomination: value,\r\n                activeLines: betModel.activeLines,\r\n            }, function (overLimit) {\r\n                if (overLimit) {\r\n                    self.view.elements.denomSlider.dropFocus();\r\n                    updateView({\r\n                        betModel: betModel\r\n                    });\r\n                    pubsub.publish('request:showAlert', {\r\n                        text: ['maxBetLimitReached', \r\n                            '! ' + format.formatAmount(globalConfig.MAX_BET_IN_MONEY)],\r\n                        oneLiner: true,\r\n                        buttonOk: function () {\r\n                        },\r\n                    });\r\n                } else {\r\n                    pubsub.publish('notify:denominationChanged', value);\r\n                }\r\n            });\r\n        },\r\n        betChanged: function (value) {\r\n            checkLimit({\r\n                bet: value,\r\n                denomination: betModel.denomination,\r\n                activeLines: betModel.activeLines,\r\n            }, function (overLimit) {\r\n                if (overLimit) {\r\n                    self.view.elements.betSlider.dropFocus();\r\n                    updateView({\r\n                        betModel: betModel\r\n                    });\r\n                    pubsub.publish('request:showAlert', {\r\n                        text: ['maxBetLimitReached', \r\n                            '! ' + format.formatAmount(globalConfig.MAX_BET_IN_MONEY)],\r\n                        oneLiner: true,\r\n                        buttonOk: function () {\r\n                        },\r\n                    });\r\n                } else {\r\n                    pubsub.publish('notify:betChanged', value);\r\n                }\r\n            });\r\n        },\r\n        linesChanged: function (value) {\r\n            checkLimit({\r\n                bet: betModel.bet,\r\n                denomination: betModel.denomination,\r\n                activeLines: value,\r\n            }, function (overLimit) {\r\n                if (overLimit) {\r\n                    self.view.elements.linesSlider.dropFocus();\r\n                    updateView({\r\n                        betModel: betModel\r\n                    });\r\n                    pubsub.publish('request:showAlert', {\r\n                        text: ['maxBetLimitReached',\r\n                            '! ' + format.formatAmount(globalConfig.MAX_BET_IN_MONEY)],\r\n                        oneLiner: true,\r\n                        buttonOk: function () {\r\n                        },\r\n                    });\r\n                } else {\r\n                    pubsub.publish('notify:betlinesChanged', value);\r\n                }\r\n            });\r\n        },\r\n        cashCreditsFlipSwitchChanged: function (activeBtn) {\r\n            model.showInCash = activeBtn === 'left';\r\n            pubsub.publish('notify:cashCreditsFlipSwitchChanged');\r\n            pubsub.publish('request:viewUpdate');\r\n            settings.save();\r\n        },\r\n        balanceClicked: function () {\r\n            pubsub.publish('request:balanceUpdate');\r\n        }\r\n    };\r\n\r\n    // initialize view\r\n    self.view = menuPage1View(self, menuCtrl.view.elements.container.jQueryEl[1]);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initMenuViews': function (id, data) {\r\n            model = data.model.credits;\r\n            updateView(data);\r\n        },\r\n        'request:showMenuPage1': function (id, data) {\r\n            self.showAll();\r\n        },\r\n        'request:hideMenuPages': function (id, data) {\r\n            self.hideAll();\r\n        },\r\n        'request:updateViewsWithModels': function (id, data) {\r\n            betModel = data.betModel;\r\n            setTotalBet(data);\r\n        },\r\n    })\r\n    return self;\r\n\r\n    // helpers\r\n    function updateView(data) {\r\n        self.view.elements.cashCreditsFlipSwitch.setActiveBtn(\r\n                model.showInCash ? 'left' : 'right');\r\n        if (data) {\r\n            self.view.elements.denomSlider.setValue(data.betModel.denomination);\r\n            self.view.elements.betSlider.setValue(data.betModel.bet);\r\n            self.view.elements.linesSlider.setValue(data.betModel.activeLines);\r\n            setTotalBet(data);\r\n        }\r\n    }\r\n    function setTotalBet(data) {\r\n        self.view.elements.totalBetValue.setText('!' + data.betModel.totalBet);\r\n    }\r\n    function checkLimit(data, cb) {\r\n        var totalInCash = big(data.activeLines)\r\n                .times(data.bet).times(data.denomination).valueOf();\r\n        if (globalConfig.MAX_BET_IN_MONEY === null ||\r\n                totalInCash <= Number(globalConfig.MAX_BET_IN_MONEY)) {\r\n            cb(false);\r\n        } else {\r\n            cb(true);\r\n        }\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage1/menuPage1Ctrl.js"),eval("define('data/config-menuPage2',{\r\n    LEVEL_1_LEFT: 39,\r\n    LEVEL_2_LEFT: 19,\r\n    LINE_1_TOP: 45,\r\n    LINE_2_TOP: 115,\r\n    LINE_3_TOP: 145,\r\n    LINE_4_TOP: 245,\r\n    LINE_5_TOP: 345,\r\n    LINE_6_TOP: 445,\r\n    STOP_AUTOPLAY_LABEL_LEFT: 10,\r\n    STOP_AUTOPLAY_LABEL_FONT_SIZE: 18,\r\n    SLIDER_LEFT: 343,\r\n    SLIDER_OFFSET_TOP: -26,\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-menuPage2.js"),eval("/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */\r\n(function (window, document, Math) {\r\nvar rAF = window.requestAnimationFrame\t||\r\n\twindow.webkitRequestAnimationFrame\t||\r\n\twindow.mozRequestAnimationFrame\t\t||\r\n\twindow.oRequestAnimationFrame\t\t||\r\n\twindow.msRequestAnimationFrame\t\t||\r\n\tfunction (callback) { window.setTimeout(callback, 1000 / 60); };\r\n\r\nvar utils = (function () {\r\n\tvar me = {};\r\n\r\n\tvar _elementStyle = document.createElement('div').style;\r\n\tvar _vendor = (function () {\r\n\t\tvar vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],\r\n\t\t\ttransform,\r\n\t\t\ti = 0,\r\n\t\t\tl = vendors.length;\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\ttransform = vendors[i] + 'ransform';\r\n\t\t\tif ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t})();\r\n\r\n\tfunction _prefixStyle (style) {\r\n\t\tif ( _vendor === false ) return false;\r\n\t\tif ( _vendor === '' ) return style;\r\n\t\treturn _vendor + style.charAt(0).toUpperCase() + style.substr(1);\r\n\t}\r\n\r\n\tme.getTime = Date.now || function getTime () { return new Date().getTime(); };\r\n\r\n\tme.extend = function (target, obj) {\r\n\t\tfor ( var i in obj ) {\r\n\t\t\ttarget[i] = obj[i];\r\n\t\t}\r\n\t};\r\n\r\n\tme.addEvent = function (el, type, fn, capture) {\r\n\t\tel.addEventListener(type, fn, !!capture);\r\n\t};\r\n\r\n\tme.removeEvent = function (el, type, fn, capture) {\r\n\t\tel.removeEventListener(type, fn, !!capture);\r\n\t};\r\n\r\n\tme.prefixPointerEvent = function (pointerEvent) {\r\n\t\treturn window.MSPointerEvent ?\r\n\t\t\t'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8):\r\n\t\t\tpointerEvent;\r\n\t};\r\n\r\n\tme.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {\r\n\t\tvar distance = current - start,\r\n\t\t\tspeed = Math.abs(distance) / time,\r\n\t\t\tdestination,\r\n\t\t\tduration;\r\n\r\n\t\tdeceleration = deceleration === undefined ? 0.0006 : deceleration;\r\n\r\n\t\tdestination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );\r\n\t\tduration = speed / deceleration;\r\n\r\n\t\tif ( destination < lowerMargin ) {\r\n\t\t\tdestination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;\r\n\t\t\tdistance = Math.abs(destination - current);\r\n\t\t\tduration = distance / speed;\r\n\t\t} else if ( destination > 0 ) {\r\n\t\t\tdestination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;\r\n\t\t\tdistance = Math.abs(current) + destination;\r\n\t\t\tduration = distance / speed;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tdestination: Math.round(destination),\r\n\t\t\tduration: duration\r\n\t\t};\r\n\t};\r\n\r\n\tvar _transform = _prefixStyle('transform');\r\n\r\n\tme.extend(me, {\r\n\t\thasTransform: _transform !== false,\r\n\t\thasPerspective: _prefixStyle('perspective') in _elementStyle,\r\n\t\thasTouch: 'ontouchstart' in window,\r\n\t\thasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed\r\n\t\thasTransition: _prefixStyle('transition') in _elementStyle\r\n\t});\r\n\r\n\t/*\r\n\tThis should find all Android browsers lower than build 535.19 (both stock browser and webview)\r\n\t- galaxy S2 is ok\r\n    - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`\r\n    - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`\r\n   - galaxy S3 is badAndroid (stock brower, webview)\r\n     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`\r\n   - galaxy S4 is badAndroid (stock brower, webview)\r\n     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`\r\n   - galaxy S5 is OK\r\n     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`\r\n   - galaxy S6 is OK\r\n     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`\r\n  */\r\n\tme.isBadAndroid = (function() {\r\n\t\tvar appVersion = window.navigator.appVersion;\r\n\t\t// Android browser is not a chrome browser.\r\n\t\tif (/Android/.test(appVersion) && !(/Chrome\\/\\d/.test(appVersion))) {\r\n\t\t\tvar safariVersion = appVersion.match(/Safari\\/(\\d+.\\d)/);\r\n\t\t\tif(safariVersion && typeof safariVersion === \"object\" && safariVersion.length >= 2) {\r\n\t\t\t\treturn parseFloat(safariVersion[1]) < 535.19;\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t})();\r\n\r\n\tme.extend(me.style = {}, {\r\n\t\ttransform: _transform,\r\n\t\ttransitionTimingFunction: _prefixStyle('transitionTimingFunction'),\r\n\t\ttransitionDuration: _prefixStyle('transitionDuration'),\r\n\t\ttransitionDelay: _prefixStyle('transitionDelay'),\r\n\t\ttransformOrigin: _prefixStyle('transformOrigin')\r\n\t});\r\n\r\n\tme.hasClass = function (e, c) {\r\n\t\tvar re = new RegExp(\"(^|\\\\s)\" + c + \"(\\\\s|$)\");\r\n\t\treturn re.test(e.className);\r\n\t};\r\n\r\n\tme.addClass = function (e, c) {\r\n\t\tif ( me.hasClass(e, c) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar newclass = e.className.split(' ');\r\n\t\tnewclass.push(c);\r\n\t\te.className = newclass.join(' ');\r\n\t};\r\n\r\n\tme.removeClass = function (e, c) {\r\n\t\tif ( !me.hasClass(e, c) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar re = new RegExp(\"(^|\\\\s)\" + c + \"(\\\\s|$)\", 'g');\r\n\t\te.className = e.className.replace(re, ' ');\r\n\t};\r\n\r\n\tme.offset = function (el) {\r\n\t\tvar left = -el.offsetLeft,\r\n\t\t\ttop = -el.offsetTop;\r\n\r\n\t\t// jshint -W084\r\n\t\twhile (el = el.offsetParent) {\r\n\t\t\tleft -= el.offsetLeft;\r\n\t\t\ttop -= el.offsetTop;\r\n\t\t}\r\n\t\t// jshint +W084\r\n\r\n\t\treturn {\r\n\t\t\tleft: left,\r\n\t\t\ttop: top\r\n\t\t};\r\n\t};\r\n\r\n\tme.preventDefaultException = function (el, exceptions) {\r\n\t\tfor ( var i in exceptions ) {\r\n\t\t\tif ( exceptions[i].test(el[i]) ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\tme.extend(me.eventType = {}, {\r\n\t\ttouchstart: 1,\r\n\t\ttouchmove: 1,\r\n\t\ttouchend: 1,\r\n\r\n\t\tmousedown: 2,\r\n\t\tmousemove: 2,\r\n\t\tmouseup: 2,\r\n\r\n\t\tpointerdown: 3,\r\n\t\tpointermove: 3,\r\n\t\tpointerup: 3,\r\n\r\n\t\tMSPointerDown: 3,\r\n\t\tMSPointerMove: 3,\r\n\t\tMSPointerUp: 3\r\n\t});\r\n\r\n\tme.extend(me.ease = {}, {\r\n\t\tquadratic: {\r\n\t\t\tstyle: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',\r\n\t\t\tfn: function (k) {\r\n\t\t\t\treturn k * ( 2 - k );\r\n\t\t\t}\r\n\t\t},\r\n\t\tcircular: {\r\n\t\t\tstyle: 'cubic-bezier(0.1, 0.57, 0.1, 1)',\t// Not properly \"circular\" but this looks better, it should be (0.075, 0.82, 0.165, 1)\r\n\t\t\tfn: function (k) {\r\n\t\t\t\treturn Math.sqrt( 1 - ( --k * k ) );\r\n\t\t\t}\r\n\t\t},\r\n\t\tback: {\r\n\t\t\tstyle: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',\r\n\t\t\tfn: function (k) {\r\n\t\t\t\tvar b = 4;\r\n\t\t\t\treturn ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;\r\n\t\t\t}\r\n\t\t},\r\n\t\tbounce: {\r\n\t\t\tstyle: '',\r\n\t\t\tfn: function (k) {\r\n\t\t\t\tif ( ( k /= 1 ) < ( 1 / 2.75 ) ) {\r\n\t\t\t\t\treturn 7.5625 * k * k;\r\n\t\t\t\t} else if ( k < ( 2 / 2.75 ) ) {\r\n\t\t\t\t\treturn 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\r\n\t\t\t\t} else if ( k < ( 2.5 / 2.75 ) ) {\r\n\t\t\t\t\treturn 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\telastic: {\r\n\t\t\tstyle: '',\r\n\t\t\tfn: function (k) {\r\n\t\t\t\tvar f = 0.22,\r\n\t\t\t\t\te = 0.4;\r\n\r\n\t\t\t\tif ( k === 0 ) { return 0; }\r\n\t\t\t\tif ( k == 1 ) { return 1; }\r\n\r\n\t\t\t\treturn ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tme.tap = function (e, eventName) {\r\n\t\tvar ev = document.createEvent('Event');\r\n\t\tev.initEvent(eventName, true, true);\r\n\t\tev.pageX = e.pageX;\r\n\t\tev.pageY = e.pageY;\r\n\t\te.target.dispatchEvent(ev);\r\n\t};\r\n\r\n\tme.click = function (e) {\r\n\t\tvar target = e.target,\r\n\t\t\tev;\r\n\r\n\t\tif ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {\r\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent\r\n\t\t\t// initMouseEvent is deprecated.\r\n\t\t\tev = document.createEvent(window.MouseEvent ? 'MouseEvents' : 'Event');\r\n\t\t\tev.initEvent('click', true, true);\r\n\t\t\tev.view = e.view || window;\r\n\t\t\tev.detail = 1;\r\n\t\t\tev.screenX = target.screenX || 0;\r\n\t\t\tev.screenY = target.screenY || 0;\r\n\t\t\tev.clientX = target.clientX || 0;\r\n\t\t\tev.clientY = target.clientY || 0;\r\n\t\t\tev.ctrlKey = !!e.ctrlKey;\r\n\t\t\tev.altKey = !!e.altKey;\r\n\t\t\tev.shiftKey = !!e.shiftKey;\r\n\t\t\tev.metaKey = !!e.metaKey;\r\n\t\t\tev.button = 0;\r\n\t\t\tev.relatedTarget = null;\r\n\t\t\tev._constructed = true;\r\n\t\t\ttarget.dispatchEvent(ev);\r\n\t\t}\r\n\t};\r\n\r\n\treturn me;\r\n})();\r\nfunction IScroll (el, options) {\r\n\tthis.wrapper = typeof el == 'string' ? document.querySelector(el) : el;\r\n\tthis.scroller = this.wrapper.children[0];\r\n\tthis.scrollerStyle = this.scroller.style;\t\t// cache style for better performance\r\n\r\n\tthis.options = {\r\n\r\n\t\tresizeScrollbars: true,\r\n\r\n\t\tmouseWheelSpeed: 20,\r\n\r\n\t\tsnapThreshold: 0.334,\r\n\r\n// INSERT POINT: OPTIONS\r\n\t\tdisablePointer : !utils.hasPointer,\r\n\t\tdisableTouch : utils.hasPointer || !utils.hasTouch,\r\n\t\tdisableMouse : utils.hasPointer || utils.hasTouch,\r\n\t\tstartX: 0,\r\n\t\tstartY: 0,\r\n\t\tscrollY: true,\r\n\t\tdirectionLockThreshold: 5,\r\n\t\tmomentum: true,\r\n\r\n\t\tbounce: true,\r\n\t\tbounceTime: 600,\r\n\t\tbounceEasing: '',\r\n\r\n\t\tpreventDefault: true,\r\n\t\tpreventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },\r\n\r\n\t\tHWCompositing: true,\r\n\t\tuseTransition: true,\r\n\t\tuseTransform: true,\r\n\t\tbindToWrapper: typeof window.onmousedown === \"undefined\"\r\n\t};\r\n\r\n\tfor ( var i in options ) {\r\n\t\tthis.options[i] = options[i];\r\n\t}\r\n\r\n\t// Normalize options\r\n\tthis.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';\r\n\r\n\tthis.options.useTransition = utils.hasTransition && this.options.useTransition;\r\n\tthis.options.useTransform = utils.hasTransform && this.options.useTransform;\r\n\r\n\tthis.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;\r\n\tthis.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;\r\n\r\n\t// If you want eventPassthrough I have to lock one of the axes\r\n\tthis.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;\r\n\tthis.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;\r\n\r\n\t// With eventPassthrough we also need lockDirection mechanism\r\n\tthis.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;\r\n\tthis.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;\r\n\r\n\tthis.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;\r\n\r\n\tthis.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;\r\n\r\n\tif ( this.options.tap === true ) {\r\n\t\tthis.options.tap = 'tap';\r\n\t}\r\n\r\n\t// https://github.com/cubiq/iscroll/issues/1029\r\n\tif (!this.options.useTransition && !this.options.useTransform) {\r\n\t\tif(!(/relative|absolute/i).test(this.scrollerStyle.position)) {\r\n\t\t\tthis.scrollerStyle.position = \"relative\";\r\n\t\t}\r\n\t}\r\n\r\n\tif ( this.options.shrinkScrollbars == 'scale' ) {\r\n\t\tthis.options.useTransition = false;\r\n\t}\r\n\r\n\tthis.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;\r\n\r\n// INSERT POINT: NORMALIZATION\r\n\r\n\t// Some defaults\r\n\tthis.x = 0;\r\n\tthis.y = 0;\r\n\tthis.directionX = 0;\r\n\tthis.directionY = 0;\r\n\tthis._events = {};\r\n\r\n// INSERT POINT: DEFAULTS\r\n\r\n\tthis._init();\r\n\tthis.refresh();\r\n\r\n\tthis.scrollTo(this.options.startX, this.options.startY);\r\n\tthis.enable();\r\n}\r\n\r\nIScroll.prototype = {\r\n\tversion: '5.2.0',\r\n\r\n\t_init: function () {\r\n\t\tthis._initEvents();\r\n\r\n\t\tif ( this.options.scrollbars || this.options.indicators ) {\r\n\t\t\tthis._initIndicators();\r\n\t\t}\r\n\r\n\t\tif ( this.options.mouseWheel ) {\r\n\t\t\tthis._initWheel();\r\n\t\t}\r\n\r\n\t\tif ( this.options.snap ) {\r\n\t\t\tthis._initSnap();\r\n\t\t}\r\n\r\n\t\tif ( this.options.keyBindings ) {\r\n\t\t\tthis._initKeys();\r\n\t\t}\r\n\r\n// INSERT POINT: _init\r\n\r\n\t},\r\n\r\n\tdestroy: function () {\r\n\t\tthis._initEvents(true);\r\n\t\tclearTimeout(this.resizeTimeout);\r\n \t\tthis.resizeTimeout = null;\r\n\t\tthis._execEvent('destroy');\r\n\t},\r\n\r\n\t_transitionEnd: function (e) {\r\n\t\tif ( e.target != this.scroller || !this.isInTransition ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._transitionTime();\r\n\t\tif ( !this.resetPosition(this.options.bounceTime) ) {\r\n\t\t\tthis.isInTransition = false;\r\n\t\t\tthis._execEvent('scrollEnd');\r\n\t\t}\r\n\t},\r\n\r\n\t_start: function (e) {\r\n\t\t// React to left mouse button only\r\n\t\tif ( utils.eventType[e.type] != 1 ) {\r\n\t\t  // for button property\r\n\t\t  // http://unixpapa.com/js/mouse.html\r\n\t\t  var button;\r\n\t    if (!e.which) {\r\n\t      /* IE case */\r\n\t      button = (e.button < 2) ? 0 :\r\n\t               ((e.button == 4) ? 1 : 2);\r\n\t    } else {\r\n\t      /* All others */\r\n\t      button = e.button;\r\n\t    }\r\n\t\t\tif ( button !== 0 ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\r\n\t\tvar point = e.touches ? e.touches[0] : e,\r\n\t\t\tpos;\r\n\r\n\t\tthis.initiated\t= utils.eventType[e.type];\r\n\t\tthis.moved\t\t= false;\r\n\t\tthis.distX\t\t= 0;\r\n\t\tthis.distY\t\t= 0;\r\n\t\tthis.directionX = 0;\r\n\t\tthis.directionY = 0;\r\n\t\tthis.directionLocked = 0;\r\n\r\n\t\tthis.startTime = utils.getTime();\r\n\r\n\t\tif ( this.options.useTransition && this.isInTransition ) {\r\n\t\t\tthis._transitionTime();\r\n\t\t\tthis.isInTransition = false;\r\n\t\t\tpos = this.getComputedPosition();\r\n\t\t\tthis._translate(Math.round(pos.x), Math.round(pos.y));\r\n\t\t\tthis._execEvent('scrollEnd');\r\n\t\t} else if ( !this.options.useTransition && this.isAnimating ) {\r\n\t\t\tthis.isAnimating = false;\r\n\t\t\tthis._execEvent('scrollEnd');\r\n\t\t}\r\n\r\n\t\tthis.startX    = this.x;\r\n\t\tthis.startY    = this.y;\r\n\t\tthis.absStartX = this.x;\r\n\t\tthis.absStartY = this.y;\r\n\t\tthis.pointX    = point.pageX;\r\n\t\tthis.pointY    = point.pageY;\r\n\r\n\t\tthis._execEvent('beforeScrollStart');\r\n\t},\r\n\r\n\t_move: function (e) {\r\n\t\tif ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( this.options.preventDefault ) {\t// increases performance on Android? TODO: check!\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\r\n\t\tvar point\t\t= e.touches ? e.touches[0] : e,\r\n\t\t\tdeltaX\t\t= point.pageX - this.pointX,\r\n\t\t\tdeltaY\t\t= point.pageY - this.pointY,\r\n\t\t\ttimestamp\t= utils.getTime(),\r\n\t\t\tnewX, newY,\r\n\t\t\tabsDistX, absDistY;\r\n\r\n\t\tthis.pointX\t\t= point.pageX;\r\n\t\tthis.pointY\t\t= point.pageY;\r\n\r\n\t\tthis.distX\t\t+= deltaX;\r\n\t\tthis.distY\t\t+= deltaY;\r\n\t\tabsDistX\t\t= Math.abs(this.distX);\r\n\t\tabsDistY\t\t= Math.abs(this.distY);\r\n\r\n\t\t// We need to move at least 10 pixels for the scrolling to initiate\r\n\t\tif ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// If you are scrolling in one direction lock the other\r\n\t\tif ( !this.directionLocked && !this.options.freeScroll ) {\r\n\t\t\tif ( absDistX > absDistY + this.options.directionLockThreshold ) {\r\n\t\t\t\tthis.directionLocked = 'h';\t\t// lock horizontally\r\n\t\t\t} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {\r\n\t\t\t\tthis.directionLocked = 'v';\t\t// lock vertically\r\n\t\t\t} else {\r\n\t\t\t\tthis.directionLocked = 'n';\t\t// no lock\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( this.directionLocked == 'h' ) {\r\n\t\t\tif ( this.options.eventPassthrough == 'vertical' ) {\r\n\t\t\t\te.preventDefault();\r\n\t\t\t} else if ( this.options.eventPassthrough == 'horizontal' ) {\r\n\t\t\t\tthis.initiated = false;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tdeltaY = 0;\r\n\t\t} else if ( this.directionLocked == 'v' ) {\r\n\t\t\tif ( this.options.eventPassthrough == 'horizontal' ) {\r\n\t\t\t\te.preventDefault();\r\n\t\t\t} else if ( this.options.eventPassthrough == 'vertical' ) {\r\n\t\t\t\tthis.initiated = false;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tdeltaX = 0;\r\n\t\t}\r\n\r\n\t\tdeltaX = this.hasHorizontalScroll ? deltaX : 0;\r\n\t\tdeltaY = this.hasVerticalScroll ? deltaY : 0;\r\n\r\n\t\tnewX = this.x + deltaX;\r\n\t\tnewY = this.y + deltaY;\r\n\r\n\t\t// Slow down if outside of the boundaries\r\n\t\tif ( newX > 0 || newX < this.maxScrollX ) {\r\n\t\t\tnewX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;\r\n\t\t}\r\n\t\tif ( newY > 0 || newY < this.maxScrollY ) {\r\n\t\t\tnewY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;\r\n\t\t}\r\n\r\n\t\tthis.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;\r\n\t\tthis.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;\r\n\r\n\t\tif ( !this.moved ) {\r\n\t\t\tthis._execEvent('scrollStart');\r\n\t\t}\r\n\r\n\t\tthis.moved = true;\r\n\r\n\t\tthis._translate(newX, newY);\r\n\r\n/* REPLACE START: _move */\r\n\r\n\t\tif ( timestamp - this.startTime > 300 ) {\r\n\t\t\tthis.startTime = timestamp;\r\n\t\t\tthis.startX = this.x;\r\n\t\t\tthis.startY = this.y;\r\n\t\t}\r\n\r\n/* REPLACE END: _move */\r\n\r\n\t},\r\n\r\n\t_end: function (e) {\r\n\t\tif ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\r\n\t\tvar point = e.changedTouches ? e.changedTouches[0] : e,\r\n\t\t\tmomentumX,\r\n\t\t\tmomentumY,\r\n\t\t\tduration = utils.getTime() - this.startTime,\r\n\t\t\tnewX = Math.round(this.x),\r\n\t\t\tnewY = Math.round(this.y),\r\n\t\t\tdistanceX = Math.abs(newX - this.startX),\r\n\t\t\tdistanceY = Math.abs(newY - this.startY),\r\n\t\t\ttime = 0,\r\n\t\t\teasing = '';\r\n\r\n\t\tthis.isInTransition = 0;\r\n\t\tthis.initiated = 0;\r\n\t\tthis.endTime = utils.getTime();\r\n\r\n\t\t// reset if we are outside of the boundaries\r\n\t\tif ( this.resetPosition(this.options.bounceTime) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.scrollTo(newX, newY);\t// ensures that the last position is rounded\r\n\r\n\t\t// we scrolled less than 10 pixels\r\n\t\tif ( !this.moved ) {\r\n\t\t\tif ( this.options.tap ) {\r\n\t\t\t\tutils.tap(e, this.options.tap);\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.options.click ) {\r\n\t\t\t\tutils.click(e);\r\n\t\t\t}\r\n\r\n\t\t\tthis._execEvent('scrollCancel');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {\r\n\t\t\tthis._execEvent('flick');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// start momentum animation if needed\r\n\t\tif ( this.options.momentum && duration < 300 ) {\r\n\t\t\tmomentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };\r\n\t\t\tmomentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };\r\n\t\t\tnewX = momentumX.destination;\r\n\t\t\tnewY = momentumY.destination;\r\n\t\t\ttime = Math.max(momentumX.duration, momentumY.duration);\r\n\t\t\tthis.isInTransition = 1;\r\n\t\t}\r\n\r\n\r\n\t\tif ( this.options.snap ) {\r\n\t\t\tvar snap = this._nearestSnap(newX, newY);\r\n\t\t\tthis.currentPage = snap;\r\n\t\t\ttime = this.options.snapSpeed || Math.max(\r\n\t\t\t\t\tMath.max(\r\n\t\t\t\t\t\tMath.min(Math.abs(newX - snap.x), 1000),\r\n\t\t\t\t\t\tMath.min(Math.abs(newY - snap.y), 1000)\r\n\t\t\t\t\t), 300);\r\n\t\t\tnewX = snap.x;\r\n\t\t\tnewY = snap.y;\r\n\r\n\t\t\tthis.directionX = 0;\r\n\t\t\tthis.directionY = 0;\r\n\t\t\teasing = this.options.bounceEasing;\r\n\t\t}\r\n\r\n// INSERT POINT: _end\r\n\r\n\t\tif ( newX != this.x || newY != this.y ) {\r\n\t\t\t// change easing function when scroller goes out of the boundaries\r\n\t\t\tif ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {\r\n\t\t\t\teasing = utils.ease.quadratic;\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollTo(newX, newY, time, easing);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._execEvent('scrollEnd');\r\n\t},\r\n\r\n\t_resize: function () {\r\n\t\tvar that = this;\r\n\r\n\t\tclearTimeout(this.resizeTimeout);\r\n\r\n\t\tthis.resizeTimeout = setTimeout(function () {\r\n\t\t\tthat.refresh();\r\n\t\t}, this.options.resizePolling);\r\n\t},\r\n\r\n\tresetPosition: function (time) {\r\n\t\tvar x = this.x,\r\n\t\t\ty = this.y;\r\n\r\n\t\ttime = time || 0;\r\n\r\n\t\tif ( !this.hasHorizontalScroll || this.x > 0 ) {\r\n\t\t\tx = 0;\r\n\t\t} else if ( this.x < this.maxScrollX ) {\r\n\t\t\tx = this.maxScrollX;\r\n\t\t}\r\n\r\n\t\tif ( !this.hasVerticalScroll || this.y > 0 ) {\r\n\t\t\ty = 0;\r\n\t\t} else if ( this.y < this.maxScrollY ) {\r\n\t\t\ty = this.maxScrollY;\r\n\t\t}\r\n\r\n\t\tif ( x == this.x && y == this.y ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tthis.scrollTo(x, y, time, this.options.bounceEasing);\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tthis.enabled = false;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tthis.enabled = true;\r\n\t},\r\n\r\n\trefresh: function () {\r\n\t\tvar rf = this.wrapper.offsetHeight;\t\t// Force reflow\r\n\r\n\t\tthis.wrapperWidth\t= this.wrapper.clientWidth;\r\n\t\tthis.wrapperHeight\t= this.wrapper.clientHeight;\r\n\r\n/* REPLACE START: refresh */\r\n\r\n\t\tthis.scrollerWidth\t= this.scroller.offsetWidth;\r\n\t\tthis.scrollerHeight\t= this.scroller.offsetHeight;\r\n\r\n\t\tthis.maxScrollX\t\t= this.wrapperWidth - this.scrollerWidth;\r\n\t\tthis.maxScrollY\t\t= this.wrapperHeight - this.scrollerHeight;\r\n\r\n/* REPLACE END: refresh */\r\n\r\n\t\tthis.hasHorizontalScroll\t= this.options.scrollX && this.maxScrollX < 0;\r\n\t\tthis.hasVerticalScroll\t\t= this.options.scrollY && this.maxScrollY < 0;\r\n\r\n\t\tif ( !this.hasHorizontalScroll ) {\r\n\t\t\tthis.maxScrollX = 0;\r\n\t\t\tthis.scrollerWidth = this.wrapperWidth;\r\n\t\t}\r\n\r\n\t\tif ( !this.hasVerticalScroll ) {\r\n\t\t\tthis.maxScrollY = 0;\r\n\t\t\tthis.scrollerHeight = this.wrapperHeight;\r\n\t\t}\r\n\r\n\t\tthis.endTime = 0;\r\n\t\tthis.directionX = 0;\r\n\t\tthis.directionY = 0;\r\n\r\n\t\tthis.wrapperOffset = utils.offset(this.wrapper);\r\n\r\n\t\tthis._execEvent('refresh');\r\n\r\n\t\tthis.resetPosition();\r\n\r\n// INSERT POINT: _refresh\r\n\r\n\t},\r\n\r\n\ton: function (type, fn) {\r\n\t\tif ( !this._events[type] ) {\r\n\t\t\tthis._events[type] = [];\r\n\t\t}\r\n\r\n\t\tthis._events[type].push(fn);\r\n\t},\r\n\r\n\toff: function (type, fn) {\r\n\t\tif ( !this._events[type] ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar index = this._events[type].indexOf(fn);\r\n\r\n\t\tif ( index > -1 ) {\r\n\t\t\tthis._events[type].splice(index, 1);\r\n\t\t}\r\n\t},\r\n\r\n\t_execEvent: function (type) {\r\n\t\tif ( !this._events[type] ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar i = 0,\r\n\t\t\tl = this._events[type].length;\r\n\r\n\t\tif ( !l ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\tthis._events[type][i].apply(this, [].slice.call(arguments, 1));\r\n\t\t}\r\n\t},\r\n\r\n\tscrollBy: function (x, y, time, easing) {\r\n\t\tx = this.x + x;\r\n\t\ty = this.y + y;\r\n\t\ttime = time || 0;\r\n\r\n\t\tthis.scrollTo(x, y, time, easing);\r\n\t},\r\n\r\n\tscrollTo: function (x, y, time, easing) {\r\n\t\teasing = easing || utils.ease.circular;\r\n\r\n\t\tthis.isInTransition = this.options.useTransition && time > 0;\r\n\t\tvar transitionType = this.options.useTransition && easing.style;\r\n\t\tif ( !time || transitionType ) {\r\n\t\t\t\tif(transitionType) {\r\n\t\t\t\t\tthis._transitionTimingFunction(easing.style);\r\n\t\t\t\t\tthis._transitionTime(time);\r\n\t\t\t\t}\r\n\t\t\tthis._translate(x, y);\r\n\t\t} else {\r\n\t\t\tthis._animate(x, y, time, easing.fn);\r\n\t\t}\r\n\t},\r\n\r\n\tscrollToElement: function (el, time, offsetX, offsetY, easing) {\r\n\t\tel = el.nodeType ? el : this.scroller.querySelector(el);\r\n\r\n\t\tif ( !el ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar pos = utils.offset(el);\r\n\r\n\t\tpos.left -= this.wrapperOffset.left;\r\n\t\tpos.top  -= this.wrapperOffset.top;\r\n\r\n\t\t// if offsetX/Y are true we center the element to the screen\r\n\t\tif ( offsetX === true ) {\r\n\t\t\toffsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);\r\n\t\t}\r\n\t\tif ( offsetY === true ) {\r\n\t\t\toffsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);\r\n\t\t}\r\n\r\n\t\tpos.left -= offsetX || 0;\r\n\t\tpos.top  -= offsetY || 0;\r\n\r\n\t\tpos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;\r\n\t\tpos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;\r\n\r\n\t\ttime = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;\r\n\r\n\t\tthis.scrollTo(pos.left, pos.top, time, easing);\r\n\t},\r\n\r\n\t_transitionTime: function (time) {\r\n\t\tif (!this.options.useTransition) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttime = time || 0;\r\n\t\tvar durationProp = utils.style.transitionDuration;\r\n\t\tif(!durationProp) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.scrollerStyle[durationProp] = time + 'ms';\r\n\r\n\t\tif ( !time && utils.isBadAndroid ) {\r\n\t\t\tthis.scrollerStyle[durationProp] = '0.0001ms';\r\n\t\t\t// remove 0.0001ms\r\n\t\t\tvar self = this;\r\n\t\t\trAF(function() {\r\n\t\t\t\tif(self.scrollerStyle[durationProp] === '0.0001ms') {\r\n\t\t\t\t\tself.scrollerStyle[durationProp] = '0s';\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\r\n\t\tif ( this.indicators ) {\r\n\t\t\tfor ( var i = this.indicators.length; i--; ) {\r\n\t\t\t\tthis.indicators[i].transitionTime(time);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n// INSERT POINT: _transitionTime\r\n\r\n\t},\r\n\r\n\t_transitionTimingFunction: function (easing) {\r\n\t\tthis.scrollerStyle[utils.style.transitionTimingFunction] = easing;\r\n\r\n\r\n\t\tif ( this.indicators ) {\r\n\t\t\tfor ( var i = this.indicators.length; i--; ) {\r\n\t\t\t\tthis.indicators[i].transitionTimingFunction(easing);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n// INSERT POINT: _transitionTimingFunction\r\n\r\n\t},\r\n\r\n\t_translate: function (x, y) {\r\n\t\tif ( this.options.useTransform ) {\r\n\r\n/* REPLACE START: _translate */\r\n\r\n\t\t\tthis.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;\r\n\r\n/* REPLACE END: _translate */\r\n\r\n\t\t} else {\r\n\t\t\tx = Math.round(x);\r\n\t\t\ty = Math.round(y);\r\n\t\t\tthis.scrollerStyle.left = x + 'px';\r\n\t\t\tthis.scrollerStyle.top = y + 'px';\r\n\t\t}\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\r\n\tif ( this.indicators ) {\r\n\t\tfor ( var i = this.indicators.length; i--; ) {\r\n\t\t\tthis.indicators[i].updatePosition();\r\n\t\t}\r\n\t}\r\n\r\n\r\n// INSERT POINT: _translate\r\n\r\n\t},\r\n\r\n\t_initEvents: function (remove) {\r\n\t\tvar eventType = remove ? utils.removeEvent : utils.addEvent,\r\n\t\t\ttarget = this.options.bindToWrapper ? this.wrapper : window;\r\n\r\n\t\teventType(window, 'orientationchange', this);\r\n\t\teventType(window, 'resize', this);\r\n\r\n\t\tif ( this.options.click ) {\r\n\t\t\teventType(this.wrapper, 'click', this, true);\r\n\t\t}\r\n\r\n\t\tif ( !this.options.disableMouse ) {\r\n\t\t\teventType(this.wrapper, 'mousedown', this);\r\n\t\t\teventType(target, 'mousemove', this);\r\n\t\t\teventType(target, 'mousecancel', this);\r\n\t\t\teventType(target, 'mouseup', this);\r\n\t\t}\r\n\r\n\t\tif ( utils.hasPointer && !this.options.disablePointer ) {\r\n\t\t\teventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);\r\n\t\t\teventType(target, utils.prefixPointerEvent('pointermove'), this);\r\n\t\t\teventType(target, utils.prefixPointerEvent('pointercancel'), this);\r\n\t\t\teventType(target, utils.prefixPointerEvent('pointerup'), this);\r\n\t\t}\r\n\r\n\t\tif ( utils.hasTouch && !this.options.disableTouch ) {\r\n\t\t\teventType(this.wrapper, 'touchstart', this);\r\n\t\t\teventType(target, 'touchmove', this);\r\n\t\t\teventType(target, 'touchcancel', this);\r\n\t\t\teventType(target, 'touchend', this);\r\n\t\t}\r\n\r\n\t\teventType(this.scroller, 'transitionend', this);\r\n\t\teventType(this.scroller, 'webkitTransitionEnd', this);\r\n\t\teventType(this.scroller, 'oTransitionEnd', this);\r\n\t\teventType(this.scroller, 'MSTransitionEnd', this);\r\n\t},\r\n\r\n\tgetComputedPosition: function () {\r\n\t\tvar matrix = window.getComputedStyle(this.scroller, null),\r\n\t\t\tx, y;\r\n\r\n\t\tif ( this.options.useTransform ) {\r\n\t\t\tmatrix = matrix[utils.style.transform].split(')')[0].split(', ');\r\n\t\t\tx = +(matrix[12] || matrix[4]);\r\n\t\t\ty = +(matrix[13] || matrix[5]);\r\n\t\t} else {\r\n\t\t\tx = +matrix.left.replace(/[^-\\d.]/g, '');\r\n\t\t\ty = +matrix.top.replace(/[^-\\d.]/g, '');\r\n\t\t}\r\n\r\n\t\treturn { x: x, y: y };\r\n\t},\r\n\t_initIndicators: function () {\r\n\t\tvar interactive = this.options.interactiveScrollbars,\r\n\t\t\tcustomStyle = typeof this.options.scrollbars != 'string',\r\n\t\t\tindicators = [],\r\n\t\t\tindicator;\r\n\r\n\t\tvar that = this;\r\n\r\n\t\tthis.indicators = [];\r\n\r\n\t\tif ( this.options.scrollbars ) {\r\n\t\t\t// Vertical scrollbar\r\n\t\t\tif ( this.options.scrollY ) {\r\n\t\t\t\tindicator = {\r\n\t\t\t\t\tel: createDefaultScrollbar('v', interactive, this.options.scrollbars),\r\n\t\t\t\t\tinteractive: interactive,\r\n\t\t\t\t\tdefaultScrollbars: true,\r\n\t\t\t\t\tcustomStyle: customStyle,\r\n\t\t\t\t\tresize: this.options.resizeScrollbars,\r\n\t\t\t\t\tshrink: this.options.shrinkScrollbars,\r\n\t\t\t\t\tfade: this.options.fadeScrollbars,\r\n\t\t\t\t\tlistenX: false\r\n\t\t\t\t};\r\n\r\n\t\t\t\tthis.wrapper.appendChild(indicator.el);\r\n\t\t\t\tindicators.push(indicator);\r\n\t\t\t}\r\n\r\n\t\t\t// Horizontal scrollbar\r\n\t\t\tif ( this.options.scrollX ) {\r\n\t\t\t\tindicator = {\r\n\t\t\t\t\tel: createDefaultScrollbar('h', interactive, this.options.scrollbars),\r\n\t\t\t\t\tinteractive: interactive,\r\n\t\t\t\t\tdefaultScrollbars: true,\r\n\t\t\t\t\tcustomStyle: customStyle,\r\n\t\t\t\t\tresize: this.options.resizeScrollbars,\r\n\t\t\t\t\tshrink: this.options.shrinkScrollbars,\r\n\t\t\t\t\tfade: this.options.fadeScrollbars,\r\n\t\t\t\t\tlistenY: false\r\n\t\t\t\t};\r\n\r\n\t\t\t\tthis.wrapper.appendChild(indicator.el);\r\n\t\t\t\tindicators.push(indicator);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( this.options.indicators ) {\r\n\t\t\t// TODO: check concat compatibility\r\n\t\t\tindicators = indicators.concat(this.options.indicators);\r\n\t\t}\r\n\r\n\t\tfor ( var i = indicators.length; i--; ) {\r\n\t\t\tthis.indicators.push( new Indicator(this, indicators[i]) );\r\n\t\t}\r\n\r\n\t\t// TODO: check if we can use array.map (wide compatibility and performance issues)\r\n\t\tfunction _indicatorsMap (fn) {\r\n\t\t\tif (that.indicators) {\r\n\t\t\t\tfor ( var i = that.indicators.length; i--; ) {\r\n\t\t\t\t\tfn.call(that.indicators[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( this.options.fadeScrollbars ) {\r\n\t\t\tthis.on('scrollEnd', function () {\r\n\t\t\t\t_indicatorsMap(function () {\r\n\t\t\t\t\tthis.fade();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\tthis.on('scrollCancel', function () {\r\n\t\t\t\t_indicatorsMap(function () {\r\n\t\t\t\t\tthis.fade();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\tthis.on('scrollStart', function () {\r\n\t\t\t\t_indicatorsMap(function () {\r\n\t\t\t\t\tthis.fade(1);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\tthis.on('beforeScrollStart', function () {\r\n\t\t\t\t_indicatorsMap(function () {\r\n\t\t\t\t\tthis.fade(1, true);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\r\n\t\tthis.on('refresh', function () {\r\n\t\t\t_indicatorsMap(function () {\r\n\t\t\t\tthis.refresh();\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tthis.on('destroy', function () {\r\n\t\t\t_indicatorsMap(function () {\r\n\t\t\t\tthis.destroy();\r\n\t\t\t});\r\n\r\n\t\t\tdelete this.indicators;\r\n\t\t});\r\n\t},\r\n\r\n\t_initWheel: function () {\r\n\t\tutils.addEvent(this.wrapper, 'wheel', this);\r\n\t\tutils.addEvent(this.wrapper, 'mousewheel', this);\r\n\t\tutils.addEvent(this.wrapper, 'DOMMouseScroll', this);\r\n\r\n\t\tthis.on('destroy', function () {\r\n\t\t\tclearTimeout(this.wheelTimeout);\r\n\t\t\tthis.wheelTimeout = null;\r\n\t\t\tutils.removeEvent(this.wrapper, 'wheel', this);\r\n\t\t\tutils.removeEvent(this.wrapper, 'mousewheel', this);\r\n\t\t\tutils.removeEvent(this.wrapper, 'DOMMouseScroll', this);\r\n\t\t});\r\n\t},\r\n\r\n\t_wheel: function (e) {\r\n\t\tif ( !this.enabled ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\te.preventDefault();\r\n\r\n\t\tvar wheelDeltaX, wheelDeltaY,\r\n\t\t\tnewX, newY,\r\n\t\t\tthat = this;\r\n\r\n\t\tif ( this.wheelTimeout === undefined ) {\r\n\t\t\tthat._execEvent('scrollStart');\r\n\t\t}\r\n\r\n\t\t// Execute the scrollEnd event after 400ms the wheel stopped scrolling\r\n\t\tclearTimeout(this.wheelTimeout);\r\n\t\tthis.wheelTimeout = setTimeout(function () {\r\n\t\t\tif(!that.options.snap) {\r\n\t\t\t\tthat._execEvent('scrollEnd');\r\n\t\t\t}\r\n\t\t\tthat.wheelTimeout = undefined;\r\n\t\t}, 400);\r\n\r\n\t\tif ( 'deltaX' in e ) {\r\n\t\t\tif (e.deltaMode === 1) {\r\n\t\t\t\twheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;\r\n\t\t\t\twheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;\r\n\t\t\t} else {\r\n\t\t\t\twheelDeltaX = -e.deltaX;\r\n\t\t\t\twheelDeltaY = -e.deltaY;\r\n\t\t\t}\r\n\t\t} else if ( 'wheelDeltaX' in e ) {\r\n\t\t\twheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;\r\n\t\t\twheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;\r\n\t\t} else if ( 'wheelDelta' in e ) {\r\n\t\t\twheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;\r\n\t\t} else if ( 'detail' in e ) {\r\n\t\t\twheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;\r\n\t\t} else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\twheelDeltaX *= this.options.invertWheelDirection;\r\n\t\twheelDeltaY *= this.options.invertWheelDirection;\r\n\r\n\t\tif ( !this.hasVerticalScroll ) {\r\n\t\t\twheelDeltaX = wheelDeltaY;\r\n\t\t\twheelDeltaY = 0;\r\n\t\t}\r\n\r\n\t\tif ( this.options.snap ) {\r\n\t\t\tnewX = this.currentPage.pageX;\r\n\t\t\tnewY = this.currentPage.pageY;\r\n\r\n\t\t\tif ( wheelDeltaX > 0 ) {\r\n\t\t\t\tnewX--;\r\n\t\t\t} else if ( wheelDeltaX < 0 ) {\r\n\t\t\t\tnewX++;\r\n\t\t\t}\r\n\r\n\t\t\tif ( wheelDeltaY > 0 ) {\r\n\t\t\t\tnewY--;\r\n\t\t\t} else if ( wheelDeltaY < 0 ) {\r\n\t\t\t\tnewY++;\r\n\t\t\t}\r\n\r\n\t\t\tthis.goToPage(newX, newY);\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tnewX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);\r\n\t\tnewY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);\r\n\r\n\t\tthis.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;\r\n\t\tthis.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;\r\n\r\n\t\tif ( newX > 0 ) {\r\n\t\t\tnewX = 0;\r\n\t\t} else if ( newX < this.maxScrollX ) {\r\n\t\t\tnewX = this.maxScrollX;\r\n\t\t}\r\n\r\n\t\tif ( newY > 0 ) {\r\n\t\t\tnewY = 0;\r\n\t\t} else if ( newY < this.maxScrollY ) {\r\n\t\t\tnewY = this.maxScrollY;\r\n\t\t}\r\n\r\n\t\tthis.scrollTo(newX, newY, 0);\r\n\r\n// INSERT POINT: _wheel\r\n\t},\r\n\r\n\t_initSnap: function () {\r\n\t\tthis.currentPage = {};\r\n\r\n\t\tif ( typeof this.options.snap == 'string' ) {\r\n\t\t\tthis.options.snap = this.scroller.querySelectorAll(this.options.snap);\r\n\t\t}\r\n\r\n\t\tthis.on('refresh', function () {\r\n\t\t\tvar i = 0, l,\r\n\t\t\t\tm = 0, n,\r\n\t\t\t\tcx, cy,\r\n\t\t\t\tx = 0, y,\r\n\t\t\t\tstepX = this.options.snapStepX || this.wrapperWidth,\r\n\t\t\t\tstepY = this.options.snapStepY || this.wrapperHeight,\r\n\t\t\t\tel;\r\n\r\n\t\t\tthis.pages = [];\r\n\r\n\t\t\tif ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.options.snap === true ) {\r\n\t\t\t\tcx = Math.round( stepX / 2 );\r\n\t\t\t\tcy = Math.round( stepY / 2 );\r\n\r\n\t\t\t\twhile ( x > -this.scrollerWidth ) {\r\n\t\t\t\t\tthis.pages[i] = [];\r\n\t\t\t\t\tl = 0;\r\n\t\t\t\t\ty = 0;\r\n\r\n\t\t\t\t\twhile ( y > -this.scrollerHeight ) {\r\n\t\t\t\t\t\tthis.pages[i][l] = {\r\n\t\t\t\t\t\t\tx: Math.max(x, this.maxScrollX),\r\n\t\t\t\t\t\t\ty: Math.max(y, this.maxScrollY),\r\n\t\t\t\t\t\t\twidth: stepX,\r\n\t\t\t\t\t\t\theight: stepY,\r\n\t\t\t\t\t\t\tcx: x - cx,\r\n\t\t\t\t\t\t\tcy: y - cy\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\ty -= stepY;\r\n\t\t\t\t\t\tl++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tx -= stepX;\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tel = this.options.snap;\r\n\t\t\t\tl = el.length;\r\n\t\t\t\tn = -1;\r\n\r\n\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\tif ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {\r\n\t\t\t\t\t\tm = 0;\r\n\t\t\t\t\t\tn++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( !this.pages[m] ) {\r\n\t\t\t\t\t\tthis.pages[m] = [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tx = Math.max(-el[i].offsetLeft, this.maxScrollX);\r\n\t\t\t\t\ty = Math.max(-el[i].offsetTop, this.maxScrollY);\r\n\t\t\t\t\tcx = x - Math.round(el[i].offsetWidth / 2);\r\n\t\t\t\t\tcy = y - Math.round(el[i].offsetHeight / 2);\r\n\r\n\t\t\t\t\tthis.pages[m][n] = {\r\n\t\t\t\t\t\tx: x,\r\n\t\t\t\t\t\ty: y,\r\n\t\t\t\t\t\twidth: el[i].offsetWidth,\r\n\t\t\t\t\t\theight: el[i].offsetHeight,\r\n\t\t\t\t\t\tcx: cx,\r\n\t\t\t\t\t\tcy: cy\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif ( x > this.maxScrollX ) {\r\n\t\t\t\t\t\tm++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);\r\n\r\n\t\t\t// Update snap threshold if needed\r\n\t\t\tif ( this.options.snapThreshold % 1 === 0 ) {\r\n\t\t\t\tthis.snapThresholdX = this.options.snapThreshold;\r\n\t\t\t\tthis.snapThresholdY = this.options.snapThreshold;\r\n\t\t\t} else {\r\n\t\t\t\tthis.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);\r\n\t\t\t\tthis.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.on('flick', function () {\r\n\t\t\tvar time = this.options.snapSpeed || Math.max(\r\n\t\t\t\t\tMath.max(\r\n\t\t\t\t\t\tMath.min(Math.abs(this.x - this.startX), 1000),\r\n\t\t\t\t\t\tMath.min(Math.abs(this.y - this.startY), 1000)\r\n\t\t\t\t\t), 300);\r\n\r\n\t\t\tthis.goToPage(\r\n\t\t\t\tthis.currentPage.pageX + this.directionX,\r\n\t\t\t\tthis.currentPage.pageY + this.directionY,\r\n\t\t\t\ttime\r\n\t\t\t);\r\n\t\t});\r\n\t},\r\n\r\n\t_nearestSnap: function (x, y) {\r\n\t\tif ( !this.pages.length ) {\r\n\t\t\treturn { x: 0, y: 0, pageX: 0, pageY: 0 };\r\n\t\t}\r\n\r\n\t\tvar i = 0,\r\n\t\t\tl = this.pages.length,\r\n\t\t\tm = 0;\r\n\r\n\t\t// Check if we exceeded the snap threshold\r\n\t\tif ( Math.abs(x - this.absStartX) < this.snapThresholdX &&\r\n\t\t\tMath.abs(y - this.absStartY) < this.snapThresholdY ) {\r\n\t\t\treturn this.currentPage;\r\n\t\t}\r\n\r\n\t\tif ( x > 0 ) {\r\n\t\t\tx = 0;\r\n\t\t} else if ( x < this.maxScrollX ) {\r\n\t\t\tx = this.maxScrollX;\r\n\t\t}\r\n\r\n\t\tif ( y > 0 ) {\r\n\t\t\ty = 0;\r\n\t\t} else if ( y < this.maxScrollY ) {\r\n\t\t\ty = this.maxScrollY;\r\n\t\t}\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\tif ( x >= this.pages[i][0].cx ) {\r\n\t\t\t\tx = this.pages[i][0].x;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tl = this.pages[i].length;\r\n\r\n\t\tfor ( ; m < l; m++ ) {\r\n\t\t\tif ( y >= this.pages[0][m].cy ) {\r\n\t\t\t\ty = this.pages[0][m].y;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( i == this.currentPage.pageX ) {\r\n\t\t\ti += this.directionX;\r\n\r\n\t\t\tif ( i < 0 ) {\r\n\t\t\t\ti = 0;\r\n\t\t\t} else if ( i >= this.pages.length ) {\r\n\t\t\t\ti = this.pages.length - 1;\r\n\t\t\t}\r\n\r\n\t\t\tx = this.pages[i][0].x;\r\n\t\t}\r\n\r\n\t\tif ( m == this.currentPage.pageY ) {\r\n\t\t\tm += this.directionY;\r\n\r\n\t\t\tif ( m < 0 ) {\r\n\t\t\t\tm = 0;\r\n\t\t\t} else if ( m >= this.pages[0].length ) {\r\n\t\t\t\tm = this.pages[0].length - 1;\r\n\t\t\t}\r\n\r\n\t\t\ty = this.pages[0][m].y;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tx: x,\r\n\t\t\ty: y,\r\n\t\t\tpageX: i,\r\n\t\t\tpageY: m\r\n\t\t};\r\n\t},\r\n\r\n\tgoToPage: function (x, y, time, easing) {\r\n\t\teasing = easing || this.options.bounceEasing;\r\n\r\n\t\tif ( x >= this.pages.length ) {\r\n\t\t\tx = this.pages.length - 1;\r\n\t\t} else if ( x < 0 ) {\r\n\t\t\tx = 0;\r\n\t\t}\r\n\r\n\t\tif ( y >= this.pages[x].length ) {\r\n\t\t\ty = this.pages[x].length - 1;\r\n\t\t} else if ( y < 0 ) {\r\n\t\t\ty = 0;\r\n\t\t}\r\n\r\n\t\tvar posX = this.pages[x][y].x,\r\n\t\t\tposY = this.pages[x][y].y;\r\n\r\n\t\ttime = time === undefined ? this.options.snapSpeed || Math.max(\r\n\t\t\tMath.max(\r\n\t\t\t\tMath.min(Math.abs(posX - this.x), 1000),\r\n\t\t\t\tMath.min(Math.abs(posY - this.y), 1000)\r\n\t\t\t), 300) : time;\r\n\r\n\t\tthis.currentPage = {\r\n\t\t\tx: posX,\r\n\t\t\ty: posY,\r\n\t\t\tpageX: x,\r\n\t\t\tpageY: y\r\n\t\t};\r\n\r\n\t\tthis.scrollTo(posX, posY, time, easing);\r\n\t},\r\n\r\n\tnext: function (time, easing) {\r\n\t\tvar x = this.currentPage.pageX,\r\n\t\t\ty = this.currentPage.pageY;\r\n\r\n\t\tx++;\r\n\r\n\t\tif ( x >= this.pages.length && this.hasVerticalScroll ) {\r\n\t\t\tx = 0;\r\n\t\t\ty++;\r\n\t\t}\r\n\r\n\t\tthis.goToPage(x, y, time, easing);\r\n\t},\r\n\r\n\tprev: function (time, easing) {\r\n\t\tvar x = this.currentPage.pageX,\r\n\t\t\ty = this.currentPage.pageY;\r\n\r\n\t\tx--;\r\n\r\n\t\tif ( x < 0 && this.hasVerticalScroll ) {\r\n\t\t\tx = 0;\r\n\t\t\ty--;\r\n\t\t}\r\n\r\n\t\tthis.goToPage(x, y, time, easing);\r\n\t},\r\n\r\n\t_initKeys: function (e) {\r\n\t\t// default key bindings\r\n\t\tvar keys = {\r\n\t\t\tpageUp: 33,\r\n\t\t\tpageDown: 34,\r\n\t\t\tend: 35,\r\n\t\t\thome: 36,\r\n\t\t\tleft: 37,\r\n\t\t\tup: 38,\r\n\t\t\tright: 39,\r\n\t\t\tdown: 40\r\n\t\t};\r\n\t\tvar i;\r\n\r\n\t\t// if you give me characters I give you keycode\r\n\t\tif ( typeof this.options.keyBindings == 'object' ) {\r\n\t\t\tfor ( i in this.options.keyBindings ) {\r\n\t\t\t\tif ( typeof this.options.keyBindings[i] == 'string' ) {\r\n\t\t\t\t\tthis.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.options.keyBindings = {};\r\n\t\t}\r\n\r\n\t\tfor ( i in keys ) {\r\n\t\t\tthis.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];\r\n\t\t}\r\n\r\n\t\tutils.addEvent(window, 'keydown', this);\r\n\r\n\t\tthis.on('destroy', function () {\r\n\t\t\tutils.removeEvent(window, 'keydown', this);\r\n\t\t});\r\n\t},\r\n\r\n\t_key: function (e) {\r\n\t\tif ( !this.enabled ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar snap = this.options.snap,\t// we are using this alot, better to cache it\r\n\t\t\tnewX = snap ? this.currentPage.pageX : this.x,\r\n\t\t\tnewY = snap ? this.currentPage.pageY : this.y,\r\n\t\t\tnow = utils.getTime(),\r\n\t\t\tprevTime = this.keyTime || 0,\r\n\t\t\tacceleration = 0.250,\r\n\t\t\tpos;\r\n\r\n\t\tif ( this.options.useTransition && this.isInTransition ) {\r\n\t\t\tpos = this.getComputedPosition();\r\n\r\n\t\t\tthis._translate(Math.round(pos.x), Math.round(pos.y));\r\n\t\t\tthis.isInTransition = false;\r\n\t\t}\r\n\r\n\t\tthis.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;\r\n\r\n\t\tswitch ( e.keyCode ) {\r\n\t\t\tcase this.options.keyBindings.pageUp:\r\n\t\t\t\tif ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {\r\n\t\t\t\t\tnewX += snap ? 1 : this.wrapperWidth;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewY += snap ? 1 : this.wrapperHeight;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.options.keyBindings.pageDown:\r\n\t\t\t\tif ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {\r\n\t\t\t\t\tnewX -= snap ? 1 : this.wrapperWidth;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewY -= snap ? 1 : this.wrapperHeight;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.options.keyBindings.end:\r\n\t\t\t\tnewX = snap ? this.pages.length-1 : this.maxScrollX;\r\n\t\t\t\tnewY = snap ? this.pages[0].length-1 : this.maxScrollY;\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.options.keyBindings.home:\r\n\t\t\t\tnewX = 0;\r\n\t\t\t\tnewY = 0;\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.options.keyBindings.left:\r\n\t\t\t\tnewX += snap ? -1 : 5 + this.keyAcceleration>>0;\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.options.keyBindings.up:\r\n\t\t\t\tnewY += snap ? 1 : 5 + this.keyAcceleration>>0;\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.options.keyBindings.right:\r\n\t\t\t\tnewX -= snap ? -1 : 5 + this.keyAcceleration>>0;\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.options.keyBindings.down:\r\n\t\t\t\tnewY -= snap ? 1 : 5 + this.keyAcceleration>>0;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( snap ) {\r\n\t\t\tthis.goToPage(newX, newY);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( newX > 0 ) {\r\n\t\t\tnewX = 0;\r\n\t\t\tthis.keyAcceleration = 0;\r\n\t\t} else if ( newX < this.maxScrollX ) {\r\n\t\t\tnewX = this.maxScrollX;\r\n\t\t\tthis.keyAcceleration = 0;\r\n\t\t}\r\n\r\n\t\tif ( newY > 0 ) {\r\n\t\t\tnewY = 0;\r\n\t\t\tthis.keyAcceleration = 0;\r\n\t\t} else if ( newY < this.maxScrollY ) {\r\n\t\t\tnewY = this.maxScrollY;\r\n\t\t\tthis.keyAcceleration = 0;\r\n\t\t}\r\n\r\n\t\tthis.scrollTo(newX, newY, 0);\r\n\r\n\t\tthis.keyTime = now;\r\n\t},\r\n\r\n\t_animate: function (destX, destY, duration, easingFn) {\r\n\t\tvar that = this,\r\n\t\t\tstartX = this.x,\r\n\t\t\tstartY = this.y,\r\n\t\t\tstartTime = utils.getTime(),\r\n\t\t\tdestTime = startTime + duration;\r\n\r\n\t\tfunction step () {\r\n\t\t\tvar now = utils.getTime(),\r\n\t\t\t\tnewX, newY,\r\n\t\t\t\teasing;\r\n\r\n\t\t\tif ( now >= destTime ) {\r\n\t\t\t\tthat.isAnimating = false;\r\n\t\t\t\tthat._translate(destX, destY);\r\n\r\n\t\t\t\tif ( !that.resetPosition(that.options.bounceTime) ) {\r\n\t\t\t\t\tthat._execEvent('scrollEnd');\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tnow = ( now - startTime ) / duration;\r\n\t\t\teasing = easingFn(now);\r\n\t\t\tnewX = ( destX - startX ) * easing + startX;\r\n\t\t\tnewY = ( destY - startY ) * easing + startY;\r\n\t\t\tthat._translate(newX, newY);\r\n\r\n\t\t\tif ( that.isAnimating ) {\r\n\t\t\t\trAF(step);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.isAnimating = true;\r\n\t\tstep();\r\n\t},\r\n\thandleEvent: function (e) {\r\n\t\tswitch ( e.type ) {\r\n\t\t\tcase 'touchstart':\r\n\t\t\tcase 'pointerdown':\r\n\t\t\tcase 'MSPointerDown':\r\n\t\t\tcase 'mousedown':\r\n\t\t\t\tthis._start(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'touchmove':\r\n\t\t\tcase 'pointermove':\r\n\t\t\tcase 'MSPointerMove':\r\n\t\t\tcase 'mousemove':\r\n\t\t\t\tthis._move(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'touchend':\r\n\t\t\tcase 'pointerup':\r\n\t\t\tcase 'MSPointerUp':\r\n\t\t\tcase 'mouseup':\r\n\t\t\tcase 'touchcancel':\r\n\t\t\tcase 'pointercancel':\r\n\t\t\tcase 'MSPointerCancel':\r\n\t\t\tcase 'mousecancel':\r\n\t\t\t\tthis._end(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'orientationchange':\r\n\t\t\tcase 'resize':\r\n\t\t\t\tthis._resize();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'transitionend':\r\n\t\t\tcase 'webkitTransitionEnd':\r\n\t\t\tcase 'oTransitionEnd':\r\n\t\t\tcase 'MSTransitionEnd':\r\n\t\t\t\tthis._transitionEnd(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'wheel':\r\n\t\t\tcase 'DOMMouseScroll':\r\n\t\t\tcase 'mousewheel':\r\n\t\t\t\tthis._wheel(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'keydown':\r\n\t\t\t\tthis._key(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'click':\r\n\t\t\t\tif ( this.enabled && !e._constructed ) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n};\r\nfunction createDefaultScrollbar (direction, interactive, type) {\r\n\tvar scrollbar = document.createElement('div'),\r\n\t\tindicator = document.createElement('div');\r\n\r\n\tif ( type === true ) {\r\n\t\tscrollbar.style.cssText = 'position:absolute;z-index:9999';\r\n\t\tindicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';\r\n\t}\r\n\r\n\tindicator.className = 'iScrollIndicator';\r\n\r\n\tif ( direction == 'h' ) {\r\n\t\tif ( type === true ) {\r\n\t\t\tscrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';\r\n\t\t\tindicator.style.height = '100%';\r\n\t\t}\r\n\t\tscrollbar.className = 'iScrollHorizontalScrollbar';\r\n\t} else {\r\n\t\tif ( type === true ) {\r\n\t\t\tscrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';\r\n\t\t\tindicator.style.width = '100%';\r\n\t\t}\r\n\t\tscrollbar.className = 'iScrollVerticalScrollbar';\r\n\t}\r\n\r\n\tscrollbar.style.cssText += ';overflow:hidden';\r\n\r\n\tif ( !interactive ) {\r\n\t\tscrollbar.style.pointerEvents = 'none';\r\n\t}\r\n\r\n\tscrollbar.appendChild(indicator);\r\n\r\n\treturn scrollbar;\r\n}\r\n\r\nfunction Indicator (scroller, options) {\r\n\tthis.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;\r\n\tthis.wrapperStyle = this.wrapper.style;\r\n\tthis.indicator = this.wrapper.children[0];\r\n\tthis.indicatorStyle = this.indicator.style;\r\n\tthis.scroller = scroller;\r\n\r\n\tthis.options = {\r\n\t\tlistenX: true,\r\n\t\tlistenY: true,\r\n\t\tinteractive: false,\r\n\t\tresize: true,\r\n\t\tdefaultScrollbars: false,\r\n\t\tshrink: false,\r\n\t\tfade: false,\r\n\t\tspeedRatioX: 0,\r\n\t\tspeedRatioY: 0\r\n\t};\r\n\r\n\tfor ( var i in options ) {\r\n\t\tthis.options[i] = options[i];\r\n\t}\r\n\r\n\tthis.sizeRatioX = 1;\r\n\tthis.sizeRatioY = 1;\r\n\tthis.maxPosX = 0;\r\n\tthis.maxPosY = 0;\r\n\r\n\tif ( this.options.interactive ) {\r\n\t\tif ( !this.options.disableTouch ) {\r\n\t\t\tutils.addEvent(this.indicator, 'touchstart', this);\r\n\t\t\tutils.addEvent(window, 'touchend', this);\r\n\t\t}\r\n\t\tif ( !this.options.disablePointer ) {\r\n\t\t\tutils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);\r\n\t\t\tutils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);\r\n\t\t}\r\n\t\tif ( !this.options.disableMouse ) {\r\n\t\t\tutils.addEvent(this.indicator, 'mousedown', this);\r\n\t\t\tutils.addEvent(window, 'mouseup', this);\r\n\t\t}\r\n\t}\r\n\r\n\tif ( this.options.fade ) {\r\n\t\tthis.wrapperStyle[utils.style.transform] = this.scroller.translateZ;\r\n\t\tvar durationProp = utils.style.transitionDuration;\r\n\t\tif(!durationProp) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';\r\n\t\t// remove 0.0001ms\r\n\t\tvar self = this;\r\n\t\tif(utils.isBadAndroid) {\r\n\t\t\trAF(function() {\r\n\t\t\t\tif(self.wrapperStyle[durationProp] === '0.0001ms') {\r\n\t\t\t\t\tself.wrapperStyle[durationProp] = '0s';\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tthis.wrapperStyle.opacity = '0';\r\n\t}\r\n}\r\n\r\nIndicator.prototype = {\r\n\thandleEvent: function (e) {\r\n\t\tswitch ( e.type ) {\r\n\t\t\tcase 'touchstart':\r\n\t\t\tcase 'pointerdown':\r\n\t\t\tcase 'MSPointerDown':\r\n\t\t\tcase 'mousedown':\r\n\t\t\t\tthis._start(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'touchmove':\r\n\t\t\tcase 'pointermove':\r\n\t\t\tcase 'MSPointerMove':\r\n\t\t\tcase 'mousemove':\r\n\t\t\t\tthis._move(e);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'touchend':\r\n\t\t\tcase 'pointerup':\r\n\t\t\tcase 'MSPointerUp':\r\n\t\t\tcase 'mouseup':\r\n\t\t\tcase 'touchcancel':\r\n\t\t\tcase 'pointercancel':\r\n\t\t\tcase 'MSPointerCancel':\r\n\t\t\tcase 'mousecancel':\r\n\t\t\t\tthis._end(e);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t},\r\n\r\n\tdestroy: function () {\r\n\t\tif ( this.options.fadeScrollbars ) {\r\n\t\t\tclearTimeout(this.fadeTimeout);\r\n\t\t\tthis.fadeTimeout = null;\r\n\t\t}\r\n\t\tif ( this.options.interactive ) {\r\n\t\t\tutils.removeEvent(this.indicator, 'touchstart', this);\r\n\t\t\tutils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);\r\n\t\t\tutils.removeEvent(this.indicator, 'mousedown', this);\r\n\r\n\t\t\tutils.removeEvent(window, 'touchmove', this);\r\n\t\t\tutils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);\r\n\t\t\tutils.removeEvent(window, 'mousemove', this);\r\n\r\n\t\t\tutils.removeEvent(window, 'touchend', this);\r\n\t\t\tutils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);\r\n\t\t\tutils.removeEvent(window, 'mouseup', this);\r\n\t\t}\r\n\r\n\t\tif ( this.options.defaultScrollbars ) {\r\n\t\t\tthis.wrapper.parentNode.removeChild(this.wrapper);\r\n\t\t}\r\n\t},\r\n\r\n\t_start: function (e) {\r\n\t\tvar point = e.touches ? e.touches[0] : e;\r\n\r\n\t\te.preventDefault();\r\n\t\te.stopPropagation();\r\n\r\n\t\tthis.transitionTime();\r\n\r\n\t\tthis.initiated = true;\r\n\t\tthis.moved = false;\r\n\t\tthis.lastPointX\t= point.pageX;\r\n\t\tthis.lastPointY\t= point.pageY;\r\n\r\n\t\tthis.startTime\t= utils.getTime();\r\n\r\n\t\tif ( !this.options.disableTouch ) {\r\n\t\t\tutils.addEvent(window, 'touchmove', this);\r\n\t\t}\r\n\t\tif ( !this.options.disablePointer ) {\r\n\t\t\tutils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);\r\n\t\t}\r\n\t\tif ( !this.options.disableMouse ) {\r\n\t\t\tutils.addEvent(window, 'mousemove', this);\r\n\t\t}\r\n\r\n\t\tthis.scroller._execEvent('beforeScrollStart');\r\n\t},\r\n\r\n\t_move: function (e) {\r\n\t\tvar point = e.touches ? e.touches[0] : e,\r\n\t\t\tdeltaX, deltaY,\r\n\t\t\tnewX, newY,\r\n\t\t\ttimestamp = utils.getTime();\r\n\r\n\t\tif ( !this.moved ) {\r\n\t\t\tthis.scroller._execEvent('scrollStart');\r\n\t\t}\r\n\r\n\t\tthis.moved = true;\r\n\r\n\t\tdeltaX = point.pageX - this.lastPointX;\r\n\t\tthis.lastPointX = point.pageX;\r\n\r\n\t\tdeltaY = point.pageY - this.lastPointY;\r\n\t\tthis.lastPointY = point.pageY;\r\n\r\n\t\tnewX = this.x + deltaX;\r\n\t\tnewY = this.y + deltaY;\r\n\r\n\t\tthis._pos(newX, newY);\r\n\r\n// INSERT POINT: indicator._move\r\n\r\n\t\te.preventDefault();\r\n\t\te.stopPropagation();\r\n\t},\r\n\r\n\t_end: function (e) {\r\n\t\tif ( !this.initiated ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.initiated = false;\r\n\r\n\t\te.preventDefault();\r\n\t\te.stopPropagation();\r\n\r\n\t\tutils.removeEvent(window, 'touchmove', this);\r\n\t\tutils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);\r\n\t\tutils.removeEvent(window, 'mousemove', this);\r\n\r\n\t\tif ( this.scroller.options.snap ) {\r\n\t\t\tvar snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);\r\n\r\n\t\t\tvar time = this.options.snapSpeed || Math.max(\r\n\t\t\t\t\tMath.max(\r\n\t\t\t\t\t\tMath.min(Math.abs(this.scroller.x - snap.x), 1000),\r\n\t\t\t\t\t\tMath.min(Math.abs(this.scroller.y - snap.y), 1000)\r\n\t\t\t\t\t), 300);\r\n\r\n\t\t\tif ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {\r\n\t\t\t\tthis.scroller.directionX = 0;\r\n\t\t\t\tthis.scroller.directionY = 0;\r\n\t\t\t\tthis.scroller.currentPage = snap;\r\n\t\t\t\tthis.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( this.moved ) {\r\n\t\t\tthis.scroller._execEvent('scrollEnd');\r\n\t\t}\r\n\t},\r\n\r\n\ttransitionTime: function (time) {\r\n\t\ttime = time || 0;\r\n\t\tvar durationProp = utils.style.transitionDuration;\r\n\t\tif(!durationProp) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.indicatorStyle[durationProp] = time + 'ms';\r\n\r\n\t\tif ( !time && utils.isBadAndroid ) {\r\n\t\t\tthis.indicatorStyle[durationProp] = '0.0001ms';\r\n\t\t\t// remove 0.0001ms\r\n\t\t\tvar self = this;\r\n\t\t\trAF(function() {\r\n\t\t\t\tif(self.indicatorStyle[durationProp] === '0.0001ms') {\r\n\t\t\t\t\tself.indicatorStyle[durationProp] = '0s';\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\ttransitionTimingFunction: function (easing) {\r\n\t\tthis.indicatorStyle[utils.style.transitionTimingFunction] = easing;\r\n\t},\r\n\r\n\trefresh: function () {\r\n\t\tthis.transitionTime();\r\n\r\n\t\tif ( this.options.listenX && !this.options.listenY ) {\r\n\t\t\tthis.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';\r\n\t\t} else if ( this.options.listenY && !this.options.listenX ) {\r\n\t\t\tthis.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';\r\n\t\t} else {\r\n\t\t\tthis.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';\r\n\t\t}\r\n\r\n\t\tif ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {\r\n\t\t\tutils.addClass(this.wrapper, 'iScrollBothScrollbars');\r\n\t\t\tutils.removeClass(this.wrapper, 'iScrollLoneScrollbar');\r\n\r\n\t\t\tif ( this.options.defaultScrollbars && this.options.customStyle ) {\r\n\t\t\t\tif ( this.options.listenX ) {\r\n\t\t\t\t\tthis.wrapper.style.right = '8px';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.wrapper.style.bottom = '8px';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tutils.removeClass(this.wrapper, 'iScrollBothScrollbars');\r\n\t\t\tutils.addClass(this.wrapper, 'iScrollLoneScrollbar');\r\n\r\n\t\t\tif ( this.options.defaultScrollbars && this.options.customStyle ) {\r\n\t\t\t\tif ( this.options.listenX ) {\r\n\t\t\t\t\tthis.wrapper.style.right = '2px';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.wrapper.style.bottom = '2px';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar r = this.wrapper.offsetHeight;\t// force refresh\r\n\r\n\t\tif ( this.options.listenX ) {\r\n\t\t\tthis.wrapperWidth = this.wrapper.clientWidth;\r\n\t\t\tif ( this.options.resize ) {\r\n\t\t\t\tthis.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);\r\n\t\t\t\tthis.indicatorStyle.width = this.indicatorWidth + 'px';\r\n\t\t\t} else {\r\n\t\t\t\tthis.indicatorWidth = this.indicator.clientWidth;\r\n\t\t\t}\r\n\r\n\t\t\tthis.maxPosX = this.wrapperWidth - this.indicatorWidth;\r\n\r\n\t\t\tif ( this.options.shrink == 'clip' ) {\r\n\t\t\t\tthis.minBoundaryX = -this.indicatorWidth + 8;\r\n\t\t\t\tthis.maxBoundaryX = this.wrapperWidth - 8;\r\n\t\t\t} else {\r\n\t\t\t\tthis.minBoundaryX = 0;\r\n\t\t\t\tthis.maxBoundaryX = this.maxPosX;\r\n\t\t\t}\r\n\r\n\t\t\tthis.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));\r\n\t\t}\r\n\r\n\t\tif ( this.options.listenY ) {\r\n\t\t\tthis.wrapperHeight = this.wrapper.clientHeight;\r\n\t\t\tif ( this.options.resize ) {\r\n\t\t\t\tthis.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);\r\n\t\t\t\tthis.indicatorStyle.height = this.indicatorHeight + 'px';\r\n\t\t\t} else {\r\n\t\t\t\tthis.indicatorHeight = this.indicator.clientHeight;\r\n\t\t\t}\r\n\r\n\t\t\tthis.maxPosY = this.wrapperHeight - this.indicatorHeight;\r\n\r\n\t\t\tif ( this.options.shrink == 'clip' ) {\r\n\t\t\t\tthis.minBoundaryY = -this.indicatorHeight + 8;\r\n\t\t\t\tthis.maxBoundaryY = this.wrapperHeight - 8;\r\n\t\t\t} else {\r\n\t\t\t\tthis.minBoundaryY = 0;\r\n\t\t\t\tthis.maxBoundaryY = this.maxPosY;\r\n\t\t\t}\r\n\r\n\t\t\tthis.maxPosY = this.wrapperHeight - this.indicatorHeight;\r\n\t\t\tthis.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));\r\n\t\t}\r\n\r\n\t\tthis.updatePosition();\r\n\t},\r\n\r\n\tupdatePosition: function () {\r\n\t\tvar x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,\r\n\t\t\ty = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;\r\n\r\n\t\tif ( !this.options.ignoreBoundaries ) {\r\n\t\t\tif ( x < this.minBoundaryX ) {\r\n\t\t\t\tif ( this.options.shrink == 'scale' ) {\r\n\t\t\t\t\tthis.width = Math.max(this.indicatorWidth + x, 8);\r\n\t\t\t\t\tthis.indicatorStyle.width = this.width + 'px';\r\n\t\t\t\t}\r\n\t\t\t\tx = this.minBoundaryX;\r\n\t\t\t} else if ( x > this.maxBoundaryX ) {\r\n\t\t\t\tif ( this.options.shrink == 'scale' ) {\r\n\t\t\t\t\tthis.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);\r\n\t\t\t\t\tthis.indicatorStyle.width = this.width + 'px';\r\n\t\t\t\t\tx = this.maxPosX + this.indicatorWidth - this.width;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tx = this.maxBoundaryX;\r\n\t\t\t\t}\r\n\t\t\t} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {\r\n\t\t\t\tthis.width = this.indicatorWidth;\r\n\t\t\t\tthis.indicatorStyle.width = this.width + 'px';\r\n\t\t\t}\r\n\r\n\t\t\tif ( y < this.minBoundaryY ) {\r\n\t\t\t\tif ( this.options.shrink == 'scale' ) {\r\n\t\t\t\t\tthis.height = Math.max(this.indicatorHeight + y * 3, 8);\r\n\t\t\t\t\tthis.indicatorStyle.height = this.height + 'px';\r\n\t\t\t\t}\r\n\t\t\t\ty = this.minBoundaryY;\r\n\t\t\t} else if ( y > this.maxBoundaryY ) {\r\n\t\t\t\tif ( this.options.shrink == 'scale' ) {\r\n\t\t\t\t\tthis.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);\r\n\t\t\t\t\tthis.indicatorStyle.height = this.height + 'px';\r\n\t\t\t\t\ty = this.maxPosY + this.indicatorHeight - this.height;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ty = this.maxBoundaryY;\r\n\t\t\t\t}\r\n\t\t\t} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {\r\n\t\t\t\tthis.height = this.indicatorHeight;\r\n\t\t\t\tthis.indicatorStyle.height = this.height + 'px';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\tif ( this.scroller.options.useTransform ) {\r\n\t\t\tthis.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;\r\n\t\t} else {\r\n\t\t\tthis.indicatorStyle.left = x + 'px';\r\n\t\t\tthis.indicatorStyle.top = y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_pos: function (x, y) {\r\n\t\tif ( x < 0 ) {\r\n\t\t\tx = 0;\r\n\t\t} else if ( x > this.maxPosX ) {\r\n\t\t\tx = this.maxPosX;\r\n\t\t}\r\n\r\n\t\tif ( y < 0 ) {\r\n\t\t\ty = 0;\r\n\t\t} else if ( y > this.maxPosY ) {\r\n\t\t\ty = this.maxPosY;\r\n\t\t}\r\n\r\n\t\tx = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;\r\n\t\ty = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;\r\n\r\n\t\tthis.scroller.scrollTo(x, y);\r\n\t},\r\n\r\n\tfade: function (val, hold) {\r\n\t\tif ( hold && !this.visible ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tclearTimeout(this.fadeTimeout);\r\n\t\tthis.fadeTimeout = null;\r\n\r\n\t\tvar time = val ? 250 : 500,\r\n\t\t\tdelay = val ? 0 : 300;\r\n\r\n\t\tval = val ? '1' : '0';\r\n\r\n\t\tthis.wrapperStyle[utils.style.transitionDuration] = time + 'ms';\r\n\r\n\t\tthis.fadeTimeout = setTimeout((function (val) {\r\n\t\t\tthis.wrapperStyle.opacity = val;\r\n\t\t\tthis.visible = +val;\r\n\t\t}).bind(this, val), delay);\r\n\t}\r\n};\r\n\r\nIScroll.utils = utils;\r\n\r\nif ( typeof module != 'undefined' && module.exports ) {\r\n\tmodule.exports = IScroll;\r\n} else if ( typeof define == 'function' && define.amd ) {\r\n        define( 'iscroll',[],function () { return IScroll; } );\r\n} else {\r\n\twindow.IScroll = IScroll;\r\n}\r\n\r\n})(window, document, Math);\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/iscroll.js"),
eval("define('components/ScrollContainer',['jquery',\r\n    'components/Element',\r\n    'data/config-symbolSet',\r\n    'services/dimensions',\r\n    'services/i18n',\r\n    'services/assets',\r\n    'services/format',\r\n    'iscroll',\r\n], function ($, Element, symbolSet, dimensions, i18n, assets, format, IScroll) {\r\n    return function create(options) {\r\n\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'ScrollContainer';\r\n        self.interactive = true;\r\n        self.content = options.content;\r\n        self.innerHeight = options.innerHeight;\r\n\r\n        self.jQueryEl = $('<div class=scroll-container>'\r\n                + '<div class=scroll-container-inner>' + '</div></div>');\r\n        var $inner = self.jQueryEl.find('.scroll-container-inner');\r\n\r\n        var scroll = new IScroll(self.jQueryEl[0], {\r\n            scrollbars: 'custom',\r\n            useTransform: false,\r\n            useTransition: false,\r\n            resizeScrollbars: false\r\n        });\r\n\r\n        self.jQueryEl.wrapper = self;\r\n        self.contentWrapper = $inner;\r\n        self.appendHTML();\r\n\r\n        var superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            superShow.apply(null, arguments);\r\n            $inner.height(self.innerHeight);\r\n            scroll.refresh();\r\n        };\r\n\r\n        var superResize = self.resize.bind(self);\r\n        self.resize = function () {\r\n            superResize.apply(null, arguments);\r\n            $inner.height(self.innerHeight);\r\n            scroll.refresh();\r\n        };\r\n\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/ScrollContainer.js"),eval("// menuPage2View\r\n// contains elements for AUTOPLAY page in game menu\r\ndefine('layers/menuPage2/menuPage2View',[\r\n    'data/config',\r\n    'data/config-menu',\r\n    'data/config-menuPage2',\r\n    'components/RangeSlider',\r\n    'components/Text',\r\n    'components/ScrollContainer',\r\n], function (globalConfig, menuConfig, config, RangeSlider, Text, ScrollContainer) {\r\n\r\n    return function mCreate(ctrl, contentParent) {\r\n        var elements = {};\r\n        elements.header = Text({\r\n            name: 'menu-autoplay-header',\r\n            parent: contentParent,\r\n            groupCtrl: ctrl,\r\n            left: menuConfig.MENU_LEFT_HEADER_LEFT,\r\n            top: menuConfig.MENU_HEADER_TOP,\r\n            text: 'autoplaySettings',\r\n            fontSize: menuConfig.MENU_HEADER_FONT_SIZE,\r\n            originX: 'left',\r\n            zIndex: 22,\r\n            style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n            canvasLayer: 'ui',\r\n        });\r\n        elements.scrollContainer = ScrollContainer({\r\n            name: 'menu-autoplay-scroll-container',\r\n            parent: contentParent,\r\n            groupCtrl: ctrl,\r\n            left: menuConfig.SCROLL_CONTAINER_LEFT,\r\n            top: menuConfig.SCROLL_CONTAINER_TOP,\r\n            width: menuConfig.SCROLL_CONTAINER_WIDTH,\r\n            height: menuConfig.SCROLL_CONTAINER_HEIGHT,\r\n            innerHeight: menuConfig.SCROLL_CONTAINER_HEIGHT * 1.3,\r\n        });\r\n        elements.roundsLabel = Text({\r\n            name: 'menu-autoplay-rounds-label',\r\n            groupCtrl: ctrl,\r\n            left: config.LEVEL_1_LEFT,\r\n            top: config.LINE_1_TOP,\r\n            text: 'rounds',\r\n            fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n            style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.stopAutoplayWhenLabel = Text({\r\n            name: 'menu-autoplay-stop-autoplay-when-label',\r\n            groupCtrl: ctrl,\r\n            left: config.STOP_AUTOPLAY_LABEL_LEFT,\r\n            top: config.LINE_2_TOP,\r\n            text: 'stopAutoplayWhen',\r\n            fontSize: config.STOP_AUTOPLAY_LABEL_FONT_SIZE,\r\n            style: globalConfig.MENU_SECONDARY_TEXT_STYLE,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.timeHasPassedLabel = Text({\r\n            name: 'menu-autoplay-time-has-passed-label',\r\n            groupCtrl: ctrl,\r\n            left: config.LEVEL_1_LEFT,\r\n            top: config.LINE_3_TOP,\r\n            text: 'timeHasPassed',\r\n            fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n            style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.winExceedsLabel = Text({\r\n            name: 'menu-autoplay-win-exceeds-label',\r\n            groupCtrl: ctrl,\r\n            left: config.LEVEL_1_LEFT,\r\n            top: config.LINE_4_TOP,\r\n            text: 'winExceeds',\r\n            fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n            style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.balanceDecByLabel = Text({\r\n            name: 'menu-autoplay-bal-dec-by-label',\r\n            groupCtrl: ctrl,\r\n            left: config.LEVEL_1_LEFT,\r\n            top: config.LINE_5_TOP,\r\n            text: 'balanceDecBy',\r\n            fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n            style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.balanceIncByLabel = Text({\r\n            name: 'menu-autoplay-bal-inc-by-label',\r\n            groupCtrl: ctrl,\r\n            left: config.LEVEL_1_LEFT,\r\n            top: config.LINE_6_TOP,\r\n            text: 'balanceIncBy',\r\n            fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n            style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.roundsSlider = RangeSlider({\r\n            name: 'menu-autoplay-rounds-slider',\r\n            groupCtrl: ctrl,\r\n            left: config.SLIDER_LEFT,\r\n            top: config.LINE_1_TOP\r\n                    + config.SLIDER_OFFSET_TOP,\r\n            value: 0,\r\n            values: menuConfig.AUTOPLAY_ROUNDS_CYCLE_BUTTON_ITEMS,\r\n            offStateAvailable: true,\r\n            onChange: ctrl.viewActions.roundsChanged,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.timePassedSlider = RangeSlider({\r\n            name: 'menu-autoplay-time-passed-slider',\r\n            groupCtrl: ctrl,\r\n            left: config.SLIDER_LEFT,\r\n            top: config.LINE_3_TOP\r\n                    + config.SLIDER_OFFSET_TOP,\r\n            value: 0,\r\n            values: menuConfig.AUTOPLAY_TIME_PASSED_CYCLE_BUTTON_ITEMS,\r\n            suffix: ['! ', 'min'],\r\n            showPrefixSuffixOnSides: true,\r\n            offStateAvailable: true,\r\n            onChange: ctrl.viewActions.timePassedChanged,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.winExceedsSlider = RangeSlider({\r\n            name: 'menu-autoplay-win-exceeds-slider',\r\n            groupCtrl: ctrl,\r\n            left: config.SLIDER_LEFT,\r\n            top: config.LINE_4_TOP\r\n                    + config.SLIDER_OFFSET_TOP,\r\n            value: 0,\r\n            values: menuConfig.AUTOPLAY_WIN_EXCEEDS_CYCLE_BUTTON_ITEMS,\r\n            suffix: ['! ', 'bets'],\r\n            showPrefixSuffixOnSides: true,\r\n            offStateAvailable: true,\r\n            onChange: ctrl.viewActions.winExceedsChanged,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.balanceDecBySlider = RangeSlider({\r\n            name: 'menu-autoplay-balance-dec-by-slider',\r\n            groupCtrl: ctrl,\r\n            left: config.SLIDER_LEFT,\r\n            top: config.LINE_5_TOP\r\n                    + config.SLIDER_OFFSET_TOP,\r\n            value: 0,\r\n            values: menuConfig.AUTOPLAY_BALANCE_DEC_BY_CYCLE_BUTTON_ITEMS,\r\n            suffix: '%',\r\n            showPrefixSuffixOnSides: true,\r\n            offStateAvailable: true,\r\n            onChange: ctrl.viewActions.balanceDecChanged,\r\n            domContainerParent: elements.scrollContainer,\r\n        });\r\n        elements.balanceIncBySlider = RangeSlider({\r\n            name: 'menu-autoplay-balance-inc-by-slider',\r\n            groupCtrl: ctrl,\r\n            left: config.SLIDER_LEFT,\r\n            top: config.LINE_6_TOP\r\n                    + config.SLIDER_OFFSET_TOP,\r\n            value: 0,\r\n            values: menuConfig.AUTOPLAY_BALANCE_INC_BY_CYCLE_BUTTON_ITEMS,\r\n            prefix: 'X',\r\n            showPrefixSuffixOnSides: true,\r\n            offStateAvailable: true,\r\n            domContainerParent: elements.scrollContainer,\r\n            onChange: ctrl.viewActions.balanceIncChanged,\r\n        });\r\n\r\n        contentParent.addChildren(elements);\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n            }\r\n        };\r\n\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage2/menuPage2View.js"),eval("// menuPage1Ctrl\r\n// controls the second (AUTOPLAY) page of game menu\r\n// modifies the settings model according to user actions\r\ndefine('layers/menuPage2/menuPage2Ctrl',[\r\n    'pubsub',\r\n    'components/GroupCtrl',\r\n    'layers/menuPage2/menuPage2View',\r\n    'layers/menu/menuCtrl',\r\n    'services/settings',\r\n], function (pubsub, GroupCtrl, menuPage2View, menuCtrl, settings) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var model = null;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        roundsChanged: function (val, selectedIndex) {\r\n            if (selectedIndex === 0) {\r\n                model.rounds.active = false;\r\n            } else {\r\n                model.rounds.active = true;\r\n            }\r\n            model.rounds.selectedIndex = selectedIndex;\r\n        },\r\n        timePassedChanged: function (val, selectedIndex) {\r\n            if (selectedIndex === 0) {\r\n                model.timePassed.active = false;\r\n            } else {\r\n                model.timePassed.active = true;\r\n            }\r\n            model.timePassed.selectedIndex = selectedIndex;\r\n        },\r\n        winExceedsChanged: function (val, selectedIndex) {\r\n            if (selectedIndex === 0) {\r\n                model.winExceeds.active = false;\r\n            } else {\r\n                model.winExceeds.active = true;\r\n            }\r\n            model.winExceeds.selectedIndex = selectedIndex;\r\n        },\r\n        balanceDecChanged: function (val, selectedIndex) {\r\n            if (selectedIndex === 0) {\r\n                model.balanceDecBy.active = false;\r\n            } else {\r\n                model.balanceDecBy.active = true;\r\n            }\r\n            model.balanceDecBy.selectedIndex = selectedIndex;\r\n        },\r\n        balanceIncChanged: function (val, selectedIndex) {\r\n            if (selectedIndex === 0) {\r\n                model.balanceIncBy.active = false;\r\n            } else {\r\n                model.balanceIncBy.active = true;\r\n            }\r\n            model.balanceIncBy.selectedIndex = selectedIndex;\r\n        },\r\n    };\r\n\r\n    // initialize view\r\n    self.view = menuPage2View(self, menuCtrl.view.elements.container.jQueryEl[1]);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initMenuViews': function (id, data) {\r\n            model = data.model.autoplay;\r\n            updateView();\r\n        },\r\n        'request:showMenuPage2': function (id, data) {\r\n            self.showAll();\r\n        },\r\n        'request:hideMenuPages': function (id, data) {\r\n            self.hideAll();\r\n        },\r\n    });\r\n\r\n    return self;\r\n\r\n    // helpers\r\n\r\n    function updateView() {\r\n        self.view.elements.roundsSlider.setSelectedIndex(model.rounds.selectedIndex);\r\n        self.view.elements.timePassedSlider.setSelectedIndex(model.timePassed.selectedIndex);\r\n        self.view.elements.winExceedsSlider.setSelectedIndex(model.winExceeds.selectedIndex);\r\n        self.view.elements.balanceDecBySlider.setSelectedIndex(model.balanceDecBy.selectedIndex);\r\n        self.view.elements.balanceIncBySlider.setSelectedIndex(model.balanceIncBy.selectedIndex);\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage2/menuPage2Ctrl.js"),eval("define('data/config-menuPage3',{\r\n    LINE_1_TOP: 212,\r\n    TOGGLABLES_LEFT: 497.5,\r\n    FLIPSWITCH_OFFSET_TOP: -19,\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-menuPage3.js"),eval("// menuPage3View\r\n// contains GRAPHICS menu page elements\r\ndefine('layers/menuPage3/menuPage3View',[\r\n    'data/config',\r\n    'data/config-menu',\r\n    'data/config-menuPage3',\r\n    'components/FlipSwitch',\r\n    'components/Text'\r\n], function (globalConfig, menuConfig, config,\r\n        FlipSwitch, Text) {\r\n\r\n    return function mCreate(ctrl, contentParent) {\r\n        var elements = {\r\n            header: Text({\r\n                name: 'menu-graphics-header',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_LEFT_HEADER_LEFT,\r\n                top: menuConfig.MENU_HEADER_TOP,\r\n                text: 'graphicsSettings',\r\n                fontSize: menuConfig.MENU_HEADER_FONT_SIZE,\r\n                originX: 'left',\r\n                zIndex: 22,\r\n                style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            leftHandLabel: Text({\r\n                name: 'menu-graphics-lefthand-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + menuConfig.LEVEL_1_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_1_TOP,\r\n                text: 'leftHandMode',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                zIndex: 22,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            leftHandFlipSwitch: FlipSwitch({\r\n                name: 'menu-graphics-lefthand-switch',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.TOGGLABLES_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_1_TOP\r\n                        + config.FLIPSWITCH_OFFSET_TOP,\r\n                leftText: 'off',\r\n                rightText: 'on',\r\n                fontSize: 30,\r\n                onChange: ctrl.viewActions.leftHandFlipSwitchChanged,\r\n            }),\r\n        };\r\n\r\n        contentParent.addChildren(elements);\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n            }\r\n        };\r\n\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage3/menuPage3View.js"),eval("// menuPage3Ctrl\r\n// controls GRAPHICS menu page\r\n// updates settings model according to user actions\r\ndefine('layers/menuPage3/menuPage3Ctrl',[\r\n    'pubsub',\r\n    'components/GroupCtrl',\r\n    'layers/menuPage3/menuPage3View',\r\n    'layers/menu/menuCtrl',\r\n    'data/config-menu',\r\n    'services/settings',\r\n], function (pubsub, GroupCtrl, menuPage3View, menuCtrl, menuConfig, settings) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var model = null;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        leftHandFlipSwitchChanged: function (activeBtn) {\r\n            model.lefthand = activeBtn === 'right';\r\n            pubsub.publish('request:resize');\r\n            settings.save();\r\n        },\r\n    };\r\n\r\n    // initialize view\r\n    self.view = menuPage3View(self, menuCtrl.view.elements.container.jQueryEl[1]);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initMenuViews': function (id, data) {\r\n            model = data.model.graphics;\r\n            updateView();\r\n        },\r\n        'request:showMenuPage3': function (id, data) {\r\n            self.showAll();\r\n        },\r\n        'request:hideMenuPages': function (id, data) {\r\n            self.hideAll();\r\n        },\r\n    });\r\n\r\n    return self;\r\n\r\n\r\n    function updateView() {\r\n        self.view.elements.leftHandFlipSwitch.setActiveBtn(model.lefthand ? 'right' : 'left');\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage3/menuPage3Ctrl.js"),eval("define('data/config-menuPage4',{\r\n    LABELS_LEFT: 50,\r\n    LINE_1_TOP: 100,\r\n    LINE_2_TOP: 214,\r\n    LINE_3_TOP: 328,\r\n    SLIDER_LEFT: 440,\r\n    SLIDER_OFFSET_TOP: -26,\r\n    FLIPSWITCH_LEFT: 238,\r\n    FLIPSWITCH_OFFSET_TOP: -19,\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-menuPage4.js"),eval("// menuPage4View\r\n// contains elements for SOUND menu page\r\ndefine('layers/menuPage4/menuPage4View',[\r\n    'data/config',\r\n    'data/config-menu',\r\n    'data/config-menuPage4',\r\n    'components/FlipSwitch',\r\n    'components/Text',\r\n    'components/RangeSlider'\r\n], function (globalConfig, menuConfig, config,\r\n        FlipSwitch, Text, RangeSlider) {\r\n\r\n    return function mCreate(ctrl, contentParent) {\r\n        var elements = {\r\n            header: Text({\r\n                name: 'menu-sound-header',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_LEFT_HEADER_LEFT,\r\n                top: menuConfig.MENU_HEADER_TOP,\r\n                text: 'soundSettings',\r\n                fontSize: menuConfig.MENU_HEADER_FONT_SIZE,\r\n                originX: 'left',\r\n                style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            masterVolumeLabel: Text({\r\n                name: 'menu-sound-master-volume-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.LABELS_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_1_TOP,\r\n                text: 'masterSoundVolume',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            effectsVolumeLabel: Text({\r\n                name: 'menu-sound-effects-volume-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.LABELS_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_2_TOP,\r\n                text: 'effectsSoundVolume',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            backgroundVolumeLabel: Text({\r\n                name: 'menu-sound-background-volume-label',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.LABELS_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_3_TOP,\r\n                text: 'backgroundVolume',\r\n                fontSize: menuConfig.LEVEL_1_FONT_SIZE,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n            }),\r\n            masterFlipSwitch: FlipSwitch({\r\n                name: 'menu-sound-master-switch',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.FLIPSWITCH_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_1_TOP\r\n                        + config.FLIPSWITCH_OFFSET_TOP,\r\n                leftText: 'off',\r\n                rightText: 'on',\r\n                fontSize: 30,\r\n                disableSelfUpdate: true,\r\n                onChange: ctrl.viewActions.masterFlipSwitchChanged,\r\n            }),\r\n            effectsFlipSwitch: FlipSwitch({\r\n                name: 'menu-sound-effects-switch',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.FLIPSWITCH_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_2_TOP\r\n                        + config.FLIPSWITCH_OFFSET_TOP,\r\n                leftText: 'off',\r\n                rightText: 'on',\r\n                fontSize: 30,\r\n                disableSelfUpdate: true,\r\n                onChange: ctrl.viewActions.effectsFlipSwitchChanged,\r\n            }),\r\n            backgroundFlipSwitch: FlipSwitch({\r\n                name: 'menu-sound-background-switch',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.FLIPSWITCH_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_3_TOP\r\n                        + config.FLIPSWITCH_OFFSET_TOP,\r\n                leftText: 'off',\r\n                rightText: 'on',\r\n                fontSize: 30,\r\n                disableSelfUpdate: true,\r\n                onChange: ctrl.viewActions.backgroundFlipSwitchChanged,\r\n            }),\r\n            masterSoundSlider: RangeSlider({\r\n                name: 'menu-sound-master-slider',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.SLIDER_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_1_TOP\r\n                        + config.SLIDER_OFFSET_TOP,\r\n                width: menuConfig.SLIDER_WIDTH,\r\n                height: menuConfig.SLIDER_HEIGHT,\r\n                buttonWidth: menuConfig.SLIDER_BUTTON_WIDTH,\r\n                buttonHeight: menuConfig.SLIDER_BUTTON_HEIGHT,\r\n                backHeight: menuConfig.SLIDER_BACK_HEIGHT,\r\n                value: 0,\r\n                fontSize: menuConfig.SLIDER_FONT_SIZE,\r\n                zIndex: 22,\r\n                onChange: ctrl.viewActions.masterVolumeChanged,\r\n                roundPercent: true,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            effectsSlider: RangeSlider({\r\n                name: 'menu-sound-efects-slider',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.SLIDER_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_2_TOP\r\n                        + config.SLIDER_OFFSET_TOP,\r\n                width: menuConfig.SLIDER_WIDTH,\r\n                height: menuConfig.SLIDER_HEIGHT,\r\n                buttonWidth: menuConfig.SLIDER_BUTTON_WIDTH,\r\n                buttonHeight: menuConfig.SLIDER_BUTTON_HEIGHT,\r\n                backHeight: menuConfig.SLIDER_BACK_HEIGHT,\r\n                value: 0,\r\n                fontSize: menuConfig.SLIDER_FONT_SIZE,\r\n                zIndex: 22,\r\n                onChange: ctrl.viewActions.effectsVolumeChanged,\r\n                roundPercent: true,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            backgroundSlider: RangeSlider({\r\n                name: 'menu-sound-background-slider',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_CONTENTS_LEFT\r\n                        + config.SLIDER_LEFT,\r\n                top: menuConfig.MENU_CONTENTS_TOP\r\n                        + config.LINE_3_TOP\r\n                        + config.SLIDER_OFFSET_TOP,\r\n                width: menuConfig.SLIDER_WIDTH,\r\n                height: menuConfig.SLIDER_HEIGHT,\r\n                buttonWidth: menuConfig.SLIDER_BUTTON_WIDTH,\r\n                buttonHeight: menuConfig.SLIDER_BUTTON_HEIGHT,\r\n                backHeight: menuConfig.SLIDER_BACK_HEIGHT,\r\n                value: 0,\r\n                fontSize: menuConfig.SLIDER_FONT_SIZE,\r\n                zIndex: 22,\r\n                onChange: ctrl.viewActions.backgroundVolumeChanged,\r\n                roundPercent: true,\r\n                style: globalConfig.MENU_PRIMARY_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n        };\r\n\r\n        contentParent.addChildren(elements);\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n            }\r\n        };\r\n\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage4/menuPage4View.js"),eval("// menuPage4Ctrl\r\n// controls SOUND menu page\r\n// publishes user actions so that coreSound can update the settings model\r\ndefine('layers/menuPage4/menuPage4Ctrl',[\r\n    'pubsub',\r\n    'components/GroupCtrl',\r\n    'layers/menuPage4/menuPage4View',\r\n    'services/settings',\r\n    'layers/menu/menuCtrl'\r\n], function (pubsub, GroupCtrl, menuPage4View, settings, menuCtrl) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        masterFlipSwitchChanged: function () {\r\n            pubsub.publish('notify:masterSoundSwitchChanged', {\r\n                callback: function () {\r\n                    updateView();\r\n                }\r\n            });\r\n        },\r\n        effectsFlipSwitchChanged: function () {\r\n            pubsub.publish('notify:effectsSoundSwitchChanged', {\r\n                callback: function () {\r\n                    updateView();\r\n                }\r\n            });\r\n        },\r\n        backgroundFlipSwitchChanged: function () {\r\n            pubsub.publish('notify:backgroundSoundSwitchChanged', {\r\n                callback: function () {\r\n                    updateView();\r\n                }\r\n            });\r\n        },\r\n        masterVolumeChanged: function (value) {\r\n            pubsub.publish('notify:masterVolumeChanged', {\r\n                volume: value\r\n            });\r\n            updateView();\r\n        },\r\n        effectsVolumeChanged: function (value) {\r\n            pubsub.publish('notify:effectsVolumeChanged', {\r\n                volume: value\r\n            });\r\n            updateView();\r\n        },\r\n        backgroundVolumeChanged: function (value) {\r\n            pubsub.publish('notify:backgroundVolumeChanged', {\r\n                volume: value\r\n            });\r\n            updateView();\r\n        }\r\n    };\r\n\r\n    // initialize view\r\n    self.view = menuPage4View(self, menuCtrl.view.elements.container.jQueryEl[1]);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initMenuViews': function (id, data) {\r\n            updateView(data.model.sound);\r\n        },\r\n        'request:showMenuPage4': function (id, data) {\r\n            self.showAll();\r\n        },\r\n        'request:hideMenuPages': function (id, data) {\r\n            self.hideAll();\r\n        },\r\n        'request:updateSoundViews': function (id, data) {\r\n            updateView();\r\n        }\r\n    })\r\n    return self;\r\n\r\n    // helpers\r\n    function updateView(model) {\r\n        if (!model) {\r\n            model = settings.get().sound;\r\n        }\r\n        self.view.elements.masterFlipSwitch.setActiveBtn(model.master.active ? 'right' : 'left');\r\n        self.view.elements.effectsFlipSwitch.setActiveBtn(model.effects.active ? 'right' : 'left');\r\n        self.view.elements.backgroundFlipSwitch.setActiveBtn(model.background.active ? 'right' : 'left');\r\n\r\n        self.view.elements.masterSoundSlider.setValue(model.master.volume);\r\n        self.view.elements.effectsSlider.setValue(model.effects.volume);\r\n        self.view.elements.backgroundSlider.setValue(model.background.volume);\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage4/menuPage4Ctrl.js"),eval("define('data/config-menuPage5',{\r\n\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-menuPage5.js"),eval("define('components/RulesContainer',['jquery',\r\n    'components/Element',\r\n    'data/config-symbolSet',\r\n    'services/dimensions',\r\n    'services/i18n',\r\n    'services/assets',\r\n    'services/format',\r\n    'iscroll',\r\n], function ($, Element, symbolSet, dimensions, i18n, assets, format, IScroll) {\r\n    return function create(options) {\r\n        function resize() {\r\n            var $this, $p, $img, mTop;\r\n            $('#paytable .paytable-section').each(function () {\r\n                $this = $(this);\r\n                $p = $this.find('p');\r\n                $img = $this.find('img');\r\n                mTop = $img.height() / 2\r\n                        - $p.height() / 2;\r\n                if (mTop > 0) {\r\n                    $p.css('margin-top', mTop + 'px');\r\n                }\r\n            });\r\n            $container.find('[data-center=\"true\"]').each(function () {\r\n                $this = $(this);\r\n                $p = $this.parent();\r\n                mTop = $p.height() / 2 - $this.height() / 2;\r\n                $this.css('margin-top', mTop + 'px');\r\n            });\r\n            $inner.css({\r\n                'font-size': (self.fontSize_rules * dimensions.canvasScaleY) + 'px',\r\n            });\r\n            $('#paytable').css({\r\n                'font-size': (self.fontSize_paytable * dimensions.canvasScaleY) + 'px',\r\n                'line-height': (self.fontSize_paytable * dimensions.canvasScaleY) + 'px',\r\n            });\r\n        }\r\n        function drawParagraphs(content) {\r\n            function setContentHTML(container, content) {\r\n                var item, $html, texture, ks, k, c;\r\n                for (c = 0; c < content.length; c++) {\r\n                    $html = null;\r\n                    item = content[c];\r\n                    if (item.type === 'container') {\r\n                        $html = $('<div' + ' style=\"' + item.style + '\"></div>');\r\n                        setContentHTML($html, item.content);\r\n                    }\r\n                    if (item.type === 'header') {\r\n                        $html = $('<h3 style=\"' + item.style + '\">'\r\n                                + i18n.localize(item.text) + '</h3>');\r\n                    }\r\n                    if (item.type === 'text') {\r\n                        $html = $('<p style=\"' + i18n.localize(item.style)\r\n                                + '\">' + i18n.localize(item.text) + '</p>');\r\n                    }\r\n                    if (item.type === 'img') {\r\n                        texture = assets.img(item.src);\r\n                        if (texture) {\r\n                            $html = $('<img' + ' style=\"' + item.style\r\n                                    + '\" src=\"' + texture.baseTexture.imageUrl\r\n                                    + '\"/>');\r\n                        }\r\n                    }\r\n                    if ($html) {\r\n                        if (item.attr) {\r\n                            ks = Object.keys(item.attr);\r\n                            for (k = 0; k < ks.length; k++) {\r\n                                $html.attr('data-' + ks[k], item.attr[ks[k]]);\r\n                            }\r\n                        }\r\n                        container.append($html);\r\n                    }\r\n                }\r\n            }\r\n            var $e, i;\r\n            self.content = content;\r\n            $inner.empty();\r\n            for (i = 0; i < self.content.length; i++) {\r\n                $e = $('<div class=rules-section></div>');\r\n                setContentHTML($e, self.content[i]);\r\n                $inner.append($e);\r\n            }\r\n        }\r\n\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'RulesContainer';\r\n        self.fontSize_rules = options.fontSize_rules;\r\n        self.fontSize_paytable = options.fontSize_paytable;\r\n        self.paytableCountValues = options.paytableCountValues;\r\n        self.interactive = true;\r\n\r\n        self.jQueryEl = options.domElement;\r\n        var $container = self.jQueryEl;\r\n        $container.append('<div class=gradient-overlay></div>'\r\n                + '<div class=scroller><div class=inner></div></div>');\r\n        var $scroller = $container.find('.scroller');\r\n        var $inner = $scroller.find('.inner');\r\n\r\n        drawParagraphs(options.content);\r\n\r\n        var scroll = new IScroll($scroller[0], {\r\n            scrollbars: 'custom',\r\n            useTransform: true,\r\n            useTransition: true,\r\n            resizeScrollbars: false\r\n        });\r\n\r\n        $container.css({\r\n            width: self.width,\r\n            height: self.height,\r\n            originX: self.originX,\r\n            'z-index': self.zIndex,\r\n            display: 'none'\r\n        });\r\n\r\n        $container.wrapper = self;\r\n\r\n\r\n        var superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            superShow.apply(null, arguments);\r\n            resize();\r\n            scroll.refresh();\r\n        };\r\n        var superResize = self.resize.bind(self);\r\n        self.resize = function () {\r\n            function mResize() {\r\n                resize();\r\n                $scroller.height($container.height());\r\n                $scroller.width($container.width());\r\n                scroll.refresh();\r\n            }\r\n            superResize.apply(null, arguments);\r\n            mResize();\r\n        };\r\n\r\n        self.drawParagraphs = drawParagraphs;\r\n\r\n        self.drawPaytable = function (data) {\r\n            function drawItem(item) {\r\n                var $e, $p, symbolData, symPaytableData, countMax, label,\r\n                        appendedCount;\r\n                symbolData = symbolSet.SPIN.symbols[item.icon_number - 1];\r\n                symPaytableData = self.paytableCountValues[item.icon_number - 1];\r\n                if (symbolData && symPaytableData) {\r\n                    if (typeof (symPaytableData) === 'object') {\r\n                        countMax = symPaytableData.count;\r\n                        label = symPaytableData.label;\r\n                    } else {\r\n                        countMax = symPaytableData;\r\n                        label = null;\r\n                    }\r\n                    if (countMax) {\r\n                        $e = $('<div class=paytable-section>'\r\n                                + '<img src=\"' + assets.img(symbolData.static)\r\n                                .baseTexture.imageUrl + '\"></img></div>');\r\n                        $p = $('<p></p>');\r\n                        if (label) {\r\n                            $p.append('<div class=paytable-label><span>'\r\n                                    + i18n.localize(label) + '</span></div>');\r\n                        }\r\n                        appendedCount = 0;\r\n                        for (var k = 0; k < item.wins.length; k++) {\r\n                            if (item.wins[k] && item.wins[k].win) {\r\n                                $p.append('<div><span class=paytable-count-val>'\r\n                                        + (countMax - appendedCount)\r\n                                        + 'x</span><span class=paytable-pay-val>'\r\n                                        + format.formatAmountWithDenom(item.wins[k].win)\r\n                                        + '</span></div>');\r\n                                appendedCount += 1;\r\n                            }\r\n                        }\r\n                        $e.append($p);\r\n                        return $e;\r\n                    }\r\n                }\r\n            }\r\n\r\n            $('#paytable').remove();\r\n            var item;\r\n            if (data) {\r\n                var $tableContainer = $('<div id=paytable></div>');\r\n                var sections = [];\r\n                var $row;\r\n                for (var m = 0; m < data.length; m++) {\r\n                    item = drawItem(data[m]);\r\n                    item && sections.push(item);\r\n                }\r\n                for (var m = 0; m < sections.length; m += 2) {\r\n                    $row = $('<div class=paytable-row></div>');\r\n                    $row.append(sections[m]);\r\n                    sections[m + 1] && ($row.append(sections[m + 1]));\r\n                    $tableContainer.append($row);\r\n                }\r\n                $inner.prepend($tableContainer);\r\n                scroll.refresh();\r\n            }\r\n        };\r\n\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/RulesContainer.js"),
eval("// menuPage5View\r\n// contains elements for paytable menu page\r\ndefine('layers/menuPage5/menuPage5View',[\r\n    'jquery',\r\n    'data/config-menuPage5',\r\n    'data/config-menu',\r\n    'data/config',\r\n    'components/RulesContainer',\r\n    'components/Text',\r\n], function ($, config, menuConfig, globalConfig, RulesContainer, Text) {\r\n\r\n    return function mCreate(ctrl, parent) {\r\n        var elements = {\r\n            header: Text({\r\n                name: 'menu-rules-header',\r\n                groupCtrl: ctrl,\r\n                parent: parent,\r\n                left: menuConfig.MENU_LEFT_HEADER_LEFT,\r\n                top: menuConfig.MENU_HEADER_TOP,\r\n                text: 'paytableRules',\r\n                fontSize: menuConfig.MENU_HEADER_FONT_SIZE,\r\n                originX: 'left',\r\n                zIndex: 22,\r\n//                scaleX: .9,\r\n                style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            rulesContainer: RulesContainer({\r\n                name: 'rules-container',\r\n                groupCtrl: ctrl,\r\n                parent: parent,\r\n                left: menuConfig.RULES_CONTAINER_LEFT,\r\n                top: menuConfig.RULES_CONTAINER_TOP,\r\n                width: menuConfig.RULES_CONTAINER_WIDTH,\r\n                height: menuConfig.RULES_CONTAINER_HEIGHT,\r\n                content: menuConfig.RULES_CONTENTS,\r\n                paytableCountValues: menuConfig.PAYTABLE_ICON_COUNT_VALUES,\r\n                fontSize_rules: menuConfig.FONT_SIZE_RULES,\r\n                fontSize_paytable: menuConfig.FONT_SIZE_PAYTABLE,\r\n                domElement: $('#rules-container'),\r\n                zIndex: 460,\r\n            })\r\n        };\r\n\r\n        parent.addChildren(elements);\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n            }\r\n        };\r\n\r\n\r\n\r\n\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage5/menuPage5View.js"),eval("// menuPage5Ctrl\r\n// controls PAYTABLE menu page\r\ndefine('layers/menuPage5/menuPage5Ctrl',[\r\n    'pubsub',\r\n    'data/config-menu',\r\n    'components/GroupCtrl',\r\n    'layers/menuPage5/menuPage5View',\r\n    'layers/menu/menuCtrl'\r\n], function (pubsub, menuConfig, GroupCtrl, menuPage5View, menuCtrl) {\r\n    function adjustPaytableItems(serverData) {\r\n        var table = serverData.slice();\r\n        if (menuConfig.SKIP_RTL_PAYTABLE_VALUES) {\r\n            for (var i = 0; i < table.length; i++) {\r\n                for (var w = 1; w < table[i].wins.length; w++) {\r\n                    if (w % 2 === 0) {\r\n                        table[i].wins[w] = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return table;\r\n    }\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n//    var pageVisible = false;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n    };\r\n\r\n    // initialize view\r\n    self.view = menuPage5View(self, menuCtrl.view.elements.container.jQueryEl[1]);\r\n\r\n    self.update = self.view.actions.update;\r\n\r\n    var paytableData = null;\r\n    var lastUpdateData = null;\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:updatePaytable': function (id, data) {\r\n            paytableData = data;\r\n            if (self.view.elements.rulesContainer.visible) {\r\n                self.view.elements.rulesContainer.drawPaytable(adjustPaytableItems\r\n                        (paytableData.items));\r\n            }\r\n        },\r\n        'notify:cashCreditsFlipSwitchChanged': function (id, data) {\r\n            lastUpdateData = null;\r\n        },\r\n        'request:showMenuPage5': function (id, data) {\r\n            if (paytableData !== lastUpdateData) {\r\n                lastUpdateData = paytableData;\r\n                self.view.elements.rulesContainer.drawPaytable(adjustPaytableItems\r\n                        (paytableData.items));\r\n            }\r\n            self.showAll();\r\n        },\r\n        'request:hideMenuPages': function (id, data) {\r\n            self.hideAll();\r\n        },\r\n    });\r\n    return self;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage5/menuPage5Ctrl.js"),eval("define('data/config-menuPage6',{\r\n    CYCLE_BUTTON_LEFT: 35,\r\n    CYCLE_BUTTON_OFFSET_TOP: 70,\r\n    CYCLE_BUTTON_FONT_SIZE: 28.5,\r\n    LANG_CYCLE_BUTTON_WIDTH: 770,\r\n    LANG_CYCLE_BUTTON_HEIGHT: 379,\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-menuPage6.js"),eval("define('components/LanguageCycleButton',[\r\n    'jquery',\r\n    'iscroll',\r\n    'components/Element',\r\n    'services/assets',\r\n], function (\r\n        $, IScroll, Element, assets) {\r\n\r\n    // cycle button allows the user to cycle between multiple values\r\n    // used in game menu\r\n    return function create(options) {\r\n\r\n        function createSlider() {\r\n            var i, slide;\r\n            var container = self.jQueryEl;\r\n            var gradientOverlay = $('<div class=\"gradient-overlay\">');\r\n            var inner = $('<div class=\"inner\">');\r\n            var scroller = $('<div class=\"slider-scroller\">');\r\n            container.css('z-index', self.zIndex);\r\n            for (i = 0; i < self.items.length; i++) {\r\n                slide = $('<div class=\"slider-slide\" data-id=' + i + '>'\r\n                        + '<img src=\"' + assets.img(self.items[i].flag)\r\n                        .baseTexture.imageUrl + '\"/>'\r\n                        + '<div>' + self.items[i].localizedLabel + '</div>'\r\n                        + '</div>');\r\n                scroller.append(slide);\r\n                slide.on('sliderTap', function () {\r\n                    self.setSelectedIndex(Number($(this).attr('data-id')));\r\n                    self.onChange(self.selectedItem);\r\n                });\r\n            }\r\n\r\n            inner.append(scroller);\r\n            container.append(gradientOverlay);\r\n            container.append(inner);\r\n\r\n            self.scroll = new IScroll(inner[0], {\r\n                scrollbars: 'custom',\r\n                resizeScrollbars: false,\r\n                scrollX: true,\r\n                scrollY: false,\r\n                tap: 'sliderTap',\r\n            });\r\n            return container;\r\n        }\r\n\r\n        // initialize\r\n        var self = Element(options);\r\n        var $scroller;\r\n        var $slides;\r\n        var $scrolbar;\r\n        var slideW, containerW;\r\n        self.scroll = null;\r\n\r\n        self.interactive = true;\r\n        self.name = options.name || 'LanguageCycleButton';\r\n        self.items = options.items;\r\n        self.selectedItem = options.selectedItem || 0;\r\n        self.onChange = options.onChange;\r\n        self.fontSize = options.fontSize;\r\n        self.jQueryEl = options.domElement;\r\n\r\n        createSlider();\r\n\r\n        $scroller = self.jQueryEl.find('.slider-scroller');\r\n        $slides = self.jQueryEl.find('.slider-slide');\r\n        $scrolbar = self.jQueryEl.find('.iScrollHorizontalScrollbar');\r\n\r\n//            self.onChange(currentSlide);\r\n\r\n        var superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            superShow.apply(null, arguments);\r\n            self.scroll.refresh();\r\n            self.scroll.scrollTo(-self.selectedItem * slideW, 0, 0);\r\n        };\r\n\r\n        var superResize = self.resize.bind(self);\r\n        self.resize = function () {\r\n            function mResize() {\r\n                containerW = Number(self.jQueryEl.css('width').replace('px', ''));\r\n                slideW = containerW / 3.66;\r\n                var scrollerW = slideW * self.items.length;\r\n                $scroller.css({\r\n                    width: scrollerW + 'px',\r\n                    padding: '0 ' + (containerW / 2 - slideW * .5) + 'px',\r\n                });\r\n                $slides.css({\r\n                    width: slideW + 'px'\r\n                });\r\n                self.scroll.refresh();\r\n                self.scroll.scrollTo(-self.selectedItem * slideW, 0, 0);\r\n            }\r\n            superResize.apply(null, arguments);\r\n            mResize();\r\n        };\r\n\r\n        // set current selected index and refresh view\r\n        self.setSelectedIndex = function (index) {\r\n            self.selectedItem = index;\r\n            $slides.removeClass('selected');\r\n            $slides.filter('[data-id=' + index + ']').addClass('selected');\r\n            self.scroll.scrollTo(-self.selectedItem * slideW, 0, 500);\r\n        };\r\n\r\n        return self;\r\n\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/LanguageCycleButton.js"),eval("// menuPage6View\r\n// contains LOCALE menu page elements\r\ndefine('layers/menuPage6/menuPage6View',[\r\n    'jquery',\r\n    'data/config',\r\n    'data/config-menu',\r\n    'data/config-menuPage6',\r\n    'components/LanguageCycleButton',\r\n    'components/Text'\r\n], function ($, globalConfig, menuConfig, config,\r\n        LanguageCycleButton, Text) {\r\n\r\n    return function mCreate(ctrl, contentParent) {\r\n        var elements = {\r\n            header: Text({\r\n                name: 'menu-locale-header',\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                left: menuConfig.MENU_LEFT_HEADER_LEFT,\r\n                top: menuConfig.MENU_HEADER_TOP,\r\n                text: 'localeSettings',\r\n                fontSize: menuConfig.MENU_HEADER_FONT_SIZE,\r\n                originX: 'left',\r\n                zIndex: 22,\r\n                style: globalConfig.MENU_HEADER_TEXT_STYLE,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            languageCycleButton: LanguageCycleButton({\r\n                groupCtrl: ctrl, parent: contentParent,\r\n                name: 'menu-locale-language-cycle-button',\r\n                left: config.CYCLE_BUTTON_LEFT,\r\n                top: config.CYCLE_BUTTON_OFFSET_TOP,\r\n                width: config.LANG_CYCLE_BUTTON_WIDTH,\r\n                height: config.LANG_CYCLE_BUTTON_HEIGHT,\r\n                fontSize: config.CYCLE_BUTTON_FONT_SIZE,\r\n                items: menuConfig.LANGUAGE_CYCLE_BUTTON_ITEMS,\r\n                onChange: ctrl.viewActions.languageCycleButtonChanged,\r\n                domElement: $('#slider-container'),\r\n                zIndex: 460,\r\n            }),\r\n        };\r\n\r\n        contentParent.addChildren(elements);\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n            }\r\n        };\r\n\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage6/menuPage6View.js"),eval("// menuPage6Ctrl\r\n// controls LOCALE menu page\r\n// updates settings model according to user actions\r\ndefine('layers/menuPage6/menuPage6Ctrl',[\r\n    'pubsub',\r\n    'components/GroupCtrl',\r\n    'layers/menuPage6/menuPage6View',\r\n    'layers/menu/menuCtrl',\r\n    'data/config-menu',\r\n    'services/settings',\r\n], function (pubsub, GroupCtrl, menuPage6View, menuCtrl, menuConfig, settings) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var model = null;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        languageCycleButtonChanged: function (selectedIndex) {\r\n            model.language.selectedIndex = selectedIndex;\r\n            updateView();\r\n            pubsub.publish('notify:languageChanged', {\r\n                lang: menuConfig.LANGUAGE_CYCLE_BUTTON_ITEMS[selectedIndex].label});\r\n            settings.save();\r\n        },\r\n    };\r\n\r\n    // initialize view\r\n    self.view = menuPage6View(self, menuCtrl.view.elements.container.jQueryEl[1]);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initMenuViews': function (id, data) {\r\n            model = data.model.locale;\r\n            updateView();\r\n        },\r\n        'request:showMenuPage6': function (id, data) {\r\n            self.showAll();\r\n        },\r\n        'request:hideMenuPages': function (id, data) {\r\n            self.hideAll();\r\n        },\r\n    });\r\n\r\n    return self;\r\n\r\n\r\n    function updateView() {\r\n        self.view.elements.languageCycleButton.setSelectedIndex(model.language.selectedIndex);\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/menuPage6/menuPage6Ctrl.js"),eval("define('data/config-gambleFrame',{\r\n    GAMBLE_ANIMATION: 'slide',\r\n    GAMBLE_FRAME_LEFT: 0,\r\n    GAMBLE_FRAME_TOP: 0,\r\n    GAMBLE_FRAME_HEIGHT: 649,\r\n    GAMBLE_FRAME_WIDTH: undefined,\r\n    GAMBLE_BG_IMG: 'Cards_gamble/back',\r\n    GAMBLE_AMOUNT_LABEL_TEXT_LEFT: 162,\r\n    GAMBLE_AMOUNT_LABEL_TEXT_TOP: 160,\r\n    GAMBLE_AMOUNT_VALUE_TEXT_LEFT: 295,\r\n    GAMBLE_AMOUNT_VALUE_TEXT_TOP: 200,\r\n    GAMBLE_TO_WIN_LABEL_TEXT_LEFT: 530,\r\n    GAMBLE_TO_WIN_LABEL_TEXT_TOP: 160,\r\n    GAMBLE_TO_WIN_VALUE_TEXT_LEFT: 653,\r\n    GAMBLE_TO_WIN_VALUE_TEXT_TOP: 200,\r\n    CARD_TOP: 230,\r\n    CARD_WIDTH: 129,\r\n    CARD_HEIGHT: 208,\r\n    CARD_1_LEFT: 98,\r\n    CARD_FIRST_OFFSET_LEFT: 28.6,\r\n    CARD_NEXT_OFFSET_LEFT: 7.8,\r\n    GAMBLE_LEFTHAND_OFFSET_LEFT: 67.6,\r\n    VIEW_RESULT_TIMEOUT: 2000,\r\n    BEFORE_FIRST_CARD_FLIP_TIMEOUT: 1000,\r\n    LABELS_FONT_SIZE: 35,\r\n    VALUES_FONT_SIZE: 45,\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-gambleFrame.js"),eval("define('components/FlipCard',[\r\n    'jquery',\r\n    'components/Element',\r\n    'pubsub',\r\n    'services/math',\r\n    'data/config',\r\n    'components/Sprite',\r\n    'services/pause',\r\n], function (\r\n        $, Element, pubsub, math, config, Sprite, pause) {\r\n\r\n    // flippable card element for gamble window\r\n    return function create(options) {\r\n\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'FlipCard';\r\n        // defines the front side card image path\r\n        self.imgPath = options.imgPath;\r\n        // defines current card flip state\r\n        self.flipState = 'back';\r\n        // card click callback\r\n        self.click = options.click;\r\n\r\n        // font side card element\r\n        var frontSideEl = createFrontSideElement();\r\n        // back side card element\r\n        var backSideEl = createBackSideElement();\r\n\r\n        self.pixiEl = [backSideEl, frontSideEl];\r\n\r\n        // override show to display only the element\r\n        // corresponding to current flip state\r\n        self.show = function () {\r\n            self.visible = true;\r\n            if (self.flipState === 'front') {\r\n                frontSideEl.show();\r\n                backSideEl.hide();\r\n            } else {\r\n                backSideEl.show();\r\n                frontSideEl.hide();\r\n            }\r\n        };\r\n        // override fadeIn to display only the element\r\n        // corresponding to current flip state\r\n        self.fadeIn = function () {\r\n            self.visible = true;\r\n            if (self.flipState === 'front') {\r\n                frontSideEl.fadeIn();\r\n            } else {\r\n                backSideEl.fadeIn();\r\n            }\r\n        };\r\n\r\n\r\n        self.clear = function () {\r\n            backSideEl.set({width: self.width,\r\n                left: self.layouts[self.currentLayout].left});\r\n            frontSideEl.set({width: 0, left: self.layouts[self.currentLayout].left\r\n                        + self.width / 2});\r\n            self.flipState = 'back';\r\n        };\r\n        // flip card to specified state\r\n        self.flip = function (flipState, cb) {\r\n            var durationTotal = config.GAMBLE_CARD_FLIP_DURATION / config.GAME_SPEED_MODIFIER;\r\n            if (flipState === 'front' && self.flipState === 'back') {\r\n                self.flipState = 'front';\r\n                animateFlip({\r\n                    elementToShow: frontSideEl,\r\n                    elementToHide: backSideEl,\r\n                    duration: durationTotal,\r\n                    cb: cb\r\n                });\r\n            } else if (flipState === 'back' && self.flipState === 'front') {\r\n                self.flipState = 'back';\r\n                animateFlip({\r\n                    elementToShow: backSideEl,\r\n                    elementToHide: frontSideEl,\r\n                    duration: durationTotal,\r\n                    cb: cb\r\n                });\r\n            }\r\n        };\r\n        // reinitialize card front side element with new image\r\n        self.reinit = function (newPath) {\r\n            self.flipState = 'back';\r\n            backSideEl.set({\r\n                width: self.width,\r\n                left: self.layouts[self.currentLayout].left\r\n            });\r\n            frontSideEl.hide();\r\n            frontSideEl = createFrontSideElement(newPath);\r\n            self.pixiEl = [backSideEl, frontSideEl];\r\n        };\r\n\r\n        var superUpdateLayout = self.updateLayout.bind(self);\r\n        self.updateLayout = function () {\r\n            function mResize() {\r\n                backSideEl.set({left: self.layouts[self.currentLayout].left});\r\n                frontSideEl.set({left: self.layouts[self.currentLayout].left});\r\n            }\r\n            superUpdateLayout.apply(null, arguments);\r\n            mResize();\r\n        };\r\n\r\n        return self;\r\n\r\n        // animate the card flip effect\r\n        function animateFlip(data) {\r\n            var startTime = Date.now();\r\n            var animPosition = 0;\r\n            var animProgress;\r\n            var width;\r\n            var flipInterval = pause.setInterval(function () {\r\n                animProgress = (Date.now() - startTime) / data.duration;\r\n                if (animProgress < 0.5) {\r\n                    // hiding visible side\r\n                    animPosition = math.easeInQuad(animProgress * 2) / 2;\r\n                    width = self.width - (self.width * animPosition * 2);\r\n                    data.elementToHide.set({\r\n                        width: width,\r\n                        left: self.layouts[self.currentLayout].left\r\n                                + (self.width - width) / 2\r\n                    });\r\n                    data.elementToHide.resize();\r\n                } else if (animProgress >= 0.5 && animProgress < 1) {\r\n                    // showing hidden side\r\n                    if (data.elementToHide.visible)\r\n                        data.elementToHide.hide();\r\n                    if (!data.elementToShow.visible)\r\n                        data.elementToShow.show();\r\n                    animPosition = (math.easeOutQuad(\r\n                            (animProgress - 0.5) * 2) / 2) + 0.5;\r\n                    width = self.width - (self.width * (1 - animPosition) * 2);\r\n                    data.elementToShow.set({\r\n                        width: width,\r\n                        left: self.layouts[self.currentLayout].left\r\n                                + (self.width - width) / 2\r\n                    });\r\n                    data.elementToShow.resize();\r\n                } else {\r\n                    // animation complete\r\n                    pause.clearInterval(flipInterval);\r\n                    data.elementToShow.set({\r\n                        width: self.width,\r\n                        left: self.layouts[self.currentLayout].left\r\n                    });\r\n                    data.elementToHide.set({\r\n                        width: 0,\r\n                        left: self.layouts[self.currentLayout].left + self.width / 2\r\n                    });\r\n                    data.elementToHide.hide();\r\n                    data.elementToShow.show();\r\n                    data.elementToShow.resize();\r\n                    data.elementToHide.resize();\r\n                    if (typeof data.cb === 'function') {\r\n                        data.cb();\r\n                    }\r\n                }\r\n            }, 10);\r\n        }\r\n\r\n        // create back card side element\r\n        function createBackSideElement() {\r\n            return Sprite({\r\n                groupCtrl: self.groupCtrl,\r\n                parent: self.parent,\r\n                imgPath: 'Cards_gamble/shirt',\r\n                left: self.layouts[self.currentLayout].left,\r\n                top: self.top,\r\n                width: self.width,\r\n                height: self.height,\r\n                opacity: self.opacity,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex + 0.1,\r\n                mouseOver: function () {\r\n                    if (self.click && self.flipState === 'back') {\r\n                        pubsub.publish('notify:hoverableButtonHoveredIn', {\r\n                            element: backSideEl\r\n                        });\r\n                    }\r\n                },\r\n                mouseOut: function () {\r\n                    pubsub.publish('notify:hoverableButtonHoveredOut', {\r\n                        element: backSideEl\r\n                    });\r\n                },\r\n                click: function () {\r\n                    if (self.click && self.flipState === 'back') {\r\n                        self.click();\r\n                        pubsub.publish('notify:hoverableButtonHoveredOut', {\r\n                            element: backSideEl\r\n                        });\r\n                    }\r\n                },\r\n                hitAreaAdjustment: {\r\n                    top: true,\r\n                    bottom: true,\r\n                },\r\n                canvasLayer: self.canvasLayer,\r\n                shadow: {\r\n                    imgPath: 'Cards_gamble/drop-shadow',\r\n                    offsetX: 6,\r\n                    offsetY: 6,\r\n                    opacity: .85\r\n                }\r\n            });\r\n        }\r\n\r\n        // create front card side element\r\n        function createFrontSideElement(imgPath) {\r\n            var frontLayouts = $.extend(true, {}, self.layouts);\r\n            frontLayouts.righthand.left += self.width / 2;\r\n            frontLayouts.lefthand.left += self.width / 2;\r\n            return Sprite({\r\n                groupCtrl: self.groupCtrl,\r\n                parent: self.parent,\r\n                imgPath: imgPath || 'Cards_gamble/shirt',\r\n                left: self.layouts[self.currentLayout].left,\r\n                top: self.top,\r\n                width: 0,\r\n                height: self.height,\r\n                opacity: self.opacity,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex,\r\n                canvasLayer: self.canvasLayer,\r\n                shadow: {\r\n                    imgPath: 'Cards_gamble/drop-shadow',\r\n                    offsetX: 6,\r\n                    offsetY: 6,\r\n                    opacity: .85\r\n                }\r\n            });\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/FlipCard.js"),eval("// gambleFrameView\r\n// contains gamble frame elements\r\n// and handles card initialization and flipping\r\ndefine('layers/gambleFrame/gambleFrameView',[\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-gambleFrame',\r\n    'components/Sprite',\r\n    'services/pause',\r\n    'services/math',\r\n    'services/format',\r\n    'components/FlipCard',\r\n    'components/Text'\r\n], function (pubsub, globalConfig, config, Sprite, pause, math, format,\r\n        FlipCard, Text) {\r\n\r\n    return function mCreate(ctrl) {\r\n        var elements = {};\r\n        elements.background2 = Sprite({\r\n            groupCtrl: ctrl,\r\n            name: 'gamble-background',\r\n            imgPath: config.GAMBLE_BG_IMG,\r\n            left: config.GAMBLE_FRAME_LEFT,\r\n            top: config.GAMBLE_FRAME_TOP,\r\n            height: config.GAMBLE_FRAME_HEIGHT,\r\n            width: config.GAMBLE_FRAME_WIDTH,\r\n            isReelsAreaElement: true,\r\n            zIndex: 21,\r\n            canvasLayer: 'top'\r\n        });\r\n        elements.gambleAmountLabelText = Text({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            left: config.GAMBLE_AMOUNT_LABEL_TEXT_LEFT,\r\n            top: config.GAMBLE_AMOUNT_LABEL_TEXT_TOP,\r\n            text: 'gambleAmount',\r\n            fontSize: config.LABELS_FONT_SIZE,\r\n            style: globalConfig.MAIN_TEXT_STYLE_7,\r\n            rotate: config.GAMBLE_AMOUNT_LABEL_TEXT_ROTATE,\r\n            textAlign: 'center',\r\n            isReelsAreaElement: true,\r\n            zIndex: 7,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.gambleAmountValueText = Text({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            left: config.GAMBLE_AMOUNT_VALUE_TEXT_LEFT,\r\n            top: config.GAMBLE_AMOUNT_VALUE_TEXT_TOP,\r\n            text: '',\r\n            fontSize: config.VALUES_FONT_SIZE,\r\n            style: globalConfig.MAIN_TEXT_STYLE_8,\r\n            rotate: config.GAMBLE_AMOUNT_VALUE_TEXT_ROTATE,\r\n            textAlign: 'center',\r\n            originX: 'center',\r\n            formatter: format.formatAmountWithDenom,\r\n            isReelsAreaElement: true,\r\n            zIndex: 7,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.gambleToWinLabelText = Text({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            left: config.GAMBLE_TO_WIN_LABEL_TEXT_LEFT,\r\n            top: config.GAMBLE_TO_WIN_LABEL_TEXT_TOP,\r\n            text: 'gambleToWin',\r\n            fontSize: config.LABELS_FONT_SIZE,\r\n            style: globalConfig.MAIN_TEXT_STYLE_7,\r\n            rotate: config.GAMBLE_TO_WIN_LABEL_TEXT_ROTATE,\r\n            textAlign: 'center',\r\n            isReelsAreaElement: true,\r\n            zIndex: 7,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.gambleToWinValueText = Text({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            left: config.GAMBLE_TO_WIN_VALUE_TEXT_LEFT,\r\n            top: config.GAMBLE_TO_WIN_VALUE_TEXT_TOP,\r\n            text: '',\r\n            fontSize: config.VALUES_FONT_SIZE,\r\n            style: globalConfig.MAIN_TEXT_STYLE_8,\r\n            rotate: config.GAMBLE_TO_WIN_VALUE_TEXT_ROTATE,\r\n            textAlign: 'center',\r\n            originX: 'center',\r\n            formatter: format.formatAmountWithDenom,\r\n            isReelsAreaElement: true,\r\n            zIndex: 7,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.card1 = FlipCard({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            imgPath: 'Cards_gamble/shirt',\r\n            layouts: {\r\n                'lefthand': {left: config.CARD_1_LEFT + config.GAMBLE_LEFTHAND_OFFSET_LEFT},\r\n                'righthand': {left: config.CARD_1_LEFT}\r\n            },\r\n            currentLayout: 'righthand',\r\n            top: config.CARD_TOP,\r\n            width: config.CARD_WIDTH,\r\n            height: config.CARD_HEIGHT,\r\n            opacity: config.CARD_OPACITY || 1,\r\n            zIndex: 7.1,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.card2 = FlipCard({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            imgPath: 'Cards_gamble/shirt',\r\n            layouts: {\r\n                'lefthand': {left: config.CARD_1_LEFT\r\n                            + config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT + config.GAMBLE_LEFTHAND_OFFSET_LEFT},\r\n                'righthand': {left: config.CARD_1_LEFT\r\n                            + config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT}\r\n            },\r\n            currentLayout: 'righthand',\r\n            top: config.CARD_TOP,\r\n            width: config.CARD_WIDTH,\r\n            height: config.CARD_HEIGHT,\r\n            opacity: config.CARD_OPACITY || 1,\r\n            click: function () {\r\n                ctrl.viewActions.cardClicked(2);\r\n            },\r\n            zIndex: 7.2,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.card3 = FlipCard({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            imgPath: 'Cards_gamble/shirt',\r\n            layouts: {\r\n                'lefthand': {left: config.CARD_1_LEFT\r\n                            + 2 * config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT\r\n                            + config.CARD_NEXT_OFFSET_LEFT + config.GAMBLE_LEFTHAND_OFFSET_LEFT},\r\n                'righthand': {left: config.CARD_1_LEFT\r\n                            + 2 * config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT\r\n                            + config.CARD_NEXT_OFFSET_LEFT}\r\n            },\r\n            currentLayout: 'righthand',\r\n            top: config.CARD_TOP,\r\n            width: config.CARD_WIDTH,\r\n            height: config.CARD_HEIGHT,\r\n            opacity: config.CARD_OPACITY || 1,\r\n            click: function () {\r\n                ctrl.viewActions.cardClicked(3);\r\n            },\r\n            zIndex: 7.3,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.card4 = FlipCard({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            imgPath: 'Cards_gamble/shirt',\r\n            layouts: {\r\n                'lefthand': {left: config.CARD_1_LEFT\r\n                            + 3 * config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT\r\n                            + 2 * config.CARD_NEXT_OFFSET_LEFT + config.GAMBLE_LEFTHAND_OFFSET_LEFT},\r\n                'righthand': {left: config.CARD_1_LEFT\r\n                            + 3 * config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT\r\n                            + 2 * config.CARD_NEXT_OFFSET_LEFT}\r\n            },\r\n            currentLayout: 'righthand',\r\n            top: config.CARD_TOP,\r\n            width: config.CARD_WIDTH,\r\n            height: config.CARD_HEIGHT,\r\n            opacity: config.CARD_OPACITY || 1,\r\n            click: function () {\r\n                ctrl.viewActions.cardClicked(4);\r\n            },\r\n            zIndex: 7.4,\r\n            canvasLayer: 'ui'\r\n        });\r\n        elements.card5 = FlipCard({\r\n            groupCtrl: ctrl,\r\n            parent: elements.background2,\r\n            imgPath: 'Cards_gamble/shirt',\r\n            layouts: {\r\n                'lefthand': {left: config.CARD_1_LEFT\r\n                            + 4 * config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT\r\n                            + 3 * config.CARD_NEXT_OFFSET_LEFT + config.GAMBLE_LEFTHAND_OFFSET_LEFT},\r\n                'righthand': {left: config.CARD_1_LEFT\r\n                            + 4 * config.CARD_WIDTH\r\n                            + config.CARD_FIRST_OFFSET_LEFT\r\n                            + 3 * config.CARD_NEXT_OFFSET_LEFT}\r\n            },\r\n            currentLayout: 'righthand',\r\n            top: config.CARD_TOP,\r\n            width: config.CARD_WIDTH,\r\n            height: config.CARD_HEIGHT,\r\n            opacity: config.CARD_OPACITY || 1,\r\n            click: function () {\r\n                ctrl.viewActions.cardClicked(5);\r\n            },\r\n            zIndex: 7.5,\r\n            canvasLayer: 'ui'\r\n        });\r\n\r\n        elements.background2.addChildren([elements.gambleAmountLabelText]);\r\n        elements.background2.addChildren([elements.gambleAmountValueText]);\r\n        elements.background2.addChildren([elements.gambleToWinLabelText]);\r\n        elements.background2.addChildren([elements.gambleToWinValueText]);\r\n        elements.background2.addChildren([elements.card1]);\r\n        elements.background2.addChildren([elements.card2]);\r\n        elements.background2.addChildren([elements.card3]);\r\n        elements.background2.addChildren([elements.card4]);\r\n        elements.background2.addChildren([elements.card5]);\r\n\r\n\r\n        var animations = [];\r\n\r\n        // API\r\n        return {\r\n            config: config,\r\n            elements: elements,\r\n            actions: {\r\n                update: mUpdate,\r\n                flip: mFlip,\r\n                flipAnimateFrontAll: mFlipAnimateFrontAll,\r\n                clearAll: mClearAll,\r\n                flipAnimateBackAll: mFlipAnimateBackAll,\r\n                reinitCard: mReinitCard,\r\n                animateSlideIn: mAnimateSlideIn,\r\n            }\r\n        };\r\n        function mUpdate(delta) {\r\n            var length = animations.length;\r\n            for (var i = 0; i < length; i++) {\r\n                if (animations[i] && animations[i].update(delta) === false) {\r\n                    animations.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n        // flip single card\r\n        function mFlip(cardId, flipState, mute) {\r\n            var el = elements['card' + cardId];\r\n            if (el.flipState !== flipState) {\r\n                el.flip(flipState);\r\n                pubsub.publish('notify:cardFlipStarted', {mute: mute});\r\n            }\r\n        }\r\n        // flip reveal all remaining cards to show result\r\n        function mFlipAnimateFrontAll() {\r\n            for (var i = 1; i <= 5; i++) {\r\n                var el = elements['card' + i];\r\n                if (el.flipState === 'back') {\r\n                    el.flip('front');\r\n                    pubsub.publish('notify:cardFlipStarted');\r\n                }\r\n            }\r\n        }\r\n        // flip without animation\r\n        function mClearAll() {\r\n            for (var i = 1; i <= 5; i++) {\r\n                var el = elements['card' + i];\r\n                el.clear();\r\n                el.reinit('Cards_gamble/shirt');\r\n            }\r\n        }\r\n        // flip hide all cards sequentially after win / tie\r\n        function mFlipAnimateBackAll(cb) {\r\n            function flipCurrent() {\r\n                var el = elements['card' + current];\r\n                if (el.flipState === 'front') {\r\n                    if (current === 1) {\r\n                        el.flip('back', cb);\r\n                    } else {\r\n                        el.flip('back');\r\n                    }\r\n                }\r\n                if (current > 1) {\r\n                    current -= 1;\r\n                    pause.setTimeout(flipCurrent, timeOffset);\r\n                }\r\n            }\r\n            var timeOffset = 60;\r\n            var current = 5;\r\n            pubsub.publish('notify:cardFlipAllStarted');\r\n            pause.setTimeout(flipCurrent, timeOffset);\r\n        }\r\n        // initialize card with specific image\r\n        function mReinitCard(cardId, cardSymbolPath) {\r\n            cardSymbolPath = String(cardSymbolPath);\r\n            while (cardSymbolPath.length < 5) {\r\n                cardSymbolPath = '0' + cardSymbolPath;\r\n            }\r\n            cardSymbolPath = 'Cards_gamble/' + cardSymbolPath;\r\n            elements['card' + cardId].reinit(cardSymbolPath);\r\n        }\r\n        function mAnimateSlideIn(durationMs) {\r\n            elements.background2.set({top: -config.GAMBLE_FRAME_HEIGHT});\r\n            ctrl.showAll();\r\n            var progressPerSecond = 1000 / durationMs;\r\n            var progress = 0;\r\n            var pxDiff = config.GAMBLE_FRAME_HEIGHT + config.GAMBLE_FRAME_TOP;\r\n            var newTop;\r\n            animations.push({\r\n                update: function (delta) {\r\n                    progress += delta * progressPerSecond;\r\n                    if (progress >= 1) {\r\n                        newTop = config.GAMBLE_FRAME_TOP;\r\n                    } else {\r\n                        newTop = -config.GAMBLE_FRAME_HEIGHT\r\n                                + pxDiff * math.easeOutQuad(progress);\r\n                    }\r\n                    elements.background2.set({top: newTop});\r\n                    if (progress >= 1) {\r\n                        return false;\r\n                    } else {\r\n                        return true;\r\n                    }\r\n                }\r\n            });\r\n\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/gambleFrame/gambleFrameView.js"),
eval("define('layers/gambleFrame/gambleFrameCtrl',[\r\n    'pubsub',\r\n    'data/config-gambleFrame',\r\n    'components/GroupCtrl',\r\n    'services/pause',\r\n    'layers/gambleFrame/gambleFrameView'\r\n], function (pubsub, config, GroupCtrl, pause, gambleFrameView) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        cardClicked: function (cardId) {\r\n            pubsub.publish('notify:gambleCardClicked', {\r\n                cardId: cardId\r\n            });\r\n        }\r\n    };\r\n\r\n    var animating = false;\r\n    var animationFinishedCallback = null;\r\n\r\n    // initialize view\r\n    self.view = gambleFrameView(self);\r\n    self.update = self.view.actions.update;\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        // fade in gamble window\r\n        // display gamble amount & gamble to win texts\r\n        // flip first card after delay\r\n        'request:showGambleFrame': function (id, data) {\r\n            var cardSymbolPath = String(data.firstCard);\r\n            self.view.elements.gambleAmountValueText.setText('!' + data.gambleAmount);\r\n            self.view.elements.gambleToWinValueText.setText('!' + (2 * data.gambleAmount));\r\n            if (config.GAMBLE_ANIMATION === 'slide') {\r\n                self.view.actions.animateSlideIn(400);\r\n            } else if (config.GAMBLE_ANIMATION === 'show') {\r\n                self.fadeInAll(null, 150);\r\n            } else {\r\n                self.showAll();\r\n            }\r\n            pause.setTimeout(function () {\r\n                self.view.actions.reinitCard(1, cardSymbolPath);\r\n                self.view.actions.flip(1, 'front');\r\n            }, 400);\r\n        },\r\n        // initialize clickable cards with values\r\n        'request:gambleInitCards': function (id, data) {\r\n            self.view.actions.reinitCard(2, data.cards[0]);\r\n            self.view.actions.reinitCard(3, data.cards[1]);\r\n            self.view.actions.reinitCard(4, data.cards[2]);\r\n            self.view.actions.reinitCard(5, data.cards[3]);\r\n        },\r\n        // display gamble result - flip all cards\r\n        // update gamble amount & gamble to win texts\r\n        // flip back after delay if requested\r\n        'request:animateGambleResult': function (id, data) {\r\n            self.view.actions.flipAnimateFrontAll();\r\n            self.view.elements.gambleAmountValueText.setText('!' + data.gambleAmount);\r\n            self.view.elements.gambleToWinValueText.setText('!' + data.gambleToWin);\r\n            if (data.flipBack) {\r\n                animating = true;\r\n                pause.setTimeout(function () {\r\n                    self.view.actions.flipAnimateBackAll(function () {\r\n                        animating = false;\r\n                        animationFinishedCallback && animationFinishedCallback();\r\n                        animationFinishedCallback = null;\r\n                    });\r\n                }, config.VIEW_RESULT_TIMEOUT);\r\n            }\r\n        },\r\n        // flip card specified by data.cardId open\r\n        'request:gambleFlipCard': function (id, data) {\r\n            function flip() {\r\n                if (data.card) {\r\n                    self.view.actions.reinitCard(data.cardId, data.card);\r\n                }\r\n                self.view.actions.flip(data.cardId, 'front', data.mute);\r\n            }\r\n            if (animating) {\r\n                animationFinishedCallback = flip;\r\n            } else {\r\n                flip();\r\n            }\r\n        },\r\n        // hide the gamble window\r\n        // initialize clean view\r\n        'request:clearGambleFrame': function () {\r\n            self.view.actions.clearAll();\r\n            self.hideAll();\r\n        },\r\n    });\r\n\r\n\r\n    return self;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/gambleFrame/gambleFrameCtrl.js"),eval("\r\ndefine('data/config-background',{\r\n    CANVAS_BACK_OFFSET_LEFT: -40,\r\n    CANVAS_BACK_OFFSET_TOP: 57,\r\n    CANVAS_BACK_HEIGHT: 579,\r\n    CANVAS_BACK_WIDTH: 1040,\r\n    REELS_BACK_LEFT: -40,\r\n    REELS_BACK_TOP: 57,\r\n    REELS_BACK_WIDTH: 1040,\r\n    REELS_BACK_HEIGHT: 579,\r\n    REELS_BACK_FG_IMG: 'freegames_backgrounds_1',\r\n    FG_BACKGROUND_IMG: 'freegames_backgrounds_2',\r\n    \r\n\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-background.js"),eval("\r\ndefine('data/config-reelSet',{\r\n    BASE: {\r\n        VISIBLE_SYMBOLS_ON_REEL: 3,\r\n        INJECTABLE_BLOCK_ROWS: 3,\r\n        SAFE_INJECTION_POSITION_DELTA: 1,\r\n        INJECTION_ROWS_OFFSET: 0,\r\n        REELS_COUNT: 5,\r\n        REELS_CANVAS_LEFT: 135,\r\n        REELS_CANVAS_TOP: 135,\r\n        REELS_CANVAS_WIDTH: 687,\r\n        REELS_CANVAS_HEIGHT: 375,\r\n        \r\n        \r\n        BOUNCE_DURATION_MS: 60,\r\n        BOUNCE_HEIGHT_POSITIONS: 0.25,\r\n        \r\n        \r\n    },\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-reelSet.js"),eval("define('components/RectOverlay',[\r\n    'pixi',\r\n    'components/Element',\r\n    'services/platform',\r\n    'services/dimensions',\r\n], function (\r\n        PIXI, Element, platform, dimensions) {\r\n    return function create(options) {\r\n\r\n        function getRealY(interactionData) {\r\n            return interactionData.global.y - dimensions.topLevelWrappersOffsetY /\r\n                    dimensions.canvasScaleY;\r\n        }\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'RectOverlay';\r\n\r\n        self.maxDrag = options.maxDrag;\r\n        self.onTouchStart = options.onTouchStart;\r\n        self.onDrag = options.onDrag;\r\n        self.onTouchEnd = options.onTouchEnd;\r\n        self.actionTriggerDragTresholdFraction = options.actionTriggerDragTresholdFraction;\r\n\r\n        var el = new PIXI.Graphics();\r\n        el.beginFill('0x000000');\r\n        el.fillAlpha = 0;\r\n        el.drawRect(0, 0, self.width, self.height);\r\n        el.endFill();\r\n\r\n        var\r\n                pressed = false,\r\n                dragging = false,\r\n                initialTop = self.top;\r\n\r\n        el.wrapper = self;\r\n        self.pixiEl = el;\r\n        self.resize();\r\n\r\n        el.interactive = true;\r\n\r\n        el.touchstart = el.mousedown = function (e) {\r\n            var top = getRealY(e.data);\r\n            pressed = true;\r\n            initialTop = top;\r\n            self.onTouchStart && self.onTouchStart();\r\n        };\r\n        el.touchmove = el.mousemove = function (e) {\r\n            if (pressed) {\r\n                var top = getRealY(e.data);\r\n                var diff = top - initialTop;\r\n                if (!dragging && Math.abs(diff) > 5) {\r\n                    dragging = true;\r\n                }\r\n                if (dragging) {\r\n                    diff < 0 && (diff = 0);\r\n                    diff > self.maxDrag && (diff = self.maxDrag);\r\n                    self.onDrag && self.onDrag(diff);\r\n                    if (diff > self.actionTriggerDragTresholdFraction * self.maxDrag) {\r\n                        dragging = false;\r\n                        pressed = false;\r\n                        self.onTouchEnd\r\n                                && self.onTouchEnd({actionTriggerTresholdPassed: true,\r\n                                    click: false});\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        el.touchend = el.mouseup = function (evt) {\r\n            if (pressed) {\r\n                pressed = false;\r\n                dragging = false;\r\n                self.onTouchEnd\r\n                        && self.onTouchEnd({actionTriggerTresholdPassed: false,\r\n                            click: !dragging});\r\n            }\r\n        };\r\n\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/RectOverlay.js"),eval("// backgroundView\r\n// contains background images elements\r\n// and reels overlay used to intercept pointer events\r\ndefine('layers/background/backgroundView',['jquery',\r\n    'data/config',\r\n    'data/config-background',\r\n    'data/config-symbolSet',\r\n    'data/config-reelSet',\r\n    'components/Sprite',\r\n    'components/RectOverlay',\r\n    'components/Rectangle',\r\n], function ($, globalConfig, config, symbolSet, reelSet, Sprite, RectOverlay, Rectangle) {\r\n    return function mCreate(ctrl) {\r\n\r\n        var elements = {\r\n            back: Sprite({\r\n                name: 'background-main',\r\n                groupCtrl: ctrl,\r\n                imgPath: 'backgrounds_2',\r\n                left: config.CANVAS_BACK_OFFSET_LEFT,\r\n                top: config.CANVAS_BACK_OFFSET_TOP,\r\n                width: config.CANVAS_BACK_WIDTH || globalConfig.CANVAS_BASE_WIDTH,\r\n                height: config.CANVAS_BACK_HEIGHT,\r\n                isReelsAreaElement: true,\r\n                zIndex: config.SHOW_SYMBOLS_UNDER_FRAME ? 14 : 3,\r\n                canvasLayer: 'top',\r\n            }),\r\n            backFG: Sprite({\r\n                name: 'background-fg',\r\n                groupCtrl: ctrl,\r\n                imgPath: config.FG_BACKGROUND_IMG,\r\n                left: config.CANVAS_BACK_FG_OFFSET_LEFT || config.CANVAS_BACK_OFFSET_LEFT,\r\n                top: config.CANVAS_BACK_FG_OFFSET_TOP || config.CANVAS_BACK_OFFSET_TOP,\r\n                width: config.CANVAS_BACK_FG_WIDTH || config.CANVAS_BACK_WIDTH || globalConfig.CANVAS_BASE_WIDTH,\r\n                height: config.CANVAS_BACK_FG_HEIGHT || config.CANVAS_BACK_HEIGHT,\r\n                isReelsAreaElement: true,\r\n                zIndex: config.SHOW_SYMBOLS_UNDER_FRAME ? 14 : 3,\r\n                canvasLayer: 'top',\r\n            }),\r\n            backWinnings: Sprite({\r\n                name: 'background-winnings',\r\n                groupCtrl: ctrl,\r\n//                imgPath: 'background_winnings',\r\n                left: config.CANVAS_BACK_WINNINGS_OFFSET_LEFT,\r\n                top: config.CANVAS_BACK_WINNINGS_OFFSET_TOP,\r\n                width: config.CANVAS_BACK_WINNINGS_WIDTH,\r\n                height: config.CANVAS_BACK_WINNINGS_HEIGHT,\r\n                isReelsAreaElement: true,\r\n                zIndex: 15,\r\n                canvasLayer: 'top',\r\n            }),\r\n            reelClickSurface: RectOverlay({\r\n                groupCtrl: ctrl,\r\n                left: 0,\r\n                top: 0,\r\n                width: globalConfig.CANVAS_BASE_WIDTH,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                isReelsAreaElement: true,\r\n                onTouchStart: ctrl.viewActions.onReelSurfaceTouchStart,\r\n                onDrag: ctrl.viewActions.onReelSurfaceDrag,\r\n                onTouchEnd: ctrl.viewActions.onReelSurfaceTouchEnd,\r\n                actionTriggerDragTresholdFraction: globalConfig.REELS_DRAG_SPIN_TRESHOLD_POSITIONS,\r\n                maxDrag: symbolSet.SPIN.SYMBOL_OUTER_HEIGHT,\r\n                canvasLayer: 'ui',\r\n                zIndex: 15\r\n            }),\r\n            blackOverlay1: Rectangle({\r\n                groupCtrl: ctrl,\r\n                color: 'black',\r\n                left: 0,\r\n                top: globalConfig.OVERLAY_1_TOP,\r\n                width: globalConfig.CANVAS_BASE_WIDTH,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                canvasLayer: 'ui',\r\n                zIndex: 999,\r\n            }),\r\n            blackOverlay2: Rectangle({\r\n                groupCtrl: ctrl,\r\n                color: 'black',\r\n                left: 0,\r\n                top: globalConfig.OVERLAY_2_TOP,\r\n                width: globalConfig.CANVAS_BASE_WIDTH,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                canvasLayer: 'ui',\r\n                zIndex: 999,\r\n            }),\r\n            blackOverlay3: Rectangle({\r\n                groupCtrl: ctrl,\r\n                color: 'black',\r\n                left: -globalConfig.CANVAS_BASE_WIDTH,\r\n                top: 0,\r\n                width: globalConfig.CANVAS_BASE_WIDTH,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                canvasLayer: 'ui',\r\n                zIndex: 999\r\n            }),\r\n            blackOverlay4: Rectangle({\r\n                groupCtrl: ctrl,\r\n                color: 'black',\r\n                left: globalConfig.CANVAS_BASE_WIDTH,\r\n                top: 0,\r\n                width: globalConfig.CANVAS_BASE_WIDTH,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                canvasLayer: 'ui',\r\n                zIndex: 999\r\n            }),\r\n        };\r\n\r\n        // API\r\n        return {\r\n            elements: elements\r\n        };\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/background/backgroundView.js"),eval("// backgroundCtrl\r\n// controls background images\r\n// and clickable transparent reel overlay used to intercept pointer events over reels\r\ndefine('layers/background/backgroundCtrl',[\r\n    'pubsub', 'components/GroupCtrl',\r\n    'layers/background/backgroundView',\r\n    'data/config-background'\r\n], function (pubsub, GroupCtrl, backgroundView, config) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var currentActivity;\r\n    var currentSubActivity;\r\n    var currentSpinBtnState;\r\n    var currentReelsOverlayRequestedState;\r\n\r\n    self.viewActions = {\r\n        onReelSurfaceTouchStart: onReelSurfaceTouchStart,\r\n        onReelSurfaceDrag: onReelSurfaceDrag,\r\n        onReelSurfaceTouchEnd: onReelSurfaceTouchEnd,\r\n    };\r\n\r\n    // initialize view\r\n    self.view = backgroundView(self);\r\n    self.view.elements.blackOverlay1.show();\r\n    self.view.elements.blackOverlay2.show();\r\n    self.view.elements.blackOverlay3.show();\r\n    self.view.elements.blackOverlay4.show();\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:adjustControls': mAdjustControls,\r\n        'request:showBackground': function (id, data) {\r\n            data = data || {};\r\n            var reelsBackImg;\r\n\r\n            if (data.freeSpin) {\r\n                reelsBackImg = config.REELS_BACK_FG_IMG;\r\n                self.view.elements.backFG.show();\r\n                self.view.elements.back.hide();\r\n            } else {\r\n                reelsBackImg = 'backgrounds_1';\r\n                self.view.elements.back.show();\r\n                self.view.elements.backFG.hide();\r\n            }\r\n\r\n            if (data.win) {\r\n                self.view.elements.backWinnings.show();\r\n            } else {\r\n                self.view.elements.backWinnings.hide();\r\n            }\r\n\r\n            if (data.freeSpin) {\r\n                pubsub.publish('request:setReelsBackground', {\r\n                    imgPath: reelsBackImg,\r\n                    left: config.REELS_BACK_FG_LEFT || config.REELS_BACK_LEFT,\r\n                    top: config.REELS_BACK_FG_TOP || config.REELS_BACK_TOP,\r\n                    width: config.REELS_BACK_FG_WIDTH || config.REELS_BACK_WIDTH,\r\n                    height: config.REELS_BACK_FG_HEIGHT || config.REELS_BACK_HEIGHT\r\n                });\r\n            } else {\r\n                pubsub.publish('request:setReelsBackground', {\r\n                    imgPath: reelsBackImg,\r\n                    left: config.REELS_BACK_LEFT,\r\n                    top: config.REELS_BACK_TOP,\r\n                    width: config.REELS_BACK_WIDTH,\r\n                    height: config.REELS_BACK_HEIGHT\r\n                });\r\n            }\r\n        },\r\n        'notify:activityAfterStart': function (id, data) {\r\n            currentActivity = data.activity;\r\n            currentSubActivity = null;\r\n            updateReelsOverlayState();\r\n        },\r\n        'notify:subactivityStarted': function (id, data) {\r\n            currentSubActivity = data.subactivity;\r\n            updateReelsOverlayState();\r\n        },\r\n        'notify:subactivityFinished': function (id, data) {\r\n            currentSubActivity = null;\r\n            updateReelsOverlayState();\r\n        },\r\n        'notify:spinButtonTouch': spinButtonTouch,\r\n    });\r\n\r\n    function mAdjustControls(id, data) {\r\n        currentReelsOverlayRequestedState = data.reelsClickableOverlay;\r\n        updateReelsOverlayState();\r\n    }\r\n\r\n    function onReelSurfaceTouchStart() {\r\n        pubsub.publish('notify:reelSurfaceTouchStart');\r\n    }\r\n    function onReelSurfaceDrag(yOffset) {\r\n        pubsub.publish('notify:reelSurfaceDrag', yOffset);\r\n    }\r\n    function onReelSurfaceTouchEnd(data) {\r\n        pubsub.publish('notify:reelSurfaceTouchEnd', data);\r\n    }\r\n    function spinButtonTouch(id, type) {\r\n        currentSpinBtnState = type;\r\n        updateReelsOverlayState();\r\n    }\r\n    function updateReelsOverlayState() {\r\n        if (currentReelsOverlayRequestedState === 'active'\r\n                && currentSpinBtnState !== 'down'\r\n                && (!currentSubActivity || currentSubActivity === 'reelsDrag')) {\r\n            self.view.elements.reelClickSurface.show();\r\n        } else {\r\n            self.view.elements.reelClickSurface.hide();\r\n        }\r\n    }\r\n\r\n    return self;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/background/backgroundCtrl.js"),eval("define('components/ReelSymbolAnimationBasic',[\r\n    'components/Element',\r\n    'components/SpriteSheetAnimation'\r\n], function (\r\n        Element, SpriteSheetAnimation) {\r\n\r\n    // reel symbol animation with single sprite sheet played back and forth\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'ReelSymbolAnimationBasic';\r\n        self.animationStartPath = options.animationStartPath;\r\n        self.animationCyclePath = options.animationCyclePath;\r\n        self.zIndex = options.zIndex;\r\n        self.totalCycles = options.totalCycles;\r\n        self.spriteOffset = options.spriteOffset;\r\n        self.reverse = options.reverse;\r\n        self.mask = options.mask;\r\n        self.borderImgPath = options.borderImg;\r\n        self.backImgPath = options.backImg;\r\n        self.offsets = options.offsets;\r\n\r\n        var currentlyAnimating = null;\r\n\r\n        var heights = {\r\n            start: null,\r\n            cycle: null,\r\n        };\r\n        var widths = {\r\n            start: null,\r\n            cycle: null,\r\n        };\r\n        var offsets = {\r\n            start: {x: 0, y: 0},\r\n            cycle: {x: 0, y: 0},\r\n        };\r\n\r\n        if (typeof (self.height) === 'object') {\r\n            heights.start = self.height[self.animationStartPath];\r\n            heights.cycle = self.height[self.animationCyclePath];\r\n        } else {\r\n            heights.start = self.height;\r\n            heights.cycle = self.height;\r\n        }\r\n\r\n        if (typeof (self.width) === 'object') {\r\n            widths.start = self.width[self.animationStartPath];\r\n            widths.cycle = self.width[self.animationCyclePath];\r\n        } else {\r\n            widths.start = self.width;\r\n            widths.cycle = self.width;\r\n        }\r\n\r\n        if (typeof (self.offsets) === 'object') {\r\n            self.offsets[self.animationStartPath]\r\n                    && (offsets.start = self.offsets[self.animationStartPath]);\r\n            self.offsets[self.animationCyclePath]\r\n                    && (offsets.cycle = self.offsets[self.animationCyclePath]);\r\n        }\r\n        var animationStarted = false;\r\n\r\n        var spriteSheetCycle = SpriteSheetAnimation({\r\n            groupCtrl: options.groupCtrl,\r\n            name: self.name + '-spriteSheetCycle',\r\n            imgPath: self.animationCyclePath,\r\n            left: self.left + offsets.cycle.x,\r\n            top: self.top + offsets.cycle.y,\r\n            width: widths.cycle,\r\n            height: heights.cycle,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex,\r\n            frameOffset: self.spriteOffset,\r\n            canvasLayer: self.canvasLayer,\r\n            reverse: self.reverse,\r\n            mask: self.mask\r\n        });\r\n\r\n\r\n        var spriteSheetStart = null;\r\n        if (self.animationStartPath) {\r\n            spriteSheetStart = SpriteSheetAnimation({\r\n                groupCtrl: options.groupCtrl,\r\n                name: self.name + '-spriteSheetStart',\r\n                imgPath: self.animationStartPath,\r\n                left: self.left + offsets.start.x,\r\n                top: self.top + offsets.start.y,\r\n                width: widths.start,\r\n                height: heights.start,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex,\r\n                frameOffset: self.spriteOffset,\r\n                canvasLayer: self.canvasLayer,\r\n                reverse: self.reverse,\r\n                mask: self.mask\r\n            });\r\n        }\r\n\r\n        self.pixiEl = [];\r\n        spriteSheetStart && self.pixiEl.push(spriteSheetStart);\r\n        self.pixiEl.push(spriteSheetCycle);\r\n\r\n\r\n        if (self.borderImgPath) {\r\n            var borderEl = Sprite({\r\n                groupCtrl: options.groupCtrl,\r\n                name: self.name + '-border',\r\n                left: self.left + offsets.start.x,\r\n                top: self.top + offsets.start.y,\r\n                width: widths.start,\r\n                height: heights.start,\r\n                imgPath: self.borderImgPath,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex + 0.01,\r\n                canvasLayer: self.canvasLayer\r\n            });\r\n            self.pixiEl.push(borderEl);\r\n        }\r\n        if (self.backImgPath) {\r\n            var backEl = Sprite({\r\n                groupCtrl: options.groupCtrl,\r\n                name: self.name + '-back',\r\n                left: self.left + offsets.start.x,\r\n                top: self.top + offsets.start.y,\r\n                width: widths.start,\r\n                height: heights.start,\r\n                imgPath: self.backImgPath,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex - 0.01,\r\n                canvasLayer: self.canvasLayer\r\n            });\r\n            self.pixiEl.push(backEl);\r\n        }\r\n\r\n        self.update = function (delta) {\r\n            spriteSheetStart && spriteSheetStart.update(delta);\r\n            spriteSheetCycle.update(delta);\r\n        };\r\n\r\n        self.animate = function (options) {\r\n            options = options || {};\r\n            borderEl && borderEl.show();\r\n            backEl && backEl.show();\r\n            if (spriteSheetStart) {\r\n                if (!animationStarted || self.totalCycles > 1) {\r\n                    spriteSheetStart.show();\r\n                    spriteSheetStart.animate({\r\n                        cycles: 1,\r\n                        callback: function () {\r\n                            spriteSheetCycle.show();\r\n                            spriteSheetCycle.animate({\r\n                                cycles: self.totalCycles,\r\n                                callback: options.animationFinished\r\n                            });\r\n                            spriteSheetStart.hide();\r\n                            currentlyAnimating = 'cycle';\r\n                        }\r\n                    });\r\n                    animationStarted = true;\r\n                    currentlyAnimating = 'start';\r\n                }\r\n            } else {\r\n                spriteSheetCycle.show();\r\n                if (!animationStarted || self.totalCycles > 1) {\r\n                    spriteSheetCycle.animate({\r\n                        cycles: self.totalCycles,\r\n                        callback: options.animationFinished\r\n                    });\r\n                    animationStarted = true;\r\n                    currentlyAnimating = 'cycle';\r\n                }\r\n            }\r\n        };\r\n        self.stopAnimation = function () {\r\n            spriteSheetStart && spriteSheetStart.stopAnimation();\r\n            spriteSheetCycle.stopAnimation();\r\n            currentlyAnimating = null;\r\n        };\r\n        self.reset = function () {\r\n            animationStarted = false;\r\n            spriteSheetStart && spriteSheetStart.reset();\r\n            spriteSheetCycle.reset();\r\n        };\r\n        self.show = function () {\r\n            self.visible = true;\r\n            borderEl && borderEl.show();\r\n            backEl && backEl.show();\r\n            if (animationStarted && self.totalCycles === 1) {\r\n                if (currentlyAnimating === 'start') {\r\n                    spriteSheetStart.show();\r\n                } else if (currentlyAnimating === 'cycle') {\r\n                    spriteSheetCycle.show();\r\n                } else if (spriteSheetStart) {\r\n                    spriteSheetStart.show();\r\n                } else {\r\n                    spriteSheetCycle.show();\r\n                }\r\n            }\r\n        };\r\n        self.superHide = self.hide.bind(self);\r\n        self.hide = function () {\r\n            self.stopAnimation();\r\n            self.superHide.apply(null, arguments);\r\n        };\r\n        self.superSet = self.set.bind(self);\r\n        self.set = function () {\r\n            self.superSet.apply(null, arguments);\r\n            if (spriteSheetStart) {\r\n                spriteSheetStart.set({\r\n                    left: self.left + offsets.start.x,\r\n                    top: self.top + offsets.start.y,\r\n                });\r\n            }\r\n            spriteSheetCycle.set({\r\n                left: self.left + offsets.cycle.x,\r\n                top: self.top + offsets.cycle.y,\r\n            });\r\n        };\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/ReelSymbolAnimationBasic.js"),eval("define('components/ReelSymbolCrossfade',[\r\n    'components/Element',\r\n    'components/Sprite',\r\n    'data/config'\r\n], function (\r\n        Element, Sprite, config) {\r\n\r\n    // reel symbol animation crossfading between two images\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'Sprite';\r\n        self.fromImage = options.fromImage;\r\n        self.toImage = options.toImage;\r\n        self.animations = [];\r\n        self.borderImgPath = options.borderImg;\r\n        self.backImgPath = options.backImg;\r\n        self.offsets = options.offsets;\r\n\r\n        var heights = {\r\n            from: null,\r\n            to: null,\r\n        };\r\n        var widths = {\r\n            from: null,\r\n            to: null,\r\n        };\r\n        var offsets = {\r\n            from: {x: 0, y: 0},\r\n            to: {x: 0, y: 0},\r\n        };\r\n\r\n        if (typeof (self.height) === 'object') {\r\n            heights.from = self.height[self.fromImage];\r\n            heights.to = self.height[self.toImage];\r\n        } else {\r\n            heights.from = self.height;\r\n            heights.to = self.height;\r\n        }\r\n\r\n        if (typeof (self.width) === 'object') {\r\n            widths.from = self.width[self.fromImage];\r\n            widths.to = self.width[self.toImage];\r\n        } else {\r\n            widths.from = self.width;\r\n            widths.to = self.width;\r\n        }\r\n\r\n        if (typeof (self.offsets) === 'object') {\r\n            self.offsets[self.fromImage]\r\n                    && (offsets.from = self.offsets[self.fromImage]);\r\n            self.offsets[self.toImage]\r\n                    && (offsets.to = self.offsets[self.toImage]);\r\n        }\r\n        var firstImgEl = Sprite({\r\n            groupCtrl: self.groupCtrl,\r\n            name: 'fromImage-' + name,\r\n            imgPath: self.toImage,\r\n            left: self.left + offsets.to.x,\r\n            top: self.top + offsets.to.y,\r\n            width: widths.to,\r\n            height: heights.to,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex + 0.3,\r\n            opacity: 1,\r\n            canvasLayer: self.canvasLayer\r\n        });\r\n\r\n        var secondImgEl = Sprite({\r\n            groupCtrl: self.groupCtrl,\r\n            name: 'toImage-' + name,\r\n            imgPath: self.fromImage,\r\n            left: self.left + offsets.from.x,\r\n            top: self.top + offsets.from.y,\r\n            width: widths.from,\r\n            height: heights.from,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex + 0.6,\r\n            opacity: 0.01,\r\n            canvasLayer: self.canvasLayer\r\n        });\r\n\r\n        firstImgEl.wrapper = self;\r\n        secondImgEl.wrapper = self;\r\n//\r\n        self.pixiEl = [firstImgEl, secondImgEl];\r\n\r\n        if (self.borderImgPath) {\r\n            var borderEl = Sprite({\r\n                groupCtrl: options.groupCtrl,\r\n                name: self.name + '-border',\r\n                left: self.left,\r\n                top: self.top,\r\n                width: widths.from,\r\n                height: heights.from,\r\n                imgPath: self.borderImgPath,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex + 0.01,\r\n                canvasLayer: self.canvasLayer\r\n            });\r\n            self.pixiEl.push(borderEl);\r\n        }\r\n        if (self.backImgPath) {\r\n            var backEl = Sprite({\r\n                groupCtrl: options.groupCtrl,\r\n                name: self.name + '-back',\r\n                left: self.left,\r\n                top: self.top,\r\n                width: widths.from,\r\n                height: heights.from,\r\n                imgPath: self.backImgPath,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex - 0.01,\r\n                canvasLayer: self.canvasLayer\r\n            });\r\n            self.pixiEl.push(backEl);\r\n        }\r\n\r\n        self.resize();\r\n\r\n        self.resize = function () {\r\n            firstImgEl.resize();\r\n            secondImgEl.resize();\r\n            borderEl && borderEl.resize();\r\n            backEl && backEl.resize();\r\n        };\r\n\r\n        self.update = function (delta) {\r\n            var length = self.animations.length;\r\n            for (var i = 0; i < length; i++) {\r\n                if (!self.animations[i].update(delta)) {\r\n                    self.animations.splice(i, 1);\r\n                }\r\n            }\r\n        };\r\n\r\n        self.animate = function (options) {\r\n            options = options || {};\r\n            var startTime = Date.now();\r\n            var animDuration = config.CROSSFADE_ANIMATION_DURATION;\r\n            var diff;\r\n            var normalized;\r\n            var toOpacity, fromOpacity;\r\n            self.animations = [{\r\n                    update: function (delta) {\r\n                        diff = Date.now() - startTime;\r\n                        if (diff >= animDuration) {\r\n                            if (options.animationFinished) {\r\n                                options.animationFinished();\r\n                                options.animationFinished = null;\r\n                            }\r\n                            diff = diff % animDuration;\r\n                            startTime = Date.now() - diff;\r\n                        }\r\n                        normalized = diff / animDuration;\r\n                        toOpacity = normalized * 2;\r\n                        if (toOpacity > 1) {\r\n                            toOpacity = 2 - toOpacity;\r\n                        }\r\n                        secondImgEl.set({\r\n                            opacity: toOpacity\r\n                        });\r\n                        return true;\r\n                    }\r\n                }];\r\n        };\r\n\r\n        self.stopAnimation = function () {\r\n            self.animations = [];\r\n        };\r\n        self.superHide = self.hide.bind(self);\r\n        self.hide = function () {\r\n            self.stopAnimation();\r\n            self.superHide.apply(null, arguments);\r\n        };\r\n        self.superSet = self.set.bind(self);\r\n        self.set = function () {\r\n            self.superSet.apply(null, arguments);\r\n            firstImgEl.set({\r\n                left: self.left + offsets.to.x,\r\n                top: self.top + offsets.to.y,\r\n            });\r\n            secondImgEl.set({\r\n                left: self.left + offsets.from.x,\r\n                top: self.top + offsets.from.y,\r\n            });\r\n        };\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/ReelSymbolCrossfade.js"),
eval("// reelsAnimationView\r\n// contains win symbol animation elements\r\n// initializes the elements based on spin result\r\ndefine('layers/reelsAnimation/reelsAnimationView',[\r\n    'data/config',\r\n    'services/assets',\r\n    'components/ReelSymbolAnimationBasic',\r\n    'components/ReelSymbolCrossfade',\r\n    'services/pause',\r\n], function (\r\n        config,\r\n        assets,\r\n        ReelSymbolAnimationBasic,\r\n        ReelSymbolCrossfade,\r\n        pause) {\r\n\r\n    return function mCreate(ctrl) {\r\n\r\n        var elements = {};\r\n        // timeout reference for animations start\r\n        var animateTimeout = null;\r\n\r\n        // API\r\n        return {\r\n            elements: elements,\r\n            actions: {\r\n                init: initElements,\r\n                clear: clear\r\n            }\r\n        };\r\n\r\n        // remove current animation elements\r\n        function clear() {\r\n            if (animateTimeout) {\r\n                pause.clearTimeout(animateTimeout);\r\n            }\r\n            var ks = Object.keys(elements);\r\n            for (var i = 0; i < ks.length; i++) {\r\n                elements[ks[i]].hide();\r\n                delete elements[ks[i]];\r\n            }\r\n        }\r\n\r\n        // initialize animation elements\r\n        // start animation\r\n        function initElements(options, currentReelSet) {\r\n            var keys = Object.keys(options.model.ws);\r\n            var symbolSet = options.symbolSet;\r\n            var symbols = symbolSet.symbols;\r\n            var animatePositions = [];\r\n            // iterate win positions, generate element for each one\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var ele = options.model.ws[keys[i]];\r\n                var posKeys = Object.keys(ele.post);\r\n                var symKeys = Object.keys(ele.sym);\r\n                for (var z = 0; z < posKeys.length; z++) {\r\n                    var posX = ele.post[posKeys[z]][0];\r\n                    var posY = ele.post[posKeys[z]][1];\r\n                    var symId = ele.sym[symKeys[z]];\r\n                    var posId = '' + posX + posY;\r\n                    var zIndex = (symbols[symId].stayOnTop ? 13 : 12)\r\n                            + posY * .1\r\n                            + (currentReelSet.REELS_COUNT - 1 - posX) * .01;\r\n                    if (animatePositions.indexOf(posId) === -1) {\r\n                        animatePositions.push(posId);\r\n                        initElement({\r\n                            posId: posId,\r\n                            symId: symId,\r\n                            posX: posX,\r\n                            posY: posY,\r\n                            symbols: symbols,\r\n                            symbolData: symbols[symId],\r\n                            symbolSet: symbolSet,\r\n                            reelSet: currentReelSet,\r\n                            zIndex: zIndex\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            queueAnimations(options.timeout);\r\n        }\r\n\r\n        // initialize animation element\r\n        function initElement(data) {\r\n\r\n            var symbolData = data.symbols[data.symId];\r\n            var name = 'reel-anim-' + data.posId;\r\n\r\n            // compute position\r\n            var top = data.reelSet.REELS_CANVAS_TOP\r\n                    + data.symbolSet.ALL_REELS_OFFSET_TOP\r\n                    + data.posY * data.symbolSet.SYMBOL_OUTER_HEIGHT;\r\n            var left = data.reelSet.REELS_CANVAS_LEFT\r\n                    + data.symbolSet.ALL_REELS_OFFSET_LEFT\r\n                    + data.posX * data.symbolSet.SYMBOL_OUTER_WIDTH;\r\n            if (data.symbolSet.SPECIFIC_REELS_OFFSETS_LEFT[data.posX]) {\r\n                left += data.symbolSet.SPECIFIC_REELS_OFFSETS_LEFT[data.posX];\r\n            }\r\n            if (symbolData.offsetX !== undefined) {\r\n                left += symbolData.offsetX;\r\n            }\r\n            if (symbolData.offsetY !== undefined) {\r\n                top += symbolData.offsetY;\r\n            }\r\n            // compute height\r\n            var height;\r\n            if (symbolData.keepProportions) {\r\n                var img = assets.img(symbolData.static);\r\n                var imgH = img.height;\r\n                var imgW = img.width;\r\n                var ratio = imgH / imgW;\r\n                height = data.symbolSet.SYMBOL_DEFAULT_RENDER_HEIGHT * ratio;\r\n                if (symbolData.anchor === 'bottom') {\r\n                    top += data.symbolSet.SYMBOL_DEFAULT_RENDER_HEIGHT - height;\r\n                }\r\n            } else {\r\n                height = symbolData.height || data.symbolSet.SYMBOL_DEFAULT_RENDER_HEIGHT;\r\n            }\r\n            var width = symbolData.width || data.symbolSet.SYMBOL_DEFAULT_RENDER_WIDTH;\r\n\r\n            // store computed values\r\n            data.name = name;\r\n            data.left = left;\r\n            data.top = top;\r\n            data.height = height;\r\n            data.width = width;\r\n            data.offsets = symbolData.offsets;\r\n\r\n            // choose proper animation type\r\n            if (symbolData.animationCycle) {\r\n                elements[name] = getSpriteSheetBasicAnimation(data, symbolData.reverse);\r\n            } else if (symbolData.animationStart) {\r\n                elements[name] = getSpriteSheetWithCrossfadeAnimation(data);\r\n            } else if (symbolData.fromImage) {\r\n                elements[name] = getCrossfadeAnimation(data);\r\n            }\r\n        }\r\n\r\n        // initialize basic sprite sheet animation animating back and forth\r\n        function getSpriteSheetBasicAnimation(data, reverse) {\r\n            var symbolData = data.symbols[data.symId];\r\n            return ReelSymbolAnimationBasic({\r\n                groupCtrl: ctrl,\r\n                name: data.name,\r\n                animationStartPath: symbolData.animationStart,\r\n                animationCyclePath: symbolData.animationCycle,\r\n                totalCycles: symbolData.animationCyclesCount\r\n                        || (data.symbolSet.LOOP_ANIMATION ? 999999 : 1),\r\n                left: data.left,\r\n                top: data.top,\r\n                width: data.width,\r\n                height: data.height,\r\n                offsets: data.offsets,\r\n                canvasLayer: 'top',\r\n                reverse: reverse,\r\n                zIndex: data.zIndex,\r\n                isReelsAreaElement: true,\r\n                spriteOffset: symbolData.spriteOffset\r\n            });\r\n        }\r\n\r\n        // initialize sprite sheet animation followed by crossfade between two images\r\n        function getSpriteSheetWithCrossfadeAnimation(data) {\r\n            var symbolData = data.symbols[data.symId];\r\n            return ReelSymbolAnimationWithCrossfade({\r\n                groupCtrl: ctrl,\r\n                name: data.name,\r\n                animationStartPath: symbolData.animationStart,\r\n                animationCyclePathFrom: symbolData.animationCycleFrom,\r\n                animationCyclePathTo: symbolData.animationCycleTo,\r\n                totalCycles: symbolData.animationCyclesCount\r\n                        || (data.symbolSet.LOOP_ANIMATION ? 999999 : 1),\r\n                left: data.left,\r\n                top: data.top,\r\n                width: data.width,\r\n                height: data.height,\r\n                offsets: data.offsets,\r\n                canvasLayer: 'top',\r\n                zIndex: data.zIndex,\r\n                isReelsAreaElement: true,\r\n                spriteOffset: symbolData.spriteOffset\r\n            });\r\n        }\r\n\r\n        // initialize crossfade animation\r\n        function getCrossfadeAnimation(data) {\r\n            var symbolData = data.symbols[data.symId];\r\n            return ReelSymbolCrossfade({\r\n                groupCtrl: ctrl,\r\n                name: data.name,\r\n                fromImage: symbolData.fromImage,\r\n                toImage: symbolData.toImage,\r\n                left: data.left,\r\n                top: data.top,\r\n                width: data.width,\r\n                height: data.height,\r\n                offsets: data.offsets,\r\n                canvasLayer: 'top',\r\n                isReelsAreaElement: true,\r\n                zIndex: data.zIndex\r\n            });\r\n        }\r\n\r\n        // queue start of the animations\r\n        // fire event when all animations complete\r\n        function queueAnimations(timeout) {\r\n            var ks = Object.keys(elements);\r\n            for (var i = 0; i < ks.length; i++) {\r\n                if (elements[ks[i]].animate) {\r\n                    elements[ks[i]]._left = elements[ks[i]].left;\r\n//                    elements[ks[i]].set({left: -8});\r\n                    elements[ks[i]].set({left: -800});\r\n                    elements[ks[i]].show();\r\n                    elements[ks[i]].animate();\r\n                }\r\n            }\r\n            animateTimeout = pause.setTimeout(function () {\r\n                for (var i = 0; i < ks.length; i++) {\r\n                    if (elements[ks[i]].animate) {\r\n                        elements[ks[i]].stopAnimation();\r\n                        elements[ks[i]].reset && elements[ks[i]].reset();\r\n                        elements[ks[i]].hide();\r\n                        elements[ks[i]].set({left: elements[ks[i]]._left});\r\n                        elements[ks[i]].show();\r\n                        elements[ks[i]].animate();\r\n                    }\r\n                }\r\n            }, timeout);\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/reelsAnimation/reelsAnimationView.js"),eval("// reelsAnimationCtrl\r\n// controls initialization and removal of win symbol animations\r\ndefine('layers/reelsAnimation/reelsAnimationCtrl',[\r\n   'pubsub', 'components/GroupCtrl', 'layers/reelsAnimation/reelsAnimationView',\r\n], function (pubsub, GroupCtrl, reelsAnimationView) {\r\n\r\n\r\n// initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var currentReelSet = null;\r\n\r\n    // view action handlers\r\n    self.viewActions = {\r\n        allAnimationsFinished: function () {\r\n        }\r\n    };\r\n\r\n    self.view = reelsAnimationView(self);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:initReels': function (id, data) {\r\n            currentReelSet = data.reelSet;\r\n        },\r\n        'request:animateWinSymbols': function (id, data) {\r\n            self.view.actions.init(data, currentReelSet);\r\n        },\r\n        'request:pauseWinAnimations': function () {\r\n            self.hideAll();\r\n        },\r\n        'request:resumeWinAnimations': function () {\r\n            var elements = self.view.elements;\r\n            var ks = Object.keys(elements);\r\n            for (var i = 0; i < ks.length; i++) {\r\n                if (elements[ks[i]].animate) {\r\n                    elements[ks[i]].show();\r\n                    elements[ks[i]].animate();\r\n                }\r\n            }\r\n        },\r\n        'request:clearWinAnimations': function (id) {\r\n            self.view.actions.clear();\r\n        },\r\n    });\r\n\r\n    // define action handlers end\r\n\r\n    return self;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/reelsAnimation/reelsAnimationCtrl.js"),eval("define('data/config-animations',[], function () {\r\n    var data = {\r\n        COINS_FRONT_ANIMATION_TOP: 392,\r\n        COINS_FRONT_ANIMATION_WIDTH: 337,\r\n        COINS_FRONT_ANIMATION_HEIGHT: 201,\r\n        COINS_BACK_ANIMATION_TOP: 553,\r\n        COINS_BACK_ANIMATION_WIDTH: 327,\r\n        COINS_BACK_ANIMATION_HEIGHT: 41,\r\n        BIG_WIN_BACK_TOP: 293,\r\n        BIG_WIN_BACK_WIDTH: 742,\r\n        BIG_WIN_BACK_HEIGHT: 477,\r\n        BIG_WIN_CIRCLE_TOP: 285,\r\n        BIG_WIN_CIRCLE_WIDTH: 382,\r\n        BIG_WIN_CIRCLE_HEIGHT: 382,\r\n        WIN_TEXT_TOP: 296,\r\n        BIG_WIN_TEXT_WIDTH: 453,\r\n        BIG_WIN_TEXT_HEIGHT: 258,\r\n        MEGA_WIN_TEXT_WIDTH: 572,\r\n        MEGA_WIN_TEXT_HEIGHT: 258,\r\n        AWESOME_WIN_TEXT_WIDTH: 820,\r\n        AWESOME_WIN_TEXT_HEIGHT: 258,\r\n    };\r\n    return data;\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-animations.js"),eval("define('components/FallingCoinsAnimation',[\r\n    'jquery',\r\n    'pixi',\r\n    'components/Element',\r\n    'services/assets'],\r\n        function (\r\n                $, PIXI, Element, assets) {\r\n\r\n            // basic image\r\n            return function create(options) {\r\n\r\n                function createSingleAnim() {\r\n                    var data = assets.getMovieTexturesData(self.imgPath);\r\n                    var mc = new PIXI.extras.MovieClip(data.textures);\r\n                    mc.frameOffset = data.frameOffset;\r\n                    mc.animationSpeed = 0.60;\r\n                    mc.width = COIN_SIZE;\r\n                    mc.height = COIN_SIZE;\r\n                    mc.visible = true;\r\n                    mc.fallSpeedPerSec = 250 + Math.random() * 250;\r\n                    return mc;\r\n                }\r\n\r\n                function getCoinX(i) {\r\n                    var col = i % COIN_COLS;\r\n                    var x = 45 + ((self.width) / COIN_COLS) * col\r\n                            + ((Math.random() - .5) * 80);\r\n                    return x;\r\n                }\r\n                function getCoinY(i) {\r\n                    var row = Math.floor(i / COIN_COLS);\r\n                    return -300 - self.height - COIN_SIZE\r\n                            +(self.height / COIN_ROWS) * row\r\n                            - (Math.random() * 80);\r\n                }\r\n\r\n                var self = Element(options);\r\n                self.name = options.name || 'FallingCoinsAnimation';\r\n                self.imgPath = 'Control_panel/coin_sheet';\r\n\r\n                var animating = false;\r\n                var el = new PIXI.Container();\r\n                var COIN_COLS = 30;\r\n                var COIN_ROWS = 30;\r\n                var COINS_TOTAL = COIN_COLS * COIN_ROWS;\r\n                var COIN_SIZE = 25;\r\n                var COIN_FRAMES = 39;\r\n\r\n                var pool = [];\r\n\r\n                for (var i = 0; i < COINS_TOTAL; i++) {\r\n                    pool.push(createSingleAnim());\r\n                    el.addChild(pool[i]);\r\n                    pool[i].position.x = getCoinX(i);\r\n                    pool[i].position.y = getCoinY(i);\r\n                }\r\n\r\n                self.update = function (delta) {\r\n                    if (animating) {\r\n                        for (var i = 0; i < pool.length; i++) {\r\n                            pool[i].position.y += delta * pool[i].fallSpeedPerSec;\r\n                            if (pool[i].position.y < -COIN_SIZE) {\r\n                                pool[i].visible = false;\r\n                            } else {\r\n                                pool[i].visible = true;\r\n                            }\r\n                            if (pool[i].position.y > self.height) {\r\n                                pool[i].position.y = -COIN_SIZE;\r\n                                pool[i].position.x = getCoinX(i);\r\n                            }\r\n                        }\r\n                        self.render();\r\n                    }\r\n                };\r\n\r\n                self.animate = function () {\r\n                    animating = true;\r\n                    for (var i = 0; i < pool.length; i++) {\r\n                        pool[i].position.x = getCoinX(i);\r\n                        pool[i].position.y = getCoinY(i);\r\n                        pool[i].gotoAndStop(Math.floor(Math.random() * COIN_FRAMES));\r\n                        pool[i].play();\r\n                    }\r\n                };\r\n\r\n                self.stopAnimation = function () {\r\n                    animating = false;\r\n                    for (var i = 0; i < pool.length; i++) {\r\n                        pool[i].gotoAndStop(0);\r\n                    }\r\n                };\r\n\r\n                self.superHide = self.hide.bind(self);\r\n                self.hide = function () {\r\n                    self.stopAnimation();\r\n                    self.superHide.apply(null, arguments);\r\n                };\r\n\r\n                el.wrapper = self;\r\n                self.pixiEl = el;\r\n\r\n                self.resize();\r\n\r\n                return self;\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/FallingCoinsAnimation.js"),eval("\r\ndefine('layers/animations/animationsView',['jquery',\r\n    'data/config',\r\n    'data/config-animations',\r\n    'components/SpriteSheetAnimation',\r\n    'components/Sprite',\r\n    'components/Rectangle',\r\n    'components/DomRectangle',\r\n    'components/FallingCoinsAnimation',\r\n], function ($, globalConfig, config, SpriteSheetAnimation, Sprite, Rectangle,\r\n        DomRectangle, FallingCoinsAnimation) {\r\n    return function mCreate(ctrl) {\r\n\r\n\r\n        var elements = {\r\n            teaserAnimation: SpriteSheetAnimation({\r\n                groupCtrl: ctrl,\r\n                name: 'teaser-animation',\r\n                imgPath: 'Control_panel/teaser_sheet',\r\n                left: 0,\r\n                top: globalConfig.TEASER_ANIMATION_TOP,\r\n                width: globalConfig.TEASER_ANIMATION_WIDTH,\r\n                height: globalConfig.TEASER_ANIMATION_HEIGHT,\r\n                isReelsAreaElement: true,\r\n                zIndex: 25,\r\n                canvasLayer: 'top',\r\n            }),\r\n            coinsAnimationFront: SpriteSheetAnimation({\r\n                groupCtrl: ctrl,\r\n                name: 'coins-animation-front',\r\n                imgPath: 'Control_panel/coins_sheet',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.COINS_FRONT_ANIMATION_TOP,\r\n                width: config.COINS_FRONT_ANIMATION_WIDTH,\r\n                height: config.COINS_FRONT_ANIMATION_HEIGHT,\r\n                originX: 'center',\r\n                zIndex: 25,\r\n                canvasLayer: 'over',\r\n            }),\r\n            coinsAnimationBack: SpriteSheetAnimation({\r\n                groupCtrl: ctrl,\r\n                name: 'coins-animation-back',\r\n                imgPath: 'Control_panel/WINGLOW_sheet',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.COINS_BACK_ANIMATION_TOP,\r\n                width: config.COINS_BACK_ANIMATION_WIDTH,\r\n                height: config.COINS_BACK_ANIMATION_HEIGHT,\r\n                originX: 'center',\r\n                zIndex: 5,\r\n                canvasLayer: 'over',\r\n            }),\r\n            coinsAnimationWhiteRect: DomRectangle({\r\n                groupCtrl: ctrl,\r\n                name: 'coints-animation-white-rect',\r\n                color: 'white',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.COINS_BACK_ANIMATION_TOP,\r\n                width: config.COINS_BACK_ANIMATION_WIDTH,\r\n                height: config.COINS_BACK_ANIMATION_HEIGHT,\r\n                originX: 'center',\r\n                zIndex: 40,\r\n            }),\r\n            overlayWhite: Rectangle({\r\n                groupCtrl: ctrl,\r\n                name: 'animations-white-overlay',\r\n                color: 0xFFFFFF,\r\n                left: 0,\r\n                top: 0,\r\n                width: globalConfig.CANVAS_BASE_WIDTH,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                zIndex: 7,\r\n                canvasLayer: 'over',\r\n            }),\r\n            overlayBlack: Rectangle({\r\n                groupCtrl: ctrl,\r\n                name: 'animations-black-overlay',\r\n                color: 0x000000,\r\n                left: 0,\r\n                top: 0,\r\n                width: globalConfig.CANVAS_BASE_WIDTH,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                zIndex: 30,\r\n                canvasLayer: 'ui',\r\n            }),\r\n            bigWinBack: Sprite({\r\n                groupCtrl: ctrl,\r\n                name: 'bigwin-back',\r\n                imgPath: 'Control_panel/BIGWIN_bg',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.BIG_WIN_BACK_TOP,\r\n                width: config.BIG_WIN_BACK_WIDTH,\r\n                height: config.BIG_WIN_BACK_HEIGHT,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                zIndex: 6,\r\n                canvasLayer: 'over',\r\n            }),\r\n            bigWinBack2: Sprite({\r\n                groupCtrl: ctrl,\r\n                name: 'bigwin-back',\r\n                imgPath: 'Control_panel/BIGWIN_bg',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.BIG_WIN_BACK_TOP,\r\n                width: config.BIG_WIN_BACK_WIDTH,\r\n                height: config.BIG_WIN_BACK_HEIGHT,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                zIndex: 6,\r\n                canvasLayer: 'over',\r\n            }),\r\n            bigWinCircle: Sprite({\r\n                groupCtrl: ctrl,\r\n                name: 'bigwin-circle',\r\n                imgPath: 'Control_panel/BIGWIN_circle',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.BIG_WIN_CIRCLE_TOP,\r\n                width: config.BIG_WIN_CIRCLE_WIDTH,\r\n                height: config.BIG_WIN_CIRCLE_HEIGHT,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                zIndex: 8,\r\n                canvasLayer: 'over',\r\n            }),\r\n            bigWinText: Sprite({\r\n                groupCtrl: ctrl,\r\n                name: 'bigwin-text',\r\n                imgPath: 'Control_panel/BIGWIN_text',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.WIN_TEXT_TOP,\r\n                width: config.BIG_WIN_TEXT_WIDTH,\r\n                height: config.BIG_WIN_TEXT_HEIGHT,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                zIndex: 9,\r\n                canvasLayer: 'over',\r\n            }),\r\n            megaWinText: Sprite({\r\n                groupCtrl: ctrl,\r\n                name: 'megawin-text',\r\n                imgPath: 'Control_panel/mega-win',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.WIN_TEXT_TOP,\r\n                width: config.MEGA_WIN_TEXT_WIDTH,\r\n                height: config.MEGA_WIN_TEXT_HEIGHT,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                zIndex: 9,\r\n                canvasLayer: 'over',\r\n            }),\r\n            awesomeWinText: Sprite({\r\n                groupCtrl: ctrl,\r\n                name: 'awewin-text',\r\n                imgPath: 'Control_panel/awesome-win',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.WIN_TEXT_TOP,\r\n                width: config.AWESOME_WIN_TEXT_WIDTH,\r\n                height: config.AWESOME_WIN_TEXT_HEIGHT,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                zIndex: 9,\r\n                canvasLayer: 'over',\r\n            }),\r\n            fallingCoinsAnimation: FallingCoinsAnimation({\r\n                groupCtrl: ctrl,\r\n                name: 'coins-animation',\r\n                imgPath: 'Control_panel/WINGLOW_sheet',\r\n                left: 100,\r\n                top: 0,\r\n                width: globalConfig.CANVAS_BASE_WIDTH - 200,\r\n                height: globalConfig.CANVAS_BASE_HEIGHT,\r\n                zIndex: 6,\r\n                canvasLayer: 'over',\r\n            }),\r\n        };\r\n\r\n        // API\r\n        return {\r\n            elements: elements\r\n        };\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/animations/animationsView.js"),eval("// backgroundCtrl\r\n// controls background images\r\n// and clickable transparent reel overlay used to intercept pointer events over reels\r\ndefine('layers/animations/animationsCtrl',[\r\n    'pubsub', 'components/GroupCtrl',\r\n    'layers/animations/animationsView',\r\n    'data/config',\r\n    'data/config-animations',\r\n    'services/pause',\r\n    'tweenjs',\r\n], function (pubsub, GroupCtrl, animationsView, globalConfig, config, pause, createjs) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n\r\n    var animations = [];\r\n\r\n    self.viewActions = {\r\n    };\r\n\r\n    // initialize view\r\n    self.view = animationsView(self);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:playCoinsAnimation': playCoinsAnimation,\r\n        'request:playTeaserAnimation': playTeaserAnimation,\r\n        'request:playBigWinAnimation': playBigWinAnimation,\r\n        'notify:fasterSpinStarted': playTeaserAnimation,\r\n        'notify:spinFinished': playTeaserAnimation,\r\n    });\r\n\r\n    var superUpdate = self.update.bind(self);\r\n    self.update = function (delta) {\r\n        superUpdate.apply(null, arguments);\r\n        if (animations.length) {\r\n            for (var i = 0; i < animations.length; i++) {\r\n                if (!animations[i].update(delta)) {\r\n                    animations.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    self.view.elements.coinsAnimationFront.set({opacity: .01});\r\n    self.view.elements.coinsAnimationFront.show();\r\n\r\n    function playCoinsAnimation(id, data) {\r\n        function playWinFlashAnimation(type) {\r\n            function playShortAnim() {\r\n                self.view.elements.coinsAnimationBack.set({opacity: 1});\r\n                self.view.elements.coinsAnimationBack.show();\r\n                self.view.elements.coinsAnimationBack.animate({\r\n                    cycles: 1,\r\n                    callback: function () {\r\n                        self.view.elements.coinsAnimationBack.fadeOut();\r\n                    }\r\n                });\r\n            }\r\n            function playBackgroundFlashes() {\r\n                var path;\r\n                if (type === 2) {\r\n                    path = [\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 2},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 2},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 18},\r\n                    ];\r\n                } else if (type === 3) {\r\n                    path = [\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 2},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 2},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 2},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 2},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 3},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 2},\r\n                        {alpha: .699, delay: 1},\r\n                        {alpha: 0, delay: 19},\r\n                    ];\r\n                }\r\n                self.view.elements.coinsAnimationWhiteRect.set({\r\n                    opacity: .699\r\n                });\r\n                self.view.elements.coinsAnimationWhiteRect.show();\r\n                var passedS = 0;\r\n                var step = 0;\r\n                var stepProgress, stepDiff, prevStepAlpha;\r\n                var timeFrameMs = 1 / 30 * 1000;\r\n                animations.push({\r\n                    update: function (delta) {\r\n                        passedS += delta * 1000;\r\n                        while (passedS > path[step].delay * timeFrameMs) {\r\n                            passedS -= path[step].delay * timeFrameMs;\r\n                            step += 1;\r\n                            if (!path[step]) {\r\n                                self.view.elements.coinsAnimationWhiteRect.hide();\r\n                                return false;\r\n                            }\r\n                        }\r\n                        stepProgress = passedS / (path[step].delay * timeFrameMs);\r\n                        prevStepAlpha = path[step - 1] ? path[step - 1].alpha : 0;\r\n                        stepDiff = path[step].alpha - prevStepAlpha;\r\n                        self.view.elements.coinsAnimationWhiteRect.set({\r\n                            opacity: prevStepAlpha + stepProgress * stepDiff,\r\n                        });\r\n                        return true;\r\n                    }\r\n                });\r\n            }\r\n            if (type === 1) {\r\n                playShortAnim();\r\n            } else {\r\n                playBackgroundFlashes();\r\n            }\r\n        }\r\n        function playCycle() {\r\n            self.view.elements.coinsAnimationFront.set({opacity: 1});\r\n            self.view.elements.coinsAnimationFront.show();\r\n            self.view.elements.coinsAnimationFront.animate({\r\n                cycles: 1,\r\n                callback: function () {\r\n                    cyclesPassed += 1;\r\n                    self.view.elements.coinsAnimationBack.hide();\r\n                    self.view.elements.coinsAnimationFront.hide();\r\n                    if (cyclesPassed < data.repeat) {\r\n                        pause.setTimeout(function () {\r\n                            playCycle();\r\n                            if (cyclesPassed === 2) {\r\n                                playWinFlashAnimation(1);\r\n                            }\r\n                        }, 0);\r\n                    }\r\n                }});\r\n        }\r\n        var cyclesPassed = 0;\r\n        playCycle();\r\n        playWinFlashAnimation(data.flashType);\r\n    }\r\n\r\n\r\n\r\n    function playBigWinAnimation(id, data) {\r\n\r\n\r\n        var textElement;\r\n        if (data.winType === 'big') {\r\n            textElement = self.view.elements.bigWinText;\r\n        } else if (data.winType === 'mega') {\r\n            textElement = self.view.elements.megaWinText;\r\n        } else if (data.winType === 'awesome') {\r\n            textElement = self.view.elements.awesomeWinText;\r\n        }\r\n\r\n        textElement.set({\r\n            scaleX: 1.2,\r\n            scaleY: 1.2,\r\n        });\r\n        textElement.show();\r\n        var textTween = createjs.Tween.get(textElement)\r\n                .to({scaleX: 0.95, scaleY: 0.95}, 5)\r\n                .to({scaleX: 1, scaleY: 1}, 2)\r\n                .to({startPosition: 0}, 56)\r\n                .to({scaleX: 1.1, scaleY: 1.1}, 14)\r\n                .to({scaleX: 1, scaleY: 1}, 32)\r\n                .to({scaleX: 1.1, scaleY: 1.1}, 15)\r\n                .to({scaleX: 1, scaleY: 1}, 32)\r\n                .to({scaleX: 1.1, scaleY: 1.1}, 15)\r\n                .to({scaleX: 1, scaleY: 1}, 33)\r\n                .wait(1);\r\n        textTween.addEventListener(\"change\", textElement.resize.bind(\r\n                textElement));\r\n\r\n        self.view.elements.bigWinCircle.set({\r\n            scaleX: .75,\r\n            scaleY: .75,\r\n        });\r\n        self.view.elements.bigWinCircle.show();\r\n        var circleTween = createjs.Tween.get(self.view.elements.bigWinCircle)\r\n                .to({scaleX: 1.05, scaleY: 1.05}, 5)\r\n                .to({scaleX: 1, scaleY: 1}, 2)\r\n                .to({startPosition: 0}, 56)\r\n                .to({scaleX: 0.95, scaleY: 0.95}, 14)\r\n                .to({scaleX: 1, scaleY: 1}, 32)\r\n                .to({scaleX: 0.95, scaleY: 0.95}, 15)\r\n                .to({scaleX: 1, scaleY: 1}, 32)\r\n                .to({scaleX: 0.95, scaleY: 0.95}, 15)\r\n                .to({scaleX: 1, scaleY: 1}, 33)\r\n                .wait(1);\r\n        circleTween.addEventListener(\"change\", self.view.elements.bigWinCircle.resize.bind(\r\n                self.view.elements.bigWinCircle));\r\n\r\n\r\n        self.view.elements.overlayWhite.set({\r\n            opacity: .001,\r\n        });\r\n        self.view.elements.overlayWhite.show();\r\n        var whiteTween = createjs.Tween.get(self.view.elements.overlayWhite)\r\n                .to({opacity: 0.699}, 16)\r\n                .to({opacity: 0}, 30)\r\n                .wait(158);\r\n        whiteTween.addEventListener(\"change\", self.view.elements.overlayWhite.resize.bind(\r\n                self.view.elements.overlayWhite));\r\n\r\n        self.view.elements.overlayBlack.set({\r\n            opacity: .001,\r\n        });\r\n        self.view.elements.overlayBlack.show();\r\n        var blackTween = createjs.Tween.get(self.view.elements.overlayBlack)\r\n                .wait(41)\r\n                .to({opacity: 0.75}, 22)\r\n                .wait(142);\r\n        blackTween.addEventListener(\"change\", self.view.elements.overlayBlack.resize.bind(\r\n                self.view.elements.overlayBlack));\r\n\r\n\r\n        pause.setTimeout(function () {\r\n            self.view.elements.bigWinBack.set({\r\n                opacity: .01,\r\n                rotate: -4,\r\n            });\r\n            self.view.elements.bigWinBack.show();\r\n            var backTween = createjs.Tween.get(self.view.elements.bigWinBack)\r\n                    .to({rotate: -2, opacity: 1}, 14)\r\n                    .to({rotate: 4, opacity: 0}, 32)\r\n                    .wait(1);\r\n            backTween.loop = true;\r\n            backTween.addEventListener(\"change\", self.view.elements.bigWinBack.resize.bind(\r\n                    self.view.elements.bigWinBack));\r\n\r\n            self.view.elements.bigWinBack2.set({\r\n                opacity: 1,\r\n                rotate: -4,\r\n            });\r\n            self.view.elements.bigWinBack2.show();\r\n            var back2Tween = createjs.Tween.get(self.view.elements.bigWinBack2)\r\n                    .wait(47);\r\n            back2Tween.loop = true;\r\n            back2Tween.addEventListener(\"change\", self.view.elements.bigWinBack2.resize.bind(\r\n                    self.view.elements.bigWinBack2));\r\n        }, 16 * (1000 / 30));\r\n\r\n        pause.setTimeout(function () {\r\n            createjs.Tween.removeAllTweens();\r\n\r\n            var textTween = createjs.Tween.get(textElement)\r\n                    .to({scaleX: 0.01, scaleY: 0.01}, 10);\r\n            textTween.addEventListener(\"change\", textElement.resize.bind(\r\n                    textElement));\r\n\r\n            var circleTween = createjs.Tween.get(self.view.elements.bigWinCircle)\r\n                    .to({scaleX: 0.01, scaleY: 0.01}, 10);\r\n            circleTween.addEventListener(\"change\", self.view.elements.bigWinCircle.resize.bind(\r\n                    self.view.elements.bigWinCircle));\r\n\r\n            var whiteTween = createjs.Tween.get(self.view.elements.overlayWhite)\r\n                    .to({opacity: 0.699}, 5)\r\n                    .to({opacity: 0}, 5);\r\n            whiteTween.addEventListener(\"change\", self.view.elements.overlayWhite.resize.bind(\r\n                    self.view.elements.overlayWhite));\r\n\r\n            var blackTween = createjs.Tween.get(self.view.elements.overlayBlack)\r\n                    .to({opacity: 0}, 5);\r\n            blackTween.addEventListener(\"change\", self.view.elements.overlayBlack.resize.bind(\r\n                    self.view.elements.overlayBlack));\r\n\r\n            var backTween = createjs.Tween.get(self.view.elements.bigWinBack)\r\n                    .to({opacity: 0}, 5);\r\n            backTween.addEventListener(\"change\", self.view.elements.bigWinBack.resize.bind(\r\n                    self.view.elements.bigWinBack));\r\n\r\n            var back2Tween = createjs.Tween.get(self.view.elements.bigWinBack2)\r\n                    .to({opacity: 0}, 5);\r\n            back2Tween.addEventListener(\"change\", self.view.elements.bigWinBack2.resize.bind(\r\n                    self.view.elements.bigWinBack2));\r\n\r\n            pause.setTimeout(function () {\r\n                createjs.Tween.removeAllTweens();\r\n                self.view.elements.overlayBlack.hide();\r\n                self.view.elements.overlayWhite.hide();\r\n                textElement.hide();\r\n                self.view.elements.bigWinCircle.hide();\r\n                self.view.elements.bigWinBack.hide();\r\n                self.view.elements.bigWinBack2.hide();\r\n            }, 10 * (1000 / 30));\r\n        }, 185 * (1000 / 30));\r\n    }\r\n\r\n    function playTeaserAnimation(id, data) {\r\n        if (data.reelIndex === undefined) {\r\n            self.view.elements.teaserAnimation.fadeOut(null, 200);\r\n        } else {\r\n            self.view.elements.teaserAnimation.set({\r\n                left: globalConfig.TEASER_ANIMATION_LEFT[data.reelIndex]\r\n            });\r\n            self.view.elements.teaserAnimation.show();\r\n            self.view.elements.teaserAnimation.animate();\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    return self;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/layers/animations/animationsCtrl.js"),
eval("define('data/config-freeSpin',{\r\n    BANNER_LEFT: 475,\r\n    BANNER_TOP: 50,\r\n    BANNER_WIDTH: 1025,\r\n    BANNER_HEIGHT: 490,\r\n    WELCOME_TEXT_TOP: 278,\r\n    WELCOME_TEXT_FONT_SIZE: 45,\r\n    YOU_WON_TEXT_TOP: 230,\r\n    YOU_WON_TEXT_FONT_SIZE: 55,\r\n    CREDITS_TEXT_TOP: 282,\r\n    CREDITS_TEXT_FONT_SIZE: 68,\r\n    SPIN_TEXT_TOP: 536,\r\n    SPIN_TEXT_FONT_SIZE: 18,\r\n    WELCOME_TEXT_STYLE: {type: 'bitmap', font: 'red'},\r\n});\r\n\n//# sourceURL=/modules/Vikings/src/js/data/config-freeSpin.js"),eval("// freeSpinView\r\n// contains free game related elements\r\ndefine('layers/freeSpin/freeSpinView',['data/config',\r\n    'data/config-menu',\r\n    'data/config-freeSpin',\r\n    'services/format',\r\n    'components/Text',\r\n    'components/Sprite',\r\n], function (globalConfig, menuConfig, config, format, Text, Sprite) {\r\n\r\n    return function mCreate(ctrl) {\r\n\r\n        var elements = {\r\n            banner: Sprite({\r\n                groupCtrl: ctrl,\r\n                name: 'free-spin-banner',\r\n                imgPath: 'win_table_bkg',\r\n                left: config.BANNER_LEFT,\r\n                top: config.BANNER_TOP,\r\n                width: config.BANNER_WIDTH,\r\n                height: config.BANNER_HEIGHT,\r\n                originX: 'center',\r\n                isReelsAreaElement: true,\r\n                zIndex: 7.5,\r\n                canvasLayer: 'ui'\r\n            }),\r\n            welcomeText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'free-spin-banner-welcome-text',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.WELCOME_TEXT_TOP,\r\n                text: '',\r\n                fontSize: config.WELCOME_TEXT_FONT_SIZE,\r\n                style: config.WELCOME_TEXT_STYLE,\r\n                originX: 'center',\r\n                textAlign: 'center',\r\n                isReelsAreaElement: true,\r\n                zIndex: 9,\r\n                canvasLayer: 'ui'\r\n            }),\r\n            youWonText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'free-spin-banner-you-won-text',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.YOU_WON_TEXT_TOP,\r\n                text: 'youWon',\r\n                fontSize: config.YOU_WON_TEXT_FONT_SIZE,\r\n                style: config.WELCOME_TEXT_STYLE,\r\n                originX: 'center',\r\n                textAlign: 'center',\r\n                isReelsAreaElement: true,\r\n                zIndex: 9,\r\n                canvasLayer: 'ui'\r\n            }),\r\n            creditsText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'free-spin-banner-credits-text',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: config.CREDITS_TEXT_TOP,\r\n                text: '',\r\n                fontSize: config.CREDITS_TEXT_FONT_SIZE,\r\n                style: config.WELCOME_TEXT_STYLE,\r\n                originX: 'center',\r\n                formatter: format.formatAmountWithDenom,\r\n                textAlign: 'center',\r\n                isReelsAreaElement: true,\r\n                zIndex: 9,\r\n                canvasLayer: 'ui'\r\n            }),\r\n            spinText: Text({\r\n                groupCtrl: ctrl,\r\n                name: 'free-spin-banner-spin-text',\r\n                left: globalConfig.CANVAS_BASE_WIDTH / 2,\r\n                top: menuConfig.BOTTOM_TEXT_TOP,\r\n                fontSize: menuConfig.BOTTOM_TEXT_FONT_SIZE,\r\n                text: 'pleasePressSpin',\r\n                style: {\r\n                    type: 'css',\r\n                    font: 'myriadpro-semiext',\r\n                    lineHeight: 1,\r\n                    color: 'white',\r\n                },\r\n                originX: 'center',\r\n                canvasLayer: 'ui',\r\n                zIndex: 15,\r\n            }),\r\n        };\r\n\r\n        // API\r\n        return {\r\n            elements: elements,\r\n            actions: {}\r\n        };\r\n\r\n    };\r\n});\n//# sourceURL=/modules/Vikings/src/js/layers/freeSpin/freeSpinView.js"),eval("// freeSpinCtrl\r\n// controls free game intro and outro animations\r\ndefine('layers/freeSpin/freeSpinCtrl',[\r\n    'pubsub',\r\n    'components/GroupCtrl',\r\n    'data/config',\r\n    'services/pause',\r\n    'layers/freeSpin/freeSpinView',\r\n], function (pubsub, GroupCtrl, globalConfig, pause, freeSpinView) {\r\n\r\n    // initialize self\r\n    var self = GroupCtrl();\r\n    // view action handlers\r\n    self.viewActions = {};\r\n    // initialize view\r\n    self.view = freeSpinView(self);\r\n\r\n    // define action handlers start\r\n    pubsub.subscribeBatch({\r\n        'request:showFreeSpinBanner': function (id, data) {\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: globalConfig.FREE_GAME_START_SOUND,\r\n                alt: globalConfig.LIGHWEIGHT_FG_INTRO_SOUND,\r\n            });\r\n            var msg = ['!' + data.lastSpinResult.freeSpinsRemaining,\r\n                'freeGamesWelcome'];\r\n            self.view.elements.welcomeText.setText(msg);\r\n            self.view.elements.welcomeText.show();\r\n            self.view.elements.youWonText.show();\r\n            self.view.elements.banner.show();\r\n            pause.setTimeout(function () {\r\n                self.view.elements.spinText.show();\r\n                self.view.elements.spinText.blink();\r\n                if (data.callback) {\r\n                    data.callback();\r\n                }\r\n            }, 250);\r\n        },\r\n        'request:showFreeSpinAdditionalBanner': function (id, data) {\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: globalConfig.FREE_GAME_ADDITIONAL_SOUND || globalConfig.FREE_GAME_START_SOUND,\r\n                alt: globalConfig.LIGHWEIGHT_FG_INTRO_SOUND,\r\n            });\r\n            var msg = ['!' + data.lastSpinResult.freeSpinsAdditional,\r\n                'moreFreeGames'];\r\n            self.view.elements.welcomeText.setText(msg);\r\n            self.view.elements.youWonText.show();\r\n            self.view.elements.welcomeText.show();\r\n            self.view.elements.banner.show();\r\n        },\r\n        'request:showFreeSpinOverBanner': function (id, data) {\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: globalConfig.FREE_GAME_ENDED_SOUND,\r\n                alt: globalConfig.LIGHWEIGHT_FG_INTRO_SOUND,\r\n            });\r\n            self.view.elements.creditsText.setText('!' + data.totalWin);\r\n            self.view.elements.youWonText.show();\r\n            self.view.elements.creditsText.show();\r\n            self.view.elements.banner.show();\r\n        },\r\n        'request:clearFreeSpinBanner': function (id, data) {\r\n            self.hideAll();\r\n            self.view.elements.welcomeText.setText('');\r\n            self.view.elements.creditsText.setText('');\r\n        },\r\n        'request:clearFreeSpin': function (id, data) {\r\n            self.hideAll();\r\n            self.view.elements.welcomeText.setText('');\r\n            self.view.elements.creditsText.setText('');\r\n        },\r\n    });\r\n\r\n    return self;\r\n\r\n});\n//# sourceURL=/modules/Vikings/src/js/layers/freeSpin/freeSpinCtrl.js"),eval("// loader\r\n// displays and hides loader animation\r\n// controls HTML dialog which displays messages to user\r\ndefine('services/loader',[\r\n    'jquery', 'pubsub', 'services/i18n',\r\n    'data/config',\r\n    'services/platform',\r\n    'services/assets',\r\n    'data/config-mainButtons',\r\n    'services/dimensions',\r\n    'services/settings',\r\n],\r\n        function ($, pubsub, i18n, globalConfig, platform, assets,\r\n                mainButtonsConfig, dimensions, settings) {\r\n            function showDisconnectDialog(txtLabel, opts) {\r\n                opts = opts || {};\r\n                $html.removeClass('loader-overlay-visible');\r\n                $preloader.hide();\r\n                showDialog({\r\n                    align: opts.align || 'left',\r\n                    text: i18n.localize(txtLabel),\r\n                    buttonLeft: i18n.localize('endGame'),\r\n//                    buttonRight: i18n.localize('reload'),\r\n                    buttonLeftAction: function () {\r\n                        pubsub.publish('request:quitToLobby');\r\n                    },\r\n//                    buttonRightAction: function () {\r\n//  console.log(2134124);   document.location.href='../../../';                 pubsub.publish('request:reloadGame');\r\n//                    },\r\n                    loader: false\r\n                });\r\n            }\r\n\r\n            var tickSrc, crossSrc;\r\n\r\n            var startupFinished = false;\r\n\r\n            var dialogQueue = [];\r\n\r\n            // cache DOM elements\r\n            var $html = $('html');\r\n            var $glass = $('#glass-layer');\r\n            var $preloader = $('#preloader');\r\n\r\n            var $dialog = $('#dialog');\r\n            var $buttonRight = $('#buttonRight');\r\n            var $buttonLeft = $('#buttonLeft');\r\n            var $buttonOk = $('#buttonOk');\r\n            var $dialogText = $('#dialogText');\r\n            var $simpleTextMsg = $('#simpleTextMsg');\r\n            var lastDisplayedDialogOptions = null;\r\n            // bind dialog buttons\r\n            var evt = platform.isMobile() ? 'touchend' : 'click';\r\n            // event handlers\r\n            pubsub.subscribeBatch({\r\n                'notify:startupInitialized': function (id, data) {\r\n                    tickSrc = assets.img('Control_panel/buttons/modal-yes').baseTexture.imageUrl;\r\n                    crossSrc = assets.img('Control_panel/buttons/modal-no').baseTexture.imageUrl;\r\n                    $buttonOk.css('background-image', 'url(\"' + tickSrc + '\")');\r\n                },\r\n                'notify:dimensionsChanged': function (id, data) {\r\n                    if (startupFinished && $preloader.is(':visible')) {\r\n                        adjustPreloaderPosition();\r\n                    }\r\n                },\r\n                'notify:gameVisible': function (id, data) {\r\n                    startupFinished = true;\r\n                },\r\n                'notify:websocketDisconnectedError': function (id, data) {\r\n                    showDisconnectDialog('connectionError');\r\n                },\r\n                // fires when there is a connection problem\r\n                'notify:connectionError': function (id, data) {\r\n                    showDisconnectDialog('connectionError');\r\n                },\r\n                // insufficient balance\r\n                'notify:insufficientBalanceError': function (id, data) {\r\n                    showDisconnectDialog('insufficientBalanceError', {\r\n                        align: 'center',\r\n                    });\r\n                },\r\n                // current bet is not valid any more\r\n                'notify:betInvalidError': function (id, data) {\r\n                    showDisconnectDialog('betInvalidError', {\r\n                        align: 'center',\r\n                    });\r\n                },\r\n                // fires when there is a connection problem\r\n                'request:showAlert': function (id, data) {\r\n                    data.text = i18n.localize(data.text);\r\n                    showDialog(data);\r\n                },\r\n                // fires on startup when we detect that the browser is outdated\r\n                'request:alertOutdated': function (id, data) {\r\n                    showDialog({\r\n                        text: i18n.localize('browserIsOutdated'),\r\n                        buttonOk: function () {\r\n                            pubsub.publish('request:quitToLobby');\r\n                        },\r\n                    });\r\n                },\r\n                // request to show loader\r\n                'request:showLoader': function (id, data) {\r\n                    showLoader(data);\r\n                },\r\n                // request to hide loader\r\n                'request:hideLoader': function (id, data) {\r\n                    $html.removeClass('loader-overlay-visible');\r\n                    $preloader.hide();\r\n                    $simpleTextMsg.hide();\r\n                },\r\n                'request:showDialog': function (id, data) {\r\n                    showDialog(data);\r\n                },\r\n                'request:hideDialog': function (id, data) {\r\n                    hideDialog();\r\n                }\r\n            });\r\n            return {};\r\n            function showLoader(options) {\r\n                if (startupFinished) {\r\n                    showSimpleText(i18n.localize(options.label || 'loaderConnecting'));\r\n                    adjustPreloaderPosition();\r\n                }\r\n                $html.addClass('loader-overlay-visible');\r\n                $preloader.show();\r\n            }\r\n            function showDialog(options) {\r\n                if ($dialog.is(':visible')\r\n                        && JSON.stringify(lastDisplayedDialogOptions)\r\n                        === JSON.stringify(options)) {\r\n                    return;\r\n                }\r\n                lastDisplayedDialogOptions = options;\r\n                hideDialog();\r\n                if (options.text\r\n                        && ((options.buttonRight && options.buttonLeft) ||\r\n                                options.buttonLeft || options.buttonOk)) {\r\n                    if (options.text) {\r\n                        $dialogText.removeClass('one-liner');\r\n                        $dialogText.html(options.text).show();\r\n                        if (options.oneLiner) {\r\n                            $dialogText.addClass('one-liner');\r\n                        }\r\n                        $dialogText.css('text-align', options.align);\r\n                    }\r\n                    if (options.buttonRight && options.buttonLeft) {\r\n                        $buttonRight.off().click(function () {\r\n                            options.buttonRightAction && options.buttonRightAction();\r\n                            hideDialog();\r\n                        });\r\n                        if (options.buttonRight === 'tick') {\r\n                            $buttonRight.html('').css('background-image', 'url(\"'\r\n                                    + tickSrc + '\")').show();\r\n                        } else {\r\n                            $buttonRight.css('background-image', '').html(options.buttonRight).show();\r\n                        }\r\n                        $buttonLeft.off().click(function () {\r\n                            options.buttonLeftAction && options.buttonLeftAction();\r\n                            hideDialog();\r\n                        });\r\n                        if (options.buttonLeft === 'cross') {\r\n                            $buttonLeft.html('').css('background-image', 'url(\"'\r\n                                    + crossSrc + '\")').show();\r\n                        } else {\r\n                            $buttonLeft.css('background-image', '').html(options.buttonLeft).show();\r\n                        }\r\n                    } else if (options.buttonLeft) {\r\n                        $buttonLeft.off().click(function () {\r\n                            options.buttonLeftAction && options.buttonLeftAction();\r\n                            hideDialog();\r\n                        });\r\n                        $buttonLeft.addClass('only-button');\r\n                        $buttonLeft.css('background-image', '').html(options.buttonLeft).show();\r\n                    }\r\n                    if (options.buttonOk) {\r\n                        $buttonOk.off().click(function () {\r\n                            options.buttonOk();\r\n                            hideDialog();\r\n                        }).show();\r\n                    }\r\n//                    var wh = window.innerHeight ? window.innerHeight : $(window).height();\r\n//                    $dialog.css({\r\n//                        top: wh / 2 - $dialog.outerHeight() / 2 + 'px'\r\n//                    });\r\n                    $html.addClass('dialog-overlay-visible');\r\n                    $dialog.show();\r\n                    $glass.show();\r\n                }\r\n            }\r\n\r\n            function showSimpleText(txt) {\r\n                $simpleTextMsg.hide();\r\n                $simpleTextMsg.text(txt);\r\n                $simpleTextMsg.css({\r\n                    'margin-left': -$simpleTextMsg.width() / 2 + 'px',\r\n                    'margin-top': -$simpleTextMsg.height() / 2 + 'px',\r\n                });\r\n                $simpleTextMsg.show();\r\n            }\r\n\r\n            function hideDialog() {\r\n                $html.removeClass('dialog-overlay-visible');\r\n                $dialog.hide().removeClass('loaderVisible');\r\n                $buttonRight.hide().empty();\r\n                $buttonLeft.hide().empty().removeClass('only-button');\r\n                $buttonOk.hide().empty();\r\n                $dialogText.hide().empty();\r\n                $glass.hide();\r\n                $simpleTextMsg.hide();\r\n            }\r\n\r\n            function adjustPreloaderPosition() {\r\n                var left = settings.get().graphics.lefthand ?\r\n                        mainButtonsConfig.LEFT_CONTROL_BUTTON_LEFT\r\n                        : mainButtonsConfig.RIGHT_CONTROL_BUTTON_LEFT;\r\n                var top = mainButtonsConfig.CONTROL_BUTTON_TOP;\r\n                var width = mainButtonsConfig.CONTROL_BUTTON_WIDTH;\r\n                var height = mainButtonsConfig.CONTROL_BUTTON_HEIGHT;\r\n\r\n                left -= mainButtonsConfig.CONTROL_BUTTON_WIDTH / 2;\r\n                top -= mainButtonsConfig.CONTROL_BUTTON_HEIGHT / 2;\r\n\r\n                left *= dimensions.canvasScaleX;\r\n                top *= dimensions.canvasScaleY;\r\n                width *= dimensions.canvasScaleX;\r\n                height *= dimensions.canvasScaleY;\r\n\r\n                top += dimensions.topLevelWrappersOffsetY;\r\n                top += dimensions.moveTop;\r\n                left += dimensions.topLevelWrappersOffsetX;\r\n\r\n                if (dimensions.moveTop) {\r\n                    top += dimensions.moveTop;\r\n                } else {\r\n                    top -= dimensions.topLevelWrappersOffsetY\r\n                            - dimensions.topLevelWrappersOffsetBottom;\r\n                }\r\n                $preloader.find('img').css({\r\n                    left: left + 'px',\r\n                    top: top + 'px',\r\n                    height: height + 'px',\r\n                    width: width + 'px',\r\n                    'margin-left': '0',\r\n                    'margin-top': '0',\r\n                });\r\n                $simpleTextMsg.css({\r\n                    'margin-left': -$simpleTextMsg.width() / 2 + 'px',\r\n                    'margin-top': -$simpleTextMsg.height() / 2 + 'px',\r\n                });\r\n\r\n            }\r\n\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/services/loader.js"),eval('"use strict";\r\ndefine(\'services/websocket\',[\'pubsub\', \'services/platform\'], function (pubsub, platform) {\r\n\r\n    function urlParam(name)\r\n    {\r\n        var results = new RegExp(\'[\\?&]\' + name + \'=([^&#]*)\').exec(window.location.href);\r\n        if (results == null)\r\n        {\r\n            return null;\r\n        } else\r\n        {\r\n            return results[1] || 0;\r\n        }\r\n    }\r\n\r\n    function errorCheck(body, cb) {\r\n        if (body.payload && body.payload[\'@type\'] === \'InvocationError\') {\r\n            if (body.payload.code === \'InsufficientFundsException\') {\r\n                pubsub.publish(\'notify:insufficientBalanceError\');\r\n                return;\r\n            }\r\n            if (body.payload.code === \'GLE_Invalid_Betting_Parameters\') {\r\n                pubsub.publish(\'notify:betInvalidError\');\r\n                return;\r\n            }\r\n        }\r\n        cb();\r\n    }\r\n\r\n    var windowClosed = false;\r\n\r\n    var Organic = {};\r\n    console.log("main");\r\n\r\n    Organic.Client = function () {\r\n        console.log("creating Organic.Client");\r\n\r\n        //>>includeStart("debug", pragmas.debug);\r\n        if (window.location.host.indexOf(\'10.11.43.6\') > -1) {\r\n            return;\r\n        }\r\n        //>>includeEnd("debug");\r\n\r\n        var port = window.location.port ? \':\' + window.location.port : \'\';\r\n        var protocol = window.location.protocol.indexOf(\'https\') > -1 ? \'wss\' :\r\n                \'ws\';\r\n        var settings = {\r\n            endpoint: protocol + "://"\r\n                    + window.location.host\r\n                    + port\r\n                    + "/organic/websocket/endpoint",\r\n            sessionQueryParam: "session",\r\n            element: "content"\r\n        };\r\n\r\n        this.settings = settings;\r\n\r\n        var self = this;\r\n        var endpoint = settings.endpoint + "?session="\r\n                + urlParam(settings.sessionQueryParam) + "&sign=" + urlParam("sign");\r\n        this.endpoint = endpoint;\r\n        console.log(\'endpoint\', endpoint);\r\n        var socket = new WebSocket(sserver);\r\n        this.socket = socket;\r\n        socket.onopen = function () {\r\n            console.log("Connection established");\r\n            connectCb && connectCb();\r\n        };\r\n\r\n        socket.onmessage = function (event) {\r\n            console.log("onMessage: ", event);\r\n            var jsn=event.data.substring(event.data.indexOf("{"), event.data.length);         var body = JSON.parse(jsn);\r\n\r\n            var method = "on" + body["@type"];\r\n\r\n            var callback = settings[method] || self[method];\r\n\r\n            errorCheck(body, function () {\r\n                if (callback !== undefined)\r\n                {\r\n                    callback.apply(self, [body]);\r\n                } else if (method === \'onMessage\') {\r\n                    defaultMsgHandler(body.payload || {});\r\n                } else {\r\n                    console.log("Undefined callback for", body, "method", method);\r\n                }\r\n            })\r\n\r\n\r\n\r\n        };\r\n\r\n        socket.onclose = function (e) {\r\n            console.log("Websocket Connection closed", e);\r\n            pubsub.publish(\'notify:connectionError\');\r\n        };\r\n\r\n        socket.onerror = function (e) {\r\n            console.log(\'Websocket Error\', e);\r\n            pubsub.publish(\'notify:connectionError\');\r\n        };\r\n\r\n        this.send = function (body)\r\n        {\r\n   body.game="vikings"; body.sessionKey=GetCookie("PHPSESSID");          var json = JSON.stringify(body);\r\n            socket.send(json);\r\n        };\r\n\r\n        this.close = function () {\r\n            socket.close();\r\n        };\r\n\r\n        this.openSocket = function () {\r\n            socket = new WebSocket(sserver);\r\n            self.socket = socket;\r\n        };\r\n\r\n\r\n        this.methodInvocations = {\r\n            /// map: requestId(string) -> callback(response)\r\n            methodInvocationRequests: {}\r\n            /// used to search for next available id for request\r\n            , methodInvocationNextRequestId: 0\r\n\r\n            , incrementNextRequestId: function () {\r\n                var incrementedRequestId = this.methodInvocationNextRequestId + 1;\r\n                var isIncrementOk = (incrementedRequestId > this.methodInvocationNextRequestId);\r\n                var requestIdLimit = 1e9; ///< some big number\r\n                if (!isIncrementOk || (incrementedRequestId >= requestIdLimit)) {\r\n                    incrementedRequestId = 0;\r\n                }\r\n                if (incrementedRequestId == this.methodInvocationNextRequestId) {\r\n                    throw "Couldn\'t increment request id";\r\n                }\r\n                this.methodInvocationNextRequestId = incrementedRequestId;\r\n            }\r\n\r\n            , findNextPossibleRequestId: function () {\r\n                while (this.methodInvocationNextRequestId.toString() in this.methodInvocationRequests) {\r\n                    this.incrementNextRequestId();\r\n                }\r\n                return this.methodInvocationNextRequestId;\r\n            }\r\n\r\n            /// throws if there are too many unprocessed requests\r\n            , checkRequestsAmountLimits: function () {\r\n                var requestsInProcessing = this.methodInvocationRequests.length;\r\n                var maxNumOfUnprocessedRequests = 1000; ///< just some number\r\n                if (requestsInProcessing > maxNumOfUnprocessedRequests) {\r\n                    var error = "WebSocket is overloaded with " + requestsInProcessing + " requests";\r\n                    console.error(error);\r\n                    throw error;\r\n                }\r\n            }\r\n\r\n            , getNextMethodInvocationRequestId: function () {\r\n                this.checkRequestsAmountLimits();\r\n                return this.findNextPossibleRequestId();\r\n            }\r\n\r\n            , registerMethodInvocation: function (requestId, onResponse) {\r\n                this.methodInvocationRequests[requestId.toString()] = onResponse;\r\n            }\r\n\r\n            , unregisterMethodInvocation: function (requestId) {\r\n                var responseCallback = this.methodInvocationRequests[requestId.toString()];\r\n                delete this.methodInvocationRequests[requestId.toString()];\r\n                return responseCallback;\r\n            }\r\n\r\n            , isRequestRegistered: function (requestId) {\r\n                return requestId.toString() in this.methodInvocationRequests;\r\n            }\r\n\r\n        };\r\n\r\n        /// requestId property will contain next free request id\r\n        this.createMethodInvocationRequest = function (method, payload) {\r\n            var newRequestId = this.methodInvocations.getNextMethodInvocationRequestId();\r\n            //console.log("method invocation ", method, payload);\r\n            if (method == \'START_FEATURE\') {\r\n                payload = ["logic.api.gamelogic.FeatureID", payload];\r\n            }\r\n            ;\r\n\r\n            var request = {\r\n                "@type": "MethodInvocation"\r\n                , "requestId": newRequestId\r\n                , "method": method\r\n                , "payload": payload\r\n            };\r\n            return request;\r\n        };\r\n\r\n\r\n        this.runMethodInvocation = function (method, payload, onResponse) {\r\n            console.log(\'runMethodInvocation\', method, payload);\r\n\r\n            var request = this.createMethodInvocationRequest(method, payload);\r\n            this.methodInvocations.registerMethodInvocation(request.requestId.toString(), onResponse);\r\n            this.send(request);\r\n            return request;\r\n        };\r\n\r\n        this.runMethodInvocationForInputData = function (id) {\r\n            return this.runMethodInvocation(\r\n                    document.getElementById(\'inputMethod\' + id).value\r\n                    , JSON.parse(document.getElementById(\'inputPayload\' + id).value)\r\n                    , function (response) {\r\n                        document.getElementById(\'resultPayload\').innerHTML = JSON.stringify(response["payload"]);\r\n                    }\r\n            );\r\n        };\r\n\r\n        this.onMethodInvocation = function (response) {\r\n            var theRequestId = response["requestId"];\r\n            if (this.methodInvocations.isRequestRegistered(theRequestId.toString())) {\r\n                var responseCallback = this.methodInvocations.unregisterMethodInvocation(theRequestId.toString());\r\n                if ($.isFunction(responseCallback)) {\r\n                    responseCallback(response);\r\n                } else {\r\n                    console.error("Response callback is not a function. RequestId =", theRequestId\r\n                            , ", typeof callback =", typeof (responseCallback));\r\n                }\r\n            } else {\r\n                console.warn("request id", theRequestId, "is not registered");\r\n            }\r\n        };\r\n\r\n        this.applyDefaultStrategyCallback = function (body, currentInvocation) {\r\n            var thisObj = this;\r\n            if (currentInvocation.isCommand) {\r\n                var command = body["payload"];\r\n                var method = command["command_id"];\r\n                var bStopApply = (method == null) || ((method == "START_GAME") && !currentInvocation.isFirst);\r\n                if (!bStopApply) {\r\n                    var nextRequestPayload = (method == "START_FEATURE") ?\r\n                            ["logic.api.gamelogic.FeatureID", command["featureID"]]\r\n                            : command["parameter"];\r\n                    this.runMethodInvocation(method, nextRequestPayload,\r\n                            function (body) {\r\n                                currentInvocation.isCommand = false;\r\n                                currentInvocation.isFirst = false;\r\n                                thisObj.applyDefaultStrategyCallback(body, currentInvocation);\r\n                            });\r\n                } else {\r\n                    console.log("stop applying default strategy");\r\n                    if (currentInvocation.onFinish) {\r\n                        console.log("onFinish...");\r\n                        currentInvocation.onFinish();\r\n                    } else {\r\n                        console.log("Nothing else to do");\r\n                    }\r\n                }\r\n            } else {\r\n                this.runMethodInvocation("GET_NEXT_COMMAND", null,\r\n                        function (body) {\r\n                            currentInvocation.isCommand = true;\r\n                            currentInvocation.isFirst = false;\r\n                            thisObj.applyDefaultStrategyCallback(body, currentInvocation);\r\n                        });\r\n            }\r\n        };\r\n\r\n        this.applyDefaultStrategy = function (onFinish) {\r\n            var thisObj = this;\r\n            this.runMethodInvocation("GET_NEXT_COMMAND", null,\r\n                    function (body) {\r\n                        thisObj.applyDefaultStrategyCallback(body, {\r\n                            isCommand: true\r\n                            , isFirst: true\r\n                            , onFinish: onFinish\r\n                        });\r\n                    }\r\n            );\r\n        };\r\n\r\n        this.playGames = function (gamesAmount) {\r\n            var thisObj = this;\r\n            if (gamesAmount > 0) {\r\n                console.log("Playing next game (", gamesAmount, "games left)");\r\n                this.applyDefaultStrategy(\r\n                        function () {\r\n                            thisObj.playGames(gamesAmount - 1);\r\n                        });\r\n            } else {\r\n                console.log("No more games to play");\r\n            }\r\n        };\r\n\r\n\r\n        this.getFG = function (cb) {\r\n            function getNextCommand(cmdCb) {\r\n                thisObj.runMethodInvocation("GET_NEXT_COMMAND", null, cmdCb);\r\n            }\r\n            function runCmd(body, cmdCb) {\r\n                thisObj.runMethodInvocation(body["payload"]["command_id"], body["payload"]["parameter"], cmdCb);\r\n            }\r\n\r\n            var thisObj = this;\r\n            getNextCommand(function (body) {\r\n                if (body["payload"]["command_id"] === \'START_FEATURE\') {\r\n                    cb();\r\n                } else {\r\n                    runCmd(body, function () {\r\n                        thisObj.getFG(cb);\r\n                    });\r\n                }\r\n            });\r\n\r\n        };\r\n\r\n    };\r\n\r\n    if (platform.isMobile()) {\r\n        pubsub.subscribeBatch({\r\n            \'notify:focusOut\': function () {\r\n                API.client && API.client.close();\r\n            }\r\n        });\r\n    }\r\n\r\n    var connectCb;\r\n    var defaultMsgHandler;\r\n\r\n    var API = {\r\n        client: null,\r\n        initialize: function (dMsgHandler, cb) {\r\n            defaultMsgHandler = dMsgHandler;\r\n            connectCb = cb;\r\n            var client = new Organic.Client();\r\n            API.client = client;\r\n            $(window).off(\'unload\').unload(function () {\r\n                windowClosed = true;\r\n                client.close();\r\n            });\r\n        }\r\n    };\r\n\r\n    return API;\r\n\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/services/websocket.js'),
eval("define('data/config-dummyServer',[], function () {\r\n    var data = {\r\n        FREE_GAME_WIN_PROBABILITY: 0,\r\n//        FREE_GAME_WIN_PROBABILITY: .5,\r\n        FREE_GAME_WIN_DURING_FREE_GAME_PROBABILITY: .3,\r\n        FREE_GAME_ROW_WIN: 100,\r\n        FREE_GAME_AWARD_COUNT: 20,\r\n    };\r\n    window.dummyConfig = data;\r\n    return data;\r\n});\r\n\n//# sourceURL=/modules/Type2/src/js/data/config-dummyServer.js"),eval('define(\'services/dummyServer\',[\'big\', \'data/config\', \'data/config-symbolSet\', \'data/config-reelSet\',\r\n    \'data/config-betlines\', \'data/config-dummyServer\'],\r\n        function (big, coreConfig, symbolSet, reelSet, betlinesConfig, config) {\r\n            function getRandomBlock(length, symSet) {\r\n                var block = [];\r\n                var rnd;\r\n                for (var i = 0; i < reelSet.BASE.REELS_COUNT; i++) {\r\n                    block[i] = [];\r\n                    for (var i2 = 0; i2 < length; i2++) {\r\n                        do {\r\n                            if (Math.random() < .5) {\r\n                                rnd = Math.floor(Math.random() * 3);\r\n                            } else {\r\n                                rnd = Math.floor(Math.random()\r\n                                        * Object.keys(symSet.symbols).length);\r\n                            }\r\n                        } while (symSet.symbols[rnd].excludeOnReels\r\n                                && symSet.symbols[rnd].excludeOnReels\r\n                                .indexOf(i) !== -1)\r\n                        block[i][i2] = rnd + 1;\r\n                    }\r\n                }\r\n                return block;\r\n            }\r\n            function getRandomResultFromStrips(strips, rSet) {\r\n                var rows = rSet.VISIBLE_SYMBOLS_ON_REEL;\r\n                var result = [];\r\n                var startIndex;\r\n                for (var col = 0; col < rSet.REELS_COUNT; col++) {\r\n                    result[col] = [];\r\n                    startIndex = Math.floor(Math.random() * strips[col].length);\r\n                    for (var row = 0; row < rows; row++) {\r\n                        result[col][row] = strips[col][(startIndex + row)\r\n                                % strips[col].length];\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n            function getWinData(data, block, symSet) {\r\n                function compScatter() {\r\n                    var win;\r\n                    var positions = [];\r\n                    var icons = [];\r\n                    for (var col = 0; col < block.length; col++) {\r\n                        for (var row = 0; row < block[0].length; row++) {\r\n                            if (symSet.SCATTER_SYMBOL_ID.indexOf(block[col][row] - 1) > -1) {\r\n                                positions.push({\r\n                                    "@type": "logic.api.paytable.slot.spinresult.Position2D",\r\n                                    "xPos": col,\r\n                                    "yPos": row\r\n                                });\r\n                                icons.push(block[col][row]);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (icons.length >= 3) {\r\n                        win = icons.length * 100;\r\n                        winData.items.push({\r\n                            "@type": "logic.api.paytable.slot.spinresult.Spin_Result_Item",\r\n                            "positions": positions,\r\n                            "icons": icons,\r\n                            "line_number": 0,\r\n                            "win": win,\r\n                            "win_multiplier": 1,\r\n                            "bonus_id": "NO_BONUS",\r\n                        });\r\n                        winData.win += win;\r\n                    }\r\n                }\r\n                function compLines() {\r\n                    var lineConfig, row, firstSymbol, positions, icons, win;\r\n                    for (var i = 0; i < data.num_of_lines; i++) {\r\n                        positions = [];\r\n                        icons = [];\r\n                        win = 0;\r\n                        lineConfig = betlinesConfig.BETLINES_POSITIONS[i].line;\r\n                        row = lineConfig[0] - 1;\r\n                        firstSymbol = block[0][row];\r\n                        if (symSet.SCATTER_SYMBOL_ID.indexOf(firstSymbol - 1) > -1) {\r\n                            continue;\r\n                        }\r\n                        positions[0] = {\r\n                            "@type": "logic.api.paytable.slot.spinresult.Position2D",\r\n                            "xPos": 0,\r\n                            "yPos": row\r\n                        };\r\n                        icons[0] = firstSymbol;\r\n                        for (var col = 1; col < block.length; col++) {\r\n                            row = lineConfig[col] - 1;\r\n                            if (block[col][row] === firstSymbol\r\n                                    || symSet.WILD_SYMBOL_ID.indexOf(block[col][row] - 1) > -1) {\r\n                                positions[col] = {\r\n                                    "@type": "logic.api.paytable.slot.spinresult.Position2D",\r\n                                    "xPos": col,\r\n                                    "yPos": row\r\n                                };\r\n                                icons[col] = block[col][row];\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (positions.length >= 3) {\r\n                            win = positions.length * 20;\r\n                            winData.items.push({\r\n                                "@type": "logic.api.paytable.slot.spinresult.Spin_Result_Item",\r\n                                "positions": positions,\r\n                                "icons": icons,\r\n                                "line_number": i + 1,\r\n                                "win": win,\r\n                                "win_multiplier": 1,\r\n                                "bonus_id": "NO_BONUS",\r\n                            });\r\n                            winData.win += win;\r\n                        }\r\n                    }\r\n                }\r\n                function compFreeGame() {\r\n                    function addBonusLine() {\r\n                        var row = Math.floor(Math.random() * reelSet.BASE.VISIBLE_SYMBOLS_ON_REEL);\r\n                        var item = {\r\n                            "@type": "logic.api.paytable.slot.spinresult.Spin_Result_Item",\r\n                            "positions": [],\r\n                            "icons": [],\r\n                            "line_number": 0,\r\n                            "win": config.FREE_GAME_ROW_WIN,\r\n                            "win_multiplier": 1,\r\n                            "bonus_id": "NO_BONUS",\r\n                        };\r\n                        for (var i = 0; i < 3; i++) {\r\n                            item.icons.push(symSet.SCATTER_SYMBOL_ID[0] + 1);\r\n                            item.positions.push({\r\n                                "@type": "logic.api.paytable.slot.spinresult.Position2D",\r\n                                "xPos": i,\r\n                                "yPos": row\r\n                            });\r\n                            block[i][row] = symSet.SCATTER_SYMBOL_ID[0] + 1;\r\n                        }\r\n                        winData.items[0] = item;\r\n                        winData.win += item.win;\r\n                        winData.items[1] = $.extend(true, {}, item);\r\n                        winData.items[1].bonus_id = \'FREE_GAME\';\r\n                        winData.items[1].win = 0;\r\n                    }\r\n                    addBonusLine();\r\n                    winData.freeGameFeature = {\r\n                        "@type": "logic.api.gamelogic.Feature_State",\r\n                        "feature_id": "FREE_GAME",\r\n                        "id": 2,\r\n                        "init_parameters": {\r\n                            "@type": "logic.api.gamelogic.freegames.Free_Games_Init_Parameters",\r\n                            "free_win": config.FREE_GAME_AWARD_COUNT,\r\n                            "basic_win": null,\r\n                        },\r\n                        "current_state": {\r\n                            "@type": "logic.api.gamelogic.freegames.Free_Games_Current_State",\r\n                            "strips_current": []\r\n                        },\r\n                        "current_win": 0,\r\n                        "status": "NOT_STARTED",\r\n                    };\r\n                }\r\n                function compMoreFreeGame() {\r\n                    function putStripToBlock(strip, stripPos, block, col) {\r\n                        var arr = [];\r\n                        for (var m = 0; m < reelSet.BASE.VISIBLE_SYMBOLS_ON_REEL; m++) {\r\n                            block[col][m] = strip[(stripPos + m) % strip.length];\r\n                            if (symSet.SCATTER_SYMBOL_ID.indexOf(block[col][m] - 1) > -1) {\r\n                                arr.push([col, m]);\r\n                            }\r\n                        }\r\n                        return arr;\r\n                    }\r\n                    var strips = state.freeGame.strips;\r\n                    var strip, item, i, k;\r\n                    var scatters = [];\r\n                    var newBlock = [];\r\n                    for (i = 0; i < strips.length; i++) {\r\n                        newBlock[i] = [];\r\n                        strip = strips[i];\r\n                        for (k = 0; k < strip.length; k++) {\r\n                            if (symSet.SCATTER_SYMBOL_ID.indexOf(strip[k] - 1) > -1) {\r\n                                scatters = scatters.concat(putStripToBlock(strip, k, newBlock, i));\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (scatters.length >= 3) {\r\n                        for (i = 0; i < block.length; i++) {\r\n                            if (newBlock[i][0] !== undefined) {\r\n                                for (k = 0; k < block[i].length; k++) {\r\n                                    block[i][k] = newBlock[i][k];\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                        item = {\r\n                            "@type": "logic.api.paytable.slot.spinresult.Spin_Result_Item",\r\n                            "positions": [],\r\n                            "icons": [],\r\n                            "line_number": 0,\r\n                            "win": config.FREE_GAME_ROW_WIN,\r\n                            "win_multiplier": 1,\r\n                            "bonus_id": "NO_BONUS",\r\n                        };\r\n                        for (i = 0; i < scatters.length; i++) {\r\n                            item.icons.push(symSet.SCATTER_SYMBOL_ID[0] + 1);\r\n                            item.positions.push({\r\n                                "@type": "logic.api.paytable.slot.spinresult.Position2D",\r\n                                "xPos": scatters[i][0],\r\n                                "yPos": scatters[i][1]\r\n                            });\r\n                        }\r\n\r\n\r\n\r\n                        winData.items[0] = item;\r\n                        winData.win += item.win;\r\n                        winData.items[1] = $.extend(true, {}, item);\r\n                        winData.items[1].bonus_id = \'FREE_GAME\';\r\n                        winData.items[1].win = 0;\r\n                        state.freeGame.remaining += config.FREE_GAME_AWARD_COUNT;\r\n                        state.freeGame.total += config.FREE_GAME_AWARD_COUNT;\r\n                    }\r\n                }\r\n\r\n                var winData = {\r\n                    win: 0,\r\n                    items: [],\r\n                    freeGameFeature: undefined\r\n                }\r\n                ;\r\n                if (!state.freeGame) {\r\n                    if (symbolSet.FREE_SPIN && Math.random() <\r\n                            config.FREE_GAME_WIN_PROBABILITY) {\r\n                        compFreeGame();\r\n                        compLines();\r\n                        winData.freeGameFeature.init_parameters.basic_win = winData.win;\r\n                        state.freeGame = {\r\n                            win: 0,\r\n                            strips: [],\r\n                            num_of_lines: data.num_of_lines,\r\n                            currentState: null,\r\n                            basic_win: winData.win,\r\n                            remaining: winData.freeGameFeature.init_parameters.free_win,\r\n                            total: winData.freeGameFeature.init_parameters.free_win,\r\n                        };\r\n                    } else {\r\n                        compLines();\r\n                        compScatter();\r\n                    }\r\n                } else {\r\n                    if (symbolSet.FREE_SPIN && Math.random() <\r\n                            config.FREE_GAME_WIN_DURING_FREE_GAME_PROBABILITY) {\r\n                        compMoreFreeGame();\r\n                        compLines();\r\n                    } else {\r\n                        compLines();\r\n                        compScatter();\r\n                    }\r\n                }\r\n\r\n//                winData.freeGameFeature &&\r\n//                        (winData.freeGameFeature.init_parameters.basic_win = 0);\r\n//                winData.win = 0;\r\n\r\n                return winData;\r\n            }\r\n            function getRandomSpinResult(data, symSet) {\r\n                function getRndTeaserFlags() {\r\n                    var flags = [false, false];\r\n                    var isTrue = false;\r\n                    for (var i = 2; i < reelSet.BASE.REELS_COUNT; i++) {\r\n                        flags[i] = isTrue || Math.random() > 0;\r\n                        if (flags[i]) {\r\n                            isTrue = true;\r\n                        }\r\n                    }\r\n                    return flags;\r\n                }\r\n\r\n                var response = {\r\n                    "@type": "GameResponse",\r\n                    "data": {\r\n                        "@type": "logic.api.gamelogic.Game_History_Item",\r\n                        "features": [{\r\n                                "@type": "logic.api.gamelogic.Feature_State",\r\n                                "feature_id": "SLOT",\r\n                                "id": 1,\r\n                                "init_parameters": {\r\n                                    "@type": "logic.api.gamelogic.slot.Slot_Init_Parameters"\r\n                                },\r\n                                "current_state": {\r\n                                    "strips_current": state.game.strips,\r\n                                },\r\n                                "prev_current_state": {\r\n                                },\r\n                                "current_win": 0,\r\n                                "status": "",\r\n                                "last_step": {\r\n                                    "@type": "logic.api.gamelogic.Feature_Step",\r\n                                    "action": {\r\n                                        "@type": "logic.api.gamelogic.slot.Slot_Action"\r\n                                    },\r\n                                    "reaction": {\r\n                                        "@type": "logic.api.gamelogic.slot.Slot_Reaction",\r\n                                        "spin_result": {\r\n                                            "@type": "logic.api.paytable.slot.spinresult.Slot_Spin_Result",\r\n                                            "drum": [],\r\n                                            "items": [],\r\n                                        }\r\n                                    }\r\n                                },\r\n                                "parent_index": 0\r\n                            }],\r\n                        "betting_param": {\r\n                        },\r\n                        "status": "FINISHED",\r\n                        "game_current_state": {\r\n                        }\r\n                    },\r\n                    "balance": {\r\n                        "@type": "Balance",\r\n                        "balance": state.money.cash,\r\n                        "currency": state.money.currency\r\n                    },\r\n                    "jackpot": null\r\n                };\r\n                var block = getRandomResultFromStrips(state.game.strips, reelSet.BASE);\r\n                var winData = getWinData(data, block, symSet);\r\n                response.data.features[0].last_step.reaction.spin_result.drum = block;\r\n                response.data.features[0].last_step.reaction.spin_result.teaser_flags = getRndTeaserFlags();\r\n                response.data.features[0].current_win = winData.win;\r\n                response.data.features[0].last_step.reaction.spin_result.items = winData.items;\r\n                winData.freeGameFeature && (response.data.features[1] = winData.freeGameFeature);\r\n                return response;\r\n            }\r\n\r\n            var features = {\r\n                \'GAMBLE\': {\r\n                    start: function (data) {\r\n                        var initWin;\r\n                        if (state.freeGame) {\r\n                            initWin = state.freeGame.basic_win + state.freeGame.win;\r\n                            state.freeGame = null;\r\n                        } else {\r\n                            initWin = state.game.lastResult.data.features[0].current_win;\r\n                        }\r\n                        state.gamble = {\r\n                            initWin: initWin,\r\n                            multiplier: 1,\r\n                            triesRemaining: 10,\r\n                            dealerCard: {\r\n                                "@type": "logic.api.gamelogic.gamble.Card",\r\n                                "rank": Math.floor(Math.random() * 12),\r\n                                "is_joker": false,\r\n                                "suit": GAMBLE_SUITS[Math.floor(Math.random()\r\n                                        * GAMBLE_SUITS.length)],\r\n                            }\r\n                        };\r\n                        var response = {\r\n                            "@type": "logic.api.gamelogic.Feature_State",\r\n                            "feature_id": "GAMBLE",\r\n                            "id": 2,\r\n                            "init_parameters": {\r\n                            },\r\n                            "current_state": {\r\n                                "@type": "logic.api.gamelogic.gamble.BTD_Gamble_Current_State",\r\n                                "dealer_card": state.gamble.dealerCard,\r\n                                tries: state.gamble.triesRemaining,\r\n                            },\r\n                            "prev_current_state": {\r\n                            },\r\n                            "current_win": 0,\r\n                            "status": "IN_PROGRESS",\r\n                            "last_step": null,\r\n                            "parent_index": 0\r\n                        };\r\n                        return response;\r\n                    },\r\n                    step: function (data) {\r\n                        state.gamble.triesRemaining -= 1;\r\n                        var prevCurrentState = {\r\n                            "curr_win": state.gamble.multiplier\r\n                                    * state.gamble.initWin,\r\n                        };\r\n                        var cards = [$.extend({}, state.gamble.dealerCard)];\r\n                        for (var i = 0; i < 4; i++) {\r\n                            var rank = Math.floor(Math.random() * 12);\r\n                            cards.push({\r\n                                "@type": "logic.api.gamelogic.gamble.Card",\r\n                                "rank": rank,\r\n                                "is_joker": rank === 13,\r\n                                "suit": GAMBLE_SUITS[Math.floor(Math.random()\r\n                                        * GAMBLE_SUITS.length)]\r\n                            });\r\n                        }\r\n\r\n                        var type;\r\n                        var playerChoice = cards[data.player_choice + 1];\r\n                        if (state.gamble.dealerCard.rank > playerChoice.rank) {\r\n                            type = \'lose\';\r\n                            state.gamble.multiplier *= 0;\r\n                        } else if (state.gamble.dealerCard.rank === playerChoice.rank) {\r\n                            type = \'tie\';\r\n                        } else {\r\n                            type = \'win\';\r\n                            state.gamble.multiplier *= 2;\r\n                        }\r\n\r\n                        state.gamble.dealerCard = {\r\n                            "@type": "logic.api.gamelogic.gamble.Card",\r\n                            "rank": Math.floor(Math.random() * 12),\r\n//                            "rank": 0,\r\n                            "is_joker": false,\r\n                            "suit": GAMBLE_SUITS[Math.floor(Math.random()\r\n                                    * GAMBLE_SUITS.length)]\r\n                        };\r\n                        return  {\r\n                            "@type": "logic.api.gamelogic.FeatureStateWrapper",\r\n                            "state": {\r\n                                "@type": "logic.api.gamelogic.Feature_State",\r\n                                "feature_id": "GAMBLE",\r\n                                "id": 2,\r\n                                "init_parameters": {\r\n                                    "@type": "logic.api.gamelogic.gamble.Gamble_Init_Parameters",\r\n                                    "start_win": state.gamble.initWin,\r\n                                },\r\n                                "current_state": {\r\n                                    "@type": "logic.api.gamelogic.gamble.BTD_Gamble_Current_State",\r\n                                    "curr_win": state.gamble.multiplier\r\n                                            * state.gamble.initWin,\r\n                                    "tries": state.gamble.triesRemaining,\r\n                                    "dealer_card": state.gamble.dealerCard,\r\n                                },\r\n                                "prev_current_state": prevCurrentState,\r\n                                "last_step": {\r\n                                    "reaction": {\r\n                                        cards: cards\r\n                                    }\r\n                                },\r\n                                "status": "IN_PROGRESS",\r\n                                "parent_index": 0\r\n                            },\r\n                        };\r\n                    },\r\n                },\r\n                FREE_GAME: {\r\n                    start: function () {\r\n                        var fgStrips = getRandomBlock(20, symbolSet.FREE_SPIN);\r\n                        var response = {\r\n                            "@type": "logic.api.gamelogic.Feature_State",\r\n                            "feature_id": "FREE_GAME",\r\n                            "id": 2,\r\n                            "init_parameters": {\r\n                                "@type": "logic.api.gamelogic.freegames.Free_Games_Init_Parameters",\r\n                                "free_win": config.FREE_GAME_AWARD_COUNT,\r\n                                "basic_win": state.freeGame.basic_win,\r\n                                "init_drum": state.game.lastResult.data\r\n                                        .features[0].last_step.reaction.spin_result.drum\r\n                            },\r\n                            "current_state": {\r\n                                "@type": "logic.api.gamelogic.freegames.Free_Games_Current_State",\r\n                                "strips_current": fgStrips,\r\n                                "strips_next": null,\r\n                                "strips_changed_bet": null,\r\n                                "played_free_games": 0,\r\n                                "not_played_free_games": state.freeGame.total,\r\n                            },\r\n                            "prev_current_state": {\r\n                                "@type": "logic.api.gamelogic.freegames.Free_Games_Current_State",\r\n                                "strips_current": null,\r\n                                "strips_next": null,\r\n                                "strips_changed_bet": null,\r\n                                "played_free_games": 0,\r\n                                "not_played_free_games": state.freeGame.total,\r\n                            },\r\n                            "current_win": 0,\r\n                            "status": "IN_PROGRESS",\r\n                            "last_step": null,\r\n                            "parent_index": 0\r\n                        };\r\n                        state.freeGame.currentState = response.current_state;\r\n                        state.freeGame.strips = response.current_state.strips_current;\r\n                        return response;\r\n                    },\r\n                    step: function () {\r\n                        var block = getRandomResultFromStrips(state.freeGame.strips, reelSet.BASE);\r\n                        var winData = getWinData(state.freeGame, block, symbolSet.FREE_SPIN);\r\n                        state.freeGame.remaining -= 1;\r\n                        state.freeGame.win += winData.win;\r\n                        var prevCurrentState = $.extend({}, state.freeGame.currentState);\r\n                        state.freeGame.currentState = {\r\n                            "@type": "logic.api.gamelogic.freegames.Free_Games_Current_State",\r\n                            "played_free_games": state.freeGame.total - state.freeGame.remaining,\r\n                            "not_played_free_games": state.freeGame.remaining,\r\n                        };\r\n                        var response = {\r\n                            "@type": "logic.api.gamelogic.FeatureStateWrapper",\r\n                            "state": {\r\n                                "@type": "logic.api.gamelogic.Feature_State",\r\n                                "feature_id": "FREE_GAME",\r\n                                "id": 2,\r\n                                "init_parameters": {\r\n                                    "@type": "logic.api.gamelogic.freegames.Free_Games_Init_Parameters",\r\n                                    "free_win": config.FREE_GAME_AWARD_COUNT,\r\n                                    "basic_win": state.freeGame.basic_win,\r\n                                },\r\n                                "current_state": state.freeGame.currentState,\r\n                                "prev_current_state": prevCurrentState,\r\n                                "current_win": state.freeGame.win,\r\n                                "status": "IN_PROGRESS",\r\n                                "last_step": {\r\n                                    "@type": "logic.api.gamelogic.Feature_Step",\r\n                                    "action": {\r\n                                        "@type": "logic.api.gamelogic.freegames.Free_Games_Action"\r\n                                    },\r\n                                    "reaction": {\r\n                                        "@type": "logic.api.gamelogic.slot.Slot_Reaction",\r\n                                        "spin_result": {\r\n                                            "@type": "logic.api.paytable.slot.spinresult.Slot_Spin_Result",\r\n                                            "drum": block,\r\n                                            "items": winData.items,\r\n                                        }\r\n                                    }\r\n                                },\r\n                                "parent_index": 0\r\n                            },\r\n                        };\r\n                        return response;\r\n                    },\r\n                },\r\n                GAME: {\r\n                }\r\n            };\r\n            var methods = {\r\n                CLIENT_INFO: function (data, cb) {\r\n                    cb({\r\n                        \'@type\': \'\'\r\n                    });\r\n                },\r\n                GET_PAYTABLE_INFO: function (data, cb) {\r\n                    var linesSet = [1];\r\n                    var val = coreConfig.BETLINES_INCREMENT_STEP === 1\r\n                            ? 2 : coreConfig.BETLINES_INCREMENT_STEP;\r\n                    while (val <= coreConfig.BETLINES_TOTAL) {\r\n                        linesSet.push(val);\r\n                        val += coreConfig.BETLINES_INCREMENT_STEP;\r\n                    }\r\n                    cb({\r\n                        "@type": "logic.api.paytable.slot.Paytable_Info_Slot",\r\n                        "gameId": "",\r\n                        "gameName": "",\r\n                        "reels": 0,\r\n                        "sectors": 0,\r\n                        "symbols": 0,\r\n                        "bets_set": [1, 2, 3, 4, 5, 10, 15, 20, 30, 40, 50, 100],\r\n                        "lines_set": linesSet,\r\n                        "denoms_set": ["0.001", "0.002", "0.005", "0.008", "0.01",\r\n                            "0.02", "0.05", "0.08", "0.1", "0.2", "0.5", "0.8",\r\n                            "1", "2", "3", "5", "7", "8", "10", "20", "30", "50",\r\n                            "60", "80", "90", "100", "120", "150", "200", "500",\r\n                            "800", "1000"],\r\n                        "virtual_strips": null,\r\n                        "virtual_fg_strips": null,\r\n                        "critical_bet": null,\r\n                        "no_gamble_after_bonus": false,\r\n                        "maxwin": "10000000000000000",\r\n                        "maxwinbet": "1000000000",\r\n                        "bonus_strips": [],\r\n                        "extra_bet": null,\r\n                        "maxbet_in_money": null\r\n                    });\r\n                },\r\n                GET_BALANCE: function (data, cb) {\r\n                    cb({\r\n                        "@type": "Balance",\r\n                        "balance": String(state.money.cash),\r\n                        "currency": state.money.currency\r\n                    });\r\n                },\r\n                GET_DYNAMIC_HELP_INFO: function (data, cb) {\r\n                    var items = [];\r\n                    for (var i = 0; i < 20; i++) {\r\n                        items.push({\r\n                            "@type": "logic.api.paytable.slot.paytableinfo.one_Help_Icon_Data",\r\n                            "icon_number": i + 1,\r\n                            "wins": [{\r\n                                    "@type": "logic.api.paytable.slot.paytableinfo.win_Item",\r\n                                    "win": (i + 1) * 10,\r\n                                    "free_win": 0,\r\n                                    "is_scatter": false,\r\n                                    "_scatter": false\r\n                                },\r\n                                {\r\n                                    "@type": "logic.api.paytable.slot.paytableinfo.win_Item",\r\n                                    "win": (i + 1) * 12,\r\n                                    "free_win": 0,\r\n                                    "is_scatter": false,\r\n                                    "_scatter": false\r\n                                }, {\r\n                                    "@type": "logic.api.paytable.slot.paytableinfo.win_Item",\r\n                                    "win": (i + 1) * 15,\r\n                                    "free_win": 0,\r\n                                    "is_scatter": false,\r\n                                    "_scatter": false\r\n                                }]\r\n                        });\r\n                    }\r\n                    cb({\r\n                        "@type": "logic.api.paytable.slot.Dynamic_Help_Info_Slot",\r\n                        "items": items\r\n                    });\r\n                },\r\n                GET_LAST_GAME: function (data, cb) {\r\n                    cb(state.game.lastResult.data);\r\n                },\r\n                START_GAME: function (data, cb) {\r\n                    state.gamble = null;\r\n                    state.freeGame = null;\r\n                    state.game.lastResult = null;\r\n\r\n                    state.money.cash -= Number(big(data.bet_per_line).times(data.num_of_lines)\r\n                            .times(data.denom).valueOf());\r\n                    state.game.lastBetParams = data;\r\n                    state.game.lastResult = getRandomSpinResult(data, symbolSet.SPIN);\r\n                    cb(state.game.lastResult);\r\n                },\r\n                END_GAME: function (data, cb) {\r\n                    if (state.gamble) {\r\n                        state.money.cash += Number(big(state.gamble.initWin).times(state.gamble.multiplier)\r\n                                .times(state.game.lastBetParams.denom).valueOf());\r\n                        state.gamble = null;\r\n                    } else if (state.freeGame) {\r\n                        state.money.cash += Number(big(state.freeGame.basic_win + state.freeGame.win)\r\n                                .times(state.game.lastBetParams.denom).valueOf());\r\n                        state.freeGame = null;\r\n                    } else {\r\n                        state.money.cash += Number(big(state.game.lastResult.data.features[0].current_win)\r\n                                .times(state.game.lastBetParams.denom).valueOf());\r\n                    }\r\n\r\n                    cb({\r\n                        "@type": "GameResponse",\r\n                        "data": {\r\n                            "@type": "logic.api.gamelogic.Game_History_Item",\r\n                            "features": [],\r\n                            "betting_param": {},\r\n                            "status": "FINISHED",\r\n                            "game_current_state": {}\r\n                        },\r\n                        "balance": {\r\n                            "@type": "Balance",\r\n                            "balance": state.money.cash,\r\n                            "currency": state.money.currency\r\n                        },\r\n                        "jackpot": null\r\n                    })\r\n                },\r\n                START_FEATURE: function (data, cb) {\r\n                    features[data] && cb(features[data].start(data));\r\n                },\r\n                END_FEATURE: function (data, cb) {\r\n                    cb({\r\n                        "@type": "MethodInvocation",\r\n                        "payload": {\r\n                            "@type": "logic.api.gamelogic.Game_History_Item",\r\n                            "features": [],\r\n                            "betting_param": {},\r\n                            "status": "IN_PROGRESS",\r\n                            "game_current_state": {}\r\n                        },\r\n                        "requestId": "0",\r\n                        "method": "END_FEATURE"\r\n                    });\r\n                },\r\n                STEP_FEATURE: function (data, cb) {\r\n                    if (data[\'@type\'] === "logic.api.gamelogic.gamble.BTD_Gamble_Action") {\r\n                        cb(features.GAMBLE.step(data));\r\n                    }\r\n                    if (data[\'@type\'] === "logic.api.gamelogic.freegames.Free_Games_Action") {\r\n                        cb(features.FREE_GAME.step(data));\r\n                    }\r\n                },\r\n                GET_NEXT_COMMAND: function (data, cb) {\r\n                    cb({\r\n                        command_id: \'START_GAME\'\r\n                    });\r\n                },\r\n            };\r\n            var GAMBLE_SUITS = [\'SPADES\', \'CLUBS\', \'DIAMONDS\', \'HEARTS\'];\r\n            var state = {\r\n                money: {\r\n                    cash: 10000,\r\n                    currency: \'USD\'\r\n                },\r\n                game: {\r\n                    strips: null,\r\n                    lastResult: null,\r\n                    lastBetParams: null,\r\n                },\r\n                gamble: null,\r\n                freeGame: null,\r\n            };\r\n\r\n            state.game.strips = getRandomBlock(20, symbolSet.SPIN);\r\n            state.game.lastResult = getRandomSpinResult({\r\n                num_of_lines: 5}, symbolSet.SPIN);\r\n\r\n//>>includeStart("debug", pragmas.debug);\r\n            window.dummyServerState = state;\r\n//>>includeEnd("debug");\r\n            var API = {\r\n                client: {\r\n                    runMethodInvocation: function (cmd, data, cb) {\r\n                        methods[cmd] && methods[cmd](data, function (responsePayload) {\r\n                            var msg = {\r\n                                "@type": "MethodInvocation",\r\n                                payload: responsePayload,\r\n                                method: cmd,\r\n                            };\r\n                            console.log("onMessage: ", msg);\r\n                            setTimeout(function () {\r\n                                cb(msg);\r\n                            }, 0);\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            return API;\r\n        });\n//# sourceURL=/modules/Type2/src/js/services/dummyServer.js'),
eval("// transport service\r\n// specifies interface for the game to communicate with server\r\ndefine('services/transport',['jquery', 'pubsub', 'services/websocket', 'services/dummyServer', 'data/config'],\r\n        function ($, pubsub, websocket, dummyServer, config) {\r\n\r\n            // update current user alert level\r\n            function setAlertLevel(newValue) {\r\n                // ignore requests to set lower than current alert level\r\n                if (newValue !== alertLevel && (newValue === 0 || newValue > alertLevel)) {\r\n                    alertLevel = newValue;\r\n                    switch (alertLevel) {\r\n                        case 0:\r\n                            pubsub.publish('request:hideDialog');\r\n                            pubsub.publish('request:hideLoader');\r\n                            break;\r\n                        case 1:\r\n                            pubsub.publish('request:showLoader');\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // handle requests\r\n            function mPost(opts) {\r\n                function doNextReqest() {\r\n                    var options = requestQueue[0];\r\n                    console.log('mPost', options);\r\n                    // set request duration tracking timeout\r\n                    requestDurationTrackerTimeout = setTimeout(function () {\r\n                        // display loader after first timeout expired\r\n                        setAlertLevel(1);\r\n                    }, config.LONG_REQUEST_NOTIFICATION_TRESHOLD_MS);\r\n                    interface.client.runMethodInvocation(\r\n                            options.command,\r\n                            options.data,\r\n                            function (response) {\r\n                                // clear request duration tracking timeout\r\n                                if (requestDurationTrackerTimeout) {\r\n                                    clearTimeout(requestDurationTrackerTimeout);\r\n                                }\r\n                                requestQueue.shift();\r\n                                if (requestQueue.length > 0) {\r\n                                    doNextReqest();\r\n                                } else {\r\n                                    // clear alerts\r\n                                    setAlertLevel(0);\r\n                                }\r\n                                if (response['payload']['@type'] === 'InvocationError'\r\n                                        && (!options.ignoreErrorCode\r\n                                                || response['code'] === options.ignoreErrorCode)) {\r\n                                    pubsub.publish('notify:connectionError');\r\n                                } else {\r\n                                    options.success(response['payload']);\r\n                                }\r\n                            });\r\n                }\r\n               if (opts.doNotWaitForResponse) {\r\n                    interface.client.runMethodInvocation(\r\n                            opts.command,\r\n                            opts.data,\r\n                            function(){});\r\n                } else {\r\n                    requestQueue.push(opts);\r\n                    if (requestQueue.length === 1) {\r\n                        doNextReqest();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // -------------------------------------------------------------\r\n\r\n            // Standard game parser\r\n            function parseSpinResult(spinResultRemote) {\r\n                var spin = spinResultRemote.data.features[0];\r\n                var freeGameFeature = spinResultRemote.data.features[1];\r\n                var drum = spin.last_step.reaction.spin_result.drum;\r\n                var teaser_flags = spin.last_step.reaction.spin_result.teaser_flags;\r\n                var winItems = spin.last_step.reaction.spin_result.items;\r\n                var setup = {\r\n                    rs: {},\r\n                    ws: {},\r\n                    freeSpins: 0,\r\n                    totalWin: spin.current_win,\r\n                };\r\n                setup.rs = getRS(drum, teaser_flags);\r\n                setup.ws = getWS(winItems);\r\n                // FG\r\n                if (freeGameFeature) {\r\n                    setup.freeSpins = freeGameFeature.init_parameters.free_win;\r\n                    setup.freeSpinsRemaining = freeGameFeature.init_parameters.free_win;\r\n                    setup.freeSpinNumber = 0;\r\n                }\r\n\r\n                // balance\r\n                var betModel = {\r\n                };\r\n                if (spinResultRemote.balance) {\r\n                    betModel.cash = spinResultRemote.balance.balance;\r\n                }\r\n\r\n                return {\r\n                    setup: setup,\r\n                    model: betModel\r\n                };\r\n            }\r\n\r\n            // gamble parsers\r\n            function parseGambleCard(cardObj) {\r\n                var gambleSuitPositionMap = {\r\n                    'SPADES': 1,\r\n                    'CLUBS': 14,\r\n                    'DIAMONDS': 27,\r\n                    'HEARTS': 40\r\n                };\r\n                var card;\r\n                if (cardObj.is_joker) {\r\n                    card = 53;\r\n                } else {\r\n                    card = gambleSuitPositionMap[cardObj.suit] + cardObj.rank;\r\n                }\r\n\r\n                return card;\r\n            }\r\n            function parseGambleFirstCard(serverResult) {\r\n                var dealer_card = serverResult.current_state.dealer_card;\r\n                var cardId = parseGambleCard(dealer_card);\r\n                var parsed = {\r\n                    card: cardId,\r\n                };\r\n                return parsed;\r\n            }\r\n            function parseGambleAllCards(serverResult) {\r\n                var parsed = {\r\n                    cards: [],\r\n                    card: null,\r\n                    win: null,\r\n                    tie: false,\r\n                    step: null,\r\n                    finished: false,\r\n                };\r\n                var prev_current_state = serverResult.state.prev_current_state;\r\n                var current_state = serverResult.state.current_state;\r\n                var reaction = serverResult.state.last_step.reaction;\r\n                parsed.win = current_state.curr_win;\r\n                parsed.tie = current_state.curr_win === prev_current_state.curr_win;\r\n                parsed.step = 11 - current_state.tries;\r\n                parsed.card = parseGambleCard(current_state.dealer_card);\r\n                parsed.finished = current_state.tries === 0;\r\n                for (var i = 1; i < reaction.cards.length; i++) {\r\n                    parsed.cards[i - 1] = parseGambleCard(reaction.cards[i]);\r\n                }\r\n                return parsed;\r\n            }\r\n\r\n            // free game parsers\r\n            function parseFreeSpinInit(serverResult) {\r\n                var result = {\r\n                    stripes: parseStrips(serverResult.current_state.strips_current),\r\n                };\r\n                return result;\r\n            }\r\n            function parseFreeSpinResult(spinResultRemote) {\r\n                var drum = spinResultRemote.state.last_step.reaction.spin_result.drum;\r\n                var winItems = spinResultRemote.state.last_step.reaction.spin_result.items;\r\n                var teaser_flags = spinResultRemote.state.last_step.reaction.spin_result.teaser_flags;\r\n                var setup = {\r\n                    rs: {},\r\n                    ws: {},\r\n                    freeSpinNumber: spinResultRemote.state.current_state\r\n                            .played_free_games,\r\n                    freeSpinsRemaining: spinResultRemote.state.current_state\r\n                            .not_played_free_games,\r\n                    freeSpins: spinResultRemote.state.current_state\r\n                            .not_played_free_games\r\n                            + spinResultRemote.state.current_state\r\n                            .played_free_games,\r\n                    freeSpinsAdditional: null,\r\n                    totalWin: spinResultRemote.state.init_parameters.basic_win\r\n                            + spinResultRemote.state.current_win,\r\n                };\r\n\r\n                for (var i = 0; i < winItems.length; i++) {\r\n                    if (winItems[i].bonus_id === 'FREE_GAME') {\r\n                        setup.freeSpinsAdditional = spinResultRemote.state.current_state\r\n                                .not_played_free_games + 1\r\n                                - spinResultRemote.state.prev_current_state\r\n                                .not_played_free_games;\r\n                    }\r\n                }\r\n\r\n                setup.rs = getRS(drum, teaser_flags);\r\n                setup.ws = getWS(winItems);\r\n                return {\r\n                    setup: setup,\r\n                };\r\n            }\r\n\r\n            // parser helpers\r\n            function getSymPost(ws, item) {\r\n                var post = {};\r\n                var sym = {};\r\n                var animatedSymbolCount = 0;\r\n                for (var i = 0; i < item.positions.length; i++) {\r\n                    if (item.icons[i] !== 0) {\r\n                        post[animatedSymbolCount] = [item.positions[i].xPos,\r\n                            item.positions[i].yPos];\r\n                        sym[animatedSymbolCount] = item.icons[i] - 1;\r\n                        animatedSymbolCount += 1;\r\n                    }\r\n                }\r\n                ws.sym = sym;\r\n                ws.post = post;\r\n                return ws;\r\n            }\r\n            function getSym(icons) {\r\n                var sym = {};\r\n                for (var i = 0; i < icons.length; i++) {\r\n                    sym[i] = icons[i] - 1;\r\n                }\r\n                return sym;\r\n            }\r\n            function getRS(drum, teaser_flags) {\r\n                var rs = {};\r\n                for (var i = 0; i < drum.length; i++) {\r\n                    rs[i] = {\r\n                        sym: getSym(drum[i]),\r\n                        teaser: teaser_flags && teaser_flags[i],\r\n                    };\r\n                }\r\n                return rs;\r\n            }\r\n            function getWS(winItems) {\r\n                function mergeFreeGameWinItems(items) {\r\n                    var item, bonusWinItemIndex, scatterWinItemIndex;\r\n                    for (var i = 0; i < items.length; i++) {\r\n                        item = items[i];\r\n                        if (item.line_number === 0) {\r\n                            if (item.bonus_id === 'FREE_GAME') {\r\n                                bonusWinItemIndex = i;\r\n                            } else if (item.bonus_id === 'NO_BONUS') {\r\n                                scatterWinItemIndex = i;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (bonusWinItemIndex !== undefined\r\n                            && scatterWinItemIndex !== undefined) {\r\n                        items[bonusWinItemIndex] = null;\r\n                        items[scatterWinItemIndex].bonus_id = 'FREE_GAME';\r\n                    }\r\n                    return items;\r\n                }\r\n                function addLines(bonusId) {\r\n                    function addLine(winItem) {\r\n                        id = Object.keys(ws).length;\r\n                        if (winItem.line_number === 0) {\r\n                            betline = 99;\r\n                        } else {\r\n                            betline = winItem.line_number - 1;\r\n                        }\r\n                        ws[id] = {\r\n                            betline: betline,\r\n                            post: null,\r\n                            sym: null,\r\n                            win: winItem.win * winItem.win_multiplier,\r\n                        };\r\n                        ws[id] = getSymPost(ws[id], winItem);\r\n                    }\r\n                    var orderedIds = [];\r\n                    for (var i = 0; i < winItems.length; i++) {\r\n                        winItem = winItems[i];\r\n                        if (winItem !== null\r\n                                && winItem.bonus_id === bonusId) {\r\n                            orderedIds.push(i);\r\n                        }\r\n                    }\r\n                    var box;\r\n                    var change = true;\r\n                    while (change) {\r\n                        change = false;\r\n                        for (var i = 0; i < orderedIds.length - 1; i++) {\r\n                            var thisOne = winItems[orderedIds[i]];\r\n                            var nextOne = winItems[orderedIds[i + 1]];\r\n                            if (thisOne.win * thisOne.win_multiplier <\r\n                                    nextOne.win * nextOne.win_multiplier) {\r\n                                box = winItems[orderedIds[i]];\r\n                                winItems[orderedIds[i]] = nextOne;\r\n                                winItems[orderedIds[i + 1]] = box;\r\n                                change = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    for (var i = 0; i < orderedIds.length; i++) {\r\n                        addLine(winItems[orderedIds[i]]);\r\n                    }\r\n                }\r\n\r\n                var winItem, id, betline;\r\n                var ws = {};\r\n                winItems = mergeFreeGameWinItems(winItems);\r\n\r\n                addLines('FREE_GAME');\r\n                addLines('NO_BONUS');\r\n\r\n                return ws;\r\n            }\r\n            function parseStrips(strips) {\r\n                strips = $.extend(true, [], strips);\r\n                for (var i = 0; i < strips.length; i++) {\r\n                    for (var k = 0; k < strips[i].length; k++) {\r\n                        strips[i][k] -= 1;\r\n                    }\r\n                }\r\n                return strips;\r\n            }\r\n            // -------------------------------------------------------------\r\n\r\n function mSendClientInfo(loadTimeSeconds, doneCb) {\r\n                function getClientInfo() {\r\n                    var screenRes = \"{0}x{1}\".format(screen.width, screen.height);\r\n                    var lang = window.navigator.language;\r\n                    var langs = JSON.stringify(window.navigator.languages);\r\n                    var gameRes = \"{0}x{1}\".format($(window).width(), $(window).height());\r\n                    var userAgent = \"{0} GAME (lg{1} GR[{2}])\".format(window.navigator.userAgent, langs, gameRes);\r\n                    var timeZone = new Date().toString().match(/([A-Z]+[\\+-][0-9]+)/)[1];\r\n                    var os = navigator.oscpu ? navigator.oscpu : navigator.platform;\r\n                    var info = \"UA={0}&L={1}&GR={2}&R={3}&TZ={4}&LS={5}&OS={6}\".format(\r\n                            userAgent, lang, gameRes, screenRes, timeZone, langs, os);\r\n                    return info;\r\n                }\r\n                 var data = getClientInfo() + '&DP=' + Math.ceil(loadTimeSeconds);\r\n                mPost({\r\n                    command: 'CLIENT_INFO',\r\n                    data: {\r\n                        \"@type\": \"ClientInfo\",\r\n                        \"data\": data,\r\n                    },\r\n                    doNotWaitForResponse: true,\r\n                });\r\n                doneCb();\r\n            }\r\n            \r\n            function mFinishCurrentGame(doneCb) {\r\n                function step() {\r\n                    mPost({command: 'GET_NEXT_COMMAND',\r\n                        success: function (result) {\r\n                            if (result.command_id === 'START_GAME') {\r\n                                doneCb();\r\n                            } else {\r\n                                var payload = result.parameter;\r\n                                mPost({\r\n                                    command: result.command_id,\r\n                                    data: payload,\r\n                                    success: step\r\n                                });\r\n                            }\r\n                        }});\r\n                }\r\n                step();\r\n            }\r\n\r\n            function mGetInitData(data, onSuccess) {\r\n                function onInit() {\r\n                    mPost({\r\n                                command: 'GET_PAYTABLE_INFO',\r\n                                success: function (paytableResult) {\r\n                                    mPost({\r\n                                        command: 'GET_LAST_GAME',\r\n                                        success: function (lastGameResult) {\r\n                                            var parsedLastGameResult = $.extend(true, {}, lastGameResult);\r\n                                            parsedLastGameResult.features[0].current_state\r\n                                                    .strips_current = parseStrips(\r\n                                                            parsedLastGameResult.features[0].current_state\r\n                                                            .strips_current);\r\n                                            parsedLastGameResult.features[0].last_step.reaction\r\n                                                    .spin_result.drum = parseStrips(\r\n                                                            parsedLastGameResult.features[0].last_step.reaction\r\n                                                            .spin_result.drum);\r\n                                    onSuccess(paytableResult,\r\n                                                    lastGameResult, parsedLastGameResult);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            });\r\n                        }\r\n\r\n                if (config.DUMMY_DATA) {\r\n                    interface = dummyServer;\r\n                    dummyServer.defaultMsgHandler = defaultMsgHandler;\r\n                    defaultMsgHandler({\r\n                        '@type': 'Balance',\r\n                        balance: '10100.000',\r\n                        currency: 'EUR',\r\n                    });\r\n                    onInit();\r\n                } else {\r\n                    interface = websocket;\r\n                    interface.initialize(defaultMsgHandler, onInit);\r\n                }\r\n\r\n            }\r\n            function mGetCurrentPaytableValues(betModel, onSuccess) {\r\n                mPost({\r\n                    command: 'GET_DYNAMIC_HELP_INFO',\r\n                    data: {\r\n                        \"@type\": \"logic.api.gamelogic.slot.Slot_Betting_Parameters\",\r\n                        \"bet_per_line\": Number(betModel.bet),\r\n                        \"num_of_lines\": Number(betModel.activeLines),\r\n                        \"extra_bet\": 0,\r\n                        \"denom\": String(betModel.denomination)\r\n                    },\r\n                    success: function (result) {\r\n                        onSuccess(result.items);\r\n                    }\r\n                });\r\n            }\r\n            function mGetCurrentBalance(data, onSuccess) {\r\n                mPost({\r\n                    command: 'GET_BALANCE',\r\n                    success: function (balanceResult) {\r\n                        onSuccess(balanceResult);\r\n                    }});\r\n            }\r\n            function mGetSpinResult(data, onSuccess) {\r\n                mPost({\r\n                    command: 'START_GAME',\r\n                    data: {\r\n                        \"@type\": \"logic.api.gamelogic.slot.Slot_Betting_Parameters\",\r\n                        \"bet_per_line\": Number(data.model.bet),\r\n                        \"num_of_lines\": Number(data.model.activeLines),\r\n                        \"extra_bet\": 0,\r\n                        \"denom\": String(data.model.denomination)},\r\n                    success: function (spinResult) {\r\n                        onSuccess(parseSpinResult(spinResult));\r\n                    }});\r\n            }\r\n\r\n            function mEndGame(data, onSuccess) {\r\n                mPost({\r\n                    command: 'END_GAME',\r\n                    success: function (result) {\r\n                        var betModel = {};\r\n                        if (result.balance) {\r\n                            betModel.cash = result.balance.balance;\r\n                        }\r\n                        onSuccess(betModel);\r\n                    },\r\n                    ignoreErrorCode: 'GLE_Unexpected_End_Game',\r\n                });\r\n            }\r\n\r\n            function mEndFeature(data, onSuccess) {\r\n                mPost({\r\n                    command: 'END_FEATURE',\r\n                    success: function (result) {\r\n                        onSuccess(result);\r\n                    },\r\n                    ignoreErrorCode: 'GLE_Unexpected_End_Feature',\r\n                });\r\n            }\r\n\r\n            function mGetGambleFirstCard(data, onSuccess) {\r\n                mPost({\r\n                    command: 'START_FEATURE',\r\n                    data: \"GAMBLE\",\r\n                    success: function (result) {\r\n                        onSuccess(parseGambleFirstCard(result));\r\n                    }\r\n                });\r\n            }\r\n\r\n            function mGetGambleAllCards(data, onSuccess) {\r\n                var payload = {\r\n                    \"@type\": \"logic.api.gamelogic.gamble.BTD_Gamble_Action\",\r\n                    player_choice: data.cardId - 2,\r\n                    bet: data.bet,\r\n                };\r\n                mPost({\r\n                    command: 'STEP_FEATURE',\r\n                    data: payload,\r\n                    success: function (result) {\r\n                        onSuccess(parseGambleAllCards(result));\r\n                    }\r\n                });\r\n            }\r\n\r\n            function mGetFreeSpinResult(data, onSuccess) {\r\n                var payload = {\r\n                    \"@type\": \"logic.api.gamelogic.freegames.Free_Games_Action\",\r\n                };\r\n                mPost({\r\n                    command: 'STEP_FEATURE',\r\n                    data: payload,\r\n                    success: function (result) {\r\n                        onSuccess(parseFreeSpinResult(result));\r\n                    }\r\n                });\r\n            }\r\n\r\n            function mGetFreeSpinInit(data, onSuccess) {\r\n                mPost({\r\n                    command: 'START_FEATURE',\r\n                    data: \"FREE_GAME\",\r\n                    success: function (result) {\r\n                        onSuccess(parseFreeSpinInit(result));\r\n                    }\r\n                });\r\n            }\r\n\r\n            function mParseLastGameResult(data, callback) {\r\n                function parseBetModelData(input) {\r\n                    var output = {\r\n                        activeLines: input.num_of_lines,\r\n                        bet: input.bet_per_line,\r\n                        denomination: input.denom,\r\n                    };\r\n                    return output;\r\n                }\r\n\r\n                var result, activeFeature;\r\n                \r\n                if (data.status !== 'IN_PROGRESS') {\r\n                    result = {\r\n                        betModelData: parseBetModelData(data.betting_param)\r\n                    };\r\n                    callback(result);\r\n                    return;\r\n                }\r\n                \r\n                if (data.features.length === 1) {\r\n                    // spin win\r\n                    result = {\r\n                        data: {\r\n                            activity: 'spin',\r\n                        },\r\n                        lastSpinResult: parseSpinResult({data: data}).setup,\r\n                        betModelData: parseBetModelData(data.betting_param)\r\n                    };\r\n                    callback(result);\r\n                    // GAMBLE RESUME\r\n                } else {\r\n                    activeFeature = data.features[data.features.length - 1];\r\n                    if (activeFeature.feature_id === 'GAMBLE') {\r\n                        if (activeFeature.last_step) {\r\n                            // gamble has previous result\r\n                            result = {\r\n                                data: {\r\n                                    activity: 'gamble',\r\n                                    gambleResultData: parseGambleAllCards({\r\n                                        state: activeFeature\r\n                                    })\r\n                                },\r\n                                lastSpinResult: {\r\n                                    totalWin: activeFeature.current_state.curr_win\r\n                                },\r\n                                betModelData: parseBetModelData(data.betting_param)\r\n                            };\r\n                            result.lastSpinResult.totalWin = result.data.gambleResultData.win;\r\n                            callback(result);\r\n                        } else {\r\n                            // gamble pick first card\r\n                            result = {\r\n                                data: {\r\n                                    activity: 'gamble',\r\n                                    firstCardData: parseGambleFirstCard(activeFeature),\r\n                                },\r\n                                lastSpinResult: {\r\n                                    totalWin: activeFeature.current_state.curr_win\r\n                                },\r\n                                betModelData: parseBetModelData(data.betting_param)\r\n                            };\r\n                            callback(result);\r\n                        }\r\n\r\n                        // FREE GAME RESUME\r\n                    } else if (activeFeature.feature_id === 'FREE_GAME') {\r\n\r\n                        // free spins won, post end feature, pre init\r\n                        if (activeFeature.status === 'NOT_STARTED') {\r\n                            // free spins won, pre end feature\r\n                            result = {\r\n                                data: {\r\n                                    activity: 'spin',\r\n                                },\r\n                                lastSpinResult: parseSpinResult({data: data}).setup,\r\n                                betModelData: parseBetModelData(data.betting_param)\r\n                            };\r\n                            callback(result);\r\n                        } else if (activeFeature.status === 'IN_PROGRESS') {\r\n                            if (activeFeature.last_step) {\r\n                                if (activeFeature.current_state.not_played_free_games === 0) {\r\n                                    // FG has previous result, no games remaining\r\n                                    result = {\r\n                                        data: {\r\n                                            activity: 'freeSpinOver',\r\n                                        },\r\n                                        lastSpinResult: parseFreeSpinResult({state:\r\n                                                    activeFeature}).setup,\r\n                                        betModelData: parseBetModelData(data.betting_param)\r\n                                    };\r\n                                    callback(result);\r\n                                } else {\r\n                                    // FG has previous result, games remaining\r\n                                    result = {\r\n                                        data: {\r\n                                            activity: 'freeSpinIntro',\r\n                                            fgInitData: parseFreeSpinInit(activeFeature),\r\n                                        },\r\n                                        lastSpinResult: parseFreeSpinResult({state:\r\n                                                    activeFeature}).setup,\r\n                                        betModelData: parseBetModelData(data.betting_param)\r\n                                    };\r\n                                    callback(result);\r\n                                }\r\n                            } else {\r\n                                // first FG\r\n                                result = {\r\n                                    data: {\r\n                                        activity: 'freeSpinIntro',\r\n                                        fgInitData: parseFreeSpinInit(activeFeature),\r\n                                    },\r\n                                    lastSpinResult: parseSpinResult({data: data}).setup,\r\n                                    betModelData: parseBetModelData(data.betting_param)\r\n                                };\r\n                                callback(result);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            function mOnResult(command, response) {\r\n\r\n            }\r\n\r\n            function defaultMsgHandler(payload) {\r\n                if (payload['@type'] === 'Balance') {\r\n                    pubsub.publish('notify:balanceUpdate', payload);\r\n                }\r\n            }\r\n\r\n            // what we are connecting to\r\n            var interface;\r\n\r\n            // request queue\r\n            var requestQueue = [];\r\n            // timeout to keep track of request duration\r\n            var requestDurationTrackerTimeout = null;\r\n            // user alert level\r\n            // 0 - no error\r\n            // 1 - loader displayed\r\n            // 2 - notification displayed\r\n            var alertLevel = 0;\r\n            var API = {\r\n                finishCurrentGame: mFinishCurrentGame,\r\n                getInitData: mGetInitData,\r\n                getCurrentPaytableValues: mGetCurrentPaytableValues,\r\n                getSpinResult: mGetSpinResult,\r\n                endGame: mEndGame,\r\n                endFeature: mEndFeature,\r\n                getGambleFirstCard: mGetGambleFirstCard,\r\n                getGambleAllCards: mGetGambleAllCards,\r\n                getCurrentBalance: mGetCurrentBalance,\r\n                getFreeSpinInit: mGetFreeSpinInit,\r\n                getFreeSpinResult: mGetFreeSpinResult,\r\n                parseLastGameResult: mParseLastGameResult,\r\n                sendClientInfo: mSendClientInfo,\r\n                get: mPost,\r\n                onResult: mOnResult\r\n            };\r\n            return API;\r\n        });\n//# sourceURL=/modules/Type2/src/js/services/transport.js"),eval("// init service\r\n// handles game initialization\r\ndefine('services/init',[\r\n    'jquery',\r\n    'soundjs',\r\n    'require',\r\n    'pubsub',\r\n    'services/engine',\r\n    'services/pause',\r\n    'services/platform',\r\n    'services/loader',\r\n    'services/assets',\r\n    'services/dimensions',\r\n    'data/config',\r\n    'services/transport',\r\n], function (\r\n        $, createjs, require, pubsub, engine, pause, platform,\r\n        loader, assets, dimensions, config, transport) {\r\n\r\n//    console.log = function () {\r\n//    };\r\n\r\n//>>includeStart(\"debug\", pragmas.debug);\r\n    window.config = config;\r\n    window.pubsub = pubsub;\r\n    window.assets = assets;\r\n    window.loader = loader;\r\n    window.pause = pause;\r\n    window.platform = platform;\r\n    window.transport = transport;\r\n\r\n    // debug - set win probabilities\r\n    winProbability = .5;\r\n//    freeGameWinProbability = 0;\r\n//    winProbability = 0;\r\n    freeGameWinProbability = .05;\r\n//alert();\r\n    //>>includeEnd(\"debug\");\r\n\r\n    // array contains references to renederer layers\r\n    var renderers = [];\r\n    // array contains layers which will be updated on each frame\r\n    var layers = [];\r\n    // cache DOM elements used during loading\r\n    var $html = $('html');\r\n    var $intro = $('#intro-video');\r\n    var $blackDiv = $('#black-div');\r\n    var $startButton = $('#start-button');\r\n    var $progressBarWrap = $('#progress-bar-wrap');\r\n    var $progressBarBack = $('#progress-bar-back');\r\n    var $progressBarProgress = $('#progress-bar-front');\r\n    var $loadingBackground = $('#loading-back');\r\n    var progressBarSizeToken;\r\n    var balanceUpdateToken;\r\n\r\n    initEngineRenderers();\r\n    disableTouchToScrollOnLoadingHtml();\r\n    pubsub.publish('request:resize');\r\n    // init module files\r\n    initModules(function (settings) {\r\n        // adjust settings model for platform\r\n        adjustStartupSettings(settings, platform);\r\n        pubsub.publish('request:hideLoader');\r\n        // play intro video if supported\r\n        playIntroVideoIfSupported(function () {\r\n            showSplashLoadGameAssets(function () {\r\n                // download game assets\r\n                // request initial game data from server\r\n                startEngineFrames();\r\n                getInitData(function (betModel, gameModel, visibleSymbols) {\r\n                    // initialize layers\r\n                    initLayers(function () {\r\n                        // publish startup initialized event\r\n                        pubsub.publish('notify:startupInitialized', {\r\n                            betModel: $.extend(true, {}, betModel),\r\n                            gameModel: $.extend(true, {}, gameModel),\r\n                            visibleSymbols: visibleSymbols,\r\n                        });\r\n                        pubsub.unsubscribe(balanceUpdateToken);\r\n                        // display start button and wait for click\r\n                        showAndBindStartButton(function () {\r\n                            pubsub.publish('notify:startButtonClicked');\r\n                            pubsub.publish('notify:focusIn');\r\n                            triggerFullScreenIfRequested();\r\n                            // show loader for a moment\r\n                            // till everythings renders properly\r\n                            allowStartupDelayWithLoader(function () {\r\n                                // publish game visible event\r\n                                pubsub.publish('notify:gameVisible');\r\n                            }, 1000);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    });\r\n    // initialize engine (builds canvases and containers)\r\n    // get renderer references\r\n    function initEngineRenderers() {\r\n        engine.initialize();\r\n        renderers = engine.getRenderers();\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n        window.engine = engine;\r\n        window.renderers = renderers;\r\n        //>>includeEnd(\"debug\");\r\n    }\r\n    // request animation frame loop\r\n    // update registered layers on each callback\r\n    // repaint dirty canvases on each frame\r\n    function startEngineFrames() {\r\n        var k, len;\r\n        engine.startFrames(function onFrame(delta, running) {\r\n            if (running) {\r\n                for (k = 0, len = layers.length; k < len; k++) {\r\n                    layers[k].update && layers[k].update(delta);\r\n                }\r\n            }\r\n\r\n            for (k = 0, len = renderers.length; k < len; k++) {\r\n                if (renderers[k].container.needsRepaint) {\r\n                    renderers[k].container.needsRepaint = false;\r\n                    renderers[k].repaint();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    // show start button and bind to click event\r\n    function showAndBindStartButton(onClick) {\r\n        // show start button\r\n        var evt = platform.isMobile() ? 'touchend' : 'click';\r\n        $progressBarBack.hide();\r\n        $progressBarProgress.hide();\r\n        $startButton.on(evt, function () {\r\n            pubsub.unsubscribe(progressBarSizeToken);\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: config.BUTTON_CLICK_SOUND\r\n            });\r\n            $html.removeClass('startup').addClass('startup-done');\r\n            $progressBarWrap.hide();\r\n            $loadingBackground.hide();\r\n            $startButton.hide();\r\n            pubsub.publish('request:showLoader');\r\n            setTimeout(onClick, 100);\r\n        }).show();\r\n        pubsub.publish(\"request:playSound\", {\r\n            sound: config.START_BUTTON_SHOW_SOUND\r\n        });\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n//        $startButton.click().trigger('touchend');\r\n        //>>includeEnd(\"debug\");\r\n    }\r\n    // adjust settings model according to current platform\r\n    function adjustStartupSettings(settings, platform) {\r\n        var model = settings.get();\r\n        pubsub.publish('notify:languageChanged', {\r\n            lang: model.locale.language.steps[\r\n                    model.locale.language.selectedIndex].label});\r\n    }\r\n    // play intro video if supported on current plaform\r\n    function playIntroVideoIfSupported(cb) {\r\n        function play() {\r\n            $intro[0].onplay = function () {\r\n                pubsub.publish('request:resize');\r\n                pubsub.publish(\"request:playSound\", {\r\n                    sound: config.INTRO_SOUND\r\n                });\r\n            };\r\n            $intro[0].onended = function () {\r\n                $intro.hide();\r\n                cb();\r\n            };\r\n            pubsub.publish('request:resize');\r\n            $intro.show();\r\n            $intro[0].play();\r\n        }\r\n        if (platform.isVideoAvailable()) {\r\n            $intro[0].src = 'img/intro.mp4';\r\n            if ($intro[0].readyState === 4) {\r\n                play();\r\n            } else {\r\n                $intro[0].oncanplaythrough = play;\r\n            }\r\n        } else {\r\n            cb();\r\n        }\r\n    }\r\n    // show loading splash with progress bar\r\n    // load game assets\r\n    // track progress and display it on progress bar\r\n    function showSplashLoadGameAssets(cb) {\r\n        function setTransitionTime(val) {\r\n            $progressBarProgress.css({\r\n                transition: val ? 'width ' + val + 's' : 'initial',\r\n                '-webkit-transition': val ? 'width ' + val + 's' : 'initial',\r\n            });\r\n        }\r\n        function recomputeProgessbarSize(force) {\r\n            function setWidth() {\r\n                barBackWidth = $progressBarBack.outerWidth();\r\n                lastNormSet = normDone;\r\n                $progressBarProgress.css({\r\n                    visibility: 'visible',\r\n                    width: (normDone * barBackWidth) + 'px'\r\n                });\r\n            }\r\n            if (normDone > 0.99) {\r\n                setTransitionTime(0.1);\r\n                setWidth();\r\n            } else if ((normDone > 0.025 && force) || normDone > lastNormSet + 0.025) {\r\n                if (force) {\r\n                    setTransitionTime(0);\r\n                    setWidth();\r\n                    setTransitionTime(8);\r\n                } else {\r\n                    setWidth();\r\n                    setTransitionTime(8);\r\n                }\r\n            }\r\n            $progressBarWrap.css({\r\n                top: ((dimensions.windowHeight - $loadingBackground.height()\r\n                        - ($progressBarBack.is(':visible') ? $progressBarBack.outerHeight() : 0)) / 2)\r\n                        + 'px'\r\n            });\r\n        }\r\n        // show loading screen\r\n        $progressBarWrap.show();\r\n        recomputeProgessbarSize();\r\n        $loadingBackground.css('visibility', 'visible');\r\n        setTransitionTime(0);\r\n        progressBarSizeToken = pubsub.subscribe('notify:dimensionsChanged', function () {\r\n            recomputeProgessbarSize(true);\r\n        });\r\n        var barBackWidth;\r\n        var normDone = 0;\r\n        var lastNormSet = 0.05;\r\n        assets.loadGameAssets(\r\n                function onProgress(nd) {\r\n                    normDone = nd;\r\n                    recomputeProgessbarSize();\r\n                },\r\n                function onReady() {\r\n                    setTransitionTime(0);\r\n                    normDone = 1;\r\n                    recomputeProgessbarSize();\r\n                    cb();\r\n                });\r\n    }\r\n    // display loader with black screen for a moment\r\n    // till everything renders properly\r\n    function allowStartupDelayWithLoader(cb, delay) {\r\n        pubsub.publish('request:showLoader');\r\n        setTimeout(function () {\r\n            $blackDiv.hide();\r\n            pubsub.publish('request:hideLoader');\r\n            cb();\r\n        }, delay);\r\n    }\r\n    function initLayers(cb) {\r\n        var ks = Object.keys(window.initModulesList.layers);\r\n        var valsCtrl = ks.map(function (key) {\r\n            return 'layers/' + key + '/' + key + 'Ctrl';\r\n        });\r\n        require(valsCtrl, function () {\r\n            //>>includeStart(\"debug\", pragmas.debug);\r\n            for (var i = 0; i < ks.length; i++) {\r\n                window[ks[i]] = arguments[i];\r\n                if (arguments[i].view) {\r\n                    window[ks[i]].el = arguments[i].view.elements;\r\n                }\r\n            }\r\n            window.layers = layers;\r\n            //>>includeEnd(\"debug\");\r\n            // add reference to layers to be updated on each frame\r\n            for (var i = 0; i < ks.length; i++) {\r\n                layers.push(arguments[ks.indexOf(ks[i])]);\r\n            }\r\n            cb();\r\n        });\r\n    }\r\n    function initModules(cb) {\r\n        function initType(type, cb) {\r\n            var ks = Object.keys(window.initModulesList[type]);\r\n            var vals = ks.map(function (key) {\r\n                return type + '/' + key;\r\n            });\r\n            require(vals, function () {\r\n                //>>includeStart(\"debug\", pragmas.debug);\r\n                for (var i = 0; i < ks.length; i++) {\r\n                    window[ks[i]] = arguments[i];\r\n                }\r\n                //>>includeEnd(\"debug\");\r\n                cb();\r\n            });\r\n        }\r\n        var types = ['data', 'services', 'activities', 'components'];\r\n        var current = 0;\r\n        var onFinished = function () {\r\n            current++;\r\n            if (current === types.length) {\r\n                require(['services/settings'], cb);\r\n            } else {\r\n                initType(types[current], onFinished);\r\n            }\r\n        };\r\n        initType(types[current], onFinished);\r\n    }\r\n\r\n    function getInitData(initDoneCb) {\r\n        function onDataReceived() {\r\n            function setBetModel(resumeBetData) {\r\n                function checkBetModelValidity() {\r\n                    if (config.BET_STEPS.indexOf(betModel.bet) === -1) {\r\n                        betModel.bet = config.BET_STEPS[0];\r\n                    }\r\n                    if (config.LINES_STEPS.indexOf(betModel.activeLines) === -1) {\r\n                        betModel.activeLines = config.LINES_STEPS[config.LINES_STEPS.length - 1];\r\n                    }\r\n                    if (config.DENOMINATION_STEPS.indexOf(\r\n                            betModel.denomination) === -1) {\r\n                        betModel.denomination = config.DENOMINATION_STEPS[0];\r\n                    }\r\n                }\r\n\r\n                if (!resumeBetData) {\r\n                    // default bet model\r\n                    betModel.bet = config.BET_STEPS[0];\r\n                    betModel.activeLines = config.LINES_STEPS[config.LINES_STEPS.length - 1];\r\n                    betModel.denomination = config.DENOMINATION_STEPS[0];\r\n                } else {\r\n                    betModel.bet = resumeBetData.bet;\r\n                    betModel.activeLines = resumeBetData.activeLines;\r\n                    betModel.denomination = resumeBetData.denomination;\r\n                }\r\n                checkBetModelValidity();\r\n                betModel.totalBet = betModel.bet * betModel.activeLines;\r\n            }\r\n\r\n            var loadTimeSeconds = (Date.now() - window.loadTimeStartMs) / 1000;\r\n            transport.sendClientInfo(loadTimeSeconds, function () {\r\n                transport.parseLastGameResult(lastGameResult, function (resumeData) {\r\n                    if (lastGameResult.status === 'IN_PROGRESS') {\r\n                        //>>includeStart(\"debug\", pragmas.debug);\r\n                        console.log('resumeData', resumeData);\r\n                        //>>includeEnd(\"debug\");\r\n                        gameModel.resumeData = resumeData.data;\r\n                        gameModel.lastSpinResult = resumeData.lastSpinResult;\r\n                        setBetModel(resumeData.betModelData);\r\n                        initDoneCb(betModel, gameModel, visibleSymbols);\r\n                    } else {\r\n                        setBetModel(config.DUMMY_DATA ?\r\n                                null : resumeData.betModelData);\r\n                        initDoneCb(betModel, gameModel, visibleSymbols);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        var betModel = {\r\n            bet: null,\r\n            totalBet: null,\r\n            denomination: null,\r\n            activeLines: null,\r\n            cash: null,\r\n            currency: null,\r\n            credits: null,\r\n        };\r\n        var gameModel = {\r\n            currentActivity: null,\r\n            startupData: null,\r\n            lastSpinResult: null,\r\n            hasEnoughCashToSpin: null,\r\n        };\r\n        var stripes, visibleSymbols;\r\n        var lastGameResult;\r\n        balanceUpdateToken = pubsub.subscribe('notify:balanceUpdate', function (id, bResult) {\r\n            betModel.cash = bResult.balance;\r\n            betModel.currency = bResult.currency;\r\n        });\r\n\r\n        transport.getInitData(null, function (paytableResult,\r\n                lgResult, parsedLastGameResult) {\r\n\r\n            transport.getCurrentBalance(null, function (result) {\r\n                pubsub.publish('notify:balanceUpdate', result);\r\n                stripes = parsedLastGameResult.features[0].current_state\r\n                        .strips_current;\r\n                visibleSymbols = parsedLastGameResult.features[0].last_step.reaction\r\n                        .spin_result.drum;\r\n                gameModel.startupData = {\r\n                    stripes: stripes\r\n                };\r\n                config.BET_STEPS = paytableResult.bets_set;\r\n                config.DENOMINATION_STEPS = paytableResult.denoms_set;\r\n                config.LINES_STEPS = paytableResult.lines_set;\r\n                config.MAX_BET_IN_MONEY = paytableResult.maxbet_in_money;\r\n                lastGameResult = lgResult;\r\n                onDataReceived();\r\n            });\r\n\r\n//            if (lastGameResult.status === 'IN_PROGRESS') {\r\n//                transport.finishCurrentGame(function () {\r\n//                    setBetModel(null);\r\n//                    cb(betModel, gameModel, visibleSymbols);\r\n//                });\r\n//            } else {\r\n//                setBetModel(null);\r\n//                cb(betModel, gameModel, visibleSymbols);\r\n//            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n    // disable touch to scroll on loading elements\r\n    function disableTouchToScrollOnLoadingHtml() {\r\n//        $loadingBackground.add($progressBarWrap).add($blackDiv)\r\n//                .on('touchstart', function (e) {\r\n//                    e.preventDefault();\r\n//                });\r\n    }\r\n    // triggers full screen if defined in config\r\n    function triggerFullScreenIfRequested() {\r\n        if (config.SET_FULL_SCREEN_ON_START && !config.DUMMY_DATA) {\r\n            pubsub.publish('request:setFullScreen', {fullScreen: true});\r\n        }\r\n        // update full screen status view after a delay\r\n        pause.setTimeout(function () {\r\n            pubsub.publish('request:updateFullScreenStatus');\r\n        }, 5000);\r\n    }\r\n   \r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/services/init.js"),
eval("// game service\r\n// hold and updates game and bet models\r\n// handles transitions between activities\r\n// routes events to activities\r\ndefine('services/game',[\r\n    'jquery',\r\n    'pubsub',\r\n    'big',\r\n    'services/settings',\r\n    'services/transport',\r\n    'data/config',\r\n    'data/config-reelSet',\r\n    'data/config-symbolSet',\r\n], function (\r\n        $,\r\n        pubsub,\r\n        big,\r\n        settings,\r\n        transport,\r\n        config,\r\n        reelSet,\r\n        symbolSet\r\n        ) {\r\n\r\n//>>includeStart(\"debug\", pragmas.debug);\r\n    window.symbolSet = symbolSet;\r\n    window.big = big;\r\n//>>includeEnd(\"debug\");\r\n\r\n    // object represents current bet and balance\r\n    var betModel;\r\n    // object represents important game parameters\r\n    var gameModel;\r\n\r\n    // object holds refernces to all activities\r\n    var activities = {};\r\n\r\n    // paytable refresh\r\n    var paytableRefreshTimeout;\r\n\r\n    // object defines main action handlers\r\n    pubsub.subscribeBatch({\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n        // DEBUG\r\n        // for testing purposes: recompute bet model\r\n        'request:recomputeBetModel': recomputeBetModel,\r\n        //>>includeEnd(\"debug\");\r\n        // NOTIFICATIONS\r\n        // the game has loaded\r\n        'notify:startupInitialized': initStartupData,\r\n        'notify:gameVisible': gameVisible,\r\n        'notify:balanceUpdate': onBalanceUpdateMsg,\r\n        // game received spin result from server\r\n        'notify:spinResultReceived': spinResultReceived,\r\n        // REQUESTS\r\n        'request:runActivity': runActivity,\r\n        // request to resolve credits balance with server\r\n        'request:cashIn': cashIn,\r\n        // request to update views with current models\r\n        'request:viewUpdate': updateViewsWithModels,\r\n        // request to update views with current models\r\n        'request:balanceUpdate': updateBalance,\r\n        // request to load menu with models\r\n        'request:loadMenu': loadMenu,\r\n        // BUTTONS\r\n        // button events handled in game controller\r\n        'notify:startButtonClicked': startButtonClicked,\r\n        'request:exit': exitRequested,\r\n        'notify:betUpButtonClicked': betUpClicked,\r\n        'notify:betDownButtonClicked': betDownClicked,\r\n        'notify:betChanged': betChanged,\r\n        'notify:betlinesButtonClicked': betlinesButtonClicked,\r\n        'notify:betlineButtonClicked': betlineButtonClicked,\r\n        'notify:betlinesChanged': betlinesChanged,\r\n        'notify:creditCoinClicked': creditCoinClicked,\r\n        'notify:denominationChanged': denominationChanged,\r\n        // DISPATCHED EVENTS - BUTTONS\r\n        // button events dispatched to activities\r\n        'notify:bottomPanelClicked': dispatchEventToActivity,\r\n        'notify:spacePressed': dispatchEventToActivity,\r\n        'notify:spinButtonClicked': dispatchEventToActivity,\r\n        'notify:autoButtonClicked': dispatchEventToActivity,\r\n        'notify:turboButtonClicked': dispatchEventToActivity,\r\n        'notify:stopButtonClicked': dispatchEventToActivity,\r\n        'notify:takeWinButtonClicked': dispatchEventToActivity,\r\n        'notify:takeRiskButtonClicked': dispatchEventToActivity,\r\n        'notify:gambleCardClicked': dispatchEventToActivity,\r\n        // DISPATCHED EVENTS - NOTIFICATIONS\r\n        // notification events dispatched to activities\r\n        'notify:menuStateChange': dispatchEventToActivity,\r\n        'notify:spinButtonTouch': dispatchEventToActivity,\r\n        'notify:nextToLastReelStopped': dispatchEventToActivity,\r\n        'notify:fasterSpinStarted': dispatchEventToActivity,\r\n        'notify:spinFinished': dispatchEventToActivity,\r\n        'notify:winAmountAnimationFinished': dispatchEventToActivity,\r\n        'notify:winLinesViewFirstPassFinished': dispatchEventToActivity,\r\n        'notify:winLineDisplayed': dispatchEventToActivity,\r\n        'notify:allWinLinesPreviewDisplayed': dispatchEventToActivity,\r\n        'notify:reelSurfaceTouchStart': dispatchEventToActivity,\r\n        'notify:reelSurfaceTouchEnd': dispatchEventToActivity,\r\n        'notify:reelBounceStart': dispatchEventToActivity,\r\n        // DISPATCHED REQUESTS\r\n        'request:updateViewsWithModels': dispatchEventToActivity,\r\n        // special activity commands\r\n        'request:specialCommand': dispatchEventToActivity,\r\n    });\r\n    return {};\r\n    // -------------------------------------------------------\r\n    // START INIT\r\n    // stores startup data from server in models\r\n    function initStartupData(id, data) {\r\n        betModel = data.betModel;\r\n        gameModel = data.gameModel;\r\n        //>>includeStart(\"debug\", pragmas.debug);\r\n        window.betModel = betModel;\r\n        window.gameModel = gameModel;\r\n        //>>includeEnd(\"debug\");\r\n        // recompute model values\r\n        updateModel();\r\n        // initialize betlines\r\n        pubsub.publish('request:initBetlines', {\r\n            symbolSet: symbolSet.SPIN\r\n        });\r\n        // display current models to user\r\n        updateViewsWithModels();\r\n\r\n        updatePaytable();\r\n\r\n//      initialize reels with data from server\r\n        pubsub.publish('request:initReels', {\r\n            reelSet: reelSet.BASE,\r\n            symbolSet: symbolSet.SPIN,\r\n            stripes: gameModel.startupData.stripes,\r\n            soundData: config.BASIC_SPIN_SOUND_DATA,\r\n            visibleSymbols: data.visibleSymbols,\r\n        });\r\n    }\r\n\r\n    function gameVisible() {\r\n        if (gameModel.currentActivity.name === 'idle') {\r\n            pubsub.publish('request:showHelpOverlay');\r\n            pubsub.publish('request:resize');\r\n        }\r\n    }\r\n\r\n\r\n    // -------------------------------------------------------\r\n    // BUTTON HANDLERS\r\n    //\r\n    // game start button handler\r\n    // load references to activities\r\n    function startButtonClicked() {\r\n        pubsub.publish('notify:gameStartupFinished');\r\n        pubsub.publish('request:showBackground');\r\n        // load references to activities and run idle activity\r\n        loadAllActivities(function () {\r\n            if (gameModel.resumeData) {\r\n                // unfinished game, resume state\r\n                runActivity(null, {\r\n                    activity: gameModel.resumeData.activity,\r\n                    options: {\r\n                        resumeData: gameModel.resumeData\r\n                    }\r\n                });\r\n            } else {\r\n                runActivity(null, {activity: 'idle'});\r\n            }\r\n        });\r\n    }\r\n\r\n    // exit button handler\r\n    // redirects away from game\r\n    function exitRequested(id, data) {\r\n        pubsub.publish('request:quitToLobby');\r\n    }\r\n    // bet up button handler\r\n    // increment current bet by one step\r\n    // clear animations\r\n    // update view\r\n    function betUpClicked() {\r\n        incrementBet();\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n        pubsub.publish('request:previewBetlines', betModel.activeLines);\r\n    }\r\n    // bet down button handler\r\n    // decrement current bet by one step\r\n    // clear animations\r\n    // update view\r\n    // preview betlines\r\n    function betDownClicked() {\r\n        decrementBet();\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n        pubsub.publish('request:previewBetlines', betModel.activeLines);\r\n    }\r\n    // increment betlines button handler\r\n    // increment active betlines count by specified step\r\n    // clear animations\r\n    // update view\r\n    // preview betlines\r\n    function betlinesButtonClicked(id, data) {\r\n        if (data.sign === undefined) {\r\n            data.sign = 1;\r\n        }\r\n        changeBetLines(data.sign);\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n        pubsub.publish('request:previewBetlines', betModel.activeLines);\r\n    }\r\n    // specific betline button handler\r\n    // set betlines count to selected value\r\n    // clear animations\r\n    // update view\r\n    // preview betlines\r\n    function betlineButtonClicked(id, betlineIndex) {\r\n        setBetLines(betlineIndex);\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n        pubsub.publish('request:previewBetlines', betModel.activeLines);\r\n    }\r\n    // cash denomination button handler\r\n    // increment denomination value by one step\r\n    function creditCoinClicked(id, data) {\r\n        if (data.sign === undefined) {\r\n            data.sign = 1;\r\n        }\r\n        changeDenomination(data.sign);\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n        pubsub.publish('request:previewBetlines', betModel.activeLines);\r\n    }\r\n    function loadMenu(id, data) {\r\n        pubsub.publish('request:showMenu', {\r\n            settings: settings.get(),\r\n            gameModel: $.extend({}, gameModel),\r\n            betModel: $.extend({}, betModel),\r\n            page: data.page\r\n        });\r\n    }\r\n\r\n    // -------------------------------------------------------\r\n    // LOGIC EVENT HANDLERS\r\n\r\n    // spin result receive handler\r\n    // runs when the browser receives a spin results\r\n    // interchange the local bet model for the one from server\r\n    // stores the spin result in game model\r\n    function spinResultReceived(id, data) {\r\n        if (data.result) {\r\n            var result = data.result;\r\n            if (result.model) {\r\n                setBetModel(result.model);\r\n                //>>includeStart(\"debug\", pragmas.debug);\r\n                window.betModel = betModel;\r\n                //>>includeEnd(\"debug\");\r\n            }\r\n            if (result.setup) {\r\n                gameModel.lastSpinResult = result.setup;\r\n            }\r\n            updateModel();\r\n            updateViewsWithModels();\r\n        }\r\n    }\r\n    // -------------------------------------------------------\r\n    // ACTIVITIES OPERATIONS\r\n    // starts a new activity\r\n    function runActivity(id, data) {\r\n        var prevActivity = gameModel.currentActivity\r\n                ? gameModel.currentActivity.name : null;\r\n        var options = data.options || {};\r\n        var activity = activities[data.activity];\r\n        gameModel.currentActivity = activity;\r\n        // recompute model values\r\n        updateModel();\r\n        // publish activity before start event\r\n        pubsub.publish('notify:activityBeforeStart', {\r\n            activity: gameModel.currentActivity.name,\r\n        });\r\n        // start activity\r\n        gameModel.currentActivity.start({\r\n            betModel: $.extend({}, betModel),\r\n            gameModel: $.extend({}, gameModel),\r\n            prevActivity: prevActivity,\r\n            options: options,\r\n        });\r\n        // publish activity after start event\r\n        pubsub.publish('notify:activityAfterStart', {\r\n            activity: gameModel.currentActivity.name\r\n        });\r\n    }\r\n    // dispatch events to activity handlers\r\n    function dispatchEventToActivity(id, data) {\r\n        console.log('dispatch', id, gameModel.currentActivity)\r\n        if (gameModel.currentActivity) {\r\n            // call current activity handler\r\n            gameModel.currentActivity.handle(id, data);\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------\r\n    // BET MODEL OPERATIONS\r\n    function setBetModel(model) {\r\n        betModel = $.extend(betModel, model);\r\n    }\r\n\r\n    // sync model from server after win\r\n    function cashIn(id, data) {\r\n        if (data.betModel && data.betModel.cash !== undefined) {\r\n            betModel.cash = data.betModel.cash;\r\n        }\r\n        // update views if requested\r\n        if (data.updateViews) {\r\n            updateViewsWithModels();\r\n        }\r\n        // run callbacks if requested\r\n        if (data.callback) {\r\n            setTimeout(function () {\r\n                pubsub.publish('notify:winAccepted', {\r\n                    betModel: betModel,\r\n                    gameModel: gameModel\r\n                });\r\n                data.callback({\r\n                    betModel: betModel,\r\n                    gameModel: gameModel\r\n                });\r\n            }, 0);\r\n        }\r\n    }\r\n    // publish a request to update views with current model\r\n    function updateViewsWithModels() {\r\n        pubsub.publish('request:updateViewsWithModels', {\r\n            betModel: betModel,\r\n            gameModel: gameModel,\r\n        });\r\n    }\r\n    // recompute model values\r\n    function updateModel() {\r\n        betModel.totalBet = big(betModel.activeLines).times(betModel.bet).valueOf();\r\n        betModel.credits = Math.floor(big(betModel.cash).div(betModel.denomination).valueOf());\r\n        gameModel.hasEnoughCashToSpin = Number(betModel.totalBet) <= Number(betModel.credits);\r\n    }\r\n\r\n    function updatePaytable() {\r\n        function refresh() {\r\n            pubsub.publish('request:updatePaytable', {\r\n                items: null\r\n            });\r\n            transport.getCurrentPaytableValues(betModel, function (items) {\r\n                pubsub.publish('request:updatePaytable', {\r\n                    items: items\r\n                });\r\n            });\r\n        }\r\n        paytableRefreshTimeout && clearTimeout(paytableRefreshTimeout);\r\n        paytableRefreshTimeout = setTimeout(refresh, 300);\r\n    }\r\n\r\n    function updateBalance() {\r\n        pubsub.publish('request:showLoader');\r\n        transport.getCurrentBalance(null, function (bResult) {\r\n            betModel.cash = bResult.balance;\r\n            updateModel();\r\n            updateViewsWithModels();\r\n            pubsub.publish('request:hideLoader');\r\n        });\r\n    }\r\n    function onBalanceUpdateMsg(id, body) {\r\n        if (!betModel) {\r\n            // msg during startup - handled by init service\r\n            return;\r\n        }\r\n        betModel.cash = body.balance;\r\n        updateModel();\r\n        updateViewsWithModels();\r\n    }\r\n\r\n    //>>includeStart(\"debug\", pragmas.debug);\r\n    // for testing purposes: recompute bet model\r\n    function recomputeBetModel() {\r\n        updateModel();\r\n        updateViewsWithModels();\r\n    }\r\n    //>>includeEnd(\"debug\");\r\n\r\n    // increment denomination by one step\r\n    // update views\r\n    function changeDenomination(sign) {\r\n        var availableValues = config.DENOMINATION_STEPS;\r\n        var currentIndex = config.DENOMINATION_STEPS.indexOf(betModel.denomination);\r\n        var newIndex = currentIndex + sign * 1;\r\n        if (newIndex > availableValues.length - 1) {\r\n            newIndex = 0;\r\n        }\r\n        if (newIndex < 0) {\r\n            newIndex = availableValues.length - 1;\r\n        }\r\n        betModel.denomination = availableValues[newIndex];\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n    // increment active betlines count by one step\r\n    // update views\r\n    function changeBetLines(sign) {\r\n        var availableValues = config.LINES_STEPS;\r\n        var currentIndex = config.LINES_STEPS.indexOf(betModel.activeLines);\r\n        var newIndex = currentIndex + sign * 1;\r\n        if (newIndex > availableValues.length - 1) {\r\n            newIndex = 0;\r\n        }\r\n        if (newIndex < 0) {\r\n            newIndex = availableValues.length - 1;\r\n        }\r\n        betModel.activeLines = availableValues[newIndex];\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n    // set active betlines count to selected value\r\n    // update views\r\n    function setBetLines(index) {\r\n        var maxBetlines = config.BETLINES_TOTAL;\r\n        if (index > -1 && index < maxBetlines) {\r\n            betModel.activeLines = index + 1;\r\n        }\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n    // increment current bet by one step\r\n    // update views\r\n    function incrementBet() {\r\n        var availableValues = config.BET_STEPS;\r\n        var currentIndex = config.BET_STEPS.indexOf(betModel.bet);\r\n        var newIndex = currentIndex + 1;\r\n        if (newIndex > availableValues.length - 1) {\r\n            newIndex = 0;\r\n        }\r\n        betModel.bet = availableValues[newIndex];\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n    // decrement current bet by one step\r\n    // update views\r\n    function decrementBet() {\r\n        var availableValues = config.BET_STEPS;\r\n        var currentIndex = config.BET_STEPS.indexOf(betModel.bet);\r\n        var newIndex = currentIndex - 1;\r\n        if (newIndex < 0) {\r\n            newIndex = availableValues.length - 1;\r\n        }\r\n        betModel.bet = availableValues[newIndex];\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n\r\n    function betChanged(id, newVal) {\r\n        betModel.bet = newVal;\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n    function betlinesChanged(id, newVal) {\r\n        betModel.activeLines = newVal;\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n    function denominationChanged(id, newVal) {\r\n        betModel.denomination = newVal;\r\n        updateModel();\r\n        updateViewsWithModels();\r\n        updatePaytable();\r\n    }\r\n\r\n\r\n\r\n    // -------------------------------------------------------\r\n    // HELPERS\r\n    // load references to all activities\r\n    function loadAllActivities(cb) {\r\n        var ks = Object.keys(window.initModulesList.activities);\r\n        var vals = ks.map(function (key) {\r\n            return 'activities/' + key;\r\n        })\r\n        require(vals, function () {\r\n            for (var i = 0; i < arguments.length; i++) {\r\n                activities[ks[i]] = arguments[i];\r\n            }\r\n            cb();\r\n        });\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/game.js"),eval("// start\r\n// runs first on application startup\r\n// - augments javascript environment\r\n// - halts loading and displays message when the browser is outdated\r\n// - then gives control init controller\r\ndefine('services/start',[],function () {\r\n    startupAugmentation();\r\n    require(['pubsub', 'services/platform'],\r\n            function (pubsub, platform) {\r\n                // check wheteher browser is suitable for the game\r\n                if (platform.isOutdatedBrowser()) {\r\n                    // browser is outdated, publish a request to alert user about the fack\r\n                    pubsub.publish('request:alertOutdated');\r\n                } else {\r\n                    // browser is OK\r\n                    // show loader\r\n                    // run initialization controller\r\n                    pubsub.publish('request:showLoader');\r\n                    require(['services/init'], function () {\r\n                    });\r\n                }\r\n            });\r\n\r\n    // enhance javascript\r\n    function startupAugmentation() {\r\n        // attach the .equals method to Array's prototype to call it on any array\r\n        Array.prototype.equals = function (array) {\r\n            // if the other array is a falsy value, return\r\n            if (!array)\r\n                return false;\r\n\r\n            // compare lengths - can save a lot of time\r\n            if (this.length != array.length)\r\n                return false;\r\n\r\n            for (var i = 0, l = this.length; i < l; i++) {\r\n                // Check if we have nested arrays\r\n                if (this[i] instanceof Array && array[i] instanceof Array) {\r\n                    // recurse into the nested arrays\r\n                    if (!this[i].equals(array[i]))\r\n                        return false;\r\n                } else if (this[i] != array[i]) {\r\n                    // Warning - two different object instances will never be equal: {x:20} != {x:20}\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        // string format method\r\n        if (!String.prototype.format) {\r\n            String.prototype.format = function () {\r\n                var args = arguments;\r\n                return this.replace(/{(\\d+)}/g, function (match, number) {\r\n                    return typeof args[number] != 'undefined'\r\n                            ? args[number]\r\n                            : match\r\n                            ;\r\n                });\r\n            };\r\n        }\r\n        // add superior method\r\n        Object.defineProperty(Object.prototype, 'superior', {\r\n            value: function (name) {\r\n                var that = this,\r\n                        method = that[name];\r\n                return function ( ) {\r\n                    return method.apply(that, arguments);\r\n                };\r\n            },\r\n            enumerable: false\r\n        });\r\n        // create common objects to fix older browser errors\r\n        (function () {\r\n            var method;\r\n            var noop = function () {\r\n            };\r\n            var methods = [\r\n                'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',\r\n                'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',\r\n                'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',\r\n                'timeStamp', 'trace', 'warn'\r\n            ];\r\n            var length = methods.length;\r\n            var console = (window.console = window.console || {});\r\n\r\n            while (length--) {\r\n                method = methods[length];\r\n\r\n                // Only stub undefined methods.\r\n                if (!console[method]) {\r\n                    console[method] = noop;\r\n                }\r\n            }\r\n        }());\r\n    }\r\n\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/services/start.js"),eval("// cursor\r\n// controls button hover in-out cursor behavior\r\n// when the user hovers over a button, the upper-most canvas class is changed\r\n// so that the cursor is a pointer\r\ndefine('services/cursor',['jquery', 'pubsub'], function ($, pubsub) {\r\n\r\n    var $canvas = null;\r\n    var currentlyHovering = null;\r\n\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        'notify:hoverableButtonHoveredIn': function (id, data) {\r\n            if (!$canvas) {\r\n                $canvas = $('canvas').last();\r\n            }\r\n            currentlyHovering = data.element;\r\n            $canvas.addClass('hovered');\r\n        },\r\n        'notify:hoverableButtonHoveredOut': function (id, data) {\r\n            if (data.element !== currentlyHovering) {\r\n                return;\r\n            }\r\n            if (!$canvas) {\r\n                $canvas = $('canvas').last();\r\n            }\r\n            $canvas.removeClass('hovered');\r\n        }\r\n    });\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/cursor.js"),eval("// keyboard\r\n// handles keyboard events a publishes them as pubsub events\r\ndefine('services/keyboard',['jquery', 'pubsub', 'data/config'], function ($, pubsub, config) {\r\n\r\n    var currentActivity = null;\r\n    var currentSubActivity = null;\r\n    var gamePaused = null;\r\n    pubsub.subscribeBatch({\r\n        'notify:activityAfterStart': function (id, data) {\r\n            currentActivity = data.activity;\r\n        },\r\n        'notify:subactivityStarted': function (id, data) {\r\n            currentSubActivity = data.subactivity;\r\n        },\r\n        'notify:subactivityFinished': function (id, data) {\r\n            currentSubActivity = null;\r\n        },\r\n        'notify:gamePaused': function (id, data) {\r\n            gamePaused = true;\r\n        },\r\n        'notify:gameResumed': function (id, data) {\r\n            gamePaused = false;\r\n        }\r\n    });\r\n    var ACTIONS = {\r\n        GO: function () {\r\n            if (currentSubActivity === null) {\r\n                pubsub.publish('notify:spacePressed');\r\n            }\r\n        },\r\n        SELECT_GAME: {\r\n            'idle': function () {\r\n                pubsub.publish('request:exit');\r\n            }\r\n        },\r\n        BET_UP: {\r\n            'idle': function () {\r\n                pubsub.publish('notify:betUpButtonClicked');\r\n            }\r\n        },\r\n        BET_DOWN: {\r\n            'idle': function () {\r\n                pubsub.publish('notify:betDownButtonClicked');\r\n            }\r\n        },\r\n        LINES_UP: {\r\n            'idle': function () {\r\n                pubsub.publish('notify:betlinesButtonClicked', {\r\n                    sign: 1\r\n                });\r\n            }\r\n        },\r\n        LINES_DOWN: {\r\n            'idle': function () {\r\n                pubsub.publish('notify:betlinesButtonClicked', {\r\n                    sign: -1\r\n                });\r\n            }\r\n        },\r\n        DENOM_UP: {\r\n            'idle': function () {\r\n                pubsub.publish('notify:creditCoinClicked', {\r\n                    sign: 1\r\n                });\r\n            }\r\n        },\r\n        DENOM_DOWN: {\r\n            'idle': function () {\r\n                pubsub.publish('notify:creditCoinClicked', {\r\n                    sign: -1\r\n                });\r\n            }\r\n        },\r\n        HELP: function () {\r\n            if (currentSubActivity === 'menu') {\r\n                pubsub.publish('request:closeMenu');\r\n            } else if (!currentSubActivity\r\n                    && (currentActivity === 'idle' || currentActivity === 'gamble')) {\r\n                pubsub.publish('request:loadMenu', {page: 5});\r\n            }\r\n        },\r\n        AUTOSPIN: {\r\n            'idle,autoSpin,autoSpinNoWin,autoSpinWin': function () {\r\n                pubsub.publish('notify:autoButtonClicked');\r\n            }\r\n        },\r\n        LINES_1: {\r\n        },\r\n        LINES_2: {\r\n            'gamble': function () {\r\n                pubsub.publish('notify:gambleCardClicked', {\r\n                    cardId: 2\r\n                });\r\n            },\r\n        },\r\n        LINES_3: {\r\n            'gamble': function () {\r\n                pubsub.publish('notify:gambleCardClicked', {\r\n                    cardId: 3\r\n                });\r\n            },\r\n        },\r\n        LINES_4: {\r\n            'gamble': function () {\r\n                pubsub.publish('notify:gambleCardClicked', {\r\n                    cardId: 4\r\n                });\r\n            },\r\n        },\r\n        LINES_5: {\r\n            'gamble': function () {\r\n                pubsub.publish('notify:gambleCardClicked', {\r\n                    cardId: 5\r\n                });\r\n            },\r\n        },\r\n        GAMBLE: {\r\n            'win': function () {\r\n                pubsub.publish('notify:takeRiskButtonClicked');\r\n            }\r\n        },\r\n        MAXBET: {\r\n            'idle': function () {\r\n                pubsub.publish('notify:betChanged',\r\n                        config.BET_STEPS[config.BET_STEPS.length - 1]);\r\n            }\r\n        },\r\n    };\r\n    var KEYS = {\r\n        13: ACTIONS.GO, // enter\r\n        32: ACTIONS.GO, // space\r\n        38: ACTIONS.BET_UP, // arrow up\r\n        40: ACTIONS.BET_DOWN, // arrow down\r\n        39: ACTIONS.LINES_UP, // arrow right\r\n        37: ACTIONS.LINES_DOWN, // arrow left\r\n        36: ACTIONS.DENOM_UP, // home\r\n        35: ACTIONS.DENOM_DOWN, // end\r\n        56: ACTIONS.HELP, // number 8\r\n        111: ACTIONS.SELECT_GAME, // pad /\r\n        9: ACTIONS.SELECT_GAME, // tab\r\n        20: ACTIONS.AUTOSPIN, // caps lock\r\n        106: ACTIONS.AUTOSPIN, // pad *\r\n        49: ACTIONS.LINES_1, // number 1\r\n        50: ACTIONS.LINES_2, // number 2\r\n        51: ACTIONS.LINES_3, // number 3\r\n        52: ACTIONS.LINES_4, // number 4\r\n        53: ACTIONS.LINES_5, // number 5\r\n        55: ACTIONS.GAMBLE, // number 7\r\n        57: ACTIONS.MAXBET, // number 9\r\n    };\r\n//    $(parent.parent.document).on('keydown', function (e) {\r\n    $(document).on('keydown', function (e) {\r\n        var i, k, activities, fns;\r\n        var action = KEYS[e.keyCode];\r\n        e.stopImmediatePropagation();\r\n        e.preventDefault();\r\n        if (gamePaused) {\r\n            return;\r\n        }\r\n\r\n        if (action) {\r\n            if (typeof action === 'function') {\r\n                action();\r\n            } else if (currentSubActivity === null) {\r\n                fns = Object.keys(action);\r\n                for (i = 0; i < fns.length; i++) {\r\n                    activities = fns[i].split(',');\r\n                    for (k = 0; k < activities.length; k++) {\r\n                        if (currentActivity === activities[k]) {\r\n                            action[fns[i]]();\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    });\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/keyboard.js"),eval("// coreSound\r\n// controls audio playback in game\r\ndefine('services/coreSound',[\r\n    'pubsub',\r\n    'soundjs',\r\n    'data/config',\r\n    'services/assets',\r\n    'services/settings',\r\n    'services/pause',\r\n    'services/platform',\r\n], function (pubsub, soundjs, config, assets, settings, pause, platform) {\r\n\r\n// holds reference to currently playing sound effects\r\n    var currentlyPlayingEffects = {};\r\n    // holds reference to currently playing background sounds\r\n    var currentlyPlayingBackground = {};\r\n    // currently played background sound\r\n    var currentBackgroundSound = config.BACKGROUND_SOUND;\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        // runs on startup\r\n        'notify:gameStartupFinished': function () {\r\n            // publish model update event\r\n            // so that views can update themselves\r\n            pubsub.publish('request:updateSoundViews');\r\n        },\r\n        // the user switched the sounds ON/OFF\r\n        'notify:masterSoundSwitchChanged': toggleMaster,\r\n        // the user pressed the sound button in top right panel\r\n        'notify:masterSoundButtonClicked': toggleMaster,\r\n        // the user switched sound effects ON/OFF\r\n        'notify:effectsSoundSwitchChanged': toggleEffects,\r\n        // the user switched background sound ON/OFF\r\n        'notify:backgroundSoundSwitchChanged': toggleBackground,\r\n        // the user changed master volume setting\r\n        'notify:masterVolumeChanged': function (id, data) {\r\n            var model = settings.get().sound;\r\n            model.master.volume = data.volume;\r\n            updatePlayback();\r\n            settings.save();\r\n        },\r\n        // the user changed effects volume setting\r\n        'notify:effectsVolumeChanged': function (id, data) {\r\n            var model = settings.get().sound;\r\n            model.effects.volume = data.volume;\r\n            settings.save();\r\n        },\r\n        // the user changed background volume setting\r\n        'notify:backgroundVolumeChanged': function (id, data) {\r\n            var model = settings.get().sound;\r\n            model.background.volume = data.volume;\r\n            updatePlayback();\r\n            settings.save();\r\n        },\r\n        // request to play a sound\r\n        'request:playSound': function (id, data) {\r\n            mPlaySound(data);\r\n        },\r\n        // request to stop a sound\r\n        'request:stopSound': function (id, data) {\r\n            mStopSound(data);\r\n        },\r\n        // play multiple sounds\r\n        'request:playMultipleSounds': function (id, data) {\r\n            mPlaySounds(data);\r\n        },\r\n        // fade sound volume\r\n        'request:fadeSoundVolume': function (id, data) {\r\n            mFadeVolume(data);\r\n        },\r\n        // stop all sound effects\r\n        'request:stopSoundEffects': mStopEffects,\r\n        // request to set background sound\r\n        'request:setBackgroundSound': function (id, data) {\r\n            currentBackgroundSound = data.sound;\r\n        },\r\n        // events which trigger background sound playback\r\n        'request:updateSoundViews': mPlayBackgroundSound,\r\n        'notify:startButtonClicked': mPlayBackgroundSound,\r\n        'notify:spinButtonClicked': mPlayBackgroundSound,\r\n        'notify:autoButtonClicked': mPlayBackgroundSound,\r\n        'notify:turboButtonClicked': mPlayBackgroundSound,\r\n        'notify:takeWinButtonClicked': mPlayBackgroundSound,\r\n        'notify:takeRiskButtonClicked': mPlayBackgroundSound,\r\n        'notify:exitMenuButtonClicked': mPlayBackgroundSound,\r\n        'notify:spacePressed': mPlayBackgroundSound,\r\n        'request:retriggerBackgroundSound': mPlayBackgroundSound,\r\n        'notify:activityBeforeStart': function (id, data) {\r\n            switch (data.activity) {\r\n                case 'freeSpin':\r\n                    mPlayBackgroundSound();\r\n                    break;\r\n                case 'autoSpin':\r\n                    mPlayBackgroundSound();\r\n                case 'spin':\r\n                    mPlayBackgroundSound();\r\n                    break;\r\n            }\r\n        },\r\n        'notify:focusOut': onFocusOut,\r\n    });\r\n    return {};\r\n    function toggleMaster(id, data) {\r\n\r\n        var model = settings.get().sound;\r\n        if (!model.master.active) {\r\n            assets.loadSoundsIfNeeded('effects', function () {\r\n                model.master.active = true;\r\n                model.effects.active = true;\r\n                settingsUpdated(data);\r\n            });\r\n        } else {\r\n            model.master.active = false;\r\n            model.effects.active = false;\r\n            model.background.active = false;\r\n            settingsUpdated(data);\r\n        }\r\n    }\r\n// user toggled effects sound switch\r\n// update model, views and playback\r\n    function toggleEffects(id, data) {\r\n        var model = settings.get().sound;\r\n        if (!model.effects.active) {\r\n            assets.loadSoundsIfNeeded('effects', function () {\r\n                model.master.active = true;\r\n                model.effects.active = true;\r\n                settingsUpdated(data);\r\n            });\r\n        } else {\r\n            model.effects.active = false;\r\n            if (!model.background.active) {\r\n                model.master.active = false;\r\n            }\r\n            settingsUpdated(data);\r\n        }\r\n    }\r\n// user toggled background sound switch\r\n// update model, views and playback\r\n    function toggleBackground(id, data) {\r\n        var model = settings.get().sound;\r\n        if (!model.background.active) {\r\n            assets.loadSoundsIfNeeded('background', function () {\r\n                model.master.active = true;\r\n                model.background.active = true;\r\n                settingsUpdated(data);\r\n            });\r\n        } else {\r\n            model.background.active = false;\r\n            if (!model.effects.active) {\r\n                model.master.active = false;\r\n            }\r\n            settingsUpdated(data);\r\n        }\r\n    }\r\n// play sound\r\n    function mPlaySound(data) {\r\n// if type is not specified, it is an effect sound\r\n        data.type = data.type || 'effects';\r\n        var model = settings.get().sound;\r\n        // cancel if master sound or sound type is disabled\r\n        if (!model.master.active || !model[data.type].active)\r\n            return;\r\n        if (platform.isMobile() && platform.isIE()) {\r\n            mStopEffects();\r\n        }\r\n\r\n// container for sound type\r\n        var container;\r\n        // whether the sound should be played in a loop\r\n        var loop;\r\n        var sndName = data.sound;\r\n        var sndData = assets.sound(data.type === 'background' ?\r\n                currentBackgroundSound : sndName);\r\n\r\n\r\n        if (!sndData) {\r\n            if (data.alt && assets.sound(data.alt)) {\r\n                sndName = data.alt;\r\n                sndData = assets.sound(sndName);\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (data.type === 'effects') {\r\n            container = currentlyPlayingEffects;\r\n            loop = sndData[1];\r\n        } else if (data.type === 'background') {\r\n            container = currentlyPlayingBackground;\r\n            loop = true;\r\n        } else {\r\n            return;\r\n        }\r\n\r\n// cancel if a looping sound is playing already\r\n        if (loop && container[sndName]) {\r\n            return;\r\n        }\r\n\r\n        var baseVolume = sndData[2] ? sndData[2] : 1;\r\n        // compute volume if not specified\r\n        var volume = baseVolume\r\n                * (data.volume || ((model.master.volume / 100)\r\n                        * (model[data.type].volume / 100)));\r\n        var instance = createjs.Sound.play(sndName);\r\n        container[sndName] = instance;\r\n        instance.volume = volume;\r\n        instance.loop = loop ? 999999 : false;\r\n        if (!instance.loop) {\r\n            instance.on(\"complete\", function () {\r\n                delete container[sndName];\r\n            }, this);\r\n        }\r\n\r\n//>>includeStart(\"debug\", pragmas.debug);\r\n        window.currentlyPlayingEffects = currentlyPlayingEffects;\r\n        window.currentlyPlayingBackground = currentlyPlayingBackground;\r\n        //>>includeEnd(\"debug\");\r\n\r\n    }\r\n// play multiple sounds\r\n    function mPlaySounds(sounds) {\r\n        for (var i = 0; i < sounds.length; i++) {\r\n            mPlaySound({\r\n                sound: sounds[i]\r\n            });\r\n        }\r\n    }\r\n// stop sound and clear from sound container\r\n    function mStopSound(data) {\r\n        if (currentlyPlayingBackground[data.sound]) {\r\n            currentlyPlayingBackground[data.sound].stop();\r\n            delete currentlyPlayingBackground[data.sound];\r\n        }\r\n        if (currentlyPlayingEffects[data.sound]) {\r\n            currentlyPlayingEffects[data.sound].stop();\r\n            delete currentlyPlayingEffects[data.sound];\r\n        }\r\n    }\r\n// fade background volume\r\n// data.modifier defines how the volume should change\r\n// if not specified, the volume is faded to default level\r\n// data.duration specifies fade duration\r\n    function mFadeVolume(data) {\r\n        var model = settings.get().sound;\r\n        if (!model.master.active || !model.background.active)\r\n            return;\r\n        function fadeIt(snd) {\r\n            function run() {\r\n                current += step;\r\n                snd.volume = current;\r\n                if ((target > start && current >= target)\r\n                        || (target < start && current <= target)) {\r\n                    snd.volume = target;\r\n                } else {\r\n                    pause.setTimeout(run, 50);\r\n                }\r\n                console.log(snd.volume);\r\n            }\r\n            !data.duration && (data.duration = 500);\r\n            var start = snd.volume;\r\n            var current = start;\r\n            var target;\r\n            if (data.modifier !== undefined) {\r\n                target = current * data.modifier;\r\n            } else {\r\n                target = (model.master.volume / 100) * (model.background.volume / 100);\r\n            }\r\n            var step = (target - current) / (data.duration / 50);\r\n            console.log(current, target, step)\r\n            if (step !== 0) {\r\n                run();\r\n            }\r\n        }\r\n        if (currentlyPlayingBackground[currentBackgroundSound]) {\r\n            fadeIt(currentlyPlayingBackground[currentBackgroundSound]);\r\n        }\r\n    }\r\n\r\n// stop all effects playback\r\n    function mStopEffects() {\r\n        var ks = Object.keys(currentlyPlayingEffects);\r\n        for (var i = 0; i < ks.length; i++) {\r\n            currentlyPlayingEffects[ks[i]].stop();\r\n            currentlyPlayingEffects[ks[i]].destroy();\r\n        }\r\n        currentlyPlayingEffects = {};\r\n    }\r\n// stop all background playback\r\n    function mStopBackground() {\r\n        var ks = Object.keys(currentlyPlayingBackground);\r\n        for (var i = 0; i < ks.length; i++) {\r\n            currentlyPlayingBackground[ks[i]].stop();\r\n            currentlyPlayingBackground[ks[i]].destroy();\r\n        }\r\n        currentlyPlayingBackground = {};\r\n    }\r\n\r\n// play current backround sound if not playing already\r\n// with a fade effects\r\n    function mPlayBackgroundSound() {\r\n        var soundToPlay = currentBackgroundSound;\r\n        if (!currentlyPlayingBackground[soundToPlay]) {\r\n            mStopBackground();\r\n            mPlaySound({\r\n                sound: soundToPlay,\r\n                type: 'background',\r\n            });\r\n        }\r\n    }\r\n// update playback according to model\r\n// stop disabled sounds and update volume\r\n    function updatePlayback() {\r\n        if (!assets.isSoundAvailable()) {\r\n            return;\r\n        }\r\n        var model = settings.get().sound;\r\n        if (!model.master.active || !model.effects.active) {\r\n            mStopEffects(true);\r\n        }\r\n        if (!model.master.active || !model.background.active) {\r\n            mStopBackground(true);\r\n        } else {\r\n            var volume = (model.master.volume / 100) * (model.background.volume / 100);\r\n            if (currentlyPlayingBackground[currentBackgroundSound]) {\r\n                currentlyPlayingBackground[currentBackgroundSound].volume = volume;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onFocusOut() {\r\n        mStopEffects();\r\n        mStopBackground();\r\n    }\r\n\r\n    function settingsUpdated(data) {\r\n        settings.save();\r\n        pubsub.publish('request:updateSoundViews');\r\n        updatePlayback();\r\n        if (data.callback) {\r\n            data.callback();\r\n        }\r\n    }\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/coreSound.js"),
eval("// autoplay service\r\n// computes whether the autoplay should be stopped\r\n// based on current autoplay user settings and autoplay progress\r\n// and cash remaining\r\n\r\ndefine('services/autoplay',['services/settings'], function (settings) {\r\n\r\n    var model = null;\r\n\r\n    // API\r\n    var API = {\r\n        autoplayStarted: mAutoplayStarted,\r\n        shouldAutospinMore: mShouldAutospinMore,\r\n        clearAutoplay: mClearAutoplay,\r\n        getBottomRightLabel: mGetLabel\r\n    };\r\n\r\n    return API;\r\n\r\n    // runs on autoplay start\r\n    // store the relevant properties in model\r\n    function mAutoplayStarted(data) {\r\n        if (model === null) {\r\n            model = {\r\n                // cash when autoplay started\r\n                startCash: data.cash,\r\n                // timestamp when autoplay started\r\n                startTime: Date.now(),\r\n                // number of rounds played in autoplay\r\n                roundsPlayed: 0,\r\n                // total autoplay win\r\n                winTotal: 0,\r\n            };\r\n        }\r\n    }\r\n    // runs when next autospin should start\r\n    // determines whether the autospin should continue or not\r\n    // based on autoplay progress and user settings\r\n    function mShouldAutospinMore(data) {\r\n\r\n        data.win = Number(data.win);\r\n        data.bet = Number(data.bet);\r\n        data.cash = Number(data.cash);\r\n        data.credits = Number(data.credits);\r\n\r\n        // increment round counter\r\n        model.roundsPlayed += 1;\r\n        if (data.win) {\r\n            // add last spin win amount\r\n            model.winTotal += data.win;\r\n        }\r\n        // check for credits remaining\r\n        if (data.credits < data.bet) {\r\n            return false;\r\n        }\r\n\r\n        var stgs = settings.get().autoplay;\r\n\r\n        // check if user-defined round limit was reached\r\n        if (stgs.rounds.active) {\r\n            var rounds = stgs.rounds.steps[stgs.rounds.selectedIndex];\r\n            if (model.roundsPlayed >= rounds) {\r\n                return false;\r\n            }\r\n        }\r\n        // check if user-defined time limit was reached\r\n        if (stgs.timePassed.active) {\r\n            var minutes = stgs.timePassed.steps[stgs.timePassed.selectedIndex];\r\n            var ms = minutes * 60 * 1000;\r\n            if (Date.now() - model.startTime > ms) {\r\n                return false;\r\n            }\r\n        }\r\n        // check if user-defined win limit was reached\r\n        if (stgs.winExceeds.active) {\r\n            var winExceedsBetTimes = stgs.winExceeds.steps[stgs.winExceeds.selectedIndex];\r\n            if (model.winTotal > winExceedsBetTimes * data.bet) {\r\n                return false;\r\n            }\r\n        }\r\n        // check if user-defined balance decrease limit was reached\r\n        if (stgs.balanceDecBy.active) {\r\n            var decPerc = stgs.balanceDecBy.steps[stgs.balanceDecBy.selectedIndex];\r\n            if (data.cash <= model.startCash - (model.startCash * (decPerc / 100))) {\r\n                return false;\r\n            }\r\n        }\r\n        // check if user-defined balance increase limit was reached\r\n        if (stgs.balanceIncBy.active) {\r\n            var incModifier = stgs.balanceIncBy.steps[stgs.balanceIncBy.selectedIndex];\r\n            if (data.cash >= model.startCash * incModifier) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // runs when autoplay ends\r\n    // clear autoplay model\r\n    function mClearAutoplay() {\r\n        model = null;\r\n    }\r\n\r\n    function mGetLabel() {\r\n        var stgs, s, m, ts;\r\n        var txt = ''\r\n        if (model) {\r\n            stgs = settings.get().autoplay;\r\n            if (stgs.rounds.active) {\r\n                txt = ['autospin', '! ' + (model.roundsPlayed + 1), '! ', 'of',\r\n                    '! ' + stgs.rounds.steps[stgs.rounds.selectedIndex]]\r\n            } else if (stgs.timePassed.active) {\r\n                s = Math.floor((Date.now() - model.startTime) / 1000);\r\n                m = Math.floor(s / 60);\r\n                s -= m * 60;\r\n                ts = m + ':' + (String(s).length === 1 ? '0' + s : s);\r\n                txt = ['autospin', '! ', 'playedFor', '! ' + ts];\r\n            }\r\n        }\r\n        return txt;\r\n    }\r\n\r\n\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/autoplay.js"),eval("define('data/config-buttonStates-core',[], function () {\r\n\r\n    var\r\n            ACTIVE = 'active',\r\n            DISABLED = 'disabled',\r\n            HIDDEN = 'hidden',\r\n            SPECIAL = 'special',\r\n            SPECIAL_2 = 'special_2';\r\n\r\n    var data = {\r\n        idle: {\r\n            base: {\r\n                bottomControls: ACTIVE,\r\n                menuButton: ACTIVE,\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n            },\r\n            spinnable: {\r\n                reelsClickableOverlay: ACTIVE,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: true,\r\n                    disabled: false,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: 'spin',\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                }\r\n            },\r\n            notSpinnable: {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: false,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                },\r\n            },\r\n            menu: {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: false,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                },\r\n            },\r\n        },\r\n        spin: {\r\n            base: {\r\n                bottomControls: ACTIVE,\r\n                menuButton: DISABLED,\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                reelsClickableOverlay: ACTIVE,\r\n            },\r\n            basicSpin: {\r\n                spinButton: {\r\n                    text: 'STOP',\r\n                    draggable: false,\r\n                    disabled: false,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: 'stop',\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                },\r\n            },\r\n            autoSpin: {\r\n                spinButton: {\r\n                    text: 'STOP',\r\n                    draggable: true,\r\n                    disabled: false,\r\n                    logo: true,\r\n                    logo2: false,\r\n                    actionClick: 'stop',\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n            },\r\n            autoNotStoppable: {\r\n                spinButton: {\r\n                    text: 'STOP',\r\n                    draggable: true,\r\n                    disabled: true,\r\n                    logo: true,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                }\r\n            },\r\n            turboSpin: {\r\n                spinButton: {\r\n                    text: 'STOP',\r\n                    draggable: true,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: true,\r\n                    actionClick: 'stop',\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n            },\r\n            turboNotStoppable: {\r\n                spinButton: {\r\n                    text: 'STOP',\r\n                    draggable: true,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: true,\r\n                    actionClick: null,\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                }\r\n            },\r\n            spinNotStoppable: {\r\n                spinButton: {\r\n                    text: 'STOP',\r\n                    draggable: false,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                }\r\n            }\r\n        },\r\n        autoSpinPause: {\r\n            base: {\r\n                bottomControls: ACTIVE,\r\n                menuButton: DISABLED,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: true,\r\n                    disabled: true,\r\n                    logo: true,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                reelsClickableOverlay: HIDDEN,\r\n            },\r\n        },\r\n        turboSpinPause: {\r\n            base: {\r\n                bottomControls: ACTIVE,\r\n                menuButton: DISABLED,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: true,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: true,\r\n                    actionClick: null,\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                reelsClickableOverlay: HIDDEN,\r\n            },\r\n        },\r\n        win: {\r\n            base: {\r\n                bottomControls: ACTIVE,\r\n            },\r\n            beforeWin: {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: false,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n            afterAction: {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: HIDDEN,\r\n                takeWinButton: DISABLED,\r\n                takeRiskButton: DISABLED,\r\n                menuButton: HIDDEN,\r\n            },\r\n            beforeWinAuto: {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: true,\r\n                    disabled: true,\r\n                    logo: true,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n            beforeWinTurbo: {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: true,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: true,\r\n                    actionClick: null,\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n            'spin': {\r\n                reelsClickableOverlay: ACTIVE,\r\n                spinButton: HIDDEN,\r\n                takeWinButton: ACTIVE,\r\n                takeRiskButton: ACTIVE,\r\n                menuButton: HIDDEN,\r\n            },\r\n            'autoSpin': {\r\n                reelsClickableOverlay: ACTIVE,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: true,\r\n                    disabled: false,\r\n                    logo: true,\r\n                    logo2: false,\r\n                    actionClick: 'spin',\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n            'turboSpin': {\r\n                reelsClickableOverlay: ACTIVE,\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: true,\r\n                    disabled: false,\r\n                    logo: false,\r\n                    logo2: true,\r\n                    actionClick: 'spin',\r\n                    actionAutoDrag: 'auto',\r\n                    actionTurboDrag: 'turbo'\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n            'gambleQuittable': {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: HIDDEN,\r\n                takeWinButton: ACTIVE,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: ACTIVE,\r\n            },\r\n            'gambleNotQuittable': {\r\n                reelsClickableOverlay: HIDDEN,\r\n                spinButton: HIDDEN,\r\n                takeWinButton: DISABLED,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n            amountAnimation: {\r\n                reelsClickableOverlay: ACTIVE,\r\n                spinButton: HIDDEN,\r\n                takeWinButton: ACTIVE,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            }\r\n        },\r\n    };\r\n    return data;\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-buttonStates-core.js"),eval("define('data/config-buttonStates',[], function () {\r\n\r\n    var\r\n            ACTIVE = 'active',\r\n            DISABLED = 'disabled',\r\n            HIDDEN = 'hidden',\r\n            SPECIAL = 'special',\r\n            SPECIAL_2 = 'special_2';\r\n\r\n    var data = {\r\n        win: {\r\n            'freeSpin': {\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: false,\r\n                    disabled: false,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: 'spin',\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n                reelsClickableOverlay: ACTIVE,\r\n            },\r\n            'wonFreeSpins': {\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: false,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                },\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n        },\r\n        freeSpinBanner: {\r\n            base: {\r\n                bottomControls: ACTIVE,\r\n                takeWinButton: HIDDEN,\r\n                takeRiskButton: HIDDEN,\r\n                reelsClickableOverlay: HIDDEN,\r\n                menuButton: DISABLED,\r\n            },\r\n            spinnable: {\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: false,\r\n                    disabled: false,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: 'spin',\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                },\r\n            },\r\n            notSpinnable: {\r\n                spinButton: {\r\n                    text: 'SPIN',\r\n                    draggable: false,\r\n                    disabled: true,\r\n                    logo: false,\r\n                    logo2: false,\r\n                    actionClick: null,\r\n                    actionAutoDrag: null,\r\n                    actionTurboDrag: null\r\n                }\r\n            },\r\n            onlyBottomPanel: {\r\n                spinButton: HIDDEN,\r\n                menuButton: HIDDEN,\r\n            },\r\n        }\r\n    };\r\n    return data;\r\n});\n//# sourceURL=/modules/Type2/src/js/data/config-buttonStates.js"),eval("// ui\r\n// handles various UI button states\r\n// constructs appropriate configuration JSON for requested state\r\n// and publishes it\r\ndefine('services/ui',['jquery', 'pubsub', 'data/config',\r\n//    'data/config-buttonStates-old-core',\r\n//    'data/config-buttonStates-old',\r\n    'data/config-buttonStates-core',\r\n    'data/config-buttonStates'],\r\n        function ($, pubsub, coreConfig,\r\n//        oldCoreButtonConfig,\r\n//        oldTypeButtonConfig,\r\n                coreButtonConfig, typeButtonConfig) {\r\n\r\n            // event handlers\r\n            pubsub.subscribeBatch({\r\n                'request:buttonState': function (id, data) {\r\n                    setButtonState(data.state);\r\n                },\r\n            });\r\n\r\n            var model = null;\r\n\r\n            var config;\r\n\r\n//            if (coreConfig.UI_TYPE === 'original') {\r\n//                config = $.extend(true, {}, oldCoreButtonConfig, oldTypeButtonConfig);\r\n//            }\r\n            if (coreConfig.UI_TYPE === 'mobile') {\r\n                config = $.extend(true, {}, coreButtonConfig, typeButtonConfig);\r\n            }\r\n\r\n\r\n            /**\r\n             * Builds JSON with desired button states according to requested configuration\r\n             * Publishes update request for registered modules\r\n             *\r\n             * @method setButtonState\r\n             * @param stateKey {String} requested button state configuration\r\n             */\r\n            function setButtonState(stateKey) {\r\n                var arr = stateKey.split('-');\r\n                model = $.extend({}, config[arr[0]].base, true);\r\n                for (var i = 1; i < arr.length; i++) {\r\n                    var ext = $.extend({}, config[arr[0]][arr[i]], true);\r\n                    model = $.extend(model, ext);\r\n                }\r\n                pubsub.publish('request:adjustControls', model);\r\n            }\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/services/ui.js"),eval("// assets/services\r\n// controls game-specific audio\r\ndefine('services/sound',[\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'services/assets'\r\n], function (pubsub, config, symbolSet, assets) {\r\n\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        'request:spinReels': spinStarted,\r\n        'notify:spinFinished': spinFinished,\r\n        'notify:cardFlipStarted': cardFlipStarted,\r\n        'notify:cardFlipAllStarted': cardFlipAllStarted\r\n    });\r\n\r\n    var API = {\r\n        // get audio information for specific standard spin win\r\n        getWinSoundData: function (data) {\r\n            return mGetWinSoundData(data, config.BASIC_SPIN_SYMBOL_WIN_SOUND,\r\n                    config.JOKER_SOUND, config.MINIMUM_FIRST_WIN_LINE_VIEW_DURATION);\r\n        },\r\n        getFreeGameWinSoundData: function (data) {\r\n            return mGetWinSoundData(data,\r\n                    config.FREE_GAME_SYMBOL_WIN_SOUND\r\n                    ? config.FREE_GAME_SYMBOL_WIN_SOUND\r\n                    : config.BASIC_SPIN_SYMBOL_WIN_SOUND,\r\n                    config.FREE_GAME_JOKER_SOUND\r\n                    ? config.FREE_GAME_JOKER_SOUND\r\n                    : config.JOKER_SOUND,\r\n                    config.FREE_GAME_MINIMUM_FIRST_WIN_LINE_VIEW_DURATION\r\n                    ? config.FREE_GAME_MINIMUM_FIRST_WIN_LINE_VIEW_DURATION\r\n                    : config.MINIMUM_FIRST_WIN_LINE_VIEW_DURATION);\r\n        },\r\n    };\r\n    return API;\r\n\r\n    // play card flip sound\r\n    function cardFlipStarted(id, data) {\r\n        if (!data.mute) {\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: config.CARD_FLIP_SOUND\r\n            });\r\n        }\r\n    }\r\n    // play multile card flip sound\r\n    function cardFlipAllStarted() {\r\n        pubsub.publish(\"request:playSound\", {\r\n            sound: config.CARD_FLIP_ALL_SOUND\r\n        });\r\n    }\r\n\r\n    function spinStarted() {\r\n        pubsub.publish(\"request:playSound\", {\r\n            sound: config.ROTATE_SOUND\r\n        });\r\n    }\r\n    function spinFinished() {\r\n        pubsub.publish(\"request:stopSound\", {\r\n            sound: config.ROTATE_SOUND\r\n        });\r\n    }\r\n\r\n\r\n    // compute sounds that should be played for a specific win set in standard spin\r\n    // return sounds array and duration of longest playing sound\r\n    function mGetWinSoundData(data, winSounds, jokerSound, minSoundDuration) {\r\n        var keys = Object.keys(data.winLines);\r\n        var length = keys.length;\r\n        var highestWinLine;\r\n        var highestWin = -1;\r\n        for (var i = 0; i < 1; i++) {\r\n            if (data.winLines[keys[i]].win > highestWin) {\r\n                highestWinLine = data.winLines[keys[i]];\r\n                highestWin = data.winLines[keys[i]].win;\r\n            }\r\n        }\r\n        var sounds = [];\r\n        var symbolsInLine = highestWinLine.sym;\r\n        keys = Object.keys(symbolsInLine);\r\n        length = keys.length;\r\n        if (symbolSet.SPIN.SCATTER_SYMBOL_ID.indexOf(symbolsInLine[keys[0]]) > -1\r\n                && keys.length >= 3) {\r\n            // free game\r\n            sounds = [config.TRIPLE_SCATTER_WIN_SOUND];\r\n        } else {\r\n            // basic symbols\r\n            var symbols = {};\r\n            var symId;\r\n            for (var i = 0; i < length; i++) {\r\n                symId = symbolsInLine[keys[i]];\r\n                if (symbols[symId]) {\r\n                    symbols[symId] += 1;\r\n                } else {\r\n                    symbols[symId] = 1;\r\n                }\r\n            }\r\n            keys = Object.keys(symbols);\r\n            length = keys.length;\r\n\r\n            var soundData, soundString, z;\r\n\r\n            for (var i = 0; i < length; i++) {\r\n                if (symbolSet.SPIN.WILD_SYMBOL_ID.indexOf(Number(keys[i])) > -1\r\n                        && length > 1) {\r\n                    if (jokerSound) {\r\n                        soundData = jokerSound;\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    soundData = winSounds[keys[i]];\r\n                }\r\n//            console.log('winSounds', winSounds, keys, i);\r\n                if (soundData) {\r\n                    if (typeof soundData === 'string' || soundData instanceof String) {\r\n                        soundString = soundData;\r\n                    } else {\r\n                        z = symbols[keys[i]];\r\n                        while (!soundData[z] && z > 2) {\r\n                            z -= 1;\r\n                        }\r\n                        soundString = soundData[z];\r\n                    }\r\n                    if (sounds.indexOf(soundString) === -1) {\r\n                        sounds.push(soundString);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n//        console.log(sounds);\r\n        var durationMax = 0;\r\n        for (var i = 0; i < sounds.length; i++) {\r\n//            console.log('sounds[i]', sounds[i]);\r\n            if (assets.sound([sounds[i]]) && assets.sound(sounds[i])[0]\r\n                    > durationMax) {\r\n                durationMax = assets.sound(sounds[i])[0];\r\n            }\r\n        }\r\n        if (durationMax < minSoundDuration) {\r\n            durationMax = minSoundDuration;\r\n        }\r\n\r\n        return {\r\n            soundDuration: durationMax,\r\n            sounds: sounds\r\n        };\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/sound.js"),eval("// winAnimations\r\n// controls animations sequence when user wins credits\r\ndefine('services/winAnimations',[\r\n    'pubsub',\r\n    'services/pause',\r\n    'services/sound',\r\n    'services/assets',\r\n    'services/settings',\r\n    'data/config',\r\n    'data/config-reelSet',\r\n], function (pubsub, pause, sound, assets, settings, config, reelSet) {\r\n\r\n    //\r\n\r\n    // reference to current win configuration\r\n    var winData = null;\r\n    // flag specifies whether the betline button should be animated\r\n    var buttonAnimations = null;\r\n\r\n    // event handlers\r\n    pubsub.subscribeBatch({\r\n        'request:runCommonAnimations': initializeCommon,\r\n        'request:runWinAnimations': initializeWin,\r\n        'request:clearButtonAnimations': clearButtonAnimations,\r\n        'notify:allWinLinesPreviewDisplayed': higlightWinButtons,\r\n        'notify:winLineDisplayed': showWinLineInfo,\r\n    });\r\n\r\n    function initializeCommon(id, data) {\r\n        function parseCommonAnimations(data) {\r\n            var parsed = {\r\n                spinResult: {\r\n                    ws: {\r\n                    },\r\n                },\r\n                symbolSet: data.symbolSet,\r\n            };\r\n            var reelIndex = data.reel;\r\n            var ks2 = Object.keys(data.spinResult.rs[reelIndex].sym);\r\n            for (var i2 = 0; i2 < ks2.length; i2++) {\r\n                var sym = data.spinResult.rs[reelIndex].sym[ks2[i2]];\r\n                if (data.symbolSet.symbols[sym].commonAnimation) {\r\n                    parsed.spinResult.ws[Object.keys(parsed.spinResult.ws)\r\n                            .length] = {\r\n                        post: {0: [Number(reelIndex), Number(ks2[i2])]},\r\n                        sym: {0: sym},\r\n                    };\r\n                }\r\n            }\r\n            return parsed;\r\n        }\r\n        winData = parseCommonAnimations(JSON.parse(JSON.stringify(data)));\r\n        pubsub.publish('request:animateWinSymbols', {\r\n            model: winData.spinResult,\r\n            timeout: reelSet.BASE.BOUNCE_DURATION_MS * 2.65,\r\n            symbolSet: winData.symbolSet,\r\n            commonAnimations: true,\r\n        });\r\n    }\r\n    function initializeWin(id, data) {\r\n        // button animations should run on start\r\n        buttonAnimations = true;\r\n        winData = JSON.parse(JSON.stringify(data));\r\n        winData.winLinesWs = data.spinResult.ws;\r\n\r\n        var timeouts = playPreWinAnimations(winData);\r\n        // request symbol animations\r\n        pubsub.publish('request:animateWinSymbols', {\r\n            model: winData.spinResult,\r\n            timeout: config.PRE_WIN_ACTIVITY_TIMEOUT\r\n                    + timeouts.preLinesTimeout\r\n                    + timeouts.postLinesTimeout\r\n                    + winData.firstViewDuration,\r\n            symbolSet: winData.symbolSet});\r\n\r\n        // short delay before animations start\r\n        pause.setTimeout(function () {\r\n            // grab animation audio data\r\n            winData.winSoundData = getWinSoundData(winData);\r\n            // clear bottom text\r\n            pubsub.publish('request:showBottomLeftInfo', {text: ''});\r\n            if (!data.doNotShowWinnings) {\r\n                // display background\r\n                pubsub.publish('request:showBackground', {\r\n                    win: true,\r\n                    freeSpin: data.freeGame\r\n                });\r\n                // display total win\r\n                pubsub.publish('request:showWinningsHeader', {\r\n                    winnings: winData.spinResult.totalWin});\r\n            } else {\r\n                // display background\r\n                pubsub.publish('request:showBackground', {\r\n                    win: false,\r\n                    freeSpin: data.freeGame\r\n                });\r\n            }\r\n\r\n            pause.setTimeout(function () {\r\n                // fire betlines animations\r\n                pubsub.publish('request:animateWinLines', {\r\n                    ws: winData.winLinesWs,\r\n                    symbolSet: winData.symbolSet,\r\n                    firstLineDisplayTime: winData.winSoundData.soundDuration,\r\n                    firstViewDuration: winData.firstViewDuration\r\n                            + timeouts.postLinesTimeout,\r\n                    showFirstWinLineAsLast: winData.showFirstWinLineAsLast,\r\n                    firstPassCallback: data.firstPassCallback,\r\n                    otherLinesDisplayCallback: function () {\r\n                        pubsub.publish(\"request:playSound\", {\r\n                            sound: config.WIN_LINE_SHOW_SOUND\r\n                        });\r\n                    }\r\n                });\r\n            }, timeouts.preLinesTimeout);\r\n\r\n            pause.setTimeout(function () {\r\n                // play symbol sounds\r\n                pause.setTimeout(function () {\r\n                    pubsub.publish(\"request:playMultipleSounds\", winData.winSoundData.sounds);\r\n                }, config.WIN_SOUND_TIMING_ADJUSTMENT_MS || 0);\r\n                if (config.HIDE_STATIC_SYMBOLS_WHEN_ANIMATING) {\r\n                    // hide winning symbols so they dont interfere with win animations\r\n                    pubsub.publish('request:hideWinSymbolsOnReel', {\r\n                        timeout: 0,\r\n                        ws: data.spinResult.ws});\r\n                }\r\n                // callback if defined\r\n                if (data.firstViewCallback) {\r\n                    data.firstViewCallback();\r\n                }\r\n            }, timeouts.preLinesTimeout\r\n                    + timeouts.postLinesTimeout\r\n                    + winData.firstViewDuration);\r\n        }, config.PRE_WIN_ACTIVITY_TIMEOUT);\r\n    }\r\n\r\n    // do not animate buttons anymore\r\n    function clearButtonAnimations() {\r\n        buttonAnimations = false;\r\n    }\r\n\r\n    // request highlight of all winning lines button\r\n    function higlightWinButtons(id, data) {\r\n        pubsub.publish('request:higlightWinlineMultipleButtons', data);\r\n    }\r\n\r\n    // runs when a winning betline is displayed\r\n    // makes request to display win line info text and\r\n    // buttons if allowed\r\n    function showWinLineInfo(id, data) {\r\n        var showBottomText;\r\n        showBottomText = true;\r\n        var symbols = winData.symbolSet;\r\n        var requestData = {\r\n            line: data.line,\r\n            timeout: data.timeout,\r\n            showBottomText: showBottomText,\r\n            symbolSet: symbols\r\n        };\r\n        if (winData.freeSpinsWon && requestData.line.betline === 99) {\r\n            requestData.freeSpinsWin = true;\r\n        }\r\n        if (buttonAnimations) {\r\n            pubsub.publish('request:highlightWinlineButton', requestData);\r\n        }\r\n        pubsub.publish('request:showWinlineInfoText', requestData);\r\n    }\r\n\r\n    return {};\r\n\r\n    // get audio for winning symbols\r\n    function getWinSoundData(data) {\r\n        var winSoundData;\r\n        if (data.freeGame) {\r\n            winSoundData = sound.getFreeGameWinSoundData({\r\n                winLines: data.spinResult.ws\r\n            });\r\n        } else {\r\n            winSoundData = sound.getWinSoundData({\r\n                winLines: data.spinResult.ws\r\n            });\r\n        }\r\n        return winSoundData;\r\n    }\r\n\r\n    function playPreWinAnimations(data) {\r\n        function play(timeout) {\r\n            if (bigWinType) {\r\n                attentionSnd && pubsub.publish(\"request:playSound\", {\r\n                    sound: config.ATTENTION_SOUND\r\n                });\r\n                pubsub.publish(\"request:playBigWinAnimation\",\r\n                        {duration: config.BIG_WIN_ANIMATION_DURATION,\r\n                            winType: bigWinType});\r\n                pause.setTimeout(function () {\r\n                    winnerSnd && pubsub.publish(\"request:playSound\", {\r\n                        sound: winnerSnd\r\n                    });\r\n                    coinsAnimTimes && pubsub.publish(\"request:playCoinsAnimation\", {\r\n                        repeat: coinsAnimTimes,\r\n                        flashType: winFlashAnimType,\r\n                    });\r\n                }, 60 * (1000 / 30));\r\n            } else {\r\n                attentionSnd && pubsub.publish(\"request:playSound\", {\r\n                    sound: config.ATTENTION_SOUND\r\n                });\r\n                pause.setTimeout(function () {\r\n                    bounceWin && pubsub.publish('request:bounceWinText');\r\n                    winnerSnd && pubsub.publish(\"request:playSound\", {\r\n                        sound: winnerSnd\r\n                    });\r\n                    coinsAnimTimes && pubsub.publish(\"request:playCoinsAnimation\", {\r\n                        repeat: coinsAnimTimes,\r\n                        flashType: winFlashAnimType,\r\n                    });\r\n                }, attentionSnd\r\n                        ? assets.sound(config.ATTENTION_SOUND)[0]\r\n                        : 0);\r\n            }\r\n        }\r\n        function getTotalWin(ws) {\r\n            var ks = Object.keys(ws);\r\n            var total = 0;\r\n            for (var i = 0; i < ks.length; i++) {\r\n                total += ws[ks[i]].win;\r\n            }\r\n            return total;\r\n        }\r\n\r\n        function hasFiveOfAKindWin(ws) {\r\n            var ks = Object.keys(ws);\r\n            for (var i = 0; i < ks.length; i++) {\r\n                if (Object.keys(ws[ks[i]].post).length >= 5) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        var totalBet = Number(data.betModel.totalBet);\r\n        var totalWin = getTotalWin(data.spinResult.ws);\r\n\r\n        var attentionSnd, winnerSnd, coinsAnimTimes, winFlashAnimType,\r\n                bounceWin, bigWinType;\r\n\r\n        var label = '';\r\n        var preLinesTimeout = 0;\r\n        var postLinesTimeout = 0;\r\n        var sndEnabled = settings.get().sound.effects.active;\r\n\r\n//        if (true) {\r\n        if (totalWin >= 30 * totalBet) {\r\n            sndEnabled && (winnerSnd = config.HIGH_WIN_SOUND_2);\r\n            sndEnabled && (attentionSnd = true);\r\n            coinsAnimTimes = 3;\r\n            winFlashAnimType = 3;\r\n            if (totalWin >= 500 * totalBet) {\r\n                bigWinType = 'awesome';\r\n            } else if (totalWin >= 100 * totalBet) {\r\n                bigWinType = 'mega';\r\n            } else {\r\n                bigWinType = 'big';\r\n            }\r\n//        } else if (false) {\r\n        } else if (totalWin >= 10 * totalBet) {\r\n            sndEnabled && (winnerSnd = config.HIGH_WIN_SOUND_1);\r\n            coinsAnimTimes = 1;\r\n            winFlashAnimType = 2;\r\n        } else {\r\n            sndEnabled && (winnerSnd = config.BASIC_WIN_SOUND);\r\n        }\r\n        if (hasFiveOfAKindWin(data.spinResult.ws)) {\r\n            sndEnabled && (attentionSnd = true);\r\n            label = 'fiveOfAKind';\r\n        }\r\n        if (data.freeSpinsWon) {\r\n            if (data.freeSpinsWonText) {\r\n                label = data.freeSpinsWonText;\r\n            } else {\r\n                label = 'youWonFreeGames';\r\n            }\r\n            sndEnabled && (attentionSnd = true);\r\n        }\r\n\r\n        // adjust timeout\r\n        if (attentionSnd) {\r\n            preLinesTimeout += assets.sound(config.ATTENTION_SOUND)[0];\r\n        }\r\n\r\n        if (winnerSnd) {\r\n            postLinesTimeout =\r\n                    assets.sound(winnerSnd)[0]\r\n                    - assets.sound(config.BASIC_WIN_SOUND)[0];\r\n        }\r\n\r\n        if (bigWinType) {\r\n            if (preLinesTimeout < config.BIG_WIN_ANIMATION_DURATION) {\r\n                preLinesTimeout = config.BIG_WIN_ANIMATION_DURATION;\r\n                postLinesTimeout = 0;\r\n            }\r\n        }\r\n\r\n        // play sound & animations\r\n        pubsub.publish('request:showBottomInfo', {\r\n            text: label\r\n        });\r\n        play(config.PRE_WIN_ACTIVITY_TIMEOUT);\r\n\r\n        return {\r\n            preLinesTimeout: preLinesTimeout,\r\n            postLinesTimeout: postLinesTimeout\r\n        };\r\n    }\r\n\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/services/winAnimations.js"),
eval("define('data/config-help-core',[], function () {\r\n    var data = {\r\n        defaultFontSize: 22,\r\n        items: [\r\n            //tapAnywhereToStart\r\n            {\r\n                type: 'text',\r\n                text: '^tapAnywhereToStart',\r\n                css: {\r\n                    display: 'block',\r\n                    left: '0',\r\n                    width: '100%',\r\n                    'text-align': 'center',\r\n                    top: '21.5%',\r\n                    'font-size': '1.25em',\r\n                }\r\n            },\r\n            //swipeLeftToEnableAutospin\r\n            {\r\n                type: 'img',\r\n                src: 'help/arrow',\r\n                adjustPosition: true,\r\n                css: {\r\n                    left: '80.3%',\r\n                    top: '51.3%',\r\n                    width: '8.2%'\r\n                }\r\n            },\r\n            {\r\n                type: 'text',\r\n                text: '^swipeLeftToEnableAutospin',\r\n                adjustPosition: true,\r\n                css: {\r\n                    display: 'block',\r\n                    left: '0',\r\n                    width: '79%',\r\n                    'text-align': 'right',\r\n                    top: '51.1%',\r\n                }\r\n            },\r\n            //swipeLeftToEnableTurboospin\r\n            {\r\n                type: 'img',\r\n                src: 'help/arrow-long',\r\n                adjustPosition: true,\r\n                css: {\r\n                    left: '70.4%',\r\n                    top: '44.4%',\r\n                    width: '18%'\r\n                }\r\n            },\r\n            {\r\n                type: 'text',\r\n                text: '^swipeLeftToEnableTurboSpin',\r\n                adjustPosition: true,\r\n                css: {\r\n                    display: 'block',\r\n                    left: '0',\r\n                    width: '68.8%',\r\n                    'text-align': 'right',\r\n                    top: '44.3%',\r\n                }\r\n            },\r\n            //\r\n            //tapToSpin\r\n            {\r\n                type: 'img',\r\n                src: 'help/tap-circle',\r\n                adjustPosition: true,\r\n                css: {\r\n                    right: '1%',\r\n                    top: '38%',\r\n                    width: '15.1%',\r\n                }\r\n            },\r\n            {\r\n                type: 'text',\r\n                text: '^tapToSpin',\r\n                adjustPosition: true,\r\n                css: {\r\n                    display: 'block',\r\n                    left: '0',\r\n                    width: '94.9%',\r\n                    'text-align': 'right',\r\n                    top: '64.0%',\r\n                }\r\n            },\r\n            //\r\n            //tapToOpenMenu\r\n            {\r\n                type: 'img',\r\n                src: 'help/tap',\r\n                adjustPosition: true,\r\n                css: {\r\n                    left: '2.9%',\r\n                    top: '47.9%',\r\n                    width: '5.8%',\r\n                }\r\n            },\r\n            {\r\n                type: 'text',\r\n                text: '^tapToOpenMenu',\r\n                adjustPosition: true,\r\n                css: {\r\n                    left: '4.7%',\r\n                    top: '64.0%',\r\n                }\r\n            },\r\n            //\r\n        ]\r\n    }\r\n    return data;\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/data/config-help-core.js"),eval("define('data/config-help',['data/config-help-core'], function (coreConfig) {\r\n    return $.extend(coreConfig, {\r\n    }\r\n    );\r\n});\n//# sourceURL=/modules/Vikings/src/js/data/config-help.js"),eval("define('services/help',[\r\n    'jquery', 'pubsub', 'services/i18n',\r\n    'data/config', 'data/config-help', 'services/dimensions', 'services/assets'],\r\n        function ($, pubsub, i18n, globalConfig, config, dimensions, assets) {\r\n\r\n            function hide() {\r\n                $html.removeClass('rotate-overlay-visible');\r\n                $helpContainer.empty().hide();\r\n                visible = false;\r\n                pubsub.publish('notify:overlayHidden', {\r\n                    type: 'help'\r\n                });\r\n            }\r\n\r\n            function resize() {\r\n                if (visible) {\r\n                    $helpContainer.css({\r\n                        left: dimensions.topLevelWrappersOffsetX,\r\n                        top: dimensions.topLevelWrappersOffsetY + dimensions.moveTop,\r\n                        width: globalConfig.CANVAS_BASE_WIDTH * dimensions.canvasScaleX,\r\n                        height: globalConfig.CANVAS_BASE_HEIGHT * dimensions.canvasScaleY,\r\n                    });\r\n                    $innerAdjusted.add($innerStatic).css({\r\n                        width: globalConfig.CANVAS_BASE_WIDTH * dimensions.canvasScaleX,\r\n                        height: globalConfig.CANVAS_BASE_HEIGHT * dimensions.canvasScaleY,\r\n                    });\r\n                    $innerAdjusted.css({\r\n                        top: -(dimensions.topLevelWrappersOffsetY\r\n                                - dimensions.topLevelWrappersOffsetBottom)\r\n                    });\r\n                    $helpContainer.css('font-size',\r\n                            dimensions.canvasScaleY * config.defaultFontSize + 'px');\r\n                }\r\n            }\r\n\r\n            function generateHTML() {\r\n                function createText(data) {\r\n                    var el = $('<span>' + i18n.localize(data.text)\r\n                            .replace(/\\n/g, '<br/>') + '</span>');\r\n                    el.css(data.css);\r\n                    return el;\r\n                }\r\n                function createImg(data) {\r\n                    var el = $('<img src=\"' + assets.img(data.src)\r\n                            .baseTexture.imageUrl + '\"/>');\r\n                    el.css(data.css);\r\n                    return el;\r\n                }\r\n                var i, item, $el;\r\n                var items = config.items;\r\n                for (i = 0; i < items.length; i++) {\r\n                    item = items[i];\r\n                    if (item.type === 'text') {\r\n                        $el = createText(item);\r\n                    }\r\n                    if (item.type === 'img') {\r\n                        $el = createImg(item);\r\n                    }\r\n                    if ($el) {\r\n                        if (item.adjustPosition) {\r\n                            $innerAdjusted.append($el);\r\n                        } else {\r\n                            $innerStatic.append($el);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            var $html = $('html');\r\n            var $helpContainer = $('#help-container');\r\n            var $innerStatic = $('<div></div>');\r\n            var $innerAdjusted = $('<div></div>');\r\n            $helpContainer.append($innerStatic);\r\n            $helpContainer.append($innerAdjusted);\r\n            $helpContainer.click(hide);\r\n            var visible = false;\r\n\r\n\r\n            // event handlers\r\n            pubsub.subscribeBatch({\r\n                'notify:startupInitialized': function () {\r\n                    generateHTML();\r\n                },\r\n                'notify:dimensionsChanged': function () {\r\n                    resize();\r\n                },\r\n                'request:showHelpOverlay': function (id, data) {\r\n                    $helpContainer.show();\r\n                    visible = true;\r\n                    $html.addClass('help-overlay-visible');\r\n                    resize();\r\n                    pubsub.publish('notify:overlayDisplayed', {\r\n                        type: 'help'\r\n                    });\r\n                },\r\n                'request:hideHelpOverlay': function (id, data) {\r\n                    hide();\r\n                },\r\n            });\r\n            return {};\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/services/help.js"),eval("// keyboard\r\n// handles keyboard events a publishes them as pubsub events\r\ndefine('services/timer',['jquery', 'pubsub', 'data/config', 'services/pause'],\r\n        function ($, pubsub, config, pause) {\r\n\r\n            function actionHandler() {\r\n                if ((currentActivity === 'idle' && currentSubActivity === null)\r\n                        || (currentActivity === 'freeSpinIntro'\r\n                                && buttonState === 'freeSpinBanner-spinnable')) {\r\n                    setIdleTimeout(true);\r\n                } else {\r\n                    setIdleTimeout(false);\r\n                }\r\n            }\r\n\r\n            function setIdleTimeout(idle) {\r\n                pause.clearTimeout(idleTimeout);\r\n                if (idle) {\r\n                    idleTimeout = pause.setTimeout(function () {\r\n                        pubsub.publish('notify:gameIdle');\r\n                    }, config.IDLE_TIMEOUT_MS);\r\n                }\r\n            }\r\n\r\n            var idleTimeout = null;\r\n            var currentActivity = null;\r\n            var currentSubActivity = null;\r\n            var buttonState = null;\r\n\r\n            pubsub.subscribeBatch({\r\n                'notify:activityAfterStart': function (id, data) {\r\n                    currentActivity = data.activity;\r\n                    actionHandler();\r\n                },\r\n                'notify:subactivityStarted': function (id, data) {\r\n                    currentSubActivity = data.subactivity;\r\n                    actionHandler();\r\n                },\r\n                'notify:subactivityFinished': function (id, data) {\r\n                    currentSubActivity = null;\r\n                    actionHandler();\r\n                },\r\n                'request:buttonState': function (id, data) {\r\n                    buttonState = data.state;\r\n                    actionHandler();\r\n                }\r\n            });\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/services/timer.js"),eval("// exit\r\n// handles exit behavior\r\ndefine('services/exit',['pubsub', 'data/config'],\r\n        function (pubsub, config) {\r\n            function urlParam(name) {\r\n                var results = new RegExp('[\\?&]' + name + '=([^&#]*)').exec(window.location.href);\r\n                if (results == null)\r\n                {\r\n                    return null;\r\n                } else\r\n                {\r\n                    return results[1] || 0;\r\n                }\r\n            }\r\n            function postExitMsg() {\r\n                window.parent && window.parent.postMessage('closeFrame', '*');\r\n                window.opener && window.opener.postMessage('closeFrame', '*');\r\n            }\r\n            ;\r\n            pubsub.subscribeBatch({\r\n                'request:reloadGame': function (id, data) {\r\n                    postExitMsg();\r\n                    $('#main-container').hide();\r\n                    window.location.reload();\r\n                },\r\n                'request:quitToLobby': function (id, data) {\r\n      document.location.href='../../../';                postExitMsg();\r\n                    $('#main-container').hide();\r\n                    urlParam('exit') && (window.location = urlParam('exit'));\r\n                }});\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/services/exit.js"),eval("// keyboard\r\n// handles keyboard events a publishes them as pubsub events\r\ndefine('services/resume',['jquery', 'pubsub', 'data/config', 'services/pause'],\r\n        function ($, pubsub, config, pause) {\r\n\r\n\r\n//            pubsub.subscribeBatch({\r\n//                'notify:activityAfterStart': function (id, data) {\r\n//                    currentActivity = data.activity;\r\n//                    actionHandler();\r\n//                },\r\n//                'notify:subactivityStarted': function (id, data) {\r\n//                    currentSubActivity = data.subactivity;\r\n//                    actionHandler();\r\n//                },\r\n//                'notify:subactivityFinished': function (id, data) {\r\n//                    currentSubActivity = null;\r\n//                    actionHandler();\r\n//                }\r\n//            });\r\n\r\n\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/services/resume.js"),eval("// idle activity\r\n// controls the game during idle state\r\ndefine('activities/idle',[\r\n    'pubsub',\r\n    'data/config',\r\n], function (pubsub, config) {\r\n\r\n    var ACTIVITY_NAME = 'idle';\r\n\r\n    // flag defines whether spin is available during activity\r\n    var spinAvailable = null;\r\n    //\r\n    var subactivityRunning = null;\r\n\r\n    // activity event handlers\r\n    var handlers = {\r\n        'request:updateViewsWithModels': updateSpinAvailable,\r\n        'notify:spacePressed': runSpin,\r\n        'notify:spinButtonClicked': runSpinWithSound,\r\n        'notify:autoButtonClicked': runAutoSpin,\r\n        'notify:turboButtonClicked': runTurboSpin,\r\n        'notify:bottomPanelClicked': bottomPanelClicked,\r\n        'notify:reelSurfaceTouchStart': reelSurfaceDragStart,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n        'notify:menuStateChange': menuStateChanged,\r\n        'notify:spinButtonTouch': spinButtonTouch,\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        subactivityRunning = null;\r\n        pubsub.publish('request:showBackground');\r\n        pubsub.publish('request:showBottomRightInfo', {\r\n            text: ''\r\n        });\r\n        pubsub.publish('request:hideWinningsHeader');\r\n        updateSpinAvailable(null, data);\r\n        adjustTextForLastSpinResult(data);\r\n    }\r\n    // runs when user presses spin button\r\n    // plays sound\r\n    // runs spin if possible\r\n    function runSpinWithSound() {\r\n        if (spinAvailable) {\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            pubsub.publish(\"request:playSound\", {sound: config.FANCY_CLICK_SOUND});\r\n            spin();\r\n        }\r\n    }\r\n    // runs when user presses space or click reels\r\n    // runs spin if possible\r\n    function runSpin() {\r\n        if (spinAvailable) {\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            spin();\r\n        }\r\n    }\r\n    // runs on user spin event\r\n    // runs spin if possible\r\n    function spin() {\r\n        if (spinAvailable) {\r\n            spinAvailable = false;\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'spin'\r\n            });\r\n        }\r\n    }\r\n    // runs on auto event\r\n    // play autospin on sound\r\n    // runs autospin activity\r\n    function runAutoSpin() {\r\n        if (spinAvailable) {\r\n            spinAvailable = false;\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: config.AUTOSPIN_ON_SOUND\r\n            });\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'autoSpin'\r\n            });\r\n        }\r\n    }\r\n    function runTurboSpin() {\r\n        if (spinAvailable) {\r\n            spinAvailable = false;\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: config.AUTOSPIN_ON_SOUND\r\n            });\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'autoSpin',\r\n                options: {\r\n                    turbo: true\r\n                }\r\n            });\r\n        }\r\n    }\r\n    // show GAME OVER label if the last spin was a no win spin\r\n    function adjustTextForLastSpinResult(data) {\r\n        // check if there was a no-win spin on last spin\r\n        if (data.gameModel.lastSpinResult && !data.gameModel.lastSpinResult.totalWin) {\r\n            // there was a no-win spin\r\n            // show \"GAME OVER\" text\r\n            var txt = 'gameOverPlaceBet';\r\n            pubsub.publish('request:showBottomLeftInfo', {text: txt});\r\n        } else {\r\n            // there was no no-win spin\r\n            pubsub.publish('request:showBottomLeftInfo', {text: ''});\r\n        }\r\n    }\r\n    // update spin available flag according to cash remaining\r\n    function updateSpinAvailable(id, data) {\r\n        spinAvailable = true;\r\n        if (data.gameModel && !data.gameModel.hasEnoughCashToSpin) {\r\n            spinAvailable = false;\r\n        }\r\n        if (subactivityRunning === 'menu') {\r\n            spinAvailable = false;\r\n        }\r\n        adjustControls();\r\n    }\r\n    // request button state update according to game conditions\r\n    function adjustControls() {\r\n        if (spinAvailable) {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'idle-spinnable',\r\n            });\r\n        } else {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'idle-notSpinnable',\r\n            });\r\n        }\r\n    }\r\n\r\n    // subactivities management\r\n    function subactivityStarted(id) {\r\n        subactivityRunning = id;\r\n        adjustControls();\r\n        pubsub.publish('notify:subactivityStarted', {activity: 'idle', subactivity: id});\r\n    }\r\n    function subactivityFinished() {\r\n        var finishing = subactivityRunning;\r\n        subactivityRunning = null;\r\n        adjustControls();\r\n        pubsub.publish('notify:subactivityFinished', {\r\n            activity: 'idle',\r\n            subactivity: finishing\r\n        });\r\n    }\r\n    // menu subactivity\r\n    function menuStateChanged(id, state) {\r\n        if (state === 'openEnd') {\r\n            subactivityStarted('menu');\r\n            pubsub.publish('request:pauseBetlinePreview');\r\n            pubsub.publish('request:refreshReelsView');\r\n            pubsub.publish('request:clearWinAnimations');\r\n        }\r\n        if (state === 'closeEnd') {\r\n            subactivityFinished();\r\n            pubsub.publish('request:resumeBetlinePreview');\r\n        }\r\n    }\r\n    function bottomPanelClicked() {\r\n        if (subactivityRunning === 'menu') {\r\n            pubsub.publish('request:closeMenu');\r\n        } else if (!subactivityRunning) {\r\n            pubsub.publish('request:loadMenu', {page: 1});\r\n        }\r\n    }\r\n    // reel drag subactivity\r\n    function reelSurfaceDragStart() {\r\n        subactivityStarted('reelsDrag');\r\n    }\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        subactivityFinished();\r\n        if (data.actionTriggerTresholdPassed) {\r\n            runSpin();\r\n        }\r\n    }\r\n    // spin button subactivity\r\n    function spinButtonTouch(id, type) {\r\n        if (type === 'down') {\r\n            subactivityStarted('spinButton');\r\n        }\r\n        if (type === 'end') {\r\n            subactivityFinished();\r\n        }\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n\r\n\r\n}\r\n);\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/idle.js"),eval("// menu activity\r\n// controls the game during when player has won in standard spin\r\ndefine('activities/win',[\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'services/transport',\r\n], function (\r\n        pubsub, config, symbolSet, transport) {\r\n\r\n    var ACTIVITY_NAME = 'win';\r\n\r\n    // object contains last spin result\r\n    var lastSpinResult;\r\n    // flag defines whether take win and take risk buttons are active\r\n    var buttonsReady = null;\r\n\r\n    // activity event handlers\r\n    var handlers = {\r\n        'notify:spacePressed': takeWin,\r\n        'notify:takeWinButtonClicked': takeWin,\r\n        'notify:takeRiskButtonClicked': takeRisk,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        // clear\r\n        buttonsReady = false;\r\n        pubsub.publish('request:showBottomRightInfo', {\r\n            text: ''\r\n        });\r\n        lastSpinResult = $.extend(true, {}, data.gameModel.lastSpinResult);\r\n\r\n\r\n        if (!data.options.noAnimations) {\r\n            // run with animations\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-beforeWin'\r\n            });\r\n            pubsub.publish('request:runWinAnimations', {\r\n                betModel: data.betModel,\r\n                spinResult: lastSpinResult,\r\n                showFirstWinLineAsLast: false,\r\n                symbolSet: symbolSet.SPIN,\r\n                firstViewDuration: config.WIN_LINES_FIRST_VIEW_DURATION,\r\n                firstViewCallback: function () {\r\n                    // runs when first win preview is finished\r\n                    // activate take buttons\r\n                    pubsub.publish('request:buttonState', {\r\n                        state: 'win-spin'\r\n                    });\r\n                    buttonsReady = true;\r\n                }\r\n            });\r\n        } else {\r\n            // run without animations\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-spin'\r\n            });\r\n            buttonsReady = true;\r\n        }\r\n    }\r\n\r\n\r\n    // runs on take win event if available\r\n    // if available, requests current credit state from server\r\n    // runs win amount animation activity\r\n    function takeWin(id, data) {\r\n        if (buttonsReady) {\r\n            buttonsReady = false;\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-afterAction'\r\n            });\r\n            transport.endGame(null, function (betModel) {\r\n                pubsub.publish('request:cashIn', {\r\n                    betModel: betModel,\r\n                    callback: function () {\r\n                        pubsub.publish(\"request:runActivity\", {\r\n                            activity: 'winAmountAnimation'\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    // runs on take risk event if available\r\n    // runs gamble activity\r\n    function takeRisk(id, data) {\r\n        if (buttonsReady) {\r\n            buttonsReady = false;\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-afterAction'\r\n            });\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'gamble'\r\n            });\r\n        }\r\n    }\r\n\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        if (data.click) {\r\n            takeWin(id, data);\r\n        }\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n    return API;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/win.js"),eval("// menu activity\r\n// controls the game during standard spin\r\ndefine('activities/spin',['pubsub',\r\n    'services/transport',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'data/config-reelSet',\r\n], function (\r\n        pubsub, transport, config, symbolSet, reelSet) {\r\n\r\n    var ACTIVITY_NAME = 'spin';\r\n\r\n    // flag defines whether it is possible to stop running spin\r\n    var spinStoppable = null;\r\n    // stop request flag\r\n    var stopRequested = false;\r\n\r\n    // object contains the received spin result\r\n    var spinResult = null;\r\n\r\n    var gameModel = null;\r\n\r\n    // event handlers\r\n    var handlers = {\r\n        'notify:spacePressed': stopClicked,\r\n        'notify:stopButtonClicked': stopClicked,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n        'notify:reelBounceStart': reelBounceStart,\r\n        'notify:spinFinished': spinFinished,\r\n        'notify:fasterSpinStarted': animateFasterReel\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        // clear\r\n        spinResult = null;\r\n        spinStoppable = true;\r\n        stopRequested = false;\r\n\r\n        gameModel = data.gameModel;\r\n        if (data.options.resumeData) {\r\n\r\n            spinResult = {setup: gameModel.lastSpinResult};\r\n            spinFinished();\r\n\r\n        } else {\r\n\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'spin-basicSpin'\r\n            });\r\n            pubsub.publish('request:refreshReelsView');\r\n            pubsub.publish('request:clearWinAnimations');\r\n            pubsub.publish('request:showBackground');\r\n            // show \"GOOD LUCK\" text\r\n            pubsub.publish('request:showBottomLeftInfo', {text: 'goodLuck'});\r\n            // update credits view - subtract current bet\r\n            pubsub.publish('request:subtractTotalBetFromView', {\r\n                betModel: data.betModel});\r\n            // spin reels\r\n            pubsub.publish('request:spinReels');\r\n            // ask server for spin result\r\n            transport.getSpinResult({model: data.betModel, }, onGotSpinResult);\r\n\r\n        }\r\n    }\r\n\r\n    function onGotSpinResult(result, isResuming) {\r\n        // result received\r\n        // allow spin stop\r\n        // publish result\r\n        // request reels stop\r\n        spinResult = result;\r\n        spinStoppable = true;\r\n        pubsub.publish('notify:spinResultReceived', {\r\n            result: spinResult\r\n        });\r\n        pubsub.publish('request:stopReels', {\r\n            setup: spinResult.setup\r\n        });\r\n        if (stopRequested) {\r\n            stopSpin();\r\n        }\r\n    }\r\n\r\n    function stopClicked() {\r\n        stopRequested = true;\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'spin-spinNotStoppable'\r\n        });\r\n        if (spinStoppable) {\r\n            stopSpin.apply(null, arguments);\r\n        }\r\n    }\r\n\r\n    // runs on force stop event\r\n    // disables force stop button\r\n    // publishes a request to force stop reels if allowed\r\n    function stopSpin(id, data) {\r\n        spinStoppable = false;\r\n        if (!data || !data.silent) {\r\n            pubsub.publish(\"request:playSound\", {sound: config.BUTTON_CLICK_SOUND});\r\n        }\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'spin-spinNotStoppable'\r\n        });\r\n        pubsub.publish('request:forceStopReels');\r\n    }\r\n\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        if (data.click) {\r\n            stopClicked(id, {silent: true});\r\n        }\r\n    }\r\n\r\n    // runs on spin finished event\r\n    function spinFinished() {\r\n        // clear teaser animations\r\n        pubsub.publish('request:clearFastReelAnimations');\r\n\r\n        // check last spin result\r\n        if (spinResult.setup.freeSpins) {\r\n            // user has won free spins\r\n            // run free spin intro activity\r\n            transport.endFeature(null, function () {\r\n                pubsub.publish(\"request:runActivity\", {\r\n                    activity: 'freeSpinIntro',\r\n                });\r\n            });\r\n        } else {\r\n            if (Object.keys(spinResult.setup.ws).length !== 0) {\r\n                // user has won credits\r\n                // run win activity\r\n                transport.endFeature(null, function () {\r\n                    pubsub.publish(\"request:runActivity\", {\r\n                        activity: 'win'\r\n                    });\r\n                });\r\n            } else {\r\n                // user has not won\r\n                pubsub.publish('request:cashIn', {\r\n                    betModel: spinResult.model,\r\n                    updateViews: true,\r\n                    callback: function () {\r\n                        // run idle activity\r\n                        pubsub.publish(\"request:runActivity\", {\r\n                            activity: 'idle'\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    // run teaser animation\r\n    function animateFasterReel(id, data) {\r\n        pubsub.publish('request:animateFasterReel', data);\r\n    }\r\n\r\n    function reelBounceStart(id, data) {\r\n        pubsub.publish('request:runCommonAnimations', {\r\n            spinResult: spinResult.setup,\r\n            reel: data.index,\r\n            symbolSet: symbolSet.SPIN,\r\n        });\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/spin.js"),eval("// autoSpin activity\r\n// controls the game during auto spin\r\ndefine('activities/autoSpin',[\r\n    'pubsub',\r\n    'data/config',\r\n    'services/transport',\r\n    'services/autoplay',\r\n    'data/config-symbolSet',\r\n    'data/config-reelSet',\r\n], function (\r\n        pubsub, config, transport, autoplayService, symbolSet, reelSet) {\r\n\r\n    var ACTIVITY_NAME = 'autoSpin';\r\n\r\n    // flag defines whether it is possible to stop running spin\r\n    var spinStoppable = null;\r\n    // flag defines whether autoplay mode is on\r\n    var autoplayOn = null;\r\n    // object contains the received spin result\r\n    var spinResult = null;\r\n    // stop request flag\r\n    var stopRequested = false;\r\n    // turbo mode\r\n    var turbo = false;\r\n\r\n    // activity event handlers\r\n    var handlers = {\r\n        'notify:spacePressed': stopClicked,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n        'notify:reelBounceStart': reelBounceStart,\r\n        'notify:stopButtonClicked': stopClicked,\r\n        'notify:autoButtonClicked': disableAutoSpin,\r\n        'notify:turboButtonClicked': turboClicked,\r\n        'notify:spinFinished': spinFinished,\r\n        'notify:fasterSpinStarted': animateFasterReel,\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        // clear\r\n        autoplayOn = true;\r\n        spinStoppable = false;\r\n        stopRequested = false;\r\n        spinResult = null;\r\n        turbo = data.options.turbo;\r\n\r\n        updateControls();\r\n\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n        pubsub.publish('request:showBackground');\r\n        // show GOOD LUCK text\r\n        pubsub.publish('request:showBottomLeftInfo', {text: 'goodLuck'});\r\n        // subtract credits from credits count view\r\n        pubsub.publish('request:subtractTotalBetFromView', {\r\n            betModel: data.betModel});\r\n\r\n        // start spin\r\n        pubsub.publish('request:spinReels');\r\n        // alert autoplay controller that another auto spin has started\r\n        autoplayService.autoplayStarted({\r\n            cash: data.betModel.cash\r\n        });\r\n        pubsub.publish('request:showBottomRightInfo', {\r\n            text: autoplayService.getBottomRightLabel(),\r\n        });\r\n        // ask server for spin result\r\n        transport.getSpinResult({\r\n            model: data.betModel,\r\n        },\r\n                function (result) {\r\n                    spinResult = result;\r\n                    spinStoppable = true;\r\n                    // fire spin result notification event\r\n                    pubsub.publish('notify:spinResultReceived', {\r\n                        result: spinResult\r\n                    });\r\n                    // request reels to stop with received result\r\n                    pubsub.publish('request:stopReels', {\r\n                        setup: spinResult.setup\r\n                    });\r\n                    if (turbo) {\r\n                        stopRequested = true;\r\n                    }\r\n                    if (stopRequested) {\r\n                        stopSpin();\r\n                    }\r\n                });\r\n    }\r\n\r\n    function stopClicked() {\r\n        stopRequested = true;\r\n        if (turbo) {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'spin-turboNotStoppable'\r\n            });\r\n        } else {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'spin-autoNotStoppable'\r\n            });\r\n        }\r\n        if (spinStoppable) {\r\n            stopSpin.apply(null, arguments);\r\n        }\r\n    }\r\n\r\n    // runs on user action (stop button)\r\n    // fires force reels stop request\r\n    function stopSpin(id, data) {\r\n        spinStoppable = false;\r\n        if (!data || !data.silent) {\r\n            pubsub.publish(\"request:playSound\", {sound: config.BUTTON_CLICK_SOUND});\r\n        }\r\n        if (turbo) {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'spin-turboNotStoppable'\r\n            });\r\n        } else {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'spin-autoNotStoppable'\r\n            });\r\n        }\r\n        updateControls();\r\n        pubsub.publish('request:forceStopReels');\r\n    }\r\n\r\n    // runs when auto button is pressed\r\n    // disables autoplay mode\r\n    // clears autoplay controller data\r\n    // fires request to disable auto button\r\n    function disableAutoSpin() {\r\n        if (autoplayOn) {\r\n            autoplayOn = false;\r\n            autoplayService.clearAutoplay();\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: config.AUTOSPIN_OFF_SOUND\r\n            });\r\n            updateControls();\r\n        }\r\n    }\r\n\r\n    function turboClicked() {\r\n        if (autoplayOn) {\r\n            if (!turbo) {\r\n                turbo = true;\r\n                pubsub.publish('request:buttonState', {\r\n                    state: 'spin-turboNotStoppable'\r\n                });\r\n            } else {\r\n                disableAutoSpin();\r\n            }\r\n        }\r\n    }\r\n\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        if (data.click) {\r\n            stopClicked(id, {silent: true});\r\n        }\r\n    }\r\n\r\n    // runs when spin is finished\r\n    function spinFinished() {\r\n        // clear teaser animations\r\n        pubsub.publish('request:clearFastReelAnimations');\r\n\r\n        // initialize reels with data from server\r\n        if (spinResult.setup.freeSpins > 0) {\r\n            // user won free spins\r\n            // disable autoplay\r\n            // clear autoplay controller data\r\n            // runs freeSpinIntro activity\r\n            transport.endFeature(null, function () {\r\n                autoplayOn = false;\r\n                autoplayService.clearAutoplay();\r\n                pubsub.publish('request:cashIn', {\r\n                    betModel: spinResult.model,\r\n                    updateViews: true,\r\n                    callback: function () {\r\n                        pubsub.publish(\"request:runActivity\", {\r\n                            activity: 'freeSpinIntro'\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        } else {\r\n            // user did not win free spins\r\n            if (Object.keys(spinResult.setup.ws).length !== 0) {\r\n                // user won credits\r\n                transport.endFeature(null, function () {\r\n                    if (autoplayOn) {\r\n                        pubsub.publish(\"request:runActivity\", {\r\n                            activity: 'autoSpinWin',\r\n                            options: {\r\n                                turbo: turbo,\r\n                            }\r\n                        });\r\n                    } else {\r\n                        pubsub.publish(\"request:runActivity\", {\r\n                            activity: 'win'\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                // user did not win credits\r\n                pubsub.publish('request:cashIn', {\r\n                    betModel: spinResult.model,\r\n                    updateViews: true,\r\n                    callback: function () {\r\n                        if (autoplayOn) {\r\n                            // autoplay is on\r\n                            // run autoSpinNoWin activity\r\n                            pubsub.publish(\"request:runActivity\", {\r\n                                activity: 'autoSpinNoWin',\r\n                                options: {\r\n                                    turbo: turbo,\r\n                                }\r\n                            });\r\n                        } else {\r\n                            // autoplay is off\r\n                            // run idle activity\r\n                            pubsub.publish(\"request:runActivity\", {\r\n                                activity: 'idle'\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    // publishes button state change request\r\n    // according to current game conditions\r\n    function updateControls() {\r\n        var state;\r\n        if (autoplayOn) {\r\n            if (turbo) {\r\n                if (stopRequested) {\r\n                    state = 'spin-turboNotStoppable';\r\n                } else {\r\n                    state = 'spin-turboSpin';\r\n                }\r\n            } else {\r\n                if (stopRequested) {\r\n                    state = 'spin-autoNotStoppable';\r\n                } else {\r\n                    state = 'spin-autoSpin';\r\n                }\r\n            }\r\n        } else {\r\n            if (stopRequested) {\r\n                state = 'spin-spinNotStoppable';\r\n            } else {\r\n                state = 'spin-basicSpin';\r\n            }\r\n        }\r\n        pubsub.publish('request:buttonState', {\r\n            state: state\r\n        });\r\n    }\r\n\r\n    // publishes a request to animate teaser animation\r\n    function animateFasterReel(id, data) {\r\n        pubsub.publish('request:animateFasterReel', data);\r\n    }\r\n\r\n    function reelBounceStart(id, data) {\r\n        pubsub.publish('request:runCommonAnimations', {\r\n            spinResult: spinResult.setup,\r\n            reel: data.index,\r\n            symbolSet: symbolSet.SPIN,\r\n        });\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/autoSpin.js"),
eval("// autoSpinWin activity\r\n// controls the game during pause after auto spin when player has won\r\ndefine('activities/autoSpinWin',[\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'services/pause',\r\n    'services/autoplay',\r\n    'services/transport',\r\n], function (\r\n        pubsub, config, symbolSet,\r\n        pause, autoplayService, transport) {\r\n\r\n    var ACTIVITY_NAME = 'autoSpinWin';\r\n\r\n    // flag defines whether autospin mode is on\r\n    var autoSpinMode = null;\r\n    // flag defines whether spin is possible\r\n    var spinAvailable = null;\r\n    // object contains the results of last spin\r\n    var lastSpinResult;\r\n\r\n    var startData;\r\n\r\n    var turbo;\r\n\r\n    // activity event handlers\r\n    var handlers = {\r\n        'notify:spinButtonClicked': runSpinWithSound,\r\n        'notify:spacePressed': runSpin,\r\n        'notify:autoButtonClicked': disableAutoSpin,\r\n        'notify:turboButtonClicked': turboClicked,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        // clear\r\n        lastSpinResult = $.extend(true, {}, data.gameModel.lastSpinResult);\r\n\r\n        startData = data;\r\n\r\n        turbo = data.options.turbo;\r\n\r\n        autoSpinMode = true;\r\n        spinAvailable = false;\r\n\r\n        if (turbo) {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-beforeWinTurbo'\r\n            });\r\n        } else {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-beforeWinAuto'\r\n            });\r\n        }\r\n        // runs animations using win animations controller\r\n        pubsub.publish('request:runWinAnimations', {\r\n            spinResult: lastSpinResult,\r\n            betModel: data.betModel,\r\n            showFirstWinLineAsLast: false,\r\n            symbolSet: symbolSet.SPIN,\r\n            firstViewDuration: config.WIN_LINES_FIRST_VIEW_DURATION,\r\n            firstViewCallback: function () {\r\n                // runs when first win preview is finished\r\n                if (autoSpinMode) {\r\n                    // autoplay still on\r\n                    // allows force spin\r\n                    spinAvailable = true;\r\n                    if (turbo) {\r\n                        pubsub.publish('request:buttonState', {\r\n                            state: 'win-turboSpin'\r\n                        });\r\n                    } else {\r\n                        pubsub.publish('request:buttonState', {\r\n                            state: 'win-autoSpin',\r\n                        });\r\n                    }\r\n                } else {\r\n                    // user turned autoplay off\r\n                    // change to win activity\r\n                    clearAutoPlayRunWin();\r\n                }\r\n            },\r\n            firstPassCallback: function () {\r\n                // runs after all betlines are cycled one by one\r\n                if (spinAvailable && autoSpinMode) {\r\n                    // there was no user action\r\n                    // disallow spin\r\n                    // clear animations\r\n                    spinAvailable = false;\r\n                    if (turbo) {\r\n                        pubsub.publish('request:buttonState', {\r\n                            state: 'spin-turboNotStoppable'\r\n                        });\r\n                    } else {\r\n                        pubsub.publish('request:buttonState', {\r\n                            state: 'spin-autoNotStoppable'\r\n                        });\r\n                    }\r\n                    pubsub.publish('request:refreshReelsView');\r\n                    pubsub.publish('request:clearWinAnimations');\r\n                    // add a slight delay before next spin\r\n                    pause.setTimeout(resolveSpinRequest,\r\n                            config.AUTO_SPIN_AFTER_WIN_PREVIEW_PAUSE_DURATION);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // runs when user presses spin button\r\n    // plays sound\r\n    // runs force spin if possible\r\n    function runSpinWithSound(id, data) {\r\n        if (spinAvailable) {\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            pubsub.publish(\"request:playSound\", {sound: config.FANCY_CLICK_SOUND});\r\n            spin();\r\n        }\r\n    }\r\n    // runs when user presses space or click reels\r\n    // runs force spin if possible\r\n    function runSpin(id, data) {\r\n        if (spinAvailable) {\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            spin();\r\n        }\r\n    }\r\n\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        if (data.click) {\r\n            runSpin(id, data);\r\n        }\r\n    }\r\n\r\n    // runs on user force spin event\r\n    // runs force spin if possible\r\n    function spin(id, data) {\r\n        if (spinAvailable) {\r\n            // disallow spin\r\n            // clear animation\r\n            spinAvailable = false;\r\n            if (turbo) {\r\n                pubsub.publish('request:buttonState', {\r\n                    state: 'spin-turboNotStoppable'\r\n                });\r\n            } else {\r\n                pubsub.publish('request:buttonState', {\r\n                    state: 'spin-autoNotStoppable'\r\n                });\r\n            }\r\n            pubsub.publish('request:refreshReelsView');\r\n            pubsub.publish('request:clearWinAnimations');\r\n            // add a slight delay before spin\r\n            pause.setTimeout(resolveSpinRequest, config.BEFORE_FORCE_SPIN_PAUSE);\r\n        }\r\n    }\r\n\r\n    function resolveSpinRequest(data) {\r\n        // check if autoplay should continue\r\n        if (!autoplayService.shouldAutospinMore({\r\n            win: startData.gameModel.lastSpinResult.totalWin,\r\n            bet: startData.betModel.totalBet,\r\n            cash: startData.betModel.cash,\r\n            credits: startData.betModel.credits\r\n        })) {\r\n            // autoplay reached an user-defined limit\r\n            // clear and run win activity\r\n            autoSpinMode = false;\r\n            clearAutoPlayRunWin();\r\n        } else {\r\n            transport.endGame(null, function (betModel) {\r\n                pubsub.publish('request:cashIn', {\r\n                    betModel: betModel,\r\n                    updateViews: true,\r\n                    callback: function (data) {\r\n                        // further autoplay is allowed\r\n                        // run activity again\r\n                        pubsub.publish('request:hideWinningsHeader');\r\n                        pubsub.publish(\"request:runActivity\", {\r\n                            activity: 'autoSpin',\r\n                            options: {\r\n                                turbo: turbo,\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    // runs on user auto button event\r\n    // disables autoplay if allowed\r\n    function disableAutoSpin() {\r\n        if (autoSpinMode) {\r\n            autoSpinMode = false;\r\n            if (spinAvailable) {\r\n                // button pressed after first win preview\r\n                // run win activity\r\n                spinAvailable = false;\r\n                clearAutoPlayRunWin();\r\n            } else {\r\n                // button pressed while still in win preview state\r\n                // update buttons state - disable them\r\n                // action is resolved in win animations callback above\r\n                pubsub.publish('request:buttonState', {\r\n                    state: 'win-beforeWin'\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function turboClicked() {\r\n        if (!turbo) {\r\n            turbo = true;\r\n            if (spinAvailable) {\r\n                pubsub.publish('request:buttonState', {\r\n                    state: 'win-turboSpin'\r\n                });\r\n            } else {\r\n                pubsub.publish('request:buttonState', {\r\n                    state: 'spin-turboNotStoppable'\r\n                });\r\n            }\r\n        } else {\r\n            disableAutoSpin();\r\n        }\r\n    }\r\n\r\n    // clear autoplay data\r\n    // run win activity without animations (they are already displayed in current activity)\r\n    function clearAutoPlayRunWin() {\r\n        autoplayService.clearAutoplay();\r\n        pubsub.publish(\"request:runActivity\", {\r\n            activity: 'win',\r\n            options: {\r\n                noAnimations: true\r\n            }\r\n        });\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/autoSpinWin.js"),eval("// autoSpinNoWin activity\r\n// controls the game during pause after auto spin when player has not won\r\ndefine('activities/autoSpinNoWin',[\r\n    'pubsub',\r\n    'services/pause',\r\n    'services/autoplay',\r\n    'data/config',\r\n], function (\r\n        pubsub, pause, autoplayService, config) {\r\n\r\n    var ACTIVITY_NAME = 'autoSpinNoWin';\r\n\r\n    // timeout allows for a pause after the previous spin finished\r\n    var autoSpinTimeout = null;\r\n    // flag defines whether the user can disable autoplay\r\n    var autoSpinDisableable = null;\r\n\r\n    var turbo = null;\r\n\r\n    // activity event handlers\r\n    var handlers = {\r\n        'notify:autoButtonClicked': disableAutoSpin,\r\n        'notify:turboButtonClicked': turboClicked,\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        // clear\r\n        autoSpinDisableable = true;\r\n        turbo = data.options.turbo;\r\n        if (turbo) {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'turboSpinPause'\r\n            });\r\n        } else {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'autoSpinPause'\r\n            });\r\n        }\r\n        pubsub.publish('request:showBottomLeftInfo', {text: ''});\r\n//        pubsub.publish('request:showReels');\r\n        pubsub.publish('request:showBackground');\r\n        // initialize pause timeout\r\n        autoSpinTimeout = pause.setTimeout(function () {\r\n            // ask autoplay controller whether we are allowed to spin another one\r\n            // depending on current autoplay setup\r\n            if (!autoplayService.shouldAutospinMore({\r\n                win: 0,\r\n                bet: data.betModel.totalBet,\r\n                cash: data.betModel.cash,\r\n                credits: data.betModel.credits,\r\n            })) {\r\n                // autoplay limit reached\r\n                // clear autoplay controller\r\n                // run idle activity\r\n                autoplayService.clearAutoplay();\r\n                pubsub.publish(\"request:runActivity\", {\r\n                    activity: 'idle',\r\n                });\r\n            } else {\r\n                // run another auto spin\r\n                pubsub.publish(\"request:runActivity\", {\r\n                    activity: 'autoSpin',\r\n                    options: {\r\n                        turbo: turbo\r\n                    },\r\n                });\r\n            }\r\n        }, config.AUTO_SPIN_NO_WIN_PAUSE_DURATION);\r\n    }\r\n\r\n    // runs on auto button press\r\n    // disables autoplay\r\n    // runs idle activity\r\n    function disableAutoSpin(id, data) {\r\n        if (autoSpinDisableable) {\r\n            autoSpinDisableable = false;\r\n            if (autoSpinTimeout) {\r\n                pause.clearTimeout(autoSpinTimeout);\r\n            }\r\n            autoplayService.clearAutoplay();\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'idle',\r\n            });\r\n        }\r\n    }\r\n\r\n    function turboClicked() {\r\n        if (!turbo) {\r\n            turbo = true;\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'turboSpinPause'\r\n            });\r\n        } else {\r\n            disableAutoSpin();\r\n        }\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/autoSpinNoWin.js"),eval("// menu activity\r\n// controls the game during win amount animation\r\n// (when user is accepting credits)\r\ndefine('activities/winAmountAnimation',['pubsub', 'data/config',\r\n    'services/pause', 'services/format', 'services/settings'], function (\r\n        pubsub, config, pause, format, settings) {\r\n\r\n    var ACTIVITY_NAME = 'winAmountAnimation';\r\n\r\n    // flag defines whether take win button is active\r\n    var buttonsReady = null;\r\n    // reference to animation interval\r\n    var animationInterval = null;\r\n\r\n    // event handlers\r\n    var handlers = {\r\n        'notify:spacePressed': takeWin,\r\n        'notify:takeWinButtonClicked': takeWin,\r\n        'notify:winAmountAnimationFinished': takeWin,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    // runs on start\r\n    function mStart(data) {\r\n        // clear\r\n        buttonsReady = true;\r\n        animationInterval = null;\r\n        pubsub.publish('request:showBackground', {win: true});\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'win-amountAnimation'\r\n        });\r\n        pubsub.publish(\"request:playSound\", {\r\n            sound: config.WIN_AMOUNT_ANIMATION_SOUND,\r\n            playInLoop: true\r\n        });\r\n        var creditsWinAmount = data.gameModel.lastSpinResult.totalWin;\r\n        var cashWinAmount = format.getCashForCredits(creditsWinAmount);\r\n        animationInterval = animateWinAmount({\r\n            fromCredits: data.betModel.credits - creditsWinAmount,\r\n            fromCash: data.betModel.cash - cashWinAmount,\r\n            cashWinAmount: cashWinAmount,\r\n            creditsWinAmount: creditsWinAmount,\r\n            onFinished: takeWin,\r\n            betModel: data.betModel,\r\n        });\r\n    }\r\n    // runs on take win event\r\n    // runs on win amount animation finish\r\n    // update views\r\n    // start idle activity\r\n    function takeWin() {\r\n        if (buttonsReady) {\r\n            animationInterval && pause.clearInterval(animationInterval);\r\n            buttonsReady = false;\r\n            pubsub.publish('request:winAmountAnimationUpdate', {\r\n                finished: true\r\n            });\r\n            pubsub.publish(\"request:stopSound\", {\r\n                sound: config.WIN_AMOUNT_ANIMATION_SOUND\r\n            });\r\n            pubsub.publish(\"request:playSound\", {\r\n                sound: config.TAKE_WIN_FINISH_SOUND\r\n            });\r\n            pubsub.publish('request:hideWinningsHeader');\r\n            pubsub.publish('request:clearButtonAnimations');\r\n            pubsub.publish('request:viewUpdate');\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'idle'\r\n            });\r\n        }\r\n    }\r\n    // controls the win amount animation\r\n    function animateWinAmount(data) {\r\n        if (data.cashWinAmount === 0) {\r\n            data.onFinished();\r\n            return;\r\n        }\r\n        var currentCountdownCash, currentCountdownCredits, diff;\r\n        var totalTime;\r\n        var showInCash = settings.get().credits.showInCash;\r\n        if (showInCash) {\r\n            totalTime = (data.cashWinAmount\r\n                    * config.CREDIT_AMOUNT_ANIMATION_DELAY) / config.GAME_SPEED_MODIFIER;\r\n        } else {\r\n            totalTime = (data.creditsWinAmount\r\n                    * config.CREDIT_AMOUNT_ANIMATION_DELAY) / config.GAME_SPEED_MODIFIER;\r\n        }\r\n        diff = 0;\r\n        var interval = pause.setInterval(function () {\r\n            diff += config.CREDIT_AMOUNT_ANIMATION_DELAY / 2;\r\n            currentCountdownCash = data.cashWinAmount - Math.round((diff / totalTime) * data.cashWinAmount);\r\n            currentCountdownCredits = data.creditsWinAmount - Math.round((diff / totalTime) * data.creditsWinAmount);\r\n            if ((showInCash && currentCountdownCash <= 0)\r\n                    || (!showInCash && currentCountdownCredits <= 0)) {\r\n                clearInterval(interval);\r\n                data.onFinished();\r\n            } else {\r\n                pubsub.publish('request:winAmountAnimationUpdate', {\r\n                    currentCountdownCash: currentCountdownCash,\r\n                    currentCountdownCredits: currentCountdownCredits,\r\n                    currentCash: data.fromCash + data.cashWinAmount - currentCountdownCash,\r\n                    currentCredits: data.fromCredits + data.creditsWinAmount - currentCountdownCredits,\r\n                    betModel: data.betModel\r\n                });\r\n            }\r\n        }, config.CREDIT_AMOUNT_ANIMATION_DELAY / 2);\r\n        return interval;\r\n    }\r\n\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        if (data.click) {\r\n            takeWin(id, data);\r\n        }\r\n    }\r\n\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/winAmountAnimation.js"),eval("// gamble activity\r\ndefine('activities/gamble',[\r\n    'pubsub',\r\n    'data/config',\r\n    'services/transport',\r\n    'services/pause',\r\n], function (pubsub, config, transport, pause) {\r\n\r\n    var ACTIVITY_NAME = 'gamble';\r\n    // flag defines whether the gamble is ready and the user can select a card\r\n    var gambleCardsReady = null;\r\n    // object contains the result of last spin\r\n    // lastSpinResult.totalWin property gets updated with each gamble\r\n    // and represents the current gamble win for the last spin\r\n    var lastSpinResult = null;\r\n    //\r\n    var subactivity = null;\r\n    //\r\n    var currentBottomInfo = '';\r\n\r\n    // event handlers\r\n    var handlers = {\r\n        'notify:takeWinButtonClicked': takeWin,\r\n        'notify:spacePressed': takeWin,\r\n        'notify:gambleCardClicked': cardClicked,\r\n        'notify:menuStateChange': menuStateChanged,\r\n    };\r\n    // runs on startup\r\n    function mStart(data) {\r\n        function displayGambleView(card, win) {\r\n            // display the gamble window\r\n            pubsub.publish('request:showBackground', {\r\n                win: false\r\n            });\r\n            pubsub.publish('request:showGambleFrame', {\r\n                firstCard: card,\r\n                gambleAmount: win\r\n            });\r\n        }\r\n        function letUserPickCard(step) {\r\n            // allow user action after a delay\r\n            !step && (step = 1);\r\n            pause.setTimeout(function () {\r\n                gambleCardsReady = true;\r\n                pubsub.publish('request:pauseWinAnimations');\r\n                currentBottomInfo = ['step', '! ', '!' + step + '. ', 'selectCardOrTakeWin'];\r\n                pubsub.publish('request:showBottomLeftInfo', {\r\n                    text: currentBottomInfo\r\n                });\r\n                pubsub.publish('request:buttonState', {\r\n                    state: 'win-gambleQuittable',\r\n                });\r\n            }, 1200);\r\n        }\r\n\r\n        // clear\r\n        gambleCardsReady = false;\r\n        lastSpinResult = data.gameModel.lastSpinResult;\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'win-gambleNotQuittable'\r\n        });\r\n\r\n        if (data.options.resumeData) {\r\n            if (data.options.resumeData.firstCardData) {\r\n                // first gamble\r\n                displayGambleView(data.options.resumeData.firstCardData.card,\r\n                        lastSpinResult.totalWin);\r\n                letUserPickCard();\r\n            } else if (data.options.resumeData.gambleResultData) {\r\n                // we have previous gamble result\r\n                if (!data.options.resumeData.gambleResultData.finished\r\n                        && (data.options.resumeData.gambleResultData.win\r\n                                || data.options.resumeData.gambleResultData.tie)) {\r\n                    // gamble not finished, offer next card\r\n                    displayGambleView(data.options.resumeData.gambleResultData.card,\r\n                            lastSpinResult.totalWin);\r\n                    letUserPickCard(data.options.resumeData.gambleResultData.step);\r\n                } else {\r\n                    // gamble finished\r\n                    cashInAndClear(false);\r\n                }\r\n            }\r\n        } else {\r\n            // ask server for the dealer card\r\n            transport.getGambleFirstCard({},\r\n                    function (result) {\r\n                        displayGambleView(result.card, lastSpinResult.totalWin);\r\n                        letUserPickCard();\r\n                    });\r\n        }\r\n    }\r\n    // runs on take win event\r\n    function takeWin(id, data) {\r\n        if (gambleCardsReady) {\r\n            gambleCardsReady = false;\r\n            cashInAndClear(true);\r\n        }\r\n    }\r\n    // runs on card select event\r\n    // ask server for gamble result and remaining cards\r\n    // flip picked card\r\n    // runs appropriate function depending on the result\r\n    function cardClicked(id, data) {\r\n        if (!gambleCardsReady) {\r\n            return;\r\n        }\r\n        gambleCardsReady = false;\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'win-gambleNotQuittable',\r\n        });\r\n        pubsub.publish('request:showBottomLeftInfo', {\r\n            text: ''\r\n        });\r\n        transport.getGambleAllCards({\r\n            cardId: data.cardId,\r\n            bet: lastSpinResult.totalWin\r\n        },\r\n        function (result) {\r\n            pubsub.publish('request:gambleInitCards', {\r\n                cards: result.cards\r\n            });\r\n            pubsub.publish('request:gambleFlipCard', {\r\n                cardId: data.cardId,\r\n                mute: true,\r\n            });\r\n            var snd;\r\n            if (result.tie) {\r\n                snd = config.GAMBLE_TIE_SOUND;\r\n            } else if (result.win) {\r\n                snd = config.GAMBLE_WIN_SOUND;\r\n            } else {\r\n                snd = config.GAMBLE_LOSE_SOUND;\r\n            }\r\n            pause.setTimeout(function () {\r\n                pubsub.publish(\"request:playSound\", {\r\n                    sound: snd\r\n                });\r\n            }, 100);\r\n            pause.setTimeout(function () {\r\n                // update the last spin object\r\n                // with current win value according to the result\r\n                lastSpinResult.totalWin = result.win;\r\n                pubsub.publish('notify:spinResultReceived', {\r\n                    result: lastSpinResult\r\n                });\r\n                pubsub.publish('request:showWinningsHeader', {\r\n                    winnings: lastSpinResult.totalWin\r\n                });\r\n                if (result.tie) {\r\n                    runTie(result);\r\n                } else if (result.win) {\r\n                    runWin(result);\r\n                } else {\r\n                    runLose(result);\r\n                }\r\n            }, config.GAMBLE_CARD_FLIP_DURATION);\r\n        });\r\n    }\r\n    // runs when gamble ends\r\n    // resolve current bet model with server\r\n    // start idle or winAmountAnimation activity depending on gamble result\r\n    function cashInAndClear(win) {\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'win-gambleNotQuittable',\r\n        });\r\n        var nextActivity = win ? 'winAmountAnimation' : 'idle';\r\n        transport.endFeature(null, function () {\r\n            transport.endGame(null, function (betModel) {\r\n                pubsub.publish('request:cashIn', {\r\n                    betModel: betModel,\r\n                    callback: function () {\r\n                        currentBottomInfo = '';\r\n                        pubsub.publish('request:showBottomLeftInfo', {\r\n                            text: currentBottomInfo\r\n                        });\r\n                        pubsub.publish('request:clearGambleFrame');\r\n                        pubsub.publish('request:showBackground', {\r\n                            win: win\r\n                        });\r\n                        pubsub.publish('request:resumeWinAnimations');\r\n                        pubsub.publish(\"request:runActivity\", {\r\n                            activity: nextActivity,\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    // API\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: function mHandle(id, data) {\r\n            if (handlers[id]) {\r\n                handlers[id](id, data);\r\n            }\r\n        },\r\n    };\r\n    return API;\r\n    // animate the gamble result - flip cards open and then hidden again\r\n    // then flip the first (reference) card open and allow user to pick next one\r\n    // parameter data specifies the gamble result\r\n    function animateResultThenRunNextGamble(data) {\r\n        pubsub.publish('request:animateGambleResult', {\r\n            gambleAmount: lastSpinResult.totalWin,\r\n            gambleToWin: 2 * lastSpinResult.totalWin,\r\n            flipBack: true\r\n        });\r\n\r\n        pubsub.publish('request:showBottomLeftInfo', {\r\n            text: data.text\r\n        });\r\n        pause.setTimeout(function () {\r\n            if (data.result.finished) {\r\n                pubsub.publish('request:clearButtonAnimations');\r\n                cashInAndClear(true);\r\n            } else {\r\n                pubsub.publish('request:showBottomLeftInfo', {\r\n                    text: ['step', '! ', '!' + data.result.step,\r\n                        '!. ', 'selectCardOrTakeWin']\r\n                });\r\n                pubsub.publish('request:gambleFlipCard', {\r\n                    cardId: 1,\r\n                    card: data.result.card,\r\n                });\r\n                pause.setTimeout(function () {\r\n                    gambleCardsReady = true;\r\n                    pubsub.publish('request:buttonState', {\r\n                        state: 'win-gambleQuittable',\r\n                    });\r\n                }, config.GAMBLE_CARD_FLIP_DURATION);\r\n            }\r\n\r\n        }, config.GAMBLE_CARD_FLIP_DURATION\r\n                + config.GAMBLE_VIEW_PAUSE_DURATION);\r\n    }\r\n\r\n    // runs on tie gamble result\r\n    // animate the result and run next gamble\r\n    function runTie(result) {\r\n        animateResultThenRunNextGamble({\r\n            text: 'forward',\r\n            result: result\r\n        });\r\n    }\r\n    // runs on win gamble result\r\n    // animate the result and run next gamble\r\n    function runWin(result) {\r\n        animateResultThenRunNextGamble({\r\n            text: 'youWin',\r\n            result: result\r\n        });\r\n    }\r\n    // runs on lose gamble result\r\n    // animate the gamble result\r\n    // resolve current bet model with server\r\n    // close gamble and run idle activity\r\n    function runLose(result) {\r\n        pubsub.publish('request:animateGambleResult', {\r\n            gambleAmount: '',\r\n            gambleToWin: '',\r\n            flipBack: false\r\n        });\r\n        pubsub.publish('request:showBottomLeftInfo', {\r\n            text: 'dealerWins'\r\n        });\r\n        pause.setTimeout(function () {\r\n            pubsub.publish('request:clearButtonAnimations');\r\n            cashInAndClear(false);\r\n        }, config.GAMBLE_CARD_FLIP_DURATION\r\n                + config.GAMBLE_VIEW_PAUSE_DURATION);\r\n    }\r\n\r\n\r\n// menu subactivity\r\n    function menuStateChanged(id, state) {\r\n        if (state === 'openEnd') {\r\n            subactivity = 'menu';\r\n            pubsub.publish('notify:subactivityStarted', {activity: 'gamble',\r\n                subactivity: subactivity});\r\n            pubsub.publish('request:showBottomLeftInfo', {\r\n                text: ''\r\n            });\r\n        }\r\n        if (state === 'closeEnd') {\r\n            pubsub.publish('notify:subactivityFinished', {activity: 'gamble',\r\n                subactivity: subactivity});\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-gambleQuittable',\r\n            });\r\n            pubsub.publish('request:showBottomLeftInfo', {\r\n                text: currentBottomInfo\r\n            });\r\n            subactivity = null;\r\n        }\r\n    }\r\n\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/activities/gamble.js"),eval("// free spin activity\r\ndefine('activities/freeSpin',['pubsub',\r\n    'services/transport',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'data/config-reelSet'\r\n], function (\r\n        pubsub, transport, config, symbolSet, reelSet) {\r\n\r\n    var ACTIVITY_NAME = 'freeSpin';\r\n\r\n    // flag defines whether spin is allowed\r\n    var spinStoppable = null;\r\n    // object contains last spin result\r\n    var spinResult = null;\r\n    // stop request flag\r\n    var stopRequested = false;\r\n\r\n    // activity event handlers\r\n    var handlers = {\r\n        'notify:spacePressed': stopClicked,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n        'notify:stopButtonClicked': stopClicked,\r\n        'notify:spinFinished': spinFinished,\r\n    };\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        // clear\r\n        spinResult = null;\r\n        spinStoppable = false;\r\n        stopRequested = false;\r\n\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'spin-basicSpin'\r\n        });\r\n        pubsub.publish('request:clearWinAnimations');\r\n        if (data.gameModel.lastSpinResult.totalWin > 0) {\r\n            // display total free spin win until now\r\n            pubsub.publish('request:showWinningsHeader', {\r\n                winnings: data.gameModel.lastSpinResult.totalWin});\r\n        }\r\n        // display bottom text with current spin info\r\n        var bottomText = ['freeGame', '! ', '!' + data.options.freeSpinNumber,\r\n            '! ', 'of', '! ', '!' + data.options.freeSpinsTotal];\r\n        pubsub.publish('request:showBottomRightInfo', {text: bottomText, bigFont: true});\r\n        // run spin\r\n        pubsub.publish('request:spinReels');\r\n        // ask server for free spin result\r\n        transport.getFreeSpinResult(null, function (result) {\r\n            spinResult = result.setup;\r\n            spinStoppable = true;\r\n            pubsub.publish('notify:spinResultReceived', {\r\n                result: result\r\n            });\r\n            pubsub.publish('request:stopReels', {setup: result.setup});\r\n            if (stopRequested) {\r\n                stopSpin();\r\n            }\r\n        });\r\n    }\r\n    function stopClicked() {\r\n        stopRequested = true;\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'spin-spinNotStoppable'\r\n        });\r\n        if (spinStoppable) {\r\n            stopSpin.apply(null, arguments);\r\n        }\r\n    }\r\n\r\n    // user made a stop request\r\n    function stopSpin(id, data) {\r\n        spinStoppable = false;\r\n        if (!data || !data.silent) {\r\n            pubsub.publish(\"request:playSound\", {sound: config.BUTTON_CLICK_SOUND});\r\n        }\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'spin-spinNotStoppable'\r\n        });\r\n        pubsub.publish('request:forceStopReels');\r\n    }\r\n\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        if (data.click) {\r\n            stopClicked(id, {silent: true});\r\n        }\r\n    }\r\n\r\n\r\n    // spin has finished\r\n    // display a win pause activity depeding on the result\r\n    function spinFinished() {\r\n        pubsub.publish('request:clearFastReelAnimations');\r\n        if (Object.keys(spinResult.ws).length !== 0) {\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'freeSpinWin'\r\n            });\r\n        } else {\r\n            pubsub.publish(\"request:runActivity\", {\r\n                activity: 'freeSpinPause'\r\n            });\r\n        }\r\n    }\r\n\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n});\n//# sourceURL=/modules/Type2/src/js/activities/freeSpin.js"),
eval("// free spin win activity\r\n// runs when user wins credits in free spin activity\r\ndefine('activities/freeSpinWin',[\r\n    'jquery',\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'services/pause',\r\n    'services/platform',\r\n], function (\r\n        $, pubsub, config, symbolSet, pause, platform) {\r\n\r\n    var ACTIVITY_NAME = 'freeSpinWin';\r\n    // refernce to last spin result\r\n    var lastSpinResult = null;\r\n    // flag specifies whether the game is ready for next spin\r\n    var spinAvailable = null;\r\n\r\n    // event handlers\r\n    var handlers = {\r\n        'notify:spinButtonClicked': runSpinWithSound,\r\n        'notify:spacePressed': runSpin,\r\n        'notify:reelSurfaceTouchEnd': reelSurfaceTouchEnd,\r\n    };\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    // runs on start\r\n    function mStart(data) {\r\n        // clear\r\n        spinAvailable = false;\r\n        lastSpinResult = $.extend({}, data.gameModel.lastSpinResult, true);\r\n        // disable the buttons\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'win-beforeWin'\r\n        });\r\n        // run win animations\r\n        if (lastSpinResult.freeSpinsAdditional) {\r\n            // user has won additional free spins\r\n            pubsub.publish('request:runWinAnimations', {\r\n                betModel: data.betModel,\r\n                spinResult: lastSpinResult,\r\n                showFirstWinLineAsLast: true,\r\n                symbolSet: symbolSet.FREE_SPIN,\r\n                freeGame: true,\r\n                freeSpinsWon: true,\r\n                firstViewDuration: config.FREE_GAME_WIN_LINES_FIRST_VIEW_DURATION,\r\n                doNotShowWinnings: lastSpinResult.totalWin === 0,\r\n                firstPassCallback: function () {\r\n                    // win animations finished\r\n                    pubsub.publish('request:buttonState', {\r\n                        state: 'freeSpinBanner-notSpinnable'\r\n                    });\r\n                    clearEffects();\r\n                    if (config.HIDE_WINNINGS_ON_FG_BANNER) {\r\n                        pubsub.publish('request:hideWinningsHeader');\r\n                    }\r\n                    pubsub.publish('request:showFreeSpinAdditionalBanner', {\r\n                        lastSpinResult: lastSpinResult,\r\n                    });\r\n                    pause.setTimeout(function () {\r\n                        pubsub.publish('request:clearFreeSpinBanner');\r\n                        spinAvailable = true;\r\n                        runSpin();\r\n                    }, config.FREE_SPIN_ADDITIONAL_WIN_PAUSE_DURATION);\r\n                }\r\n            });\r\n        } else {\r\n            // user has not won additional free spins\r\n            pubsub.publish('request:runWinAnimations', {\r\n                betModel: data.betModel,\r\n                spinResult: lastSpinResult,\r\n                showFirstWinLineAsLast: false,\r\n                symbolSet: symbolSet.FREE_SPIN,\r\n                freeGame: true,\r\n                firstViewDuration: config.FREE_GAME_WIN_LINES_FIRST_VIEW_DURATION,\r\n                firstViewCallback: function () {\r\n                    // enable the buttons\r\n                    spinAvailable = true;\r\n                    pubsub.publish('request:buttonState', {\r\n                        state: 'win-freeSpin'\r\n                    });\r\n                },\r\n                firstPassCallback: function () {\r\n                    // win animations finished\r\n                    if (spinAvailable) {\r\n                        // if there was not a force spin request\r\n                        // run freeSpin if there are spins left\r\n                        // or run freeSpinOver activity if not\r\n                        clearEffects();\r\n                        pause.setTimeout(function () {\r\n                            if (spinAvailable) {\r\n                                if (lastSpinResult.freeSpinsRemaining > 0) {\r\n                                    pubsub.publish(\"request:runActivity\", {\r\n                                        activity: 'freeSpin',\r\n                                        options: {\r\n                                            freeSpinNumber: lastSpinResult.freeSpinNumber + 1,\r\n                                            freeSpinsTotal: lastSpinResult.freeSpins\r\n                                        }\r\n                                    });\r\n                                } else {\r\n                                    pubsub.publish(\"request:runActivity\", {\r\n                                        activity: 'freeSpinOver',\r\n                                    });\r\n                                }\r\n                            }\r\n                        }, config.FREE_SPIN_AFTER_WIN_PREVIEW_PAUSE_DURATION);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // spin button clicked -> cancel winning sounds, play click sound and run spin\r\n    function runSpinWithSound(id, data) {\r\n        if (spinAvailable) {\r\n            // ref: use event\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            pubsub.publish(\"request:playSound\", {sound: config.BUTTON_CLICK_SOUND});\r\n            spin();\r\n        }\r\n    }\r\n    // spin requested -> cancel winning sounds and run spin\r\n    function runSpin(id, data) {\r\n        if (spinAvailable) {\r\n            pubsub.publish(\"request:stopSoundEffects\")\r\n            spin();\r\n        }\r\n    }\r\n    function reelSurfaceTouchEnd(id, data) {\r\n        if (data.click) {\r\n            runSpin(id, data);\r\n        }\r\n    }\r\n\r\n    // run next freeSpin activity if there are spins remaining\r\n    // run freeSpinOver activity if not\r\n    function spin(id, data) {\r\n        if (spinAvailable) {\r\n            spinAvailable = false;\r\n            clearEffects();\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'spin-spinNotStoppable'\r\n            });\r\n            pause.setTimeout(function () {\r\n                if (lastSpinResult.freeSpinsRemaining > 0) {\r\n                    pubsub.publish(\"request:runActivity\", {\r\n                        activity: 'freeSpin',\r\n                        options: {\r\n                            freeSpinNumber: lastSpinResult.freeSpinNumber + 1,\r\n                            freeSpinsTotal: lastSpinResult.freeSpins\r\n                        }\r\n                    });\r\n                } else {\r\n                    pubsub.publish(\"request:runActivity\", {\r\n                        activity: 'freeSpinOver',\r\n                    });\r\n                }\r\n            }, config.BEFORE_FORCE_SPIN_PAUSE);\r\n        }\r\n    }\r\n\r\n    // clear win animations and refresh reels\r\n    function clearEffects() {\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME, start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n\r\n});\n//# sourceURL=/modules/Type2/src/js/activities/freeSpinWin.js"),eval("// free spin pause activity\r\n// runs between two free spins when the user has not won credits in last spin\r\ndefine('activities/freeSpinPause',[\r\n    'pubsub',\r\n    'services/pause',\r\n    'data/config',\r\n], function (\r\n        pubsub, pause, config) {\r\n\r\n    var ACTIVITY_NAME = 'freeSpinPause';\r\n\r\n    // runs on start\r\n    // after a delay it either:\r\n    // - starts a freeSpin activity if user has remaining free spins\r\n    // - starts freeSpinOver acitivity if there are no free spin left\r\n    function mStart(data) {\r\n        pause.setTimeout(function () {\r\n            if (data.gameModel.lastSpinResult.freeSpinsRemaining > 0) {\r\n                pubsub.publish(\"request:runActivity\", {\r\n                    activity: 'freeSpin',\r\n                    options: {\r\n                        freeSpinNumber: data.gameModel.lastSpinResult.freeSpinNumber + 1,\r\n                        freeSpinsTotal: data.gameModel.lastSpinResult.freeSpins\r\n                    }\r\n                });\r\n            } else {\r\n                pubsub.publish(\"request:runActivity\", {\r\n                    activity: 'freeSpinOver'\r\n                });\r\n            }\r\n        }, config.FREE_SPIN_NO_WIN_PAUSE_DURATION);\r\n\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: function () {\r\n        },\r\n    };\r\n\r\n    return API;\r\n});\n//# sourceURL=/modules/Type2/src/js/activities/freeSpinPause.js"),eval("// free spin intro activity\r\n// runs after a spin activity in which the user wins free spins\r\ndefine('activities/freeSpinIntro',[\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'data/config-reelSet',\r\n    'services/pause',\r\n    'services/transport',\r\n], function (pubsub, config, symbolSet, reelSet,\r\n        pause, transport) {\r\n\r\n    var ACTIVITY_NAME = 'freeSpinIntro';\r\n    // flag specifies whether the game is ready for spin\r\n    var spinAvailable = null;\r\n    // object references the last spin result (spin that led to free game)\r\n    var lastSpinResult = null;\r\n\r\n    // event handlers\r\n    var handlers = {\r\n        'notify:spinButtonClicked': runSpinWithSound,\r\n        'notify:spacePressed': runSpin,\r\n    };\r\n\r\n    // runs on activity start\r\n    function mStart(data) {\r\n        // clear\r\n        spinAvailable = false;\r\n        pubsub.publish('request:hideBottomRightText');\r\n\r\n        lastSpinResult = data.gameModel.lastSpinResult;\r\n\r\n        if (data.options.resumeData) {\r\n            displayIntroBanner(function () {\r\n                onGameInitialized(data.options.resumeData.fgInitData);\r\n            }, true);\r\n        } else {\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-wonFreeSpins'\r\n            });\r\n            // request win animations for the previous spin\r\n            pubsub.publish('request:runWinAnimations', {\r\n                betModel: data.betModel,\r\n                spinResult: lastSpinResult,\r\n                freeSpinsWon: true,\r\n                showFirstWinLineAsLast: true,\r\n                symbolSet: symbolSet.SPIN,\r\n                firstViewDuration: config.WIN_LINES_FIRST_VIEW_DURATION,\r\n                doNotShowWinnings: lastSpinResult.totalWin === 0,\r\n                firstPassCallback: function () {\r\n                    displayIntroBanner(function () {\r\n                        transport.getFreeSpinInit(null, onGameInitialized);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    function displayIntroBanner(callback, isResuming) {\r\n        if (config.HIDE_WINNINGS_ON_FG_BANNER) {\r\n            pubsub.publish('request:hideWinningsHeader');\r\n            pubsub.publish('request:showBackground', {\r\n                freeSpin: true,\r\n                win: false\r\n            });\r\n        } else {\r\n            pubsub.publish('request:showWinningsHeader', {\r\n                winnings: lastSpinResult.totalWin});\r\n            pubsub.publish('request:showBackground', {\r\n                freeSpin: true,\r\n                win: true\r\n            });\r\n        }\r\n        pubsub.publish('request:refreshReelsView');\r\n        pubsub.publish('request:clearWinAnimations');\r\n\r\n        // hide animations and display free spin intro banner\r\n        pubsub.publish('request:setBackgroundSound', {\r\n            sound: config.FREE_GAME_SPIN_SOUND\r\n        });\r\n        pubsub.publish(\"request:stopSound\", {\r\n            sound: config.BACKGROUND_SOUND\r\n        });\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'freeSpinBanner-notSpinnable'\r\n        });\r\n        pubsub.publish('request:showFreeSpinBanner', {\r\n            lastSpinResult: lastSpinResult,\r\n            isResuming: isResuming,\r\n            callback: callback\r\n        });\r\n    }\r\n\r\n\r\n    function onGameInitialized(result) {\r\n        spinAvailable = true;\r\n        // initialize the free spin reels\r\n        pubsub.publish('request:initReels', {\r\n            slideInPrevious: true,\r\n            reelSet: reelSet.BASE,\r\n            symbolSet: symbolSet.FREE_SPIN,\r\n            soundData: config.FREE_SPIN_SOUND_DATA,\r\n            stripes: result.stripes,\r\n        });\r\n        // enable spin button\r\n        pubsub.publish('request:buttonState', {\r\n            state: 'freeSpinBanner-spinnable'\r\n        });\r\n    }\r\n\r\n    // spin button clicked\r\n    // run spin with button click sound\r\n    function runSpinWithSound() {\r\n        if (spinAvailable) {\r\n            pubsub.publish(\"request:playSound\", {sound: config.BUTTON_CLICK_SOUND});\r\n            runSpin();\r\n        }\r\n    }\r\n    // spin request was issued\r\n    // run free spin activity\r\n    function runSpin() {\r\n        if (spinAvailable) {\r\n            spinAvailable = false;\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'freeSpinBanner-notSpinnable'\r\n            });\r\n            pubsub.publish('request:clearFreeSpinBanner');\r\n            pubsub.publish('request:showBackground', {\r\n                freeSpin: true,\r\n                win: true\r\n            });\r\n            pause.setTimeout(function () {\r\n                // ref: as an event\r\n                pubsub.publish(\"request:runActivity\", {\r\n                    activity: 'freeSpin',\r\n                    options: {\r\n                        freeSpinNumber: lastSpinResult.freeSpinNumber + 1,\r\n                        freeSpinsTotal: lastSpinResult.freeSpins\r\n                    }\r\n                });\r\n            }, config.BEFORE_FREE_SPINS_START_PAUSE);\r\n\r\n        }\r\n    }\r\n\r\n    function mHandle(id, data) {\r\n        if (handlers[id]) {\r\n            handlers[id](id, data);\r\n        }\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: mHandle,\r\n    };\r\n\r\n    return API;\r\n});\n//# sourceURL=/modules/Type2/src/js/activities/freeSpinIntro.js"),eval("// free spin over activity\r\n// runs when free spin finishes\r\ndefine('activities/freeSpinOver',[\r\n    'pubsub',\r\n    'data/config',\r\n    'data/config-symbolSet',\r\n    'data/config-reelSet',\r\n    'services/transport',\r\n    'services/pause',\r\n], function (pubsub, config, symbolSet, reelSet, transport, pause) {\r\n\r\n    var ACTIVITY_NAME = 'freeSpinOver';\r\n\r\n    // runs on start\r\n    // display free spin banner with total win\r\n    // ask server for standard spin init data\r\n    // run win activity after a timeout\r\n    function mStart(data) {\r\n\r\n        function afterBannerShown() {\r\n            pubsub.publish('request:clearFreeSpin');\r\n            pubsub.publish('request:initReels', {\r\n                slideInPrevious: true,\r\n                reelSet: reelSet.BASE,\r\n                symbolSet: symbolSet.SPIN,\r\n                soundData: config.BASIC_SPIN_SOUND_DATA,\r\n                stripes: data.gameModel.startupData.stripes,\r\n            });\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-beforeWin'\r\n            });\r\n            pubsub.publish('request:showReelFrameOverLay');\r\n\r\n            pubsub.publish('request:showBackground', {win: true});\r\n            pubsub.publish('request:showWinningsHeader', {\r\n                winnings: data.gameModel.lastSpinResult.totalWin,\r\n            });\r\n            pubsub.publish('request:setBackgroundSound', {\r\n                sound: config.BACKGROUND_SOUND\r\n            });\r\n            if (data.gameModel.lastSpinResult.totalWin === 0) {\r\n                transport.endFeature(null, function () {\r\n                    transport.endGame(null, function (betModel) {\r\n                        pubsub.publish('request:cashIn', {\r\n                            betModel: betModel,\r\n                            callback: function () {\r\n                                pubsub.publish('request:hideWinningsHeader');\r\n                                pubsub.publish(\"request:runActivity\", {\r\n                                    activity: 'idle',\r\n                                });\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n            } else {\r\n                transport.endFeature(null, function () {\r\n                    pubsub.publish(\"request:runActivity\", {\r\n                        activity: 'win',\r\n                        options: {\r\n                            noAnimations: true\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n\r\n        if (data.options.resumeData) {\r\n\r\n            afterBannerShown();\r\n\r\n        } else {\r\n\r\n            pubsub.publish('request:buttonState', {\r\n                state: 'win-beforeWin'\r\n            });\r\n            pubsub.publish('request:refreshReelsView');\r\n            pubsub.publish('request:clearWinAnimations');\r\n            if (config.HIDE_WINNINGS_ON_FG_BANNER) {\r\n                pubsub.publish('request:hideWinningsHeader');\r\n            }\r\n            pubsub.publish('request:showFreeSpinOverBanner',\r\n                    data.gameModel.lastSpinResult);\r\n            pubsub.publish(\"request:stopSound\", {\r\n                sound: config.FREE_GAME_SPIN_SOUND\r\n            });\r\n            pause.setTimeout(afterBannerShown, config.FREE_GAME_OUTRO_DELAY);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    var API = {\r\n        name: ACTIVITY_NAME,\r\n        start: mStart,\r\n        handle: function () {\r\n        },\r\n    };\r\n\r\n    return API;\r\n});\n//# sourceURL=/modules/Type2/src/js/activities/freeSpinOver.js"),eval("define('components/CycleButton',[\r\n    'pixi',\r\n    'components/Element',\r\n    'components/Sprite',\r\n    'components/SpriteSheetButton',\r\n    'services/pause',\r\n    'components/Text',\r\n], function (\r\n        PIXI, Element, Sprite, SpriteSheetButtton,\r\n        pause, Text) {\r\n\r\n    // cycle button allows the user to cycle between multiple values\r\n    // used in game menu\r\n    return function create(options) {\r\n        // initialize\r\n        var self = Element(options);\r\n        self.name = options.name || 'CycleButton';\r\n        self.items = options.items;\r\n        self.prefix = options.prefix;\r\n        self.suffix = options.suffix;\r\n        self.selectedItem = options.selectedItem || 0;\r\n        self.onChange = options.onChange;\r\n        self.fontSize = options.fontSize;\r\n        self.color = options.color;\r\n        self.textOffsetTop = options.textOffsetTop;\r\n        self.style = options.style;\r\n        var buttonSize = self.height - 6;\r\n\r\n        // left button element\r\n        var buttonLeft = SpriteSheetButtton({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-button-left',\r\n            imgPath: 'menu/cycle-button-sheet',\r\n            left: self.left + 3.5,\r\n            top: self.top + 2.5,\r\n            width: buttonSize,\r\n            height: buttonSize,\r\n            upSprite: 0,\r\n            hoverSprite: 1,\r\n            downSprite: 2,\r\n            disabledSprite: 3,\r\n            steps: 4,\r\n            click: leftClicked,\r\n            hitAreaAdjustment: {\r\n                right: true,\r\n                top: true,\r\n                bottom: true,\r\n            },\r\n            zIndex: self.zIndex + 0.1,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // right button element\r\n        var buttonRight = SpriteSheetButtton({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-button-right',\r\n            imgPath: 'menu/cycle-button-sheet',\r\n            left: self.left + self.width - buttonSize - 3,\r\n            top: self.top + 2.5,\r\n            width: buttonSize,\r\n            height: buttonSize,\r\n            upSprite: 0,\r\n            hoverSprite: 1,\r\n            downSprite: 2,\r\n            disabledSprite: 3,\r\n            steps: 4,\r\n            flipX: true,\r\n            click: rightClicked,\r\n            hitAreaAdjustment: {\r\n                left: true,\r\n                right: true,\r\n                top: true,\r\n                bottom: true\r\n            },\r\n            zIndex: self.zIndex + 0.1,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // background element\r\n        var back = Sprite({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-back',\r\n            imgPath: 'menu/holder',\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            zIndex: self.zIndex,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // main text element\r\n        var text = Text({\r\n            name: self.name + '-text',\r\n            parent: self.parent,\r\n            groupCtrl: self.groupCtrl,\r\n            left: self.left + self.width / 2,\r\n            top: self.top + self.textOffsetTop,\r\n            color: self.color,\r\n            text: '',\r\n            fontSize: self.fontSize,\r\n            style: self.style,\r\n            zIndex: self.zIndex + 0.1,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n\r\n        // additional (suffix or prefix) text element\r\n        var additionalText = null;\r\n        if (self.suffix || self.prefix) {\r\n            var str = self.suffix || self.prefix;\r\n            additionalText = Text({\r\n                name: self.name + '-add-text',\r\n                parent: self.parent,\r\n                groupCtrl: self.groupCtrl,\r\n                left: self.left + self.width / 2,\r\n                top: self.top + self.textOffsetTop,\r\n                color: self.color,\r\n                text: str,\r\n                fontSize: self.fontSize,\r\n                style: self.style,\r\n                zIndex: self.zIndex + 0.1,\r\n                canvasLayer: self.canvasLayer,\r\n            });\r\n            resizeText();\r\n        }\r\n\r\n        self.pixiEl = [back, buttonLeft, buttonRight, text];\r\n        if (additionalText) {\r\n            self.pixiEl.push(additionalText);\r\n        }\r\n        // set current selected index and refresh view\r\n        self.setSelectedIndex = function (index) {\r\n            self.selectedItem = index;\r\n            refreshView();\r\n        };\r\n\r\n        var superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            superShow.apply(null, arguments);\r\n            refreshView();\r\n        };\r\n\r\n\r\n        refreshView();\r\n        return self;\r\n\r\n        // left button click handler\r\n        function leftClicked() {\r\n            self.selectedItem -= 1;\r\n            if (self.selectedItem < 0) {\r\n                self.selectedItem = self.items.length - 1;\r\n            }\r\n            refreshView();\r\n            self.onChange(self.selectedItem);\r\n        }\r\n        // right button click handler\r\n        function rightClicked() {\r\n            self.selectedItem += 1;\r\n            if (self.selectedItem > self.items.length - 1) {\r\n                self.selectedItem = 0;\r\n            }\r\n            refreshView();\r\n            self.onChange(self.selectedItem);\r\n        }\r\n        // update view state\r\n        function refreshView() {\r\n            text.setText(self.items[self.selectedItem]);\r\n            resizeText();\r\n        }\r\n        // update text position\r\n        function resizeText() {\r\n            return;\r\n            function run() {\r\n                if (text.width) {\r\n                    // custom text\r\n//                    if (additionalText) {\r\n//                        var textWidth = text.width\r\n//                                * dimensions.scaleX;\r\n//                        var addTextWidth = additionalText.width\r\n//                                * dimensions.scaleX;\r\n//                        var totalWidth = textWidth + addTextWidth;\r\n//                        var center = self.left + (self.width) / 2;\r\n//                        if (self.prefix) {\r\n//                            additionalText.left = center - totalWidth / 2;\r\n//                            text.left = additionalText.left + addTextWidth;\r\n//                        } else if (self.suffix) {\r\n//                            text.left = center - totalWidth / 2;\r\n//                            additionalText.left = text.left + textWidth + 3;\r\n//                        }\r\n//                        text.resize();\r\n//                        additionalText.resize();\r\n//                    } else {\r\n//                        var center = self.left + self.width / 2;\r\n//                        text.left = center - (text.width * dimensions.scaleX) / 2;\r\n//                        text.resize();\r\n//                    }\r\n                } else if (text.pixiEl instanceof PIXI.extras.BitmapText) {\r\n                    // pixi BitmapText\r\n                    if (additionalText) {\r\n                        var textWidth = text.pixiEl.width;\r\n                        var addTextWidth = additionalText.pixiEl.width;\r\n                        var totalWidth = textWidth + addTextWidth;\r\n                        var center = self.left + (self.width) / 2;\r\n                        if (self.prefix) {\r\n                            additionalText.left = center - totalWidth / 2;\r\n                            text.left = additionalText.left + addTextWidth;\r\n                            text.left -= 2.9;\r\n                        } else if (self.suffix) {\r\n                            text.left = center - totalWidth / 2;\r\n                            additionalText.left = text.left + textWidth + 3;\r\n                            text.left += 2.9;\r\n                        }\r\n                        text.resize();\r\n                        additionalText.resize();\r\n                    } else {\r\n                        var center = self.left + self.width / 2;\r\n                        text.left = center - ((text.pixiEl.width)) / 2;\r\n                        text.left += 2.9;\r\n                        text.resize();\r\n                    }\r\n                } else {\r\n                    // pixi text\r\n                    if (additionalText) {\r\n                        var textWidth = text.pixiEl.width;\r\n                        var addTextWidth = additionalText.pixiEl.width;\r\n                        var totalWidth = textWidth + addTextWidth;\r\n                        var center = self.left + (self.width) / 2;\r\n                        if (self.prefix) {\r\n                            additionalText.left = center - totalWidth / 2;\r\n                            text.left = additionalText.left + addTextWidth;\r\n                        } else if (self.suffix) {\r\n                            text.left = center - totalWidth / 2;\r\n                            additionalText.left = text.left + textWidth + 3;\r\n                        }\r\n                        text.resize();\r\n                        additionalText.resize();\r\n                    } else {\r\n                        var center = self.left + self.width / 2;\r\n                        text.left = center - ((text.pixiEl.width)) / 2\r\n                        text.resize();\r\n                    }\r\n                }\r\n            }\r\n            pause.setTimeout(run, 0);\r\n            pause.setTimeout(run, 50);\r\n            pause.setTimeout(run, 100);\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/CycleButton.js"),eval("define('components/DraggableSprite',[\r\n    'pixi',\r\n    'pubsub',\r\n    'components/Element',\r\n    'services/assets',\r\n    'services/dimensions',\r\n], function (\r\n        PIXI, pubsub, Element, assets, dimensions) {\r\n    return function create(options) {\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'DraggableSprite';\r\n        // the draggable image path\r\n        self.imgPath = options.imgPath;\r\n        // min left px position\r\n        self.minLeft = options.minLeft;\r\n        // max left px position\r\n        self.maxLeft = options.maxLeft;\r\n        // events\r\n        self.onDrag = options.onDrag;\r\n        self.onDragStart = options.onDragStart;\r\n        self.onDragEnd = options.onDragEnd;\r\n        self.click = options.click;\r\n        // current slide value\r\n        self.value = options.value || 0;\r\n        self.roundPercent = options.roundPercent;\r\n        self.disablePainting = options.disablePainting;\r\n        self.disabled = options.disabled;\r\n        self.disabledOpacity = options.disabledOpacity || .5;\r\n\r\n        // create PIXI element\r\n        var el = new PIXI.Sprite(assets.img(self.imgPath));\r\n        el.wrapper = self;\r\n        self.pixiEl = el;\r\n\r\n        // flag specifies whether the element is being dragged\r\n        var dragging = false;\r\n        // value when drag started\r\n        var dragStartValue = null;\r\n        var dragPositionOffset = null;\r\n\r\n        // setup event handlers\r\n        el.interactive = true;\r\n        el.click = self.click;\r\n        el.mouseover = function () {\r\n            pubsub.publish('notify:hoverableButtonHoveredIn', {\r\n                element: self\r\n            });\r\n        };\r\n        el.mouseout = function () {\r\n            pubsub.publish('notify:hoverableButtonHoveredOut', {\r\n                element: self\r\n            });\r\n        };\r\n        el.mousedown = function (e) {\r\n            if (!self.disabled) {\r\n                dragPositionOffset = getRealX(e.data) - self.left;\r\n                self.value = 100 * (((self.left)\r\n                        - self.minLeft) / (self.maxLeft - self.minLeft));\r\n                dragStartValue = self.value;\r\n                dragging = true;\r\n                self.onDragStart && self.onDragStart(self.value);\r\n            }\r\n        };\r\n        el.mouseup = function (interactionData) {\r\n            if (!self.disabled) {\r\n                dragging = false;\r\n                self.onDragEnd && self.onDragEnd(self.value);\r\n            }\r\n        };\r\n        el.mousemove = function (e) {\r\n            if (dragging) {\r\n                var x = getRealX(e.data);\r\n                x -= dragPositionOffset;\r\n                if (x < self.minLeft) {\r\n                    x = self.minLeft;\r\n                } else if (x > self.maxLeft) {\r\n                    x = self.maxLeft;\r\n                }\r\n                self.value = 100 * ((x - self.minLeft) / (self.maxLeft - self.minLeft));\r\n                self.roundPercent && (self.value = Math.round(self.value));\r\n                if (!self.disablePainting) {\r\n                    self.left = x;\r\n                    self.resize();\r\n                }\r\n                self.onDrag(self.value);\r\n            }\r\n        };\r\n        el.tap = el.click;\r\n        el.touchstart = el.mousedown;\r\n        el.mouseupoutside = el.mouseup;\r\n        el.touchend = el.mouseup;\r\n        el.touchendoutside = el.mouseup;\r\n        el.touchmove = el.mousemove;\r\n\r\n        // set current value and adjust postition\r\n        self.setValue = function (newVal) {\r\n            self.value = newVal;\r\n            if (!self.disablePainting) {\r\n                self.left = (self.minLeft + (self.value / 100) * (self.maxLeft - self.minLeft));\r\n            }\r\n        };\r\n        self.setDisabled = function (val) {\r\n            if (self.disabled !== val) {\r\n                self.disabled = val;\r\n                if (self.disabled) {\r\n                    self.currentOpacity = self.opacity;\r\n                    self.set({\r\n                        opacity: self.disabledOpacity\r\n                    });\r\n                } else {\r\n                    self.set({\r\n                        opacity: self.currentOpacity || 1\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        self.resize();\r\n\r\n        return self;\r\n\r\n        function getRealX(interactionData) {\r\n            return interactionData.global.x - dimensions.topLevelWrappersOffsetX /\r\n                    dimensions.canvasScaleX;\r\n        }\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/DraggableSprite.js"),
eval("define('components/BigFlipSwitch',['components/Element',\r\n    'components/Sprite',\r\n    'components/SpriteSheetButton',\r\n    'components/Text',\r\n    'data/config',\r\n], function (\r\n        Element, Sprite, SpriteSheetButtton, Text, globalConfig) {\r\n\r\n// FlipSwitch element with ON-OFF options\r\n    return function create(options) {\r\n        var self = Element(options);\r\n        self.name = options.name || 'BigFlipSwitch';\r\n//        self.height = options.height;\r\n//        self.width = options.width;\r\n        self.onText = options.onText;\r\n        self.offText = options.offText;\r\n        self.isOn = options.onState;\r\n        self.fontSize = options.fontSize;\r\n        self.textColor = options.textColor;\r\n        self.textOffsetTop = options.textOffsetTop;\r\n        self.fontStyle = options.fontStyle;\r\n        // on change event handler\r\n        self.onChange = options.onChange;\r\n\r\n        self.buttonWidth = options.buttonWidth;\r\n        self.buttonHeight = options.buttonHeight;\r\n        self.buttonOffsetTop = options.buttonOffsetTop;\r\n        self.buttonOffsetLeftOn = options.buttonOffsetLeftOn;\r\n        self.buttonOffsetLeftOff = options.buttonOffsetLeftOff;\r\n\r\n        var textLeft = self.left + self.width / 2;\r\n\r\n        // inner button element\r\n        var button = Sprite({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-button',\r\n            imgPath: 'menu/radio',\r\n            left: self.left,\r\n            top: self.top + self.buttonOffsetTop,\r\n            width: self.buttonWidth,\r\n            height: self.buttonHeight,\r\n            zIndex: self.zIndex + 0.2,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // background element\r\n        var back = Sprite({\r\n            groupCtrl: self.groupCtrl,\r\n            parent: self.parent,\r\n            name: self.name + '-back',\r\n            imgPath: 'menu/holder',\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            click: self.onChange,\r\n            hitAreaAdjustment: {\r\n                left: true,\r\n                right: true,\r\n            },\r\n            zIndex: self.zIndex,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // ON text element\r\n        var onText = Text({\r\n            name: self.name + '-on-text',\r\n            parent: self.parent,\r\n            groupCtrl: self.groupCtrl,\r\n            left: textLeft,\r\n            top: self.top + self.textOffsetTop,\r\n            color: self.textColor,\r\n            text: self.onText,\r\n            fontSize: self.fontSize,\r\n            zIndex: self.zIndex + 0.1,\r\n            originX: 'center',\r\n            style: self.fontStyle,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n        // OFF text element\r\n        var offText = Text({\r\n            name: self.name + '-off-text',\r\n            parent: self.parent,\r\n            groupCtrl: self.groupCtrl,\r\n            left: textLeft,\r\n            top: self.top + self.textOffsetTop,\r\n            text: self.offText,\r\n            fontSize: self.fontSize,\r\n            originX: 'center',\r\n            zIndex: self.zIndex + 0.1,\r\n            style: self.fontStyle,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n\r\n        self.pixiEl = [\r\n            back,\r\n            button,\r\n            onText, offText\r\n        ];\r\n\r\n        // set current ON/OFF state\r\n        self.setOnState = function (state) {\r\n            self.isOn = state;\r\n            refreshView();\r\n        };\r\n\r\n        var superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            superShow.apply(null, arguments);\r\n            refreshView();\r\n        };\r\n\r\n        refreshView();\r\n\r\n        return self;\r\n\r\n        // update inner button position to represent current ON/OFF value\r\n        function refreshView() {\r\n            if (self.visible) {\r\n                onText.hide();\r\n                offText.hide();\r\n                if (self.isOn) {\r\n                    button.left = self.left + self.buttonOffsetLeftOn;\r\n                    onText.show();\r\n                } else {\r\n                    button.left = self.left + self.buttonOffsetLeftOff;\r\n                    offText.show();\r\n                }\r\n                button.resize();\r\n            }\r\n        }\r\n\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/BigFlipSwitch.js"),eval("define('components/Line',['components/Element', 'pixi', 'services/dimensions'],\r\n        function (Element, PIXI, dimensions) {\r\n            return function create(options) {\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'Line';\r\n                self.color = options.color;\r\n                self.strokeThickness = options.strokeThickness || 1;\r\n\r\n                var el = new PIXI.Graphics();\r\n                el.beginFill(self.color);\r\n                el.lineStyle(self.strokeThickness, self.color);\r\n                el.moveTo(0, 0);\r\n                if (!self.width) {\r\n                    el.lineTo(0, self.height);\r\n                    self.width = self.strokeThickness;\r\n                }\r\n                else if (!self.height) {\r\n                    el.lineTo(self.width, 0);\r\n                    self.height = self.strokeThickness;\r\n                }\r\n                el.endFill();\r\n\r\n                el.wrapper = self;\r\n                self.pixiEl = el;\r\n\r\n\r\n//                self.resize = function () {\r\n//                    function getParentOffset(el) {\r\n//                        var off = {\r\n//                            left: 0,\r\n//                            top: 0\r\n//                        };\r\n//                        while (el.parent) {\r\n//                            off.left += el.parent.left;\r\n//                            off.top += el.parent.top;\r\n//                            el = el.parent;\r\n//                        }\r\n//                        return off;\r\n//                    }\r\n//                    // update position\r\n//                    var parentsOffset = getParentOffset(el);\r\n//                    el.x = parentsOffset.left + self.left;\r\n//                    el.y = parentsOffset.top + self.top;\r\n//\r\n//\r\n//                };\r\n\r\n\r\n                return self;\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/Line.js"),eval("define('components/ReelSymbolAnimationWithCrossfade',[\r\n    'components/Element',\r\n    'components/SpriteSheetAnimation',\r\n    'components/ReelSymbolCrossfade'\r\n], function (\r\n        Element, SpriteSheetAnimation, ReelSymbolCrossfade) {\r\n\r\n    // reel symbol animation running single sprite sheet cycle\r\n    // and then crossfading between two images\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n\r\n        self.name = options.name || 'ReelSymbolAnimationWithCrossafade';\r\n        self.animationStartPath = options.animationStartPath;\r\n        self.animationCyclePathFrom = options.animationCyclePathFrom;\r\n        self.animationCyclePathTo = options.animationCyclePathTo;\r\n        self.zIndex = options.zIndex;\r\n        self.spriteOffset = options.spriteOffset;\r\n        self.borderImgPath = options.borderImg;\r\n        self.backImgPath = options.backImg;\r\n        self.offsets = options.offsets;\r\n\r\n        var heights = {\r\n            start: null,\r\n            border: null,\r\n        };\r\n        var widths = {\r\n            start: null,\r\n            border: null,\r\n        };\r\n        var offsets = {\r\n            start: {x: 0, y: 0},\r\n        };\r\n\r\n        if (typeof (self.height) === 'object') {\r\n            heights.start = self.height[self.animationStartPath];\r\n            heights.border = self.height[self.animationCyclePathFrom];\r\n        } else {\r\n            heights.start = self.height;\r\n            heights.border = self.height;\r\n        }\r\n\r\n        if (typeof (self.width) === 'object') {\r\n            widths.start = self.width[self.animationStartPath];\r\n            widths.border = self.width[self.animationCyclePathFrom];\r\n        } else {\r\n            widths.start = self.width;\r\n            widths.border = self.width;\r\n        }\r\n\r\n        if (typeof (self.offsets) === 'object') {\r\n            self.offsets[self.animationStartPath]\r\n                    && (offsets.start = self.offsets[self.animationStartPath]);\r\n        }\r\n\r\n\r\n        // single sprite sheet animation element\r\n        var spriteSheetStart = SpriteSheetAnimation({\r\n            groupCtrl: options.groupCtrl,\r\n            name: self.name + '-spriteSheetStart',\r\n            imgPath: self.animationStartPath,\r\n            left: self.left + offsets.start.x,\r\n            top: self.top + offsets.start.y,\r\n            width: widths.start,\r\n            height: heights.start,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex,\r\n            spriteOffset: self.spriteOffset,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n\r\n        // crossfade animation element\r\n        var spriteSheetCycle = ReelSymbolCrossfade({\r\n            groupCtrl: options.groupCtrl,\r\n            name: self.name + '-spriteSheetCycle',\r\n            fromImage: self.animationCyclePathFrom,\r\n            toImage: self.animationCyclePathTo,\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            offsets: self.offsets,\r\n            isReelsAreaElement: self.isReelsAreaElement,\r\n            zIndex: self.zIndex + 0.01,\r\n            canvasLayer: self.canvasLayer,\r\n        });\r\n\r\n        self.pixiEl = [\r\n            spriteSheetStart,\r\n            spriteSheetCycle\r\n        ];\r\n\r\n        if (self.borderImgPath) {\r\n            var borderEl = Sprite({\r\n                groupCtrl: options.groupCtrl,\r\n                name: self.name + '-border',\r\n                left: self.left,\r\n                top: self.top,\r\n                width: widths.border,\r\n                height: heights.border,\r\n                imgPath: self.borderImgPath,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex + 0.01,\r\n                canvasLayer: self.canvasLayer\r\n            });\r\n            self.pixiEl.push(borderEl);\r\n        }\r\n        if (self.backImgPath) {\r\n            var backEl = Sprite({\r\n                groupCtrl: options.groupCtrl,\r\n                name: self.name + '-back',\r\n                left: self.left,\r\n                top: self.top,\r\n                width: widths.border,\r\n                height: heights.border,\r\n                imgPath: self.backImgPath,\r\n                isReelsAreaElement: self.isReelsAreaElement,\r\n                zIndex: self.zIndex - 0.01,\r\n                canvasLayer: self.canvasLayer\r\n            });\r\n            self.pixiEl.push(backEl);\r\n        }\r\n\r\n        self.resize = function () {\r\n            spriteSheetStart.resize();\r\n            spriteSheetCycle.resize();\r\n            borderEl && borderEl.resize();\r\n            backEl && backEl.resize();\r\n        };\r\n\r\n        self.update = function (delta) {\r\n            spriteSheetStart.update(delta);\r\n            spriteSheetCycle.update(delta);\r\n        };\r\n\r\n        self.show = function () {\r\n            self.visible = true;\r\n        };\r\n        self.superHide = self.hide.bind(self);\r\n        self.hide = function () {\r\n            self.stopAnimation();\r\n            self.superHide.apply(null, arguments);\r\n        };\r\n        self.superSet = self.set.bind(self);\r\n        self.set = function () {\r\n            self.superSet.apply(null, arguments);\r\n            spriteSheetStart.set({\r\n                left: self.left + offsets.start.x,\r\n                top: self.top + offsets.start.y,\r\n            });\r\n        };\r\n        // starts the animation\r\n        self.animate = function (options) {\r\n            options = options || {};\r\n            borderEl && borderEl.show();\r\n            backEl && backEl.show();\r\n            spriteSheetStart.show();\r\n            spriteSheetCycle.hide();\r\n            spriteSheetStart.animate({\r\n                cycles: 1,\r\n                callback: function () {\r\n                    spriteSheetCycle.show();\r\n                    spriteSheetCycle.animate({\r\n                        callback: options.animationFinished\r\n                    });\r\n                    spriteSheetStart.hide();\r\n                }\r\n            });\r\n        };\r\n        self.stopAnimation = function () {\r\n            spriteSheetCycle.stopAnimation();\r\n            spriteSheetStart.stopAnimation();\r\n        };\r\n        return self;\r\n    };\r\n});\n//# sourceURL=/modules/EndorphinaCore/src/js/components/ReelSymbolAnimationWithCrossfade.js"),eval("define('components/Shadow',[\r\n    'components/Element',\r\n    'pixi',\r\n    'services/assets'],\r\n        function (\r\n                Element, PIXI, assets) {\r\n\r\n            // basic shadow\r\n            return function create(options) {\r\n                var self = Element(options);\r\n                self.name = options.name || 'Shadow';\r\n                self.imgPath = options.imgPath;\r\n                self.shadow = options.shadow;\r\n                // grab texture\r\n                var texture = assets.img(self.imgPath);\r\n                // compute height or width if not supplied\r\n                if (self.height === undefined\r\n                        || self.width === undefined) {\r\n                    var ratio = texture.width / texture.height;\r\n                    if (self.height !== undefined) {\r\n                        self.width = self.height * ratio;\r\n                    }\r\n                    else if (self.width !== undefined) {\r\n                        self.height = self.width / ratio;\r\n                    }\r\n                }\r\n\r\n                var el = new PIXI.Graphics();\r\n\r\n                el.beginFill(self.shadow.color);\r\n                if (self.shadow.borderRadius) {\r\n                    el.drawRoundedRect(\r\n                            self.shadow.offsetX,\r\n                            self.shadow.offsetY,\r\n                            self.shadow.baseWidth,\r\n                            self.shadow.baseHeight,\r\n                            self.shadow.borderRadius);\r\n                } else {\r\n                    el.drawRect(\r\n                            self.shadow.offsetX,\r\n                            self.shadow.offsetY,\r\n                            self.shadow.baseWidth,\r\n                            self.shadow.baseHeight);\r\n                }\r\n                el.endFill();\r\n\r\n\r\n                var blurFilterX = new PIXI.BlurXFilter();\r\n                var blurFilterY = new PIXI.BlurYFilter();\r\n                blurFilterX.blur = self.shadow.blur;\r\n                blurFilterY.blur = self.shadow.blur;\r\n                blurFilterX.padding = self.shadow.blur;\r\n                blurFilterY.padding = self.shadow.blur;\r\n                el.filters = [blurFilterX, blurFilterY];\r\n\r\n                el.wrapper = self;\r\n                self.pixiEl = el;\r\n\r\n                self.resize();\r\n                return self;\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/Shadow.js"),eval("define('components/SpriteShadowed',[\r\n    'components/Element',\r\n    'components/Sprite',\r\n    'components/Shadow',\r\n],\r\n        function (Element, Sprite, Shadow) {\r\n\r\n            // basic image with shadow\r\n            return function create(options) {\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'SpriteShadowed';\r\n\r\n                var shadowOptions = $.extend({}, options);\r\n                shadowOptions.zIndex -= 0.01;\r\n\r\n                var sprite = Sprite(options);\r\n                var shadow = Shadow(shadowOptions);\r\n\r\n                self.pixiEl = [sprite, shadow];\r\n\r\n                self.resize();\r\n\r\n                return self;\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/SpriteShadowed.js"),eval("define('components/GlowText',[\r\n    'components/TextBitmap',\r\n], function (TextBitmap) {\r\n    // Bitmap text\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'GlowText';\r\n\r\n        self.glowOpacity = 0.001;\r\n\r\n        var glowOptions = $.extend(true, {}, options);\r\n        glowOptions.top += glowOptions.glowOffsetTop;\r\n        glowOptions.style = glowOptions.glowStyle;\r\n\r\n        var baseText = TextBitmap(options);\r\n        var glowText = TextBitmap(glowOptions);\r\n\r\n        glowText.set({opacity: .001});\r\n\r\n        self.pixiEl = [baseText, glowText];\r\n\r\n        self.setGlowOpacity = function (op) {\r\n            self.glowOpacity = op;\r\n            glowText.set({opacity: op});\r\n        };\r\n\r\n        var superShow = self.show.bind(self);\r\n        self.show = function () {\r\n            self.setGlowOpacity(0.001);\r\n            superShow.apply(null, arguments);\r\n        };\r\n\r\n        self.setText = function () {\r\n            baseText.setText.apply(baseText, arguments);\r\n            glowText.setText.apply(glowText, arguments);\r\n        };\r\n\r\n        self.setStyle = function () {\r\n            baseText.setStyle.apply(baseText, arguments);\r\n        };\r\n        self.setGlowStyle = function () {\r\n            glowText.setStyle.apply(glowText, arguments);\r\n        };\r\n\r\n        return self;\r\n\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/GlowText.js"),eval("define('components/TogglableButton',[\r\n    'components/Element',\r\n    'components/SpriteSheetButton'\r\n], function (\r\n        Element, SpriteSheetButton) {\r\n\r\n    // sprite sheet button\r\n    return function create(options) {\r\n\r\n        var self = Element(options);\r\n        self.name = options.name || 'TogglableButton';\r\n        self.imgPathActive = options.imgPath;\r\n        self.imgPathInactive = options.imgPathInactive;\r\n\r\n        // inactive flag\r\n        self.inactive = options.inactive;\r\n        // event handlers\r\n        self.click = options.click;\r\n        // specify whether to switch inactive state of element by itself\r\n        self.doNotToggleInternally = options.doNotToggleInternally;\r\n\r\n        var elActive = SpriteSheetButton({\r\n            parent: options.parent,\r\n            name: self.name + '-active',\r\n            imgPath: self.imgPathActive,\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            upSprite: options.upSprite,\r\n            hoverSprite: options.hoverSprite,\r\n            downSprite: options.downSprite,\r\n            steps: options.steps,\r\n            click: onClick,\r\n            hitAreaAdjustment: options.hitAreaAdjustment,\r\n            downSound: options.downSound,\r\n            zIndex: 22,\r\n            canvasLayer: 'ui',\r\n        });\r\n        var elInactive = SpriteSheetButton({\r\n            parent: options.parent,\r\n            name: self.name + '-inactive',\r\n            imgPath: self.imgPathInactive,\r\n            left: self.left,\r\n            top: self.top,\r\n            width: self.width,\r\n            height: self.height,\r\n            upSprite: options.upSprite,\r\n            hoverSprite: options.hoverSprite,\r\n            downSprite: options.downSprite,\r\n            steps: options.steps,\r\n            click: onClick,\r\n            hitAreaAdjustment: options.hitAreaAdjustment,\r\n            downSound: options.downSound,\r\n            zIndex: 22,\r\n            canvasLayer: 'ui',\r\n        });\r\n\r\n        self.pixiEl = [elActive, elInactive];\r\n\r\n\r\n        self.show = function () {\r\n            self.visible = true;\r\n            !self.inactive && elActive.show();\r\n            self.inactive && elInactive.show();\r\n        };\r\n\r\n        // update inactive flag\r\n        self.setInactive = function (state) {\r\n            if (state !== self.inactive) {\r\n                toggleState();\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function onClick() {\r\n            if (!self.doNotToggleInternally) {\r\n                toggleState();\r\n            }\r\n            self.click(self.inactive);\r\n        }\r\n        function toggleState() {\r\n            self.inactive = !self.inactive;\r\n            if (self.inactive) {\r\n                elActive.hide();\r\n                elInactive.show();\r\n            } else {\r\n                elInactive.hide();\r\n                elActive.show();\r\n            }\r\n        }\r\n\r\n    };\r\n});\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/components/TogglableButton.js"),eval("define('components/SimpleTextButton',[\r\n    'components/Element',\r\n    'components/Sprite',\r\n    'components/Text'],\r\n        function (\r\n                Element, Sprite, Text) {\r\n\r\n            // basic image\r\n            return function create(options) {\r\n\r\n                var self = Element(options);\r\n\r\n                self.name = options.name || 'SimpleTextButton';\r\n                self.click = options.click;\r\n                self.text = options.text;\r\n                self.textFontSize = options.textFontSize;\r\n                self.textFont = options.textFont;\r\n                self.textStyle = options.textStyle || {type: 'pixi', color: '#ffffff'};\r\n                self.textAlign = options.textAlign;\r\n                self.textOffsetTop = options.textOffsetTop || 0;\r\n                self.imgPath = options.imgPath || 'frame';\r\n\r\n                var sprite = Sprite({\r\n                    groupCtrl: self.groupCtrl,\r\n                    parent: self.parent,\r\n                    name: self.name + '-sprite',\r\n                    imgPath: self.imgPath,\r\n                    left: self.left,\r\n                    top: self.top,\r\n                    width: self.width,\r\n                    height: self.height,\r\n                    originX: self.originX,\r\n                    originY: self.originY,\r\n                    click: self.click,\r\n                    zIndex: self.zIndex,\r\n                    mouseDown: function () {\r\n                        sprite.set({scaleX: .95, scaleY: .95});\r\n                        text.set({fontSize: self.textFontSize * .95});\r\n                    },\r\n                    mouseUp: function () {\r\n                        sprite.set({scaleX: 1, scaleY: 1});\r\n                        text.set({fontSize: self.textFontSize});\r\n                    },\r\n                    canvasLayer: self.canvasLayer,\r\n                    isReelsAreaElement: self.isReelsAreaElement,\r\n                });\r\n\r\n\r\n                var text = Text({\r\n                    groupCtrl: self.groupCtrl,\r\n                    parent: self.parent,\r\n                    left: self.left,\r\n                    top: self.top + self.textOffsetTop,\r\n                    text: self.text,\r\n                    style: self.textStyle,\r\n                    fontSize: self.textFontSize || 15,\r\n                    zIndex: self.zIndex + 1,\r\n                    textAlign: self.textAlign,\r\n                    canvasLayer: self.canvasLayer,\r\n                    originX: self.originX,\r\n                    originY: self.originY,\r\n                    isReelsAreaElement: self.isReelsAreaElement,\r\n                });\r\n\r\n                self.pixiEl = [sprite, text];\r\n\r\n                self.setDisabled = sprite.setDisabled;\r\n                self.setText = function (txt) {\r\n                    text.setText(txt);\r\n                };\r\n\r\n\r\n                self.resize();\r\n\r\n                return self;\r\n\r\n            };\r\n        });\n//# sourceURL=/modules/EndorphinaCore/src/js/components/SimpleTextButton.js"),eval("(function () {\r\n    var data = {\r\n        layers: {\r\n            mainButtons: 'core',\r\n            menu: 'core',\r\n            reels: 'core',\r\n            statusBottom: 'core',\r\n            betlines: 'core',\r\n            infoText: 'core',\r\n            menuPage1: 'core',\r\n            menuPage2: 'core',\r\n            menuPage3: 'core',\r\n            menuPage4: 'core',\r\n            menuPage5: 'core',\r\n            menuPage6: 'core',\r\n            gambleFrame: 'core',\r\n            background: 'core',\r\n            reelsAnimation: 'core',\r\n            animations: 'core',\r\n        },\r\n        services: {\r\n            init: 'core',\r\n            game: 'core',\r\n            start: 'core',\r\n            platform: 'core',\r\n            engine: 'core',\r\n            pause: 'core',\r\n            loader: 'core',\r\n            assets: 'core',\r\n            math: 'core',\r\n            cursor: 'core',\r\n            keyboard: 'core',\r\n            coreSound: 'core',\r\n            dimensions: 'core',\r\n            autoplay: 'core',\r\n            ui: 'core',\r\n            settings: 'core',\r\n            format: 'core',\r\n            'i18n': 'core',\r\n            websocket: 'core',\r\n            winAnimations: 'core',\r\n            sound: 'core',\r\n            help: 'core',\r\n            timer: 'core',\r\n            exit: 'core',\r\n            resume: 'core',\r\n            transport: 'type',\r\n            dummyServer: 'type',\r\n        },\r\n        activities: {\r\n            idle: 'core',\r\n            win: 'core',\r\n            spin: 'core',\r\n            autoSpin: 'core',\r\n            autoSpinWin: 'core',\r\n            autoSpinNoWin: 'core',\r\n            winAmountAnimation: 'core',\r\n            gamble: 'core',\r\n        },\r\n        components: {\r\n            'GroupCtrl': 'core',\r\n            'Element': 'core',\r\n            'CycleButton': 'core',\r\n            'LanguageCycleButton': 'core',\r\n            'DraggableSprite': 'core',\r\n            'FlipSwitch': 'core',\r\n            'BigFlipSwitch': 'core',\r\n            'MenuWrapper': 'core',\r\n            'MovieClip': 'core',\r\n            'RangeSlider': 'core',\r\n            'RectOverlay': 'core',\r\n            'Rectangle': 'core',\r\n            'Line': 'core',\r\n            'FlipCard': 'core',\r\n            'ReelSymbolAnimationBasic': 'core',\r\n            'ReelSymbolAnimationWithCrossfade': 'core',\r\n            'ReelSymbolCrossfade': 'core',\r\n            'Shadow': 'core',\r\n            'SpinButton': 'core',\r\n            'Sprite': 'core',\r\n            'DomButton': 'core',\r\n            'DomSprite': 'core',\r\n            'DomRectangle': 'core',\r\n            'DomDraggableCircle': 'core',\r\n            'RulesContainer': 'core',\r\n            'ScrollContainer': 'core',\r\n            'SpriteShadowed': 'core',\r\n            'SpriteSheetAnimation': 'core',\r\n            'SpriteSheetButton': 'core',\r\n            'Text': 'core',\r\n            'GlowText': 'core',\r\n            'TextBitmap': 'core',\r\n            'TextPixi': 'core',\r\n            'TextCss': 'core',\r\n            'TextButton': 'core',\r\n            'TextBox': 'core',\r\n            'TogglableButton': 'core',\r\n            'DomTogglableButton': 'core',\r\n            'LabeledDomButton': 'core',\r\n            'SimpleTextButton': 'core',\r\n            'FallingCoinsAnimation': 'core',\r\n        },\r\n        data: {\r\n            \"init-modules-list-core\": \"core\",\r\n            \"init-modules-list\": \"game\",\r\n            'config-menuPage1': 'core',\r\n            'config-menuPage2': 'core',\r\n            'config-menuPage3': 'core',\r\n            'config-menuPage4': 'core',\r\n            'config-menuPage5': 'core',\r\n            'config-menuPage6': 'core',\r\n            'config-statusBottom': 'core',\r\n            'config-mainButtons': 'core',\r\n            'config-animations': 'core',\r\n            'sounds-core': 'core',\r\n            'config-buttonStates-core': 'core',\r\n            'config-dummyServer': 'type',\r\n            'config-buttonStates': 'type',\r\n            'fonts-array-core': 'core',\r\n            'fonts-css-array-core': 'core',\r\n            'fonts-array': 'game',\r\n            'fonts-css-array': 'game',\r\n            'i18n-core': 'core',\r\n            'i18n': 'game',\r\n            'config-core': 'core',\r\n            'config': 'game',\r\n            'config-menu-core': 'core',\r\n            'config-menu': 'game',\r\n            'config-help-core': 'core',\r\n            'config-help': 'game',\r\n            'clip-textures-game-tablet-core': 'core',\r\n            'clip-textures-game-tablet': 'game',\r\n            'config-background': 'game',\r\n            'config-betlines': 'game',\r\n            'config-gambleFrame': 'game',\r\n            'config-infoText': 'game',\r\n            'config-reelSet': 'game',\r\n            'config-symbolSet': 'game',\r\n            'sounds-game': 'game',\r\n            'sounds-game-ie-mobile': 'game',\r\n        }\r\n    };\r\n    if (typeof module !== 'undefined') {\r\n        module.exports = data;\r\n    } else if (typeof define !== 'undefined') {\r\n        define('data/init-modules-list-core',[],function () {\r\n            return data;\r\n        });\r\n    }\r\n})();\n//# sourceURL=/modules/EndorphinaCore/src/js/data/init-modules-list-core.js"),eval('(function () {\r\n    var data = {\r\n        "layers": {\r\n            "freeSpin": "game",\r\n        },\r\n        "activities": {\r\n            "freeSpin": "type",\r\n            "freeSpinWin": "type",\r\n            "freeSpinPause": "type",\r\n            "freeSpinIntro": "type",\r\n            "freeSpinOver": "type"\r\n        },\r\n        "data": {\r\n            "config-freeSpin": "game",\r\n        }\r\n    };\r\n    if (typeof module !== \'undefined\') {\r\n        module.exports = data;\r\n    } else if (typeof define !== \'undefined\') {\r\n        define(\'data/init-modules-list\',[],function () {\r\n            return data;\r\n        });\r\n    }\r\n})();\n//# sourceURL=/modules/Vikings/src/js/data/init-modules-list.js'),eval('define(\'data/sounds-game-ie-mobile\',[],function () {\r\n    return {\r\n        \'effects\': {\r\n            "accepting_credits": [\r\n                0,\r\n                15357.291666666666,\r\n                true\r\n            ],\r\n            "actions_start": [\r\n                17000,\r\n                991.1666666666683\r\n            ],\r\n            "auto_button_off": [\r\n                19000,\r\n                1461.708333333334\r\n            ],\r\n            "auto_button_on": [\r\n                22000,\r\n                1195.1874999999993\r\n            ],\r\n            "credits_accept_finished": [\r\n                25000,\r\n                960.0000000000009\r\n            ],\r\n            "end_wintable": [\r\n                27000,\r\n                7625.02083333333\r\n            ],\r\n            "gamble_cards_close": [\r\n                36000,\r\n                648.8958333333344\r\n            ],\r\n            "gamble_card_open": [\r\n                38000,\r\n                599.8958333333348\r\n            ],\r\n            "gamble_card_open_loss": [\r\n                40000,\r\n                1365.6250000000014\r\n            ],\r\n            "gamble_card_open_same": [\r\n                43000,\r\n                815.291666666667\r\n            ],\r\n            "gamble_card_open_win": [\r\n                45000,\r\n                1349.458333333331\r\n            ],\r\n            "start_wintable": [\r\n                48000,\r\n                3761.77083333333\r\n            ],\r\n            "win_$0$1$2$3": [\r\n                53000,\r\n                3500\r\n            ],\r\n            "win_$10$11$12": [\r\n                58000,\r\n                4000\r\n            ],\r\n            "win_$13$14$15": [\r\n                63000,\r\n                2500\r\n            ],\r\n            "win_$16$17$18": [\r\n                67000,\r\n                4000\r\n            ],\r\n            "win_$19$20$21": [\r\n                72000,\r\n                3000\r\n            ],\r\n            "win_$22$23$24$25$26$27": [\r\n                76000,\r\n                3000\r\n            ],\r\n            "win_$28$29$30": [\r\n                80000,\r\n                4500\r\n            ],\r\n            "win_$4$5$6": [\r\n                86000,\r\n                3500.041666666661\r\n            ],\r\n            "win_$7$8$9": [\r\n                91000,\r\n                4000\r\n            ]\r\n        }\r\n    }\r\n});\n//# sourceURL=/modules/Vikings/src/js/data/sounds-game-ie-mobile.js'),
eval("/*\r\n     _ _      _       _\r\n ___| (_) ___| | __  (_)___\r\n/ __| | |/ __| |/ /  | / __|\r\n\\__ \\ | | (__|   < _ | \\__ \\\r\n|___/_|_|\\___|_|\\_(_)/ |___/\r\n                   |__/\r\n\r\n Version: 1.6.0\r\n  Author: Ken Wheeler\r\n Website: http://kenwheeler.github.io\r\n    Docs: http://kenwheeler.github.io/slick\r\n    Repo: http://github.com/kenwheeler/slick\r\n  Issues: http://github.com/kenwheeler/slick/issues\r\n\r\n */\r\n/* global window, document, define, jQuery, setInterval, clearInterval */\r\n(function(factory) {\r\n    'use strict';\r\n    if (typeof define === 'function' && define.amd) {\r\n        define('slick',['jquery'], factory);\r\n    } else if (typeof exports !== 'undefined') {\r\n        module.exports = factory(require('jquery'));\r\n    } else {\r\n        factory(jQuery);\r\n    }\r\n\r\n}(function($) {\r\n    'use strict';\r\n    var Slick = window.Slick || {};\r\n\r\n    Slick = (function() {\r\n\r\n        var instanceUid = 0;\r\n\r\n        function Slick(element, settings) {\r\n\r\n            var _ = this, dataSettings;\r\n\r\n            _.defaults = {\r\n                accessibility: true,\r\n                adaptiveHeight: false,\r\n                appendArrows: $(element),\r\n                appendDots: $(element),\r\n                arrows: true,\r\n                asNavFor: null,\r\n                prevArrow: '<button type=\"button\" data-role=\"none\" class=\"slick-prev\" aria-label=\"Previous\" tabindex=\"0\" role=\"button\">Previous</button>',\r\n                nextArrow: '<button type=\"button\" data-role=\"none\" class=\"slick-next\" aria-label=\"Next\" tabindex=\"0\" role=\"button\">Next</button>',\r\n                autoplay: false,\r\n                autoplaySpeed: 3000,\r\n                centerMode: false,\r\n                centerPadding: '50px',\r\n                cssEase: 'ease',\r\n                customPaging: function(slider, i) {\r\n                    return $('<button type=\"button\" data-role=\"none\" role=\"button\" tabindex=\"0\" />').text(i + 1);\r\n                },\r\n                dots: false,\r\n                dotsClass: 'slick-dots',\r\n                draggable: true,\r\n                easing: 'linear',\r\n                edgeFriction: 0.35,\r\n                fade: false,\r\n                focusOnSelect: false,\r\n                infinite: true,\r\n                initialSlide: 0,\r\n                lazyLoad: 'ondemand',\r\n                mobileFirst: false,\r\n                pauseOnHover: true,\r\n                pauseOnFocus: true,\r\n                pauseOnDotsHover: false,\r\n                respondTo: 'window',\r\n                responsive: null,\r\n                rows: 1,\r\n                rtl: false,\r\n                slide: '',\r\n                slidesPerRow: 1,\r\n                slidesToShow: 1,\r\n                slidesToScroll: 1,\r\n                speed: 500,\r\n                swipe: true,\r\n                swipeToSlide: false,\r\n                touchMove: true,\r\n                touchThreshold: 5,\r\n                useCSS: true,\r\n                useTransform: true,\r\n                variableWidth: false,\r\n                vertical: false,\r\n                verticalSwiping: false,\r\n                waitForAnimate: true,\r\n                zIndex: 1000\r\n            };\r\n\r\n            _.initials = {\r\n                animating: false,\r\n                dragging: false,\r\n                autoPlayTimer: null,\r\n                currentDirection: 0,\r\n                currentLeft: null,\r\n                currentSlide: 0,\r\n                direction: 1,\r\n                $dots: null,\r\n                listWidth: null,\r\n                listHeight: null,\r\n                loadIndex: 0,\r\n                $nextArrow: null,\r\n                $prevArrow: null,\r\n                slideCount: null,\r\n                slideWidth: null,\r\n                $slideTrack: null,\r\n                $slides: null,\r\n                sliding: false,\r\n                slideOffset: 0,\r\n                swipeLeft: null,\r\n                $list: null,\r\n                touchObject: {},\r\n                transformsEnabled: false,\r\n                unslicked: false\r\n            };\r\n\r\n            $.extend(_, _.initials);\r\n\r\n            _.activeBreakpoint = null;\r\n            _.animType = null;\r\n            _.animProp = null;\r\n            _.breakpoints = [];\r\n            _.breakpointSettings = [];\r\n            _.cssTransitions = false;\r\n            _.focussed = false;\r\n            _.interrupted = false;\r\n            _.hidden = 'hidden';\r\n            _.paused = true;\r\n            _.positionProp = null;\r\n            _.respondTo = null;\r\n            _.rowCount = 1;\r\n            _.shouldClick = true;\r\n            _.$slider = $(element);\r\n            _.$slidesCache = null;\r\n            _.transformType = null;\r\n            _.transitionType = null;\r\n            _.visibilityChange = 'visibilitychange';\r\n            _.windowWidth = 0;\r\n            _.windowTimer = null;\r\n\r\n            dataSettings = $(element).data('slick') || {};\r\n\r\n            _.options = $.extend({}, _.defaults, settings, dataSettings);\r\n\r\n            _.currentSlide = _.options.initialSlide;\r\n\r\n            _.originalSettings = _.options;\r\n\r\n            if (typeof document.mozHidden !== 'undefined') {\r\n                _.hidden = 'mozHidden';\r\n                _.visibilityChange = 'mozvisibilitychange';\r\n            } else if (typeof document.webkitHidden !== 'undefined') {\r\n                _.hidden = 'webkitHidden';\r\n                _.visibilityChange = 'webkitvisibilitychange';\r\n            }\r\n\r\n            _.autoPlay = $.proxy(_.autoPlay, _);\r\n            _.autoPlayClear = $.proxy(_.autoPlayClear, _);\r\n            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);\r\n            _.changeSlide = $.proxy(_.changeSlide, _);\r\n            _.clickHandler = $.proxy(_.clickHandler, _);\r\n            _.selectHandler = $.proxy(_.selectHandler, _);\r\n            _.setPosition = $.proxy(_.setPosition, _);\r\n            _.swipeHandler = $.proxy(_.swipeHandler, _);\r\n            _.dragHandler = $.proxy(_.dragHandler, _);\r\n            _.keyHandler = $.proxy(_.keyHandler, _);\r\n\r\n            _.instanceUid = instanceUid++;\r\n\r\n            // A simple way to check for HTML strings\r\n            // Strict HTML recognition (must start with <)\r\n            // Extracted from jQuery v1.11 source\r\n            _.htmlExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*)$/;\r\n\r\n\r\n            _.registerBreakpoints();\r\n            _.init(true);\r\n\r\n        }\r\n\r\n        return Slick;\r\n\r\n    }());\r\n\r\n    Slick.prototype.activateADA = function() {\r\n        var _ = this;\r\n\r\n        _.$slideTrack.find('.slick-active').attr({\r\n            'aria-hidden': 'false'\r\n        }).find('a, input, button, select').attr({\r\n            'tabindex': '0'\r\n        });\r\n\r\n    };\r\n\r\n    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {\r\n\r\n        var _ = this;\r\n\r\n        if (typeof(index) === 'boolean') {\r\n            addBefore = index;\r\n            index = null;\r\n        } else if (index < 0 || (index >= _.slideCount)) {\r\n            return false;\r\n        }\r\n\r\n        _.unload();\r\n\r\n        if (typeof(index) === 'number') {\r\n            if (index === 0 && _.$slides.length === 0) {\r\n                $(markup).appendTo(_.$slideTrack);\r\n            } else if (addBefore) {\r\n                $(markup).insertBefore(_.$slides.eq(index));\r\n            } else {\r\n                $(markup).insertAfter(_.$slides.eq(index));\r\n            }\r\n        } else {\r\n            if (addBefore === true) {\r\n                $(markup).prependTo(_.$slideTrack);\r\n            } else {\r\n                $(markup).appendTo(_.$slideTrack);\r\n            }\r\n        }\r\n\r\n        _.$slides = _.$slideTrack.children(this.options.slide);\r\n\r\n        _.$slideTrack.children(this.options.slide).detach();\r\n\r\n        _.$slideTrack.append(_.$slides);\r\n\r\n        _.$slides.each(function(index, element) {\r\n            $(element).attr('data-slick-index', index);\r\n        });\r\n\r\n        _.$slidesCache = _.$slides;\r\n\r\n        _.reinit();\r\n\r\n    };\r\n\r\n    Slick.prototype.animateHeight = function() {\r\n        var _ = this;\r\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\r\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\r\n            _.$list.animate({\r\n                height: targetHeight\r\n            }, _.options.speed);\r\n        }\r\n    };\r\n\r\n    Slick.prototype.animateSlide = function(targetLeft, callback) {\r\n\r\n        var animProps = {},\r\n            _ = this;\r\n\r\n        _.animateHeight();\r\n\r\n        if (_.options.rtl === true && _.options.vertical === false) {\r\n            targetLeft = -targetLeft;\r\n        }\r\n        if (_.transformsEnabled === false) {\r\n            if (_.options.vertical === false) {\r\n                _.$slideTrack.animate({\r\n                    left: targetLeft\r\n                }, _.options.speed, _.options.easing, callback);\r\n            } else {\r\n                _.$slideTrack.animate({\r\n                    top: targetLeft\r\n                }, _.options.speed, _.options.easing, callback);\r\n            }\r\n\r\n        } else {\r\n\r\n            if (_.cssTransitions === false) {\r\n                if (_.options.rtl === true) {\r\n                    _.currentLeft = -(_.currentLeft);\r\n                }\r\n                $({\r\n                    animStart: _.currentLeft\r\n                }).animate({\r\n                    animStart: targetLeft\r\n                }, {\r\n                    duration: _.options.speed,\r\n                    easing: _.options.easing,\r\n                    step: function(now) {\r\n                        now = Math.ceil(now);\r\n                        if (_.options.vertical === false) {\r\n                            animProps[_.animType] = 'translate(' +\r\n                                now + 'px, 0px)';\r\n                            _.$slideTrack.css(animProps);\r\n                        } else {\r\n                            animProps[_.animType] = 'translate(0px,' +\r\n                                now + 'px)';\r\n                            _.$slideTrack.css(animProps);\r\n                        }\r\n                    },\r\n                    complete: function() {\r\n                        if (callback) {\r\n                            callback.call();\r\n                        }\r\n                    }\r\n                });\r\n\r\n            } else {\r\n\r\n                _.applyTransition();\r\n                targetLeft = Math.ceil(targetLeft);\r\n\r\n                if (_.options.vertical === false) {\r\n                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';\r\n                } else {\r\n                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';\r\n                }\r\n                _.$slideTrack.css(animProps);\r\n\r\n                if (callback) {\r\n                    setTimeout(function() {\r\n\r\n                        _.disableTransition();\r\n\r\n                        callback.call();\r\n                    }, _.options.speed);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.getNavTarget = function() {\r\n\r\n        var _ = this,\r\n            asNavFor = _.options.asNavFor;\r\n\r\n        if ( asNavFor && asNavFor !== null ) {\r\n            asNavFor = $(asNavFor).not(_.$slider);\r\n        }\r\n\r\n        return asNavFor;\r\n\r\n    };\r\n\r\n    Slick.prototype.asNavFor = function(index) {\r\n\r\n        var _ = this,\r\n            asNavFor = _.getNavTarget();\r\n\r\n        if ( asNavFor !== null && typeof asNavFor === 'object' ) {\r\n            asNavFor.each(function() {\r\n                var target = $(this).slick('getSlick');\r\n                if(!target.unslicked) {\r\n                    target.slideHandler(index, true);\r\n                }\r\n            });\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.applyTransition = function(slide) {\r\n\r\n        var _ = this,\r\n            transition = {};\r\n\r\n        if (_.options.fade === false) {\r\n            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;\r\n        } else {\r\n            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;\r\n        }\r\n\r\n        if (_.options.fade === false) {\r\n            _.$slideTrack.css(transition);\r\n        } else {\r\n            _.$slides.eq(slide).css(transition);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.autoPlay = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.autoPlayClear();\r\n\r\n        if ( _.slideCount > _.options.slidesToShow ) {\r\n            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.autoPlayClear = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.autoPlayTimer) {\r\n            clearInterval(_.autoPlayTimer);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.autoPlayIterator = function() {\r\n\r\n        var _ = this,\r\n            slideTo = _.currentSlide + _.options.slidesToScroll;\r\n\r\n        if ( !_.paused && !_.interrupted && !_.focussed ) {\r\n\r\n            if ( _.options.infinite === false ) {\r\n\r\n                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {\r\n                    _.direction = 0;\r\n                }\r\n\r\n                else if ( _.direction === 0 ) {\r\n\r\n                    slideTo = _.currentSlide - _.options.slidesToScroll;\r\n\r\n                    if ( _.currentSlide - 1 === 0 ) {\r\n                        _.direction = 1;\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            _.slideHandler( slideTo );\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.buildArrows = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.arrows === true ) {\r\n\r\n            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');\r\n            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');\r\n\r\n            if( _.slideCount > _.options.slidesToShow ) {\r\n\r\n                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\r\n                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\r\n\r\n                if (_.htmlExpr.test(_.options.prevArrow)) {\r\n                    _.$prevArrow.prependTo(_.options.appendArrows);\r\n                }\r\n\r\n                if (_.htmlExpr.test(_.options.nextArrow)) {\r\n                    _.$nextArrow.appendTo(_.options.appendArrows);\r\n                }\r\n\r\n                if (_.options.infinite !== true) {\r\n                    _.$prevArrow\r\n                        .addClass('slick-disabled')\r\n                        .attr('aria-disabled', 'true');\r\n                }\r\n\r\n            } else {\r\n\r\n                _.$prevArrow.add( _.$nextArrow )\r\n\r\n                    .addClass('slick-hidden')\r\n                    .attr({\r\n                        'aria-disabled': 'true',\r\n                        'tabindex': '-1'\r\n                    });\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.buildDots = function() {\r\n\r\n        var _ = this,\r\n            i, dot;\r\n\r\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n            _.$slider.addClass('slick-dotted');\r\n\r\n            dot = $('<ul />').addClass(_.options.dotsClass);\r\n\r\n            for (i = 0; i <= _.getDotCount(); i += 1) {\r\n                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));\r\n            }\r\n\r\n            _.$dots = dot.appendTo(_.options.appendDots);\r\n\r\n            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.buildOut = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.$slides =\r\n            _.$slider\r\n                .children( _.options.slide + ':not(.slick-cloned)')\r\n                .addClass('slick-slide');\r\n\r\n        _.slideCount = _.$slides.length;\r\n\r\n        _.$slides.each(function(index, element) {\r\n            $(element)\r\n                .attr('data-slick-index', index)\r\n                .data('originalStyling', $(element).attr('style') || '');\r\n        });\r\n\r\n        _.$slider.addClass('slick-slider');\r\n\r\n        _.$slideTrack = (_.slideCount === 0) ?\r\n            $('<div class=\"slick-track\"/>').appendTo(_.$slider) :\r\n            _.$slides.wrapAll('<div class=\"slick-track\"/>').parent();\r\n\r\n        _.$list = _.$slideTrack.wrap(\r\n            '<div aria-live=\"polite\" class=\"slick-list\"/>').parent();\r\n        _.$slideTrack.css('opacity', 0);\r\n\r\n        if (_.options.centerMode === true || _.options.swipeToSlide === true) {\r\n            _.options.slidesToScroll = 1;\r\n        }\r\n\r\n        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');\r\n\r\n        _.setupInfinite();\r\n\r\n        _.buildArrows();\r\n\r\n        _.buildDots();\r\n\r\n        _.updateDots();\r\n\r\n\r\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\r\n\r\n        if (_.options.draggable === true) {\r\n            _.$list.addClass('draggable');\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.buildRows = function() {\r\n\r\n        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;\r\n\r\n        newSlides = document.createDocumentFragment();\r\n        originalSlides = _.$slider.children();\r\n\r\n        if(_.options.rows > 1) {\r\n\r\n            slidesPerSection = _.options.slidesPerRow * _.options.rows;\r\n            numOfSlides = Math.ceil(\r\n                originalSlides.length / slidesPerSection\r\n            );\r\n\r\n            for(a = 0; a < numOfSlides; a++){\r\n                var slide = document.createElement('div');\r\n                for(b = 0; b < _.options.rows; b++) {\r\n                    var row = document.createElement('div');\r\n                    for(c = 0; c < _.options.slidesPerRow; c++) {\r\n                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));\r\n                        if (originalSlides.get(target)) {\r\n                            row.appendChild(originalSlides.get(target));\r\n                        }\r\n                    }\r\n                    slide.appendChild(row);\r\n                }\r\n                newSlides.appendChild(slide);\r\n            }\r\n\r\n            _.$slider.empty().append(newSlides);\r\n            _.$slider.children().children().children()\r\n                .css({\r\n                    'width':(100 / _.options.slidesPerRow) + '%',\r\n                    'display': 'inline-block'\r\n                });\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.checkResponsive = function(initial, forceUpdate) {\r\n\r\n        var _ = this,\r\n            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;\r\n        var sliderWidth = _.$slider.width();\r\n        var windowWidth = window.innerWidth || $(window).width();\r\n\r\n        if (_.respondTo === 'window') {\r\n            respondToWidth = windowWidth;\r\n        } else if (_.respondTo === 'slider') {\r\n            respondToWidth = sliderWidth;\r\n        } else if (_.respondTo === 'min') {\r\n            respondToWidth = Math.min(windowWidth, sliderWidth);\r\n        }\r\n\r\n        if ( _.options.responsive &&\r\n            _.options.responsive.length &&\r\n            _.options.responsive !== null) {\r\n\r\n            targetBreakpoint = null;\r\n\r\n            for (breakpoint in _.breakpoints) {\r\n                if (_.breakpoints.hasOwnProperty(breakpoint)) {\r\n                    if (_.originalSettings.mobileFirst === false) {\r\n                        if (respondToWidth < _.breakpoints[breakpoint]) {\r\n                            targetBreakpoint = _.breakpoints[breakpoint];\r\n                        }\r\n                    } else {\r\n                        if (respondToWidth > _.breakpoints[breakpoint]) {\r\n                            targetBreakpoint = _.breakpoints[breakpoint];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (targetBreakpoint !== null) {\r\n                if (_.activeBreakpoint !== null) {\r\n                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {\r\n                        _.activeBreakpoint =\r\n                            targetBreakpoint;\r\n                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\r\n                            _.unslick(targetBreakpoint);\r\n                        } else {\r\n                            _.options = $.extend({}, _.originalSettings,\r\n                                _.breakpointSettings[\r\n                                    targetBreakpoint]);\r\n                            if (initial === true) {\r\n                                _.currentSlide = _.options.initialSlide;\r\n                            }\r\n                            _.refresh(initial);\r\n                        }\r\n                        triggerBreakpoint = targetBreakpoint;\r\n                    }\r\n                } else {\r\n                    _.activeBreakpoint = targetBreakpoint;\r\n                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\r\n                        _.unslick(targetBreakpoint);\r\n                    } else {\r\n                        _.options = $.extend({}, _.originalSettings,\r\n                            _.breakpointSettings[\r\n                                targetBreakpoint]);\r\n                        if (initial === true) {\r\n                            _.currentSlide = _.options.initialSlide;\r\n                        }\r\n                        _.refresh(initial);\r\n                    }\r\n                    triggerBreakpoint = targetBreakpoint;\r\n                }\r\n            } else {\r\n                if (_.activeBreakpoint !== null) {\r\n                    _.activeBreakpoint = null;\r\n                    _.options = _.originalSettings;\r\n                    if (initial === true) {\r\n                        _.currentSlide = _.options.initialSlide;\r\n                    }\r\n                    _.refresh(initial);\r\n                    triggerBreakpoint = targetBreakpoint;\r\n                }\r\n            }\r\n\r\n            // only trigger breakpoints during an actual break. not on initialize.\r\n            if( !initial && triggerBreakpoint !== false ) {\r\n                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.changeSlide = function(event, dontAnimate) {\r\n\r\n        var _ = this,\r\n            $target = $(event.currentTarget),\r\n            indexOffset, slideOffset, unevenOffset;\r\n\r\n        // If target is a link, prevent default action.\r\n        if($target.is('a')) {\r\n            event.preventDefault();\r\n        }\r\n\r\n        // If target is not the <li> element (ie: a child), find the <li>.\r\n        if(!$target.is('li')) {\r\n            $target = $target.closest('li');\r\n        }\r\n\r\n        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);\r\n        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;\r\n\r\n        switch (event.data.message) {\r\n\r\n            case 'previous':\r\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;\r\n                if (_.slideCount > _.options.slidesToShow) {\r\n                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);\r\n                }\r\n                break;\r\n\r\n            case 'next':\r\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;\r\n                if (_.slideCount > _.options.slidesToShow) {\r\n                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);\r\n                }\r\n                break;\r\n\r\n            case 'index':\r\n                var index = event.data.index === 0 ? 0 :\r\n                    event.data.index || $target.index() * _.options.slidesToScroll;\r\n\r\n                _.slideHandler(_.checkNavigable(index), false, dontAnimate);\r\n                $target.children().trigger('focus');\r\n                break;\r\n\r\n            default:\r\n                return;\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.checkNavigable = function(index) {\r\n\r\n        var _ = this,\r\n            navigables, prevNavigable;\r\n\r\n        navigables = _.getNavigableIndexes();\r\n        prevNavigable = 0;\r\n        if (index > navigables[navigables.length - 1]) {\r\n            index = navigables[navigables.length - 1];\r\n        } else {\r\n            for (var n in navigables) {\r\n                if (index < navigables[n]) {\r\n                    index = prevNavigable;\r\n                    break;\r\n                }\r\n                prevNavigable = navigables[n];\r\n            }\r\n        }\r\n\r\n        return index;\r\n    };\r\n\r\n    Slick.prototype.cleanUpEvents = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.dots && _.$dots !== null) {\r\n\r\n            $('li', _.$dots)\r\n                .off('click.slick', _.changeSlide)\r\n                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))\r\n                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n        }\r\n\r\n        _.$slider.off('focus.slick blur.slick');\r\n\r\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);\r\n            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);\r\n        }\r\n\r\n        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);\r\n        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);\r\n        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);\r\n        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);\r\n\r\n        _.$list.off('click.slick', _.clickHandler);\r\n\r\n        $(document).off(_.visibilityChange, _.visibility);\r\n\r\n        _.cleanUpSlideEvents();\r\n\r\n        if (_.options.accessibility === true) {\r\n            _.$list.off('keydown.slick', _.keyHandler);\r\n        }\r\n\r\n        if (_.options.focusOnSelect === true) {\r\n            $(_.$slideTrack).children().off('click.slick', _.selectHandler);\r\n        }\r\n\r\n        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);\r\n\r\n        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);\r\n\r\n        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);\r\n\r\n        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);\r\n        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);\r\n\r\n    };\r\n\r\n    Slick.prototype.cleanUpSlideEvents = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));\r\n        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n    };\r\n\r\n    Slick.prototype.cleanUpRows = function() {\r\n\r\n        var _ = this, originalSlides;\r\n\r\n        if(_.options.rows > 1) {\r\n            originalSlides = _.$slides.children().children();\r\n            originalSlides.removeAttr('style');\r\n            _.$slider.empty().append(originalSlides);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.clickHandler = function(event) {\r\n\r\n        var _ = this;\r\n\r\n        if (_.shouldClick === false) {\r\n            event.stopImmediatePropagation();\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.destroy = function(refresh) {\r\n\r\n        var _ = this;\r\n\r\n        _.autoPlayClear();\r\n\r\n        _.touchObject = {};\r\n\r\n        _.cleanUpEvents();\r\n\r\n        $('.slick-cloned', _.$slider).detach();\r\n\r\n        if (_.$dots) {\r\n            _.$dots.remove();\r\n        }\r\n\r\n\r\n        if ( _.$prevArrow && _.$prevArrow.length ) {\r\n\r\n            _.$prevArrow\r\n                .removeClass('slick-disabled slick-arrow slick-hidden')\r\n                .removeAttr('aria-hidden aria-disabled tabindex')\r\n                .css('display','');\r\n\r\n            if ( _.htmlExpr.test( _.options.prevArrow )) {\r\n                _.$prevArrow.remove();\r\n            }\r\n        }\r\n\r\n        if ( _.$nextArrow && _.$nextArrow.length ) {\r\n\r\n            _.$nextArrow\r\n                .removeClass('slick-disabled slick-arrow slick-hidden')\r\n                .removeAttr('aria-hidden aria-disabled tabindex')\r\n                .css('display','');\r\n\r\n            if ( _.htmlExpr.test( _.options.nextArrow )) {\r\n                _.$nextArrow.remove();\r\n            }\r\n\r\n        }\r\n\r\n\r\n        if (_.$slides) {\r\n\r\n            _.$slides\r\n                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')\r\n                .removeAttr('aria-hidden')\r\n                .removeAttr('data-slick-index')\r\n                .each(function(){\r\n                    $(this).attr('style', $(this).data('originalStyling'));\r\n                });\r\n\r\n            _.$slideTrack.children(this.options.slide).detach();\r\n\r\n            _.$slideTrack.detach();\r\n\r\n            _.$list.detach();\r\n\r\n            _.$slider.append(_.$slides);\r\n        }\r\n\r\n        _.cleanUpRows();\r\n\r\n        _.$slider.removeClass('slick-slider');\r\n        _.$slider.removeClass('slick-initialized');\r\n        _.$slider.removeClass('slick-dotted');\r\n\r\n        _.unslicked = true;\r\n\r\n        if(!refresh) {\r\n            _.$slider.trigger('destroy', [_]);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.disableTransition = function(slide) {\r\n\r\n        var _ = this,\r\n            transition = {};\r\n\r\n        transition[_.transitionType] = '';\r\n\r\n        if (_.options.fade === false) {\r\n            _.$slideTrack.css(transition);\r\n        } else {\r\n            _.$slides.eq(slide).css(transition);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.fadeSlide = function(slideIndex, callback) {\r\n\r\n        var _ = this;\r\n\r\n        if (_.cssTransitions === false) {\r\n\r\n            _.$slides.eq(slideIndex).css({\r\n                zIndex: _.options.zIndex\r\n            });\r\n\r\n            _.$slides.eq(slideIndex).animate({\r\n                opacity: 1\r\n            }, _.options.speed, _.options.easing, callback);\r\n\r\n        } else {\r\n\r\n            _.applyTransition(slideIndex);\r\n\r\n            _.$slides.eq(slideIndex).css({\r\n                opacity: 1,\r\n                zIndex: _.options.zIndex\r\n            });\r\n\r\n            if (callback) {\r\n                setTimeout(function() {\r\n\r\n                    _.disableTransition(slideIndex);\r\n\r\n                    callback.call();\r\n                }, _.options.speed);\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.fadeSlideOut = function(slideIndex) {\r\n\r\n        var _ = this;\r\n\r\n        if (_.cssTransitions === false) {\r\n\r\n            _.$slides.eq(slideIndex).animate({\r\n                opacity: 0,\r\n                zIndex: _.options.zIndex - 2\r\n            }, _.options.speed, _.options.easing);\r\n\r\n        } else {\r\n\r\n            _.applyTransition(slideIndex);\r\n\r\n            _.$slides.eq(slideIndex).css({\r\n                opacity: 0,\r\n                zIndex: _.options.zIndex - 2\r\n            });\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {\r\n\r\n        var _ = this;\r\n\r\n        if (filter !== null) {\r\n\r\n            _.$slidesCache = _.$slides;\r\n\r\n            _.unload();\r\n\r\n            _.$slideTrack.children(this.options.slide).detach();\r\n\r\n            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);\r\n\r\n            _.reinit();\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.focusHandler = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.$slider\r\n            .off('focus.slick blur.slick')\r\n            .on('focus.slick blur.slick',\r\n                '*:not(.slick-arrow)', function(event) {\r\n\r\n            event.stopImmediatePropagation();\r\n            var $sf = $(this);\r\n\r\n            setTimeout(function() {\r\n\r\n                if( _.options.pauseOnFocus ) {\r\n                    _.focussed = $sf.is(':focus');\r\n                    _.autoPlay();\r\n                }\r\n\r\n            }, 0);\r\n\r\n        });\r\n    };\r\n\r\n    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {\r\n\r\n        var _ = this;\r\n        return _.currentSlide;\r\n\r\n    };\r\n\r\n    Slick.prototype.getDotCount = function() {\r\n\r\n        var _ = this;\r\n\r\n        var breakPoint = 0;\r\n        var counter = 0;\r\n        var pagerQty = 0;\r\n\r\n        if (_.options.infinite === true) {\r\n            while (breakPoint < _.slideCount) {\r\n                ++pagerQty;\r\n                breakPoint = counter + _.options.slidesToScroll;\r\n                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\r\n            }\r\n        } else if (_.options.centerMode === true) {\r\n            pagerQty = _.slideCount;\r\n        } else if(!_.options.asNavFor) {\r\n            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);\r\n        }else {\r\n            while (breakPoint < _.slideCount) {\r\n                ++pagerQty;\r\n                breakPoint = counter + _.options.slidesToScroll;\r\n                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\r\n            }\r\n        }\r\n\r\n        return pagerQty - 1;\r\n\r\n    };\r\n\r\n    Slick.prototype.getLeft = function(slideIndex) {\r\n\r\n        var _ = this,\r\n            targetLeft,\r\n            verticalHeight,\r\n            verticalOffset = 0,\r\n            targetSlide;\r\n\r\n        _.slideOffset = 0;\r\n        verticalHeight = _.$slides.first().outerHeight(true);\r\n\r\n        if (_.options.infinite === true) {\r\n            if (_.slideCount > _.options.slidesToShow) {\r\n                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;\r\n                verticalOffset = (verticalHeight * _.options.slidesToShow) * -1;\r\n            }\r\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\r\n                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {\r\n                    if (slideIndex > _.slideCount) {\r\n                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;\r\n                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;\r\n                    } else {\r\n                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;\r\n                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (slideIndex + _.options.slidesToShow > _.slideCount) {\r\n                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;\r\n                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;\r\n            }\r\n        }\r\n\r\n        if (_.slideCount <= _.options.slidesToShow) {\r\n            _.slideOffset = 0;\r\n            verticalOffset = 0;\r\n        }\r\n\r\n        if (_.options.centerMode === true && _.options.infinite === true) {\r\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;\r\n        } else if (_.options.centerMode === true) {\r\n            _.slideOffset = 0;\r\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);\r\n        }\r\n\r\n        if (_.options.vertical === false) {\r\n            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;\r\n        } else {\r\n            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;\r\n        }\r\n\r\n        if (_.options.variableWidth === true) {\r\n\r\n            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\r\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\r\n            } else {\r\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);\r\n            }\r\n\r\n            if (_.options.rtl === true) {\r\n                if (targetSlide[0]) {\r\n                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\r\n                } else {\r\n                    targetLeft =  0;\r\n                }\r\n            } else {\r\n                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\r\n            }\r\n\r\n            if (_.options.centerMode === true) {\r\n                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\r\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\r\n                } else {\r\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);\r\n                }\r\n\r\n                if (_.options.rtl === true) {\r\n                    if (targetSlide[0]) {\r\n                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\r\n                    } else {\r\n                        targetLeft =  0;\r\n                    }\r\n                } else {\r\n                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\r\n                }\r\n\r\n                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;\r\n            }\r\n        }\r\n\r\n        return targetLeft;\r\n\r\n    };\r\n\r\n    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {\r\n\r\n        var _ = this;\r\n\r\n        return _.options[option];\r\n\r\n    };\r\n\r\n    Slick.prototype.getNavigableIndexes = function() {\r\n\r\n        var _ = this,\r\n            breakPoint = 0,\r\n            counter = 0,\r\n            indexes = [],\r\n            max;\r\n\r\n        if (_.options.infinite === false) {\r\n            max = _.slideCount;\r\n        } else {\r\n            breakPoint = _.options.slidesToScroll * -1;\r\n            counter = _.options.slidesToScroll * -1;\r\n            max = _.slideCount * 2;\r\n        }\r\n\r\n        while (breakPoint < max) {\r\n            indexes.push(breakPoint);\r\n            breakPoint = counter + _.options.slidesToScroll;\r\n            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\r\n        }\r\n\r\n        return indexes;\r\n\r\n    };\r\n\r\n    Slick.prototype.getSlick = function() {\r\n\r\n        return this;\r\n\r\n    };\r\n\r\n    Slick.prototype.getSlideCount = function() {\r\n\r\n        var _ = this,\r\n            slidesTraversed, swipedSlide, centerOffset;\r\n\r\n        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;\r\n\r\n        if (_.options.swipeToSlide === true) {\r\n            _.$slideTrack.find('.slick-slide').each(function(index, slide) {\r\n                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {\r\n                    swipedSlide = slide;\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;\r\n\r\n            return slidesTraversed;\r\n\r\n        } else {\r\n            return _.options.slidesToScroll;\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {\r\n\r\n        var _ = this;\r\n\r\n        _.changeSlide({\r\n            data: {\r\n                message: 'index',\r\n                index: parseInt(slide)\r\n            }\r\n        }, dontAnimate);\r\n\r\n    };\r\n\r\n    Slick.prototype.init = function(creation) {\r\n\r\n        var _ = this;\r\n\r\n        if (!$(_.$slider).hasClass('slick-initialized')) {\r\n\r\n            $(_.$slider).addClass('slick-initialized');\r\n\r\n            _.buildRows();\r\n            _.buildOut();\r\n            _.setProps();\r\n            _.startLoad();\r\n            _.loadSlider();\r\n            _.initializeEvents();\r\n            _.updateArrows();\r\n            _.updateDots();\r\n            _.checkResponsive(true);\r\n            _.focusHandler();\r\n\r\n        }\r\n\r\n        if (creation) {\r\n            _.$slider.trigger('init', [_]);\r\n        }\r\n\r\n        if (_.options.accessibility === true) {\r\n            _.initADA();\r\n        }\r\n\r\n        if ( _.options.autoplay ) {\r\n\r\n            _.paused = false;\r\n            _.autoPlay();\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.initADA = function() {\r\n        var _ = this;\r\n        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({\r\n            'aria-hidden': 'true',\r\n            'tabindex': '-1'\r\n        }).find('a, input, button, select').attr({\r\n            'tabindex': '-1'\r\n        });\r\n\r\n        _.$slideTrack.attr('role', 'listbox');\r\n\r\n        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {\r\n            $(this).attr({\r\n                'role': 'option',\r\n                'aria-describedby': 'slick-slide' + _.instanceUid + i + ''\r\n            });\r\n        });\r\n\r\n        if (_.$dots !== null) {\r\n            _.$dots.attr('role', 'tablist').find('li').each(function(i) {\r\n                $(this).attr({\r\n                    'role': 'presentation',\r\n                    'aria-selected': 'false',\r\n                    'aria-controls': 'navigation' + _.instanceUid + i + '',\r\n                    'id': 'slick-slide' + _.instanceUid + i + ''\r\n                });\r\n            })\r\n                .first().attr('aria-selected', 'true').end()\r\n                .find('button').attr('role', 'button').end()\r\n                .closest('div').attr('role', 'toolbar');\r\n        }\r\n        _.activateADA();\r\n\r\n    };\r\n\r\n    Slick.prototype.initArrowEvents = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n            _.$prevArrow\r\n               .off('click.slick')\r\n               .on('click.slick', {\r\n                    message: 'previous'\r\n               }, _.changeSlide);\r\n            _.$nextArrow\r\n               .off('click.slick')\r\n               .on('click.slick', {\r\n                    message: 'next'\r\n               }, _.changeSlide);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.initDotEvents = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n            $('li', _.$dots).on('click.slick', {\r\n                message: 'index'\r\n            }, _.changeSlide);\r\n        }\r\n\r\n        if ( _.options.dots === true && _.options.pauseOnDotsHover === true ) {\r\n\r\n            $('li', _.$dots)\r\n                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))\r\n                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.initSlideEvents = function() {\r\n\r\n        var _ = this;\r\n\r\n        if ( _.options.pauseOnHover ) {\r\n\r\n            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));\r\n            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.initializeEvents = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.initArrowEvents();\r\n\r\n        _.initDotEvents();\r\n        _.initSlideEvents();\r\n\r\n        _.$list.on('touchstart.slick mousedown.slick', {\r\n            action: 'start'\r\n        }, _.swipeHandler);\r\n        _.$list.on('touchmove.slick mousemove.slick', {\r\n            action: 'move'\r\n        }, _.swipeHandler);\r\n        _.$list.on('touchend.slick mouseup.slick', {\r\n            action: 'end'\r\n        }, _.swipeHandler);\r\n        _.$list.on('touchcancel.slick mouseleave.slick', {\r\n            action: 'end'\r\n        }, _.swipeHandler);\r\n\r\n        _.$list.on('click.slick', _.clickHandler);\r\n\r\n        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));\r\n\r\n        if (_.options.accessibility === true) {\r\n            _.$list.on('keydown.slick', _.keyHandler);\r\n        }\r\n\r\n        if (_.options.focusOnSelect === true) {\r\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\r\n        }\r\n\r\n        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));\r\n\r\n        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));\r\n\r\n        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);\r\n\r\n        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);\r\n        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);\r\n\r\n    };\r\n\r\n    Slick.prototype.initUI = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n            _.$prevArrow.show();\r\n            _.$nextArrow.show();\r\n\r\n        }\r\n\r\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n            _.$dots.show();\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.keyHandler = function(event) {\r\n\r\n        var _ = this;\r\n         //Dont slide if the cursor is inside the form fields and arrow keys are pressed\r\n        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {\r\n            if (event.keyCode === 37 && _.options.accessibility === true) {\r\n                _.changeSlide({\r\n                    data: {\r\n                        message: _.options.rtl === true ? 'next' :  'previous'\r\n                    }\r\n                });\r\n            } else if (event.keyCode === 39 && _.options.accessibility === true) {\r\n                _.changeSlide({\r\n                    data: {\r\n                        message: _.options.rtl === true ? 'previous' : 'next'\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.lazyLoad = function() {\r\n\r\n        var _ = this,\r\n            loadRange, cloneRange, rangeStart, rangeEnd;\r\n\r\n        function loadImages(imagesScope) {\r\n\r\n            $('img[data-lazy]', imagesScope).each(function() {\r\n\r\n                var image = $(this),\r\n                    imageSource = $(this).attr('data-lazy'),\r\n                    imageToLoad = document.createElement('img');\r\n\r\n                imageToLoad.onload = function() {\r\n\r\n                    image\r\n                        .animate({ opacity: 0 }, 100, function() {\r\n                            image\r\n                                .attr('src', imageSource)\r\n                                .animate({ opacity: 1 }, 200, function() {\r\n                                    image\r\n                                        .removeAttr('data-lazy')\r\n                                        .removeClass('slick-loading');\r\n                                });\r\n                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);\r\n                        });\r\n\r\n                };\r\n\r\n                imageToLoad.onerror = function() {\r\n\r\n                    image\r\n                        .removeAttr( 'data-lazy' )\r\n                        .removeClass( 'slick-loading' )\r\n                        .addClass( 'slick-lazyload-error' );\r\n\r\n                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);\r\n\r\n                };\r\n\r\n                imageToLoad.src = imageSource;\r\n\r\n            });\r\n\r\n        }\r\n\r\n        if (_.options.centerMode === true) {\r\n            if (_.options.infinite === true) {\r\n                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);\r\n                rangeEnd = rangeStart + _.options.slidesToShow + 2;\r\n            } else {\r\n                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));\r\n                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;\r\n            }\r\n        } else {\r\n            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;\r\n            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);\r\n            if (_.options.fade === true) {\r\n                if (rangeStart > 0) rangeStart--;\r\n                if (rangeEnd <= _.slideCount) rangeEnd++;\r\n            }\r\n        }\r\n\r\n        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);\r\n        loadImages(loadRange);\r\n\r\n        if (_.slideCount <= _.options.slidesToShow) {\r\n            cloneRange = _.$slider.find('.slick-slide');\r\n            loadImages(cloneRange);\r\n        } else\r\n        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {\r\n            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);\r\n            loadImages(cloneRange);\r\n        } else if (_.currentSlide === 0) {\r\n            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);\r\n            loadImages(cloneRange);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.loadSlider = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.setPosition();\r\n\r\n        _.$slideTrack.css({\r\n            opacity: 1\r\n        });\r\n\r\n        _.$slider.removeClass('slick-loading');\r\n\r\n        _.initUI();\r\n\r\n        if (_.options.lazyLoad === 'progressive') {\r\n            _.progressiveLazyLoad();\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.next = Slick.prototype.slickNext = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.changeSlide({\r\n            data: {\r\n                message: 'next'\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    Slick.prototype.orientationChange = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.checkResponsive();\r\n        _.setPosition();\r\n\r\n    };\r\n\r\n    Slick.prototype.pause = Slick.prototype.slickPause = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.autoPlayClear();\r\n        _.paused = true;\r\n\r\n    };\r\n\r\n    Slick.prototype.play = Slick.prototype.slickPlay = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.autoPlay();\r\n        _.options.autoplay = true;\r\n        _.paused = false;\r\n        _.focussed = false;\r\n        _.interrupted = false;\r\n\r\n    };\r\n\r\n    Slick.prototype.postSlide = function(index) {\r\n\r\n        var _ = this;\r\n\r\n        if( !_.unslicked ) {\r\n\r\n            _.$slider.trigger('afterChange', [_, index]);\r\n\r\n            _.animating = false;\r\n\r\n            _.setPosition();\r\n\r\n            _.swipeLeft = null;\r\n\r\n            if ( _.options.autoplay ) {\r\n                _.autoPlay();\r\n            }\r\n\r\n            if (_.options.accessibility === true) {\r\n                _.initADA();\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.prev = Slick.prototype.slickPrev = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.changeSlide({\r\n            data: {\r\n                message: 'previous'\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    Slick.prototype.preventDefault = function(event) {\r\n\r\n        event.preventDefault();\r\n\r\n    };\r\n\r\n    Slick.prototype.progressiveLazyLoad = function( tryCount ) {\r\n\r\n        tryCount = tryCount || 1;\r\n\r\n        var _ = this,\r\n            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),\r\n            image,\r\n            imageSource,\r\n            imageToLoad;\r\n\r\n        if ( $imgsToLoad.length ) {\r\n\r\n            image = $imgsToLoad.first();\r\n            imageSource = image.attr('data-lazy');\r\n            imageToLoad = document.createElement('img');\r\n\r\n            imageToLoad.onload = function() {\r\n\r\n                image\r\n                    .attr( 'src', imageSource )\r\n                    .removeAttr('data-lazy')\r\n                    .removeClass('slick-loading');\r\n\r\n                if ( _.options.adaptiveHeight === true ) {\r\n                    _.setPosition();\r\n                }\r\n\r\n                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);\r\n                _.progressiveLazyLoad();\r\n\r\n            };\r\n\r\n            imageToLoad.onerror = function() {\r\n\r\n                if ( tryCount < 3 ) {\r\n\r\n                    /**\r\n                     * try to load the image 3 times,\r\n                     * leave a slight delay so we don't get\r\n                     * servers blocking the request.\r\n                     */\r\n                    setTimeout( function() {\r\n                        _.progressiveLazyLoad( tryCount + 1 );\r\n                    }, 500 );\r\n\r\n                } else {\r\n\r\n                    image\r\n                        .removeAttr( 'data-lazy' )\r\n                        .removeClass( 'slick-loading' )\r\n                        .addClass( 'slick-lazyload-error' );\r\n\r\n                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);\r\n\r\n                    _.progressiveLazyLoad();\r\n\r\n                }\r\n\r\n            };\r\n\r\n            imageToLoad.src = imageSource;\r\n\r\n        } else {\r\n\r\n            _.$slider.trigger('allImagesLoaded', [ _ ]);\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.refresh = function( initializing ) {\r\n\r\n        var _ = this, currentSlide, lastVisibleIndex;\r\n\r\n        lastVisibleIndex = _.slideCount - _.options.slidesToShow;\r\n\r\n        // in non-infinite sliders, we don't want to go past the\r\n        // last visible index.\r\n        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {\r\n            _.currentSlide = lastVisibleIndex;\r\n        }\r\n\r\n        // if less slides than to show, go to start.\r\n        if ( _.slideCount <= _.options.slidesToShow ) {\r\n            _.currentSlide = 0;\r\n\r\n        }\r\n\r\n        currentSlide = _.currentSlide;\r\n\r\n        _.destroy(true);\r\n\r\n        $.extend(_, _.initials, { currentSlide: currentSlide });\r\n\r\n        _.init();\r\n\r\n        if( !initializing ) {\r\n\r\n            _.changeSlide({\r\n                data: {\r\n                    message: 'index',\r\n                    index: currentSlide\r\n                }\r\n            }, false);\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.registerBreakpoints = function() {\r\n\r\n        var _ = this, breakpoint, currentBreakpoint, l,\r\n            responsiveSettings = _.options.responsive || null;\r\n\r\n        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {\r\n\r\n            _.respondTo = _.options.respondTo || 'window';\r\n\r\n            for ( breakpoint in responsiveSettings ) {\r\n\r\n                l = _.breakpoints.length-1;\r\n                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;\r\n\r\n                if (responsiveSettings.hasOwnProperty(breakpoint)) {\r\n\r\n                    // loop through the breakpoints and cut out any existing\r\n                    // ones with the same breakpoint number, we don't want dupes.\r\n                    while( l >= 0 ) {\r\n                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {\r\n                            _.breakpoints.splice(l,1);\r\n                        }\r\n                        l--;\r\n                    }\r\n\r\n                    _.breakpoints.push(currentBreakpoint);\r\n                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            _.breakpoints.sort(function(a, b) {\r\n                return ( _.options.mobileFirst ) ? a-b : b-a;\r\n            });\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.reinit = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.$slides =\r\n            _.$slideTrack\r\n                .children(_.options.slide)\r\n                .addClass('slick-slide');\r\n\r\n        _.slideCount = _.$slides.length;\r\n\r\n        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {\r\n            _.currentSlide = _.currentSlide - _.options.slidesToScroll;\r\n        }\r\n\r\n        if (_.slideCount <= _.options.slidesToShow) {\r\n            _.currentSlide = 0;\r\n        }\r\n\r\n        _.registerBreakpoints();\r\n\r\n        _.setProps();\r\n        _.setupInfinite();\r\n        _.buildArrows();\r\n        _.updateArrows();\r\n        _.initArrowEvents();\r\n        _.buildDots();\r\n        _.updateDots();\r\n        _.initDotEvents();\r\n        _.cleanUpSlideEvents();\r\n        _.initSlideEvents();\r\n\r\n        _.checkResponsive(false, true);\r\n\r\n        if (_.options.focusOnSelect === true) {\r\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\r\n        }\r\n\r\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\r\n\r\n        _.setPosition();\r\n        _.focusHandler();\r\n\r\n        _.paused = !_.options.autoplay;\r\n        _.autoPlay();\r\n\r\n        _.$slider.trigger('reInit', [_]);\r\n\r\n    };\r\n\r\n    Slick.prototype.resize = function() {\r\n\r\n        var _ = this;\r\n\r\n        if ($(window).width() !== _.windowWidth) {\r\n            clearTimeout(_.windowDelay);\r\n            _.windowDelay = window.setTimeout(function() {\r\n                _.windowWidth = $(window).width();\r\n                _.checkResponsive();\r\n                if( !_.unslicked ) { _.setPosition(); }\r\n            }, 50);\r\n        }\r\n    };\r\n\r\n    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {\r\n\r\n        var _ = this;\r\n\r\n        if (typeof(index) === 'boolean') {\r\n            removeBefore = index;\r\n            index = removeBefore === true ? 0 : _.slideCount - 1;\r\n        } else {\r\n            index = removeBefore === true ? --index : index;\r\n        }\r\n\r\n        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {\r\n            return false;\r\n        }\r\n\r\n        _.unload();\r\n\r\n        if (removeAll === true) {\r\n            _.$slideTrack.children().remove();\r\n        } else {\r\n            _.$slideTrack.children(this.options.slide).eq(index).remove();\r\n        }\r\n\r\n        _.$slides = _.$slideTrack.children(this.options.slide);\r\n\r\n        _.$slideTrack.children(this.options.slide).detach();\r\n\r\n        _.$slideTrack.append(_.$slides);\r\n\r\n        _.$slidesCache = _.$slides;\r\n\r\n        _.reinit();\r\n\r\n    };\r\n\r\n    Slick.prototype.setCSS = function(position) {\r\n\r\n        var _ = this,\r\n            positionProps = {},\r\n            x, y;\r\n\r\n        if (_.options.rtl === true) {\r\n            position = -position;\r\n        }\r\n        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';\r\n        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';\r\n\r\n        positionProps[_.positionProp] = position;\r\n\r\n        if (_.transformsEnabled === false) {\r\n            _.$slideTrack.css(positionProps);\r\n        } else {\r\n            positionProps = {};\r\n            if (_.cssTransitions === false) {\r\n                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';\r\n                _.$slideTrack.css(positionProps);\r\n            } else {\r\n                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';\r\n                _.$slideTrack.css(positionProps);\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.setDimensions = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.vertical === false) {\r\n            if (_.options.centerMode === true) {\r\n                _.$list.css({\r\n                    padding: ('0px ' + _.options.centerPadding)\r\n                });\r\n            }\r\n        } else {\r\n            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);\r\n            if (_.options.centerMode === true) {\r\n                _.$list.css({\r\n                    padding: (_.options.centerPadding + ' 0px')\r\n                });\r\n            }\r\n        }\r\n\r\n        _.listWidth = _.$list.width();\r\n        _.listHeight = _.$list.height();\r\n\r\n\r\n        if (_.options.vertical === false && _.options.variableWidth === false) {\r\n            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);\r\n            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));\r\n\r\n        } else if (_.options.variableWidth === true) {\r\n            _.$slideTrack.width(5000 * _.slideCount);\r\n        } else {\r\n            _.slideWidth = Math.ceil(_.listWidth);\r\n            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));\r\n        }\r\n\r\n        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();\r\n        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);\r\n\r\n    };\r\n\r\n    Slick.prototype.setFade = function() {\r\n\r\n        var _ = this,\r\n            targetLeft;\r\n\r\n        _.$slides.each(function(index, element) {\r\n            targetLeft = (_.slideWidth * index) * -1;\r\n            if (_.options.rtl === true) {\r\n                $(element).css({\r\n                    position: 'relative',\r\n                    right: targetLeft,\r\n                    top: 0,\r\n                    zIndex: _.options.zIndex - 2,\r\n                    opacity: 0\r\n                });\r\n            } else {\r\n                $(element).css({\r\n                    position: 'relative',\r\n                    left: targetLeft,\r\n                    top: 0,\r\n                    zIndex: _.options.zIndex - 2,\r\n                    opacity: 0\r\n                });\r\n            }\r\n        });\r\n\r\n        _.$slides.eq(_.currentSlide).css({\r\n            zIndex: _.options.zIndex - 1,\r\n            opacity: 1\r\n        });\r\n\r\n    };\r\n\r\n    Slick.prototype.setHeight = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\r\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\r\n            _.$list.css('height', targetHeight);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.setOption =\r\n    Slick.prototype.slickSetOption = function() {\r\n\r\n        /**\r\n         * accepts arguments in format of:\r\n         *\r\n         *  - for changing a single option's value:\r\n         *     .slick(\"setOption\", option, value, refresh )\r\n         *\r\n         *  - for changing a set of responsive options:\r\n         *     .slick(\"setOption\", 'responsive', [{}, ...], refresh )\r\n         *\r\n         *  - for updating multiple values at once (not responsive)\r\n         *     .slick(\"setOption\", { 'option': value, ... }, refresh )\r\n         */\r\n\r\n        var _ = this, l, item, option, value, refresh = false, type;\r\n\r\n        if( $.type( arguments[0] ) === 'object' ) {\r\n\r\n            option =  arguments[0];\r\n            refresh = arguments[1];\r\n            type = 'multiple';\r\n\r\n        } else if ( $.type( arguments[0] ) === 'string' ) {\r\n\r\n            option =  arguments[0];\r\n            value = arguments[1];\r\n            refresh = arguments[2];\r\n\r\n            if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {\r\n\r\n                type = 'responsive';\r\n\r\n            } else if ( typeof arguments[1] !== 'undefined' ) {\r\n\r\n                type = 'single';\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if ( type === 'single' ) {\r\n\r\n            _.options[option] = value;\r\n\r\n\r\n        } else if ( type === 'multiple' ) {\r\n\r\n            $.each( option , function( opt, val ) {\r\n\r\n                _.options[opt] = val;\r\n\r\n            });\r\n\r\n\r\n        } else if ( type === 'responsive' ) {\r\n\r\n            for ( item in value ) {\r\n\r\n                if( $.type( _.options.responsive ) !== 'array' ) {\r\n\r\n                    _.options.responsive = [ value[item] ];\r\n\r\n                } else {\r\n\r\n                    l = _.options.responsive.length-1;\r\n\r\n                    // loop through the responsive object and splice out duplicates.\r\n                    while( l >= 0 ) {\r\n\r\n                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {\r\n\r\n                            _.options.responsive.splice(l,1);\r\n\r\n                        }\r\n\r\n                        l--;\r\n\r\n                    }\r\n\r\n                    _.options.responsive.push( value[item] );\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if ( refresh ) {\r\n\r\n            _.unload();\r\n            _.reinit();\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.setPosition = function() {\r\n\r\n        var _ = this;\r\n\r\n        _.setDimensions();\r\n\r\n        _.setHeight();\r\n\r\n        if (_.options.fade === false) {\r\n            _.setCSS(_.getLeft(_.currentSlide));\r\n        } else {\r\n            _.setFade();\r\n        }\r\n\r\n        _.$slider.trigger('setPosition', [_]);\r\n\r\n    };\r\n\r\n    Slick.prototype.setProps = function() {\r\n\r\n        var _ = this,\r\n            bodyStyle = document.body.style;\r\n\r\n        _.positionProp = _.options.vertical === true ? 'top' : 'left';\r\n\r\n        if (_.positionProp === 'top') {\r\n            _.$slider.addClass('slick-vertical');\r\n        } else {\r\n            _.$slider.removeClass('slick-vertical');\r\n        }\r\n\r\n        if (bodyStyle.WebkitTransition !== undefined ||\r\n            bodyStyle.MozTransition !== undefined ||\r\n            bodyStyle.msTransition !== undefined) {\r\n            if (_.options.useCSS === true) {\r\n                _.cssTransitions = true;\r\n            }\r\n        }\r\n\r\n        if ( _.options.fade ) {\r\n            if ( typeof _.options.zIndex === 'number' ) {\r\n                if( _.options.zIndex < 3 ) {\r\n                    _.options.zIndex = 3;\r\n                }\r\n            } else {\r\n                _.options.zIndex = _.defaults.zIndex;\r\n            }\r\n        }\r\n\r\n        if (bodyStyle.OTransform !== undefined) {\r\n            _.animType = 'OTransform';\r\n            _.transformType = '-o-transform';\r\n            _.transitionType = 'OTransition';\r\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\r\n        }\r\n        if (bodyStyle.MozTransform !== undefined) {\r\n            _.animType = 'MozTransform';\r\n            _.transformType = '-moz-transform';\r\n            _.transitionType = 'MozTransition';\r\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;\r\n        }\r\n        if (bodyStyle.webkitTransform !== undefined) {\r\n            _.animType = 'webkitTransform';\r\n            _.transformType = '-webkit-transform';\r\n            _.transitionType = 'webkitTransition';\r\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\r\n        }\r\n        if (bodyStyle.msTransform !== undefined) {\r\n            _.animType = 'msTransform';\r\n            _.transformType = '-ms-transform';\r\n            _.transitionType = 'msTransition';\r\n            if (bodyStyle.msTransform === undefined) _.animType = false;\r\n        }\r\n        if (bodyStyle.transform !== undefined && _.animType !== false) {\r\n            _.animType = 'transform';\r\n            _.transformType = 'transform';\r\n            _.transitionType = 'transition';\r\n        }\r\n        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);\r\n    };\r\n\r\n\r\n    Slick.prototype.setSlideClasses = function(index) {\r\n\r\n        var _ = this,\r\n            centerOffset, allSlides, indexOffset, remainder;\r\n\r\n        allSlides = _.$slider\r\n            .find('.slick-slide')\r\n            .removeClass('slick-active slick-center slick-current')\r\n            .attr('aria-hidden', 'true');\r\n\r\n        _.$slides\r\n            .eq(index)\r\n            .addClass('slick-current');\r\n\r\n        if (_.options.centerMode === true) {\r\n\r\n            centerOffset = Math.floor(_.options.slidesToShow / 2);\r\n\r\n            if (_.options.infinite === true) {\r\n\r\n                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {\r\n\r\n                    _.$slides\r\n                        .slice(index - centerOffset, index + centerOffset + 1)\r\n                        .addClass('slick-active')\r\n                        .attr('aria-hidden', 'false');\r\n\r\n                } else {\r\n\r\n                    indexOffset = _.options.slidesToShow + index;\r\n                    allSlides\r\n                        .slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2)\r\n                        .addClass('slick-active')\r\n                        .attr('aria-hidden', 'false');\r\n\r\n                }\r\n\r\n                if (index === 0) {\r\n\r\n                    allSlides\r\n                        .eq(allSlides.length - 1 - _.options.slidesToShow)\r\n                        .addClass('slick-center');\r\n\r\n                } else if (index === _.slideCount - 1) {\r\n\r\n                    allSlides\r\n                        .eq(_.options.slidesToShow)\r\n                        .addClass('slick-center');\r\n\r\n                }\r\n\r\n            }\r\n\r\n            _.$slides\r\n                .eq(index)\r\n                .addClass('slick-center');\r\n\r\n        } else {\r\n\r\n            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {\r\n\r\n                _.$slides\r\n                    .slice(index, index + _.options.slidesToShow)\r\n                    .addClass('slick-active')\r\n                    .attr('aria-hidden', 'false');\r\n\r\n            } else if (allSlides.length <= _.options.slidesToShow) {\r\n\r\n                allSlides\r\n                    .addClass('slick-active')\r\n                    .attr('aria-hidden', 'false');\r\n\r\n            } else {\r\n\r\n                remainder = _.slideCount % _.options.slidesToShow;\r\n                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;\r\n\r\n                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {\r\n\r\n                    allSlides\r\n                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)\r\n                        .addClass('slick-active')\r\n                        .attr('aria-hidden', 'false');\r\n\r\n                } else {\r\n\r\n                    allSlides\r\n                        .slice(indexOffset, indexOffset + _.options.slidesToShow)\r\n                        .addClass('slick-active')\r\n                        .attr('aria-hidden', 'false');\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (_.options.lazyLoad === 'ondemand') {\r\n            _.lazyLoad();\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.setupInfinite = function() {\r\n\r\n        var _ = this,\r\n            i, slideIndex, infiniteCount;\r\n\r\n        if (_.options.fade === true) {\r\n            _.options.centerMode = false;\r\n        }\r\n\r\n        if (_.options.infinite === true && _.options.fade === false) {\r\n\r\n            slideIndex = null;\r\n\r\n            if (_.slideCount > _.options.slidesToShow) {\r\n\r\n                if (_.options.centerMode === true) {\r\n                    infiniteCount = _.options.slidesToShow + 1;\r\n                } else {\r\n                    infiniteCount = _.options.slidesToShow;\r\n                }\r\n\r\n                for (i = _.slideCount; i > (_.slideCount -\r\n                        infiniteCount); i -= 1) {\r\n                    slideIndex = i - 1;\r\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '')\r\n                        .attr('data-slick-index', slideIndex - _.slideCount)\r\n                        .prependTo(_.$slideTrack).addClass('slick-cloned');\r\n                }\r\n                for (i = 0; i < infiniteCount; i += 1) {\r\n                    slideIndex = i;\r\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '')\r\n                        .attr('data-slick-index', slideIndex + _.slideCount)\r\n                        .appendTo(_.$slideTrack).addClass('slick-cloned');\r\n                }\r\n                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {\r\n                    $(this).attr('id', '');\r\n                });\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.interrupt = function( toggle ) {\r\n\r\n        var _ = this;\r\n\r\n        if( !toggle ) {\r\n            _.autoPlay();\r\n        }\r\n        _.interrupted = toggle;\r\n\r\n    };\r\n\r\n    Slick.prototype.selectHandler = function(event) {\r\n\r\n        var _ = this;\r\n\r\n        var targetElement =\r\n            $(event.target).is('.slick-slide') ?\r\n                $(event.target) :\r\n                $(event.target).parents('.slick-slide');\r\n\r\n        var index = parseInt(targetElement.attr('data-slick-index'));\r\n\r\n        if (!index) index = 0;\r\n\r\n        if (_.slideCount <= _.options.slidesToShow) {\r\n\r\n            _.setSlideClasses(index);\r\n            _.asNavFor(index);\r\n            return;\r\n\r\n        }\r\n\r\n        _.slideHandler(index);\r\n\r\n    };\r\n\r\n    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {\r\n\r\n        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,\r\n            _ = this, navTarget;\r\n\r\n        sync = sync || false;\r\n\r\n        if (_.animating === true && _.options.waitForAnimate === true) {\r\n            return;\r\n        }\r\n\r\n        if (_.options.fade === true && _.currentSlide === index) {\r\n            return;\r\n        }\r\n\r\n        if (_.slideCount <= _.options.slidesToShow) {\r\n            return;\r\n        }\r\n\r\n        if (sync === false) {\r\n            _.asNavFor(index);\r\n        }\r\n\r\n        targetSlide = index;\r\n        targetLeft = _.getLeft(targetSlide);\r\n        slideLeft = _.getLeft(_.currentSlide);\r\n\r\n        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;\r\n\r\n        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {\r\n            if (_.options.fade === false) {\r\n                targetSlide = _.currentSlide;\r\n                if (dontAnimate !== true) {\r\n                    _.animateSlide(slideLeft, function() {\r\n                        _.postSlide(targetSlide);\r\n                    });\r\n                } else {\r\n                    _.postSlide(targetSlide);\r\n                }\r\n            }\r\n            return;\r\n        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {\r\n            if (_.options.fade === false) {\r\n                targetSlide = _.currentSlide;\r\n                if (dontAnimate !== true) {\r\n                    _.animateSlide(slideLeft, function() {\r\n                        _.postSlide(targetSlide);\r\n                    });\r\n                } else {\r\n                    _.postSlide(targetSlide);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        if ( _.options.autoplay ) {\r\n            clearInterval(_.autoPlayTimer);\r\n        }\r\n\r\n        if (targetSlide < 0) {\r\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\r\n                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);\r\n            } else {\r\n                animSlide = _.slideCount + targetSlide;\r\n            }\r\n        } else if (targetSlide >= _.slideCount) {\r\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\r\n                animSlide = 0;\r\n            } else {\r\n                animSlide = targetSlide - _.slideCount;\r\n            }\r\n        } else {\r\n            animSlide = targetSlide;\r\n        }\r\n\r\n        _.animating = true;\r\n\r\n        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);\r\n\r\n        oldSlide = _.currentSlide;\r\n        _.currentSlide = animSlide;\r\n\r\n        _.setSlideClasses(_.currentSlide);\r\n\r\n        if ( _.options.asNavFor ) {\r\n\r\n            navTarget = _.getNavTarget();\r\n            navTarget = navTarget.slick('getSlick');\r\n\r\n            if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {\r\n                navTarget.setSlideClasses(_.currentSlide);\r\n            }\r\n\r\n        }\r\n\r\n        _.updateDots();\r\n        _.updateArrows();\r\n\r\n        if (_.options.fade === true) {\r\n            if (dontAnimate !== true) {\r\n\r\n                _.fadeSlideOut(oldSlide);\r\n\r\n                _.fadeSlide(animSlide, function() {\r\n                    _.postSlide(animSlide);\r\n                });\r\n\r\n            } else {\r\n                _.postSlide(animSlide);\r\n            }\r\n            _.animateHeight();\r\n            return;\r\n        }\r\n\r\n        if (dontAnimate !== true) {\r\n            _.animateSlide(targetLeft, function() {\r\n                _.postSlide(animSlide);\r\n            });\r\n        } else {\r\n            _.postSlide(animSlide);\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.startLoad = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n            _.$prevArrow.hide();\r\n            _.$nextArrow.hide();\r\n\r\n        }\r\n\r\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\r\n\r\n            _.$dots.hide();\r\n\r\n        }\r\n\r\n        _.$slider.addClass('slick-loading');\r\n\r\n    };\r\n\r\n    Slick.prototype.swipeDirection = function() {\r\n\r\n        var xDist, yDist, r, swipeAngle, _ = this;\r\n\r\n        xDist = _.touchObject.startX - _.touchObject.curX;\r\n        yDist = _.touchObject.startY - _.touchObject.curY;\r\n        r = Math.atan2(yDist, xDist);\r\n\r\n        swipeAngle = Math.round(r * 180 / Math.PI);\r\n        if (swipeAngle < 0) {\r\n            swipeAngle = 360 - Math.abs(swipeAngle);\r\n        }\r\n\r\n        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {\r\n            return (_.options.rtl === false ? 'left' : 'right');\r\n        }\r\n        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {\r\n            return (_.options.rtl === false ? 'left' : 'right');\r\n        }\r\n        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {\r\n            return (_.options.rtl === false ? 'right' : 'left');\r\n        }\r\n        if (_.options.verticalSwiping === true) {\r\n            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {\r\n                return 'down';\r\n            } else {\r\n                return 'up';\r\n            }\r\n        }\r\n\r\n        return 'vertical';\r\n\r\n    };\r\n\r\n    Slick.prototype.swipeEnd = function(event) {\r\n\r\n        var _ = this,\r\n            slideCount,\r\n            direction;\r\n\r\n        _.dragging = false;\r\n        _.interrupted = false;\r\n        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;\r\n\r\n        if ( _.touchObject.curX === undefined ) {\r\n            return false;\r\n        }\r\n\r\n        if ( _.touchObject.edgeHit === true ) {\r\n            _.$slider.trigger('edge', [_, _.swipeDirection() ]);\r\n        }\r\n\r\n        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {\r\n\r\n            direction = _.swipeDirection();\r\n\r\n            switch ( direction ) {\r\n\r\n                case 'left':\r\n                case 'down':\r\n\r\n                    slideCount =\r\n                        _.options.swipeToSlide ?\r\n                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :\r\n                            _.currentSlide + _.getSlideCount();\r\n\r\n                    _.currentDirection = 0;\r\n\r\n                    break;\r\n\r\n                case 'right':\r\n                case 'up':\r\n\r\n                    slideCount =\r\n                        _.options.swipeToSlide ?\r\n                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :\r\n                            _.currentSlide - _.getSlideCount();\r\n\r\n                    _.currentDirection = 1;\r\n\r\n                    break;\r\n\r\n                default:\r\n\r\n\r\n            }\r\n\r\n            if( direction != 'vertical' ) {\r\n\r\n                _.slideHandler( slideCount );\r\n                _.touchObject = {};\r\n                _.$slider.trigger('swipe', [_, direction ]);\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n            if ( _.touchObject.startX !== _.touchObject.curX ) {\r\n\r\n                _.slideHandler( _.currentSlide );\r\n                _.touchObject = {};\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.swipeHandler = function(event) {\r\n\r\n        var _ = this;\r\n\r\n        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {\r\n            return;\r\n        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {\r\n            return;\r\n        }\r\n\r\n        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?\r\n            event.originalEvent.touches.length : 1;\r\n\r\n        _.touchObject.minSwipe = _.listWidth / _.options\r\n            .touchThreshold;\r\n\r\n        if (_.options.verticalSwiping === true) {\r\n            _.touchObject.minSwipe = _.listHeight / _.options\r\n                .touchThreshold;\r\n        }\r\n\r\n        switch (event.data.action) {\r\n\r\n            case 'start':\r\n                _.swipeStart(event);\r\n                break;\r\n\r\n            case 'move':\r\n                _.swipeMove(event);\r\n                break;\r\n\r\n            case 'end':\r\n                _.swipeEnd(event);\r\n                break;\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.swipeMove = function(event) {\r\n\r\n        var _ = this,\r\n            edgeWasHit = false,\r\n            curLeft, swipeDirection, swipeLength, positionOffset, touches;\r\n\r\n        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;\r\n\r\n        if (!_.dragging || touches && touches.length !== 1) {\r\n            return false;\r\n        }\r\n\r\n        curLeft = _.getLeft(_.currentSlide);\r\n\r\n        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;\r\n        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;\r\n\r\n        _.touchObject.swipeLength = Math.round(Math.sqrt(\r\n            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));\r\n\r\n        if (_.options.verticalSwiping === true) {\r\n            _.touchObject.swipeLength = Math.round(Math.sqrt(\r\n                Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));\r\n        }\r\n\r\n        swipeDirection = _.swipeDirection();\r\n\r\n        if (swipeDirection === 'vertical') {\r\n            return;\r\n        }\r\n\r\n        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {\r\n            event.preventDefault();\r\n        }\r\n\r\n        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);\r\n        if (_.options.verticalSwiping === true) {\r\n            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;\r\n        }\r\n\r\n\r\n        swipeLength = _.touchObject.swipeLength;\r\n\r\n        _.touchObject.edgeHit = false;\r\n\r\n        if (_.options.infinite === false) {\r\n            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {\r\n                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;\r\n                _.touchObject.edgeHit = true;\r\n            }\r\n        }\r\n\r\n        if (_.options.vertical === false) {\r\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\r\n        } else {\r\n            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;\r\n        }\r\n        if (_.options.verticalSwiping === true) {\r\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\r\n        }\r\n\r\n        if (_.options.fade === true || _.options.touchMove === false) {\r\n            return false;\r\n        }\r\n\r\n        if (_.animating === true) {\r\n            _.swipeLeft = null;\r\n            return false;\r\n        }\r\n\r\n        _.setCSS(_.swipeLeft);\r\n\r\n    };\r\n\r\n    Slick.prototype.swipeStart = function(event) {\r\n\r\n        var _ = this,\r\n            touches;\r\n\r\n        _.interrupted = true;\r\n\r\n        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {\r\n            _.touchObject = {};\r\n            return false;\r\n        }\r\n\r\n        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {\r\n            touches = event.originalEvent.touches[0];\r\n        }\r\n\r\n        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;\r\n        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;\r\n\r\n        _.dragging = true;\r\n\r\n    };\r\n\r\n    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.$slidesCache !== null) {\r\n\r\n            _.unload();\r\n\r\n            _.$slideTrack.children(this.options.slide).detach();\r\n\r\n            _.$slidesCache.appendTo(_.$slideTrack);\r\n\r\n            _.reinit();\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.unload = function() {\r\n\r\n        var _ = this;\r\n\r\n        $('.slick-cloned', _.$slider).remove();\r\n\r\n        if (_.$dots) {\r\n            _.$dots.remove();\r\n        }\r\n\r\n        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {\r\n            _.$prevArrow.remove();\r\n        }\r\n\r\n        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {\r\n            _.$nextArrow.remove();\r\n        }\r\n\r\n        _.$slides\r\n            .removeClass('slick-slide slick-active slick-visible slick-current')\r\n            .attr('aria-hidden', 'true')\r\n            .css('width', '');\r\n\r\n    };\r\n\r\n    Slick.prototype.unslick = function(fromBreakpoint) {\r\n\r\n        var _ = this;\r\n        _.$slider.trigger('unslick', [_, fromBreakpoint]);\r\n        _.destroy();\r\n\r\n    };\r\n\r\n    Slick.prototype.updateArrows = function() {\r\n\r\n        var _ = this,\r\n            centerOffset;\r\n\r\n        centerOffset = Math.floor(_.options.slidesToShow / 2);\r\n\r\n        if ( _.options.arrows === true &&\r\n            _.slideCount > _.options.slidesToShow &&\r\n            !_.options.infinite ) {\r\n\r\n            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n            if (_.currentSlide === 0) {\r\n\r\n                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\r\n                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {\r\n\r\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\r\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {\r\n\r\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\r\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.updateDots = function() {\r\n\r\n        var _ = this;\r\n\r\n        if (_.$dots !== null) {\r\n\r\n            _.$dots\r\n                .find('li')\r\n                .removeClass('slick-active')\r\n                .attr('aria-hidden', 'true');\r\n\r\n            _.$dots\r\n                .find('li')\r\n                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))\r\n                .addClass('slick-active')\r\n                .attr('aria-hidden', 'false');\r\n\r\n        }\r\n\r\n    };\r\n\r\n    Slick.prototype.visibility = function() {\r\n\r\n        var _ = this;\r\n\r\n        if ( _.options.autoplay ) {\r\n\r\n            if ( document[_.hidden] ) {\r\n\r\n                _.interrupted = true;\r\n\r\n            } else {\r\n\r\n                _.interrupted = false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    $.fn.slick = function() {\r\n        var _ = this,\r\n            opt = arguments[0],\r\n            args = Array.prototype.slice.call(arguments, 1),\r\n            l = _.length,\r\n            i,\r\n            ret;\r\n        for (i = 0; i < l; i++) {\r\n            if (typeof opt == 'object' || typeof opt == 'undefined')\r\n                _[i].slick = new Slick(_[i], opt);\r\n            else\r\n                ret = _[i].slick[opt].apply(_[i].slick, args);\r\n            if (typeof ret != 'undefined') return ret;\r\n        }\r\n        return _;\r\n    };\r\n\r\n}));\r\n\n//# sourceURL=/modules/EndorphinaCore/src/js/lib/slick.js"),
require([""]);